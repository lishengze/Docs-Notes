/////////////////////////////////////////////////////////////////////////
///@system 执行引擎系统
///@company 上海期货信息技术有限公司
///@file databaseFactories.pp
///@brief实现了若干个内存数据库的对象工厂
///@history 
///20060127	王肇东		创建该文件
/////////////////////////////////////////////////////////////////////////

#include "BaseDataStruct.h"
#include "databaseFactories.h"
#include "databaseResources.h"
#include "monitorIndex.h"

//#define COUNT_OPERATION

///强制进行复制，不理会const标记
///@param	target	复制的目标地址
///@param	source	复制的源地址
///@param	size	复制的空间大小
static void forceCopy(const void *target, const void *source, int size)
{
	if ((source==NULL)||(target==NULL))
	{
		REPORT_EVENT(LOG_CRITICAL,"InternalError","copy from or to null");
		return;
	}
	memcpy((void *)target,source,size);
}

extern int compareForExchangeIDIndexinExchangeDataSyncStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForExchangeDataSyncStatus=0;
int updateWithIndexActionForExchangeDataSyncStatus=0;
int updateWithoutIndexActionForExchangeDataSyncStatus=0;
int removeActionForExchangeDataSyncStatus=0;
int addCommitForExchangeDataSyncStatus=0;
int updateCommitForExchangeDataSyncStatus=0;
int removeCommitForExchangeDataSyncStatus=0;
#endif
void CExchangeDataSyncStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pExchangeIDIndex=new CAVLTree(maxUnit,compareForExchangeIDIndexinExchangeDataSyncStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExchangeDataSyncStatus_ExchangeIDIndex",pExchangeIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExchangeDataSyncStatus_ExchangeIDIndex");
			if(it != pIndexMap->end()) {
				pExchangeIDIndex=new CAVLTree(maxUnit,compareForExchangeIDIndexinExchangeDataSyncStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pExchangeIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CExchangeDataSyncStatusActionTrigger *>;
	pCommitTriggers=new vector<CExchangeDataSyncStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CExchangeDataSyncStatusFactory::CExchangeDataSyncStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExchangeDataSyncStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CExchangeDataSyncStatusFactory::CExchangeDataSyncStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExchangeDataSyncStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CExchangeDataSyncStatusFactory::~CExchangeDataSyncStatusFactory(void)
{
	if (runLevel>=0) {
		if (pExchangeIDIndex!=NULL)
			delete pExchangeIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CExchangeDataSyncStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CExchangeDataSyncStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pExchangeIDIndex->output(pLogger,indent+1);
	}
}

int CExchangeDataSyncStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableExchangeDataSyncStatus thisExchangeDataSyncStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisExchangeDataSyncStatus.readCSV(input,pNames))
		add(&thisExchangeDataSyncStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CExchangeDataSyncStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ExchangeDataSyncStatus.csv");
	return readCSV(szFileName);
}

int CExchangeDataSyncStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableExchangeDataSyncStatus::writeCSVHead(output);
	pExchangeDataSyncStatus=(CWriteableExchangeDataSyncStatus *)(pMem->getFirst());
	while (pExchangeDataSyncStatus!=NULL) {
		if (!pExchangeDataSyncStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pExchangeDataSyncStatus=(CWriteableExchangeDataSyncStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CExchangeDataSyncStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ExchangeDataSyncStatus.csv");
	return writeCSV(szFileName);
}

void CExchangeDataSyncStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CExchangeDataSyncStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CExchangeDataSyncStatusFactory={       Total Count=%d\n", pMem->getCount());
	pExchangeDataSyncStatus=(CWriteableExchangeDataSyncStatus *)(pMem->getFirst());
	while (pExchangeDataSyncStatus!=NULL) {
		pExchangeDataSyncStatus->dump(fp,index++);
		pExchangeDataSyncStatus=(CWriteableExchangeDataSyncStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CExchangeDataSyncStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pExchangeIDIndex->removeAll();
	}
}

CExchangeDataSyncStatus *CExchangeDataSyncStatusFactory::internalAdd(CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForExchangeDataSyncStatus++;
#endif
	CExchangeDataSyncStatus *pTarget;	
	beforeAdd(pExchangeDataSyncStatus);
	pTarget=(CExchangeDataSyncStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ExchangeDataSyncStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pExchangeDataSyncStatus, sizeof(CExchangeDataSyncStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pExchangeIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CExchangeDataSyncStatus *CExchangeDataSyncStatusFactory::add(CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus, CTransaction *pTransaction)
{
	pExchangeDataSyncStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pExchangeDataSyncStatus,true);
	}
	else {
		CExchangeDataSyncStatus *pNewExchangeDataSyncStatus;
		pNewExchangeDataSyncStatus = internalAdd(pExchangeDataSyncStatus,false);
		pTransaction->addResource(CExchangeDataSyncStatusResource::alloc(CREATE_ACTION,this,pNewExchangeDataSyncStatus,NULL));
		return pNewExchangeDataSyncStatus;
	}
}

void CExchangeDataSyncStatusFactory::internalUpdate(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pNewExchangeDataSyncStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForExchangeDataSyncStatus++;
	}
	else {
		updateWithoutIndexActionForExchangeDataSyncStatus++;
	}
#endif
	CWriteableExchangeDataSyncStatus theOldExchangeDataSyncStatus;
	beforeUpdate(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus);
	if (bNoTransaction) {
		forceCopy(&theOldExchangeDataSyncStatus,pExchangeDataSyncStatus,sizeof(CExchangeDataSyncStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus,sizeof(CExchangeDataSyncStatus));
	pMem->updateObject(pExchangeDataSyncStatus);
	if (updateIndex) {
	}
	afterUpdate(pExchangeDataSyncStatus);
	if (bNoTransaction) {
		commitUpdate(pExchangeDataSyncStatus,&theOldExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::update(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pNewExchangeDataSyncStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewExchangeDataSyncStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CExchangeDataSyncStatusResource::alloc(UPDATE_ACTION,this,pExchangeDataSyncStatus,pNewExchangeDataSyncStatus,updateIndex));
		internalUpdate(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus,updateIndex,false);
	}
}

void CExchangeDataSyncStatusFactory::internalRemove(CExchangeDataSyncStatus *pExchangeDataSyncStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForExchangeDataSyncStatus++;
#endif
	CWriteableExchangeDataSyncStatus theOldExchangeDataSyncStatus;
	beforeRemove(pExchangeDataSyncStatus);
	if (bNoTransaction) {
		forceCopy(&theOldExchangeDataSyncStatus,pExchangeDataSyncStatus,sizeof(CExchangeDataSyncStatus));
	}
	if (runLevel>=0) {
		pExchangeIDIndex->removeObject(pExchangeDataSyncStatus);
	}
	pMem->free(pExchangeDataSyncStatus);
	if(bNoTransaction) {
		commitRemove(&theOldExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::remove(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pExchangeDataSyncStatus,true);
	}
	else {
		pTransaction->addResource(CExchangeDataSyncStatusResource::alloc(DELETE_ACTION,this,pExchangeDataSyncStatus,NULL));
		internalRemove(pExchangeDataSyncStatus,false);		
	}
}

CExchangeDataSyncStatus* CExchangeDataSyncStatusFactory::addOrUpdate(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pNewExchangeDataSyncStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pExchangeDataSyncStatus == NULL) {
		return add(pNewExchangeDataSyncStatus,pTransaction);
	}
	else {
		update(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus,pTransaction,updateIndex);
		return pExchangeDataSyncStatus;
	}
}

void CExchangeDataSyncStatusFactory::retrieve(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pTargetExchangeDataSyncStatus)
{
	forceCopy(pTargetExchangeDataSyncStatus, pExchangeDataSyncStatus, sizeof(CExchangeDataSyncStatus));
}
	
int CExchangeDataSyncStatusFactory::addActionTrigger(CExchangeDataSyncStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CExchangeDataSyncStatusFactory::removeActionTrigger(CExchangeDataSyncStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CExchangeDataSyncStatusFactory::addCommitTrigger(CExchangeDataSyncStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CExchangeDataSyncStatusFactory::removeCommitTrigger(CExchangeDataSyncStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CExchangeDataSyncStatus *CExchangeDataSyncStatusFactory::getFirst(void)
{
	CExchangeDataSyncStatus *pResult=(CExchangeDataSyncStatus *)(pMem->getFirst());
	return pResult;
}
	
CExchangeDataSyncStatus *CExchangeDataSyncStatusFactory::getNext(void)
{
	CExchangeDataSyncStatus *pResult=(CExchangeDataSyncStatus *)(pMem->getNext());
	return pResult;
}
	
void CExchangeDataSyncStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CExchangeDataSyncStatusFactory::beforeAdd(CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pExchangeDataSyncStatus);
	}
}
	
void CExchangeDataSyncStatusFactory::afterAdd(CExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::beforeUpdate(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pNewExchangeDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pExchangeDataSyncStatus,pNewExchangeDataSyncStatus);
	}
}
	
void CExchangeDataSyncStatusFactory::afterUpdate(CExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pExchangeDataSyncStatus);
	}
}
	
void CExchangeDataSyncStatusFactory::beforeRemove(CExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::commitAdd(CExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForExchangeDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::commitUpdate(CExchangeDataSyncStatus *pExchangeDataSyncStatus, CWriteableExchangeDataSyncStatus *pOldExchangeDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForExchangeDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pExchangeDataSyncStatus,pOldExchangeDataSyncStatus);
	}
}
	
void CExchangeDataSyncStatusFactory::commitRemove(CWriteableExchangeDataSyncStatus *pExchangeDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForExchangeDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pExchangeDataSyncStatus);
	}
}

void CExchangeDataSyncStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSettlementGroupIDIndexinSGDataSyncStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSGDataSyncStatus=0;
int updateWithIndexActionForSGDataSyncStatus=0;
int updateWithoutIndexActionForSGDataSyncStatus=0;
int removeActionForSGDataSyncStatus=0;
int addCommitForSGDataSyncStatus=0;
int updateCommitForSGDataSyncStatus=0;
int removeCommitForSGDataSyncStatus=0;
#endif
void CSGDataSyncStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSettlementGroupIDIndex=new CAVLTree(maxUnit,compareForSettlementGroupIDIndexinSGDataSyncStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SGDataSyncStatus_SettlementGroupIDIndex",pSettlementGroupIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SGDataSyncStatus_SettlementGroupIDIndex");
			if(it != pIndexMap->end()) {
				pSettlementGroupIDIndex=new CAVLTree(maxUnit,compareForSettlementGroupIDIndexinSGDataSyncStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSettlementGroupIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartBySettlementGroupID=NULL;
	pActionTriggers=new vector<CSGDataSyncStatusActionTrigger *>;
	pCommitTriggers=new vector<CSGDataSyncStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSGDataSyncStatusFactory::CSGDataSyncStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSGDataSyncStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSGDataSyncStatusFactory::CSGDataSyncStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSGDataSyncStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSGDataSyncStatusFactory::~CSGDataSyncStatusFactory(void)
{
	if (runLevel>=0) {
		if (pSettlementGroupIDIndex!=NULL)
			delete pSettlementGroupIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSGDataSyncStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSGDataSyncStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSettlementGroupIDIndex->output(pLogger,indent+1);
	}
}

int CSGDataSyncStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSGDataSyncStatus thisSGDataSyncStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSGDataSyncStatus.readCSV(input,pNames))
		add(&thisSGDataSyncStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CSGDataSyncStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SGDataSyncStatus.csv");
	return readCSV(szFileName);
}

int CSGDataSyncStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSGDataSyncStatus *pSGDataSyncStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSGDataSyncStatus::writeCSVHead(output);
	pSGDataSyncStatus=(CWriteableSGDataSyncStatus *)(pMem->getFirst());
	while (pSGDataSyncStatus!=NULL) {
		if (!pSGDataSyncStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSGDataSyncStatus=(CWriteableSGDataSyncStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSGDataSyncStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SGDataSyncStatus.csv");
	return writeCSV(szFileName);
}

void CSGDataSyncStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSGDataSyncStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSGDataSyncStatus *pSGDataSyncStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSGDataSyncStatusFactory={       Total Count=%d\n", pMem->getCount());
	pSGDataSyncStatus=(CWriteableSGDataSyncStatus *)(pMem->getFirst());
	while (pSGDataSyncStatus!=NULL) {
		pSGDataSyncStatus->dump(fp,index++);
		pSGDataSyncStatus=(CWriteableSGDataSyncStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSGDataSyncStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSettlementGroupIDIndex->removeAll();
	}
}

CSGDataSyncStatus *CSGDataSyncStatusFactory::internalAdd(CWriteableSGDataSyncStatus *pSGDataSyncStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSGDataSyncStatus++;
#endif
	CSGDataSyncStatus *pTarget;	
	beforeAdd(pSGDataSyncStatus);
	pTarget=(CSGDataSyncStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SGDataSyncStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSGDataSyncStatus, sizeof(CSGDataSyncStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSettlementGroupIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSGDataSyncStatus *CSGDataSyncStatusFactory::add(CWriteableSGDataSyncStatus *pSGDataSyncStatus, CTransaction *pTransaction)
{
	pSGDataSyncStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSGDataSyncStatus,true);
	}
	else {
		CSGDataSyncStatus *pNewSGDataSyncStatus;
		pNewSGDataSyncStatus = internalAdd(pSGDataSyncStatus,false);
		pTransaction->addResource(CSGDataSyncStatusResource::alloc(CREATE_ACTION,this,pNewSGDataSyncStatus,NULL));
		return pNewSGDataSyncStatus;
	}
}

void CSGDataSyncStatusFactory::internalUpdate(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pNewSGDataSyncStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSGDataSyncStatus++;
	}
	else {
		updateWithoutIndexActionForSGDataSyncStatus++;
	}
#endif
	CWriteableSGDataSyncStatus theOldSGDataSyncStatus;
	beforeUpdate(pSGDataSyncStatus,pNewSGDataSyncStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSGDataSyncStatus,pSGDataSyncStatus,sizeof(CSGDataSyncStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pSGDataSyncStatus,pNewSGDataSyncStatus,sizeof(CSGDataSyncStatus));
	pMem->updateObject(pSGDataSyncStatus);
	if (updateIndex) {
	}
	afterUpdate(pSGDataSyncStatus);
	if (bNoTransaction) {
		commitUpdate(pSGDataSyncStatus,&theOldSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::update(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pNewSGDataSyncStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewSGDataSyncStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSGDataSyncStatus,pNewSGDataSyncStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSGDataSyncStatusResource::alloc(UPDATE_ACTION,this,pSGDataSyncStatus,pNewSGDataSyncStatus,updateIndex));
		internalUpdate(pSGDataSyncStatus,pNewSGDataSyncStatus,updateIndex,false);
	}
}

void CSGDataSyncStatusFactory::internalRemove(CSGDataSyncStatus *pSGDataSyncStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSGDataSyncStatus++;
#endif
	CWriteableSGDataSyncStatus theOldSGDataSyncStatus;
	beforeRemove(pSGDataSyncStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSGDataSyncStatus,pSGDataSyncStatus,sizeof(CSGDataSyncStatus));
	}
	if (runLevel>=0) {
		pSettlementGroupIDIndex->removeObject(pSGDataSyncStatus);
	}
	pMem->free(pSGDataSyncStatus);
	if(bNoTransaction) {
		commitRemove(&theOldSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::remove(CSGDataSyncStatus *pSGDataSyncStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSGDataSyncStatus,true);
	}
	else {
		pTransaction->addResource(CSGDataSyncStatusResource::alloc(DELETE_ACTION,this,pSGDataSyncStatus,NULL));
		internalRemove(pSGDataSyncStatus,false);		
	}
}

CSGDataSyncStatus* CSGDataSyncStatusFactory::addOrUpdate(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pNewSGDataSyncStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pSGDataSyncStatus == NULL) {
		return add(pNewSGDataSyncStatus,pTransaction);
	}
	else {
		update(pSGDataSyncStatus,pNewSGDataSyncStatus,pTransaction,updateIndex);
		return pSGDataSyncStatus;
	}
}

void CSGDataSyncStatusFactory::retrieve(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pTargetSGDataSyncStatus)
{
	forceCopy(pTargetSGDataSyncStatus, pSGDataSyncStatus, sizeof(CSGDataSyncStatus));
}
	
int CSGDataSyncStatusFactory::addActionTrigger(CSGDataSyncStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSGDataSyncStatusFactory::removeActionTrigger(CSGDataSyncStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSGDataSyncStatusFactory::addCommitTrigger(CSGDataSyncStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSGDataSyncStatusFactory::removeCommitTrigger(CSGDataSyncStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSGDataSyncStatus *CSGDataSyncStatusFactory::getFirst(void)
{
	CSGDataSyncStatus *pResult=(CSGDataSyncStatus *)(pMem->getFirst());
	return pResult;
}
	
CSGDataSyncStatus *CSGDataSyncStatusFactory::getNext(void)
{
	CSGDataSyncStatus *pResult=(CSGDataSyncStatus *)(pMem->getNext());
	return pResult;
}
	
void CSGDataSyncStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CSGDataSyncStatusFactory::beforeAdd(CWriteableSGDataSyncStatus *pSGDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSGDataSyncStatus);
	}
}
	
void CSGDataSyncStatusFactory::afterAdd(CSGDataSyncStatus *pSGDataSyncStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::beforeUpdate(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pNewSGDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSGDataSyncStatus,pNewSGDataSyncStatus);
	}
}
	
void CSGDataSyncStatusFactory::afterUpdate(CSGDataSyncStatus *pSGDataSyncStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSGDataSyncStatus);
	}
}
	
void CSGDataSyncStatusFactory::beforeRemove(CSGDataSyncStatus *pSGDataSyncStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::commitAdd(CSGDataSyncStatus *pSGDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSGDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::commitUpdate(CSGDataSyncStatus *pSGDataSyncStatus, CWriteableSGDataSyncStatus *pOldSGDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSGDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSGDataSyncStatus,pOldSGDataSyncStatus);
	}
}
	
void CSGDataSyncStatusFactory::commitRemove(CWriteableSGDataSyncStatus *pSGDataSyncStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSGDataSyncStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSGDataSyncStatus);
	}
}

void CSGDataSyncStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrentTime=0;
int updateWithIndexActionForCurrentTime=0;
int updateWithoutIndexActionForCurrentTime=0;
int removeActionForCurrentTime=0;
int addCommitForCurrentTime=0;
int updateCommitForCurrentTime=0;
int removeCommitForCurrentTime=0;
#endif
void CCurrentTimeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pActionTriggers=new vector<CCurrentTimeActionTrigger *>;
	pCommitTriggers=new vector<CCurrentTimeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrentTimeFactory::CCurrentTimeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrentTime),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrentTimeFactory::CCurrentTimeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrentTime),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrentTimeFactory::~CCurrentTimeFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrentTimeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrentTimeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrentTimeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrentTime thisCurrentTime;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrentTime.readCSV(input,pNames))
		add(&thisCurrentTime);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrentTimeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrentTime.csv");
	return readCSV(szFileName);
}

int CCurrentTimeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrentTime *pCurrentTime;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrentTime::writeCSVHead(output);
	pCurrentTime=(CWriteableCurrentTime *)(pMem->getFirst());
	while (pCurrentTime!=NULL) {
		if (!pCurrentTime->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrentTime=(CWriteableCurrentTime *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrentTimeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrentTime.csv");
	return writeCSV(szFileName);
}

void CCurrentTimeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrentTimeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrentTime *pCurrentTime;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrentTimeFactory={       Total Count=%d\n", pMem->getCount());
	pCurrentTime=(CWriteableCurrentTime *)(pMem->getFirst());
	while (pCurrentTime!=NULL) {
		pCurrentTime->dump(fp,index++);
		pCurrentTime=(CWriteableCurrentTime *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrentTimeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CCurrentTime *CCurrentTimeFactory::internalAdd(CWriteableCurrentTime *pCurrentTime, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrentTime++;
#endif
	CCurrentTime *pTarget;	
	beforeAdd(pCurrentTime);
	pTarget=(CCurrentTime *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrentTime in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrentTime, sizeof(CCurrentTime));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrentTime *CCurrentTimeFactory::add(CWriteableCurrentTime *pCurrentTime, CTransaction *pTransaction)
{
	pCurrentTime->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrentTime,true);
	}
	else {
		CCurrentTime *pNewCurrentTime;
		pNewCurrentTime = internalAdd(pCurrentTime,false);
		pTransaction->addResource(CCurrentTimeResource::alloc(CREATE_ACTION,this,pNewCurrentTime,NULL));
		return pNewCurrentTime;
	}
}

void CCurrentTimeFactory::internalUpdate(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pNewCurrentTime, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrentTime++;
	}
	else {
		updateWithoutIndexActionForCurrentTime++;
	}
#endif
	CWriteableCurrentTime theOldCurrentTime;
	beforeUpdate(pCurrentTime,pNewCurrentTime);
	if (bNoTransaction) {
		forceCopy(&theOldCurrentTime,pCurrentTime,sizeof(CCurrentTime));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrentTime,pNewCurrentTime,sizeof(CCurrentTime));
	pMem->updateObject(pCurrentTime);
	if (updateIndex) {
	}
	afterUpdate(pCurrentTime);
	if (bNoTransaction) {
		commitUpdate(pCurrentTime,&theOldCurrentTime);
	}
}

void CCurrentTimeFactory::update(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pNewCurrentTime, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrentTime->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrentTime,pNewCurrentTime,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrentTimeResource::alloc(UPDATE_ACTION,this,pCurrentTime,pNewCurrentTime,updateIndex));
		internalUpdate(pCurrentTime,pNewCurrentTime,updateIndex,false);
	}
}

void CCurrentTimeFactory::internalRemove(CCurrentTime *pCurrentTime, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrentTime++;
#endif
	CWriteableCurrentTime theOldCurrentTime;
	beforeRemove(pCurrentTime);
	if (bNoTransaction) {
		forceCopy(&theOldCurrentTime,pCurrentTime,sizeof(CCurrentTime));
	}
	pMem->free(pCurrentTime);
	if(bNoTransaction) {
		commitRemove(&theOldCurrentTime);
	}
}

void CCurrentTimeFactory::remove(CCurrentTime *pCurrentTime, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrentTime,true);
	}
	else {
		pTransaction->addResource(CCurrentTimeResource::alloc(DELETE_ACTION,this,pCurrentTime,NULL));
		internalRemove(pCurrentTime,false);		
	}
}

CCurrentTime* CCurrentTimeFactory::addOrUpdate(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pNewCurrentTime, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrentTime == NULL) {
		return add(pNewCurrentTime,pTransaction);
	}
	else {
		update(pCurrentTime,pNewCurrentTime,pTransaction,updateIndex);
		return pCurrentTime;
	}
}

void CCurrentTimeFactory::retrieve(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pTargetCurrentTime)
{
	forceCopy(pTargetCurrentTime, pCurrentTime, sizeof(CCurrentTime));
}
	
int CCurrentTimeFactory::addActionTrigger(CCurrentTimeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrentTimeFactory::removeActionTrigger(CCurrentTimeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrentTimeFactory::addCommitTrigger(CCurrentTimeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrentTimeFactory::removeCommitTrigger(CCurrentTimeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrentTime *CCurrentTimeFactory::getFirst(void)
{
	CCurrentTime *pResult=(CCurrentTime *)(pMem->getFirst());
	return pResult;
}
	
CCurrentTime *CCurrentTimeFactory::getNext(void)
{
	CCurrentTime *pResult=(CCurrentTime *)(pMem->getNext());
	return pResult;
}
	
void CCurrentTimeFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrentTimeFactory::beforeAdd(CWriteableCurrentTime *pCurrentTime)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrentTime);
	}
}
	
void CCurrentTimeFactory::afterAdd(CCurrentTime *pCurrentTime)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrentTime);
	}
}

void CCurrentTimeFactory::beforeUpdate(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pNewCurrentTime)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrentTime,pNewCurrentTime);
	}
}
	
void CCurrentTimeFactory::afterUpdate(CCurrentTime *pCurrentTime)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrentTime);
	}
}
	
void CCurrentTimeFactory::beforeRemove(CCurrentTime *pCurrentTime)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrentTime);
	}
}

void CCurrentTimeFactory::commitAdd(CCurrentTime *pCurrentTime)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrentTime++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrentTime);
	}
}

void CCurrentTimeFactory::commitUpdate(CCurrentTime *pCurrentTime, CWriteableCurrentTime *pOldCurrentTime)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrentTime++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrentTime,pOldCurrentTime);
	}
}
	
void CCurrentTimeFactory::commitRemove(CWriteableCurrentTime *pCurrentTime)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrentTime++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrentTime);
	}
}

void CCurrentTimeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForDataCenterDesc=0;
int updateWithIndexActionForDataCenterDesc=0;
int updateWithoutIndexActionForDataCenterDesc=0;
int removeActionForDataCenterDesc=0;
int addCommitForDataCenterDesc=0;
int updateCommitForDataCenterDesc=0;
int removeCommitForDataCenterDesc=0;
#endif
void CDataCenterDescFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pActionTriggers=new vector<CDataCenterDescActionTrigger *>;
	pCommitTriggers=new vector<CDataCenterDescCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CDataCenterDescFactory::CDataCenterDescFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDataCenterDesc),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CDataCenterDescFactory::CDataCenterDescFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDataCenterDesc),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CDataCenterDescFactory::~CDataCenterDescFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CDataCenterDescFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CDataCenterDescFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CDataCenterDescFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableDataCenterDesc thisDataCenterDesc;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisDataCenterDesc.readCSV(input,pNames))
		add(&thisDataCenterDesc);
	fclose(input);
	delete pNames;
	return 1;
}

int CDataCenterDescFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "DataCenterDesc.csv");
	return readCSV(szFileName);
}

int CDataCenterDescFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableDataCenterDesc *pDataCenterDesc;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableDataCenterDesc::writeCSVHead(output);
	pDataCenterDesc=(CWriteableDataCenterDesc *)(pMem->getFirst());
	while (pDataCenterDesc!=NULL) {
		if (!pDataCenterDesc->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pDataCenterDesc=(CWriteableDataCenterDesc *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CDataCenterDescFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "DataCenterDesc.csv");
	return writeCSV(szFileName);
}

void CDataCenterDescFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CDataCenterDescFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableDataCenterDesc *pDataCenterDesc;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CDataCenterDescFactory={       Total Count=%d\n", pMem->getCount());
	pDataCenterDesc=(CWriteableDataCenterDesc *)(pMem->getFirst());
	while (pDataCenterDesc!=NULL) {
		pDataCenterDesc->dump(fp,index++);
		pDataCenterDesc=(CWriteableDataCenterDesc *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CDataCenterDescFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CDataCenterDesc *CDataCenterDescFactory::internalAdd(CWriteableDataCenterDesc *pDataCenterDesc, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForDataCenterDesc++;
#endif
	CDataCenterDesc *pTarget;	
	beforeAdd(pDataCenterDesc);
	pTarget=(CDataCenterDesc *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough DataCenterDesc in memory database");
		return NULL;
	}
	forceCopy(pTarget, pDataCenterDesc, sizeof(CDataCenterDesc));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CDataCenterDesc *CDataCenterDescFactory::add(CWriteableDataCenterDesc *pDataCenterDesc, CTransaction *pTransaction)
{
	pDataCenterDesc->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pDataCenterDesc,true);
	}
	else {
		CDataCenterDesc *pNewDataCenterDesc;
		pNewDataCenterDesc = internalAdd(pDataCenterDesc,false);
		pTransaction->addResource(CDataCenterDescResource::alloc(CREATE_ACTION,this,pNewDataCenterDesc,NULL));
		return pNewDataCenterDesc;
	}
}

void CDataCenterDescFactory::internalUpdate(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pNewDataCenterDesc, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForDataCenterDesc++;
	}
	else {
		updateWithoutIndexActionForDataCenterDesc++;
	}
#endif
	CWriteableDataCenterDesc theOldDataCenterDesc;
	beforeUpdate(pDataCenterDesc,pNewDataCenterDesc);
	if (bNoTransaction) {
		forceCopy(&theOldDataCenterDesc,pDataCenterDesc,sizeof(CDataCenterDesc));
	}
	if (updateIndex) {
	}

	forceCopy(pDataCenterDesc,pNewDataCenterDesc,sizeof(CDataCenterDesc));
	pMem->updateObject(pDataCenterDesc);
	if (updateIndex) {
	}
	afterUpdate(pDataCenterDesc);
	if (bNoTransaction) {
		commitUpdate(pDataCenterDesc,&theOldDataCenterDesc);
	}
}

void CDataCenterDescFactory::update(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pNewDataCenterDesc, CTransaction *pTransaction, bool updateIndex)
{
	pNewDataCenterDesc->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pDataCenterDesc,pNewDataCenterDesc,updateIndex,true);
	}
	else {
		pTransaction->addResource(CDataCenterDescResource::alloc(UPDATE_ACTION,this,pDataCenterDesc,pNewDataCenterDesc,updateIndex));
		internalUpdate(pDataCenterDesc,pNewDataCenterDesc,updateIndex,false);
	}
}

void CDataCenterDescFactory::internalRemove(CDataCenterDesc *pDataCenterDesc, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForDataCenterDesc++;
#endif
	CWriteableDataCenterDesc theOldDataCenterDesc;
	beforeRemove(pDataCenterDesc);
	if (bNoTransaction) {
		forceCopy(&theOldDataCenterDesc,pDataCenterDesc,sizeof(CDataCenterDesc));
	}
	pMem->free(pDataCenterDesc);
	if(bNoTransaction) {
		commitRemove(&theOldDataCenterDesc);
	}
}

void CDataCenterDescFactory::remove(CDataCenterDesc *pDataCenterDesc, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pDataCenterDesc,true);
	}
	else {
		pTransaction->addResource(CDataCenterDescResource::alloc(DELETE_ACTION,this,pDataCenterDesc,NULL));
		internalRemove(pDataCenterDesc,false);		
	}
}

CDataCenterDesc* CDataCenterDescFactory::addOrUpdate(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pNewDataCenterDesc, CTransaction *pTransaction, bool updateIndex)
{
	if(pDataCenterDesc == NULL) {
		return add(pNewDataCenterDesc,pTransaction);
	}
	else {
		update(pDataCenterDesc,pNewDataCenterDesc,pTransaction,updateIndex);
		return pDataCenterDesc;
	}
}

void CDataCenterDescFactory::retrieve(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pTargetDataCenterDesc)
{
	forceCopy(pTargetDataCenterDesc, pDataCenterDesc, sizeof(CDataCenterDesc));
}
	
int CDataCenterDescFactory::addActionTrigger(CDataCenterDescActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CDataCenterDescFactory::removeActionTrigger(CDataCenterDescActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CDataCenterDescFactory::addCommitTrigger(CDataCenterDescCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CDataCenterDescFactory::removeCommitTrigger(CDataCenterDescCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CDataCenterDesc *CDataCenterDescFactory::getFirst(void)
{
	CDataCenterDesc *pResult=(CDataCenterDesc *)(pMem->getFirst());
	return pResult;
}
	
CDataCenterDesc *CDataCenterDescFactory::getNext(void)
{
	CDataCenterDesc *pResult=(CDataCenterDesc *)(pMem->getNext());
	return pResult;
}
	
void CDataCenterDescFactory::endGet(void)
{
	pMem->endGet();
}

void CDataCenterDescFactory::beforeAdd(CWriteableDataCenterDesc *pDataCenterDesc)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pDataCenterDesc);
	}
}
	
void CDataCenterDescFactory::afterAdd(CDataCenterDesc *pDataCenterDesc)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pDataCenterDesc);
	}
}

void CDataCenterDescFactory::beforeUpdate(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pNewDataCenterDesc)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pDataCenterDesc,pNewDataCenterDesc);
	}
}
	
void CDataCenterDescFactory::afterUpdate(CDataCenterDesc *pDataCenterDesc)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pDataCenterDesc);
	}
}
	
void CDataCenterDescFactory::beforeRemove(CDataCenterDesc *pDataCenterDesc)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pDataCenterDesc);
	}
}

void CDataCenterDescFactory::commitAdd(CDataCenterDesc *pDataCenterDesc)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForDataCenterDesc++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pDataCenterDesc);
	}
}

void CDataCenterDescFactory::commitUpdate(CDataCenterDesc *pDataCenterDesc, CWriteableDataCenterDesc *pOldDataCenterDesc)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForDataCenterDesc++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pDataCenterDesc,pOldDataCenterDesc);
	}
}
	
void CDataCenterDescFactory::commitRemove(CWriteableDataCenterDesc *pDataCenterDesc)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForDataCenterDesc++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pDataCenterDesc);
	}
}

void CDataCenterDescFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForExchange=0;
int updateWithIndexActionForExchange=0;
int updateWithoutIndexActionForExchange=0;
int removeActionForExchange=0;
int addCommitForExchange=0;
int updateCommitForExchange=0;
int removeCommitForExchange=0;
#endif
void CExchangeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pActionTriggers=new vector<CExchangeActionTrigger *>;
	pCommitTriggers=new vector<CExchangeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CExchangeFactory::CExchangeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExchange),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CExchangeFactory::CExchangeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExchange),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CExchangeFactory::~CExchangeFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CExchangeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CExchangeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CExchangeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableExchange thisExchange;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisExchange.readCSV(input,pNames))
		add(&thisExchange);
	fclose(input);
	delete pNames;
	return 1;
}

int CExchangeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Exchange.csv");
	return readCSV(szFileName);
}

int CExchangeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableExchange *pExchange;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableExchange::writeCSVHead(output);
	pExchange=(CWriteableExchange *)(pMem->getFirst());
	while (pExchange!=NULL) {
		if (!pExchange->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pExchange=(CWriteableExchange *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CExchangeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Exchange.csv");
	return writeCSV(szFileName);
}

void CExchangeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CExchangeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableExchange *pExchange;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CExchangeFactory={       Total Count=%d\n", pMem->getCount());
	pExchange=(CWriteableExchange *)(pMem->getFirst());
	while (pExchange!=NULL) {
		pExchange->dump(fp,index++);
		pExchange=(CWriteableExchange *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CExchangeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CExchange *CExchangeFactory::internalAdd(CWriteableExchange *pExchange, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForExchange++;
#endif
	CExchange *pTarget;	
	beforeAdd(pExchange);
	pTarget=(CExchange *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Exchange in memory database");
		return NULL;
	}
	forceCopy(pTarget, pExchange, sizeof(CExchange));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CExchange *CExchangeFactory::add(CWriteableExchange *pExchange, CTransaction *pTransaction)
{
	pExchange->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pExchange,true);
	}
	else {
		CExchange *pNewExchange;
		pNewExchange = internalAdd(pExchange,false);
		pTransaction->addResource(CExchangeResource::alloc(CREATE_ACTION,this,pNewExchange,NULL));
		return pNewExchange;
	}
}

void CExchangeFactory::internalUpdate(CExchange *pExchange, CWriteableExchange *pNewExchange, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForExchange++;
	}
	else {
		updateWithoutIndexActionForExchange++;
	}
#endif
	CWriteableExchange theOldExchange;
	beforeUpdate(pExchange,pNewExchange);
	if (bNoTransaction) {
		forceCopy(&theOldExchange,pExchange,sizeof(CExchange));
	}
	if (updateIndex) {
	}

	forceCopy(pExchange,pNewExchange,sizeof(CExchange));
	pMem->updateObject(pExchange);
	if (updateIndex) {
	}
	afterUpdate(pExchange);
	if (bNoTransaction) {
		commitUpdate(pExchange,&theOldExchange);
	}
}

void CExchangeFactory::update(CExchange *pExchange, CWriteableExchange *pNewExchange, CTransaction *pTransaction, bool updateIndex)
{
	pNewExchange->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pExchange,pNewExchange,updateIndex,true);
	}
	else {
		pTransaction->addResource(CExchangeResource::alloc(UPDATE_ACTION,this,pExchange,pNewExchange,updateIndex));
		internalUpdate(pExchange,pNewExchange,updateIndex,false);
	}
}

void CExchangeFactory::internalRemove(CExchange *pExchange, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForExchange++;
#endif
	CWriteableExchange theOldExchange;
	beforeRemove(pExchange);
	if (bNoTransaction) {
		forceCopy(&theOldExchange,pExchange,sizeof(CExchange));
	}
	pMem->free(pExchange);
	if(bNoTransaction) {
		commitRemove(&theOldExchange);
	}
}

void CExchangeFactory::remove(CExchange *pExchange, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pExchange,true);
	}
	else {
		pTransaction->addResource(CExchangeResource::alloc(DELETE_ACTION,this,pExchange,NULL));
		internalRemove(pExchange,false);		
	}
}

CExchange* CExchangeFactory::addOrUpdate(CExchange *pExchange, CWriteableExchange *pNewExchange, CTransaction *pTransaction, bool updateIndex)
{
	if(pExchange == NULL) {
		return add(pNewExchange,pTransaction);
	}
	else {
		update(pExchange,pNewExchange,pTransaction,updateIndex);
		return pExchange;
	}
}

void CExchangeFactory::retrieve(CExchange *pExchange, CWriteableExchange *pTargetExchange)
{
	forceCopy(pTargetExchange, pExchange, sizeof(CExchange));
}
	
int CExchangeFactory::addActionTrigger(CExchangeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CExchangeFactory::removeActionTrigger(CExchangeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CExchangeFactory::addCommitTrigger(CExchangeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CExchangeFactory::removeCommitTrigger(CExchangeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CExchange *CExchangeFactory::getFirst(void)
{
	CExchange *pResult=(CExchange *)(pMem->getFirst());
	return pResult;
}
	
CExchange *CExchangeFactory::getNext(void)
{
	CExchange *pResult=(CExchange *)(pMem->getNext());
	return pResult;
}
	
void CExchangeFactory::endGet(void)
{
	pMem->endGet();
}

void CExchangeFactory::beforeAdd(CWriteableExchange *pExchange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pExchange);
	}
}
	
void CExchangeFactory::afterAdd(CExchange *pExchange)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pExchange);
	}
}

void CExchangeFactory::beforeUpdate(CExchange *pExchange, CWriteableExchange *pNewExchange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pExchange,pNewExchange);
	}
}
	
void CExchangeFactory::afterUpdate(CExchange *pExchange)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pExchange);
	}
}
	
void CExchangeFactory::beforeRemove(CExchange *pExchange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pExchange);
	}
}

void CExchangeFactory::commitAdd(CExchange *pExchange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForExchange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pExchange);
	}
}

void CExchangeFactory::commitUpdate(CExchange *pExchange, CWriteableExchange *pOldExchange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForExchange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pExchange,pOldExchange);
	}
}
	
void CExchangeFactory::commitRemove(CWriteableExchange *pExchange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForExchange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pExchange);
	}
}

void CExchangeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSettlementGroupIDIndexinSettlementGroup(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSettlementGroup=0;
int updateWithIndexActionForSettlementGroup=0;
int updateWithoutIndexActionForSettlementGroup=0;
int removeActionForSettlementGroup=0;
int addCommitForSettlementGroup=0;
int updateCommitForSettlementGroup=0;
int removeCommitForSettlementGroup=0;
#endif
void CSettlementGroupFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSettlementGroupIDIndex=new CAVLTree(maxUnit,compareForSettlementGroupIDIndexinSettlementGroup,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SettlementGroup_SettlementGroupIDIndex",pSettlementGroupIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SettlementGroup_SettlementGroupIDIndex");
			if(it != pIndexMap->end()) {
				pSettlementGroupIDIndex=new CAVLTree(maxUnit,compareForSettlementGroupIDIndexinSettlementGroup,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSettlementGroupIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CSettlementGroupActionTrigger *>;
	pCommitTriggers=new vector<CSettlementGroupCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSettlementGroupFactory::CSettlementGroupFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSettlementGroup),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSettlementGroupFactory::CSettlementGroupFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSettlementGroup),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSettlementGroupFactory::~CSettlementGroupFactory(void)
{
	if (runLevel>=0) {
		if (pSettlementGroupIDIndex!=NULL)
			delete pSettlementGroupIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSettlementGroupFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSettlementGroupFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSettlementGroupIDIndex->output(pLogger,indent+1);
	}
}

int CSettlementGroupFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSettlementGroup thisSettlementGroup;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSettlementGroup.readCSV(input,pNames))
		add(&thisSettlementGroup);
	fclose(input);
	delete pNames;
	return 1;
}

int CSettlementGroupFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SettlementGroup.csv");
	return readCSV(szFileName);
}

int CSettlementGroupFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSettlementGroup *pSettlementGroup;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSettlementGroup::writeCSVHead(output);
	pSettlementGroup=(CWriteableSettlementGroup *)(pMem->getFirst());
	while (pSettlementGroup!=NULL) {
		if (!pSettlementGroup->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSettlementGroup=(CWriteableSettlementGroup *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSettlementGroupFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SettlementGroup.csv");
	return writeCSV(szFileName);
}

void CSettlementGroupFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSettlementGroupFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSettlementGroup *pSettlementGroup;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSettlementGroupFactory={       Total Count=%d\n", pMem->getCount());
	pSettlementGroup=(CWriteableSettlementGroup *)(pMem->getFirst());
	while (pSettlementGroup!=NULL) {
		pSettlementGroup->dump(fp,index++);
		pSettlementGroup=(CWriteableSettlementGroup *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSettlementGroupFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSettlementGroupIDIndex->removeAll();
	}
}

CSettlementGroup *CSettlementGroupFactory::internalAdd(CWriteableSettlementGroup *pSettlementGroup, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSettlementGroup++;
#endif
	CSettlementGroup *pTarget;	
	beforeAdd(pSettlementGroup);
	pTarget=(CSettlementGroup *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SettlementGroup in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSettlementGroup, sizeof(CSettlementGroup));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSettlementGroupIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSettlementGroup *CSettlementGroupFactory::add(CWriteableSettlementGroup *pSettlementGroup, CTransaction *pTransaction)
{
	pSettlementGroup->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSettlementGroup,true);
	}
	else {
		CSettlementGroup *pNewSettlementGroup;
		pNewSettlementGroup = internalAdd(pSettlementGroup,false);
		pTransaction->addResource(CSettlementGroupResource::alloc(CREATE_ACTION,this,pNewSettlementGroup,NULL));
		return pNewSettlementGroup;
	}
}

void CSettlementGroupFactory::internalUpdate(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pNewSettlementGroup, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSettlementGroup++;
	}
	else {
		updateWithoutIndexActionForSettlementGroup++;
	}
#endif
	CWriteableSettlementGroup theOldSettlementGroup;
	beforeUpdate(pSettlementGroup,pNewSettlementGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSettlementGroup,pSettlementGroup,sizeof(CSettlementGroup));
	}
	if (updateIndex) {
	}

	forceCopy(pSettlementGroup,pNewSettlementGroup,sizeof(CSettlementGroup));
	pMem->updateObject(pSettlementGroup);
	if (updateIndex) {
	}
	afterUpdate(pSettlementGroup);
	if (bNoTransaction) {
		commitUpdate(pSettlementGroup,&theOldSettlementGroup);
	}
}

void CSettlementGroupFactory::update(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pNewSettlementGroup, CTransaction *pTransaction, bool updateIndex)
{
	pNewSettlementGroup->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSettlementGroup,pNewSettlementGroup,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSettlementGroupResource::alloc(UPDATE_ACTION,this,pSettlementGroup,pNewSettlementGroup,updateIndex));
		internalUpdate(pSettlementGroup,pNewSettlementGroup,updateIndex,false);
	}
}

void CSettlementGroupFactory::internalRemove(CSettlementGroup *pSettlementGroup, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSettlementGroup++;
#endif
	CWriteableSettlementGroup theOldSettlementGroup;
	beforeRemove(pSettlementGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSettlementGroup,pSettlementGroup,sizeof(CSettlementGroup));
	}
	if (runLevel>=0) {
		pSettlementGroupIDIndex->removeObject(pSettlementGroup);
	}
	pMem->free(pSettlementGroup);
	if(bNoTransaction) {
		commitRemove(&theOldSettlementGroup);
	}
}

void CSettlementGroupFactory::remove(CSettlementGroup *pSettlementGroup, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSettlementGroup,true);
	}
	else {
		pTransaction->addResource(CSettlementGroupResource::alloc(DELETE_ACTION,this,pSettlementGroup,NULL));
		internalRemove(pSettlementGroup,false);		
	}
}

CSettlementGroup* CSettlementGroupFactory::addOrUpdate(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pNewSettlementGroup, CTransaction *pTransaction, bool updateIndex)
{
	if(pSettlementGroup == NULL) {
		return add(pNewSettlementGroup,pTransaction);
	}
	else {
		update(pSettlementGroup,pNewSettlementGroup,pTransaction,updateIndex);
		return pSettlementGroup;
	}
}

void CSettlementGroupFactory::retrieve(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pTargetSettlementGroup)
{
	forceCopy(pTargetSettlementGroup, pSettlementGroup, sizeof(CSettlementGroup));
}
	
int CSettlementGroupFactory::addActionTrigger(CSettlementGroupActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSettlementGroupFactory::removeActionTrigger(CSettlementGroupActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSettlementGroupFactory::addCommitTrigger(CSettlementGroupCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSettlementGroupFactory::removeCommitTrigger(CSettlementGroupCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSettlementGroup *CSettlementGroupFactory::getFirst(void)
{
	CSettlementGroup *pResult=(CSettlementGroup *)(pMem->getFirst());
	return pResult;
}
	
CSettlementGroup *CSettlementGroupFactory::getNext(void)
{
	CSettlementGroup *pResult=(CSettlementGroup *)(pMem->getNext());
	return pResult;
}
	
void CSettlementGroupFactory::endGet(void)
{
	pMem->endGet();
}

void CSettlementGroupFactory::beforeAdd(CWriteableSettlementGroup *pSettlementGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSettlementGroup);
	}
}
	
void CSettlementGroupFactory::afterAdd(CSettlementGroup *pSettlementGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSettlementGroup);
	}
}

void CSettlementGroupFactory::beforeUpdate(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pNewSettlementGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSettlementGroup,pNewSettlementGroup);
	}
}
	
void CSettlementGroupFactory::afterUpdate(CSettlementGroup *pSettlementGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSettlementGroup);
	}
}
	
void CSettlementGroupFactory::beforeRemove(CSettlementGroup *pSettlementGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSettlementGroup);
	}
}

void CSettlementGroupFactory::commitAdd(CSettlementGroup *pSettlementGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSettlementGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSettlementGroup);
	}
}

void CSettlementGroupFactory::commitUpdate(CSettlementGroup *pSettlementGroup, CWriteableSettlementGroup *pOldSettlementGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSettlementGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSettlementGroup,pOldSettlementGroup);
	}
}
	
void CSettlementGroupFactory::commitRemove(CWriteableSettlementGroup *pSettlementGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSettlementGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSettlementGroup);
	}
}

void CSettlementGroupFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForMarketIDIndexinMarket(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarket=0;
int updateWithIndexActionForMarket=0;
int updateWithoutIndexActionForMarket=0;
int removeActionForMarket=0;
int addCommitForMarket=0;
int updateCommitForMarket=0;
int removeCommitForMarket=0;
#endif
void CMarketFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pMarketIDIndex=new CAVLTree(maxUnit,compareForMarketIDIndexinMarket,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Market_MarketIDIndex",pMarketIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Market_MarketIDIndex");
			if(it != pIndexMap->end()) {
				pMarketIDIndex=new CAVLTree(maxUnit,compareForMarketIDIndexinMarket,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pMarketIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CMarketActionTrigger *>;
	pCommitTriggers=new vector<CMarketCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketFactory::CMarketFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarket),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketFactory::CMarketFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarket),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketFactory::~CMarketFactory(void)
{
	if (runLevel>=0) {
		if (pMarketIDIndex!=NULL)
			delete pMarketIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pMarketIDIndex->output(pLogger,indent+1);
	}
}

int CMarketFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarket thisMarket;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarket.readCSV(input,pNames))
		add(&thisMarket);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Market.csv");
	return readCSV(szFileName);
}

int CMarketFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarket *pMarket;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarket::writeCSVHead(output);
	pMarket=(CWriteableMarket *)(pMem->getFirst());
	while (pMarket!=NULL) {
		if (!pMarket->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarket=(CWriteableMarket *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Market.csv");
	return writeCSV(szFileName);
}

void CMarketFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarket *pMarket;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketFactory={       Total Count=%d\n", pMem->getCount());
	pMarket=(CWriteableMarket *)(pMem->getFirst());
	while (pMarket!=NULL) {
		pMarket->dump(fp,index++);
		pMarket=(CWriteableMarket *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pMarketIDIndex->removeAll();
	}
}

CMarket *CMarketFactory::internalAdd(CWriteableMarket *pMarket, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarket++;
#endif
	CMarket *pTarget;	
	beforeAdd(pMarket);
	pTarget=(CMarket *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Market in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarket, sizeof(CMarket));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pMarketIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarket *CMarketFactory::add(CWriteableMarket *pMarket, CTransaction *pTransaction)
{
	pMarket->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarket,true);
	}
	else {
		CMarket *pNewMarket;
		pNewMarket = internalAdd(pMarket,false);
		pTransaction->addResource(CMarketResource::alloc(CREATE_ACTION,this,pNewMarket,NULL));
		return pNewMarket;
	}
}

void CMarketFactory::internalUpdate(CMarket *pMarket, CWriteableMarket *pNewMarket, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarket++;
	}
	else {
		updateWithoutIndexActionForMarket++;
	}
#endif
	CWriteableMarket theOldMarket;
	beforeUpdate(pMarket,pNewMarket);
	if (bNoTransaction) {
		forceCopy(&theOldMarket,pMarket,sizeof(CMarket));
	}
	if (updateIndex) {
	}

	forceCopy(pMarket,pNewMarket,sizeof(CMarket));
	pMem->updateObject(pMarket);
	if (updateIndex) {
	}
	afterUpdate(pMarket);
	if (bNoTransaction) {
		commitUpdate(pMarket,&theOldMarket);
	}
}

void CMarketFactory::update(CMarket *pMarket, CWriteableMarket *pNewMarket, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarket->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarket,pNewMarket,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketResource::alloc(UPDATE_ACTION,this,pMarket,pNewMarket,updateIndex));
		internalUpdate(pMarket,pNewMarket,updateIndex,false);
	}
}

void CMarketFactory::internalRemove(CMarket *pMarket, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarket++;
#endif
	CWriteableMarket theOldMarket;
	beforeRemove(pMarket);
	if (bNoTransaction) {
		forceCopy(&theOldMarket,pMarket,sizeof(CMarket));
	}
	if (runLevel>=0) {
		pMarketIDIndex->removeObject(pMarket);
	}
	pMem->free(pMarket);
	if(bNoTransaction) {
		commitRemove(&theOldMarket);
	}
}

void CMarketFactory::remove(CMarket *pMarket, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarket,true);
	}
	else {
		pTransaction->addResource(CMarketResource::alloc(DELETE_ACTION,this,pMarket,NULL));
		internalRemove(pMarket,false);		
	}
}

CMarket* CMarketFactory::addOrUpdate(CMarket *pMarket, CWriteableMarket *pNewMarket, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarket == NULL) {
		return add(pNewMarket,pTransaction);
	}
	else {
		update(pMarket,pNewMarket,pTransaction,updateIndex);
		return pMarket;
	}
}

void CMarketFactory::retrieve(CMarket *pMarket, CWriteableMarket *pTargetMarket)
{
	forceCopy(pTargetMarket, pMarket, sizeof(CMarket));
}
	
int CMarketFactory::addActionTrigger(CMarketActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketFactory::removeActionTrigger(CMarketActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketFactory::addCommitTrigger(CMarketCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketFactory::removeCommitTrigger(CMarketCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarket *CMarketFactory::getFirst(void)
{
	CMarket *pResult=(CMarket *)(pMem->getFirst());
	return pResult;
}
	
CMarket *CMarketFactory::getNext(void)
{
	CMarket *pResult=(CMarket *)(pMem->getNext());
	return pResult;
}
	
void CMarketFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketFactory::beforeAdd(CWriteableMarket *pMarket)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarket);
	}
}
	
void CMarketFactory::afterAdd(CMarket *pMarket)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarket);
	}
}

void CMarketFactory::beforeUpdate(CMarket *pMarket, CWriteableMarket *pNewMarket)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarket,pNewMarket);
	}
}
	
void CMarketFactory::afterUpdate(CMarket *pMarket)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarket);
	}
}
	
void CMarketFactory::beforeRemove(CMarket *pMarket)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarket);
	}
}

void CMarketFactory::commitAdd(CMarket *pMarket)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarket++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarket);
	}
}

void CMarketFactory::commitUpdate(CMarket *pMarket, CWriteableMarket *pOldMarket)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarket++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarket,pOldMarket);
	}
}
	
void CMarketFactory::commitRemove(CWriteableMarket *pMarket)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarket++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarket);
	}
}

void CMarketFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForProductIDIndexinMarketProduct(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketProduct=0;
int updateWithIndexActionForMarketProduct=0;
int updateWithoutIndexActionForMarketProduct=0;
int removeActionForMarketProduct=0;
int addCommitForMarketProduct=0;
int updateCommitForMarketProduct=0;
int removeCommitForMarketProduct=0;
#endif
void CMarketProductFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinMarketProduct,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketProduct_ProductIDIndex",pProductIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketProduct_ProductIDIndex");
			if(it != pIndexMap->end()) {
				pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinMarketProduct,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByProductID=NULL;
	pActionTriggers=new vector<CMarketProductActionTrigger *>;
	pCommitTriggers=new vector<CMarketProductCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketProductFactory::CMarketProductFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketProduct),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketProductFactory::CMarketProductFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketProduct),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketProductFactory::~CMarketProductFactory(void)
{
	if (runLevel>=0) {
		if (pProductIDIndex!=NULL)
			delete pProductIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketProductFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketProductFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pProductIDIndex->output(pLogger,indent+1);
	}
}

int CMarketProductFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketProduct thisMarketProduct;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketProduct.readCSV(input,pNames))
		add(&thisMarketProduct);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketProductFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketProduct.csv");
	return readCSV(szFileName);
}

int CMarketProductFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketProduct *pMarketProduct;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketProduct::writeCSVHead(output);
	pMarketProduct=(CWriteableMarketProduct *)(pMem->getFirst());
	while (pMarketProduct!=NULL) {
		if (!pMarketProduct->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketProduct=(CWriteableMarketProduct *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketProductFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketProduct.csv");
	return writeCSV(szFileName);
}

void CMarketProductFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketProductFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketProduct *pMarketProduct;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketProductFactory={       Total Count=%d\n", pMem->getCount());
	pMarketProduct=(CWriteableMarketProduct *)(pMem->getFirst());
	while (pMarketProduct!=NULL) {
		pMarketProduct->dump(fp,index++);
		pMarketProduct=(CWriteableMarketProduct *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketProductFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pProductIDIndex->removeAll();
	}
}

CMarketProduct *CMarketProductFactory::internalAdd(CWriteableMarketProduct *pMarketProduct, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketProduct++;
#endif
	CMarketProduct *pTarget;	
	beforeAdd(pMarketProduct);
	pTarget=(CMarketProduct *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketProduct in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketProduct, sizeof(CMarketProduct));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pProductIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketProduct *CMarketProductFactory::add(CWriteableMarketProduct *pMarketProduct, CTransaction *pTransaction)
{
	pMarketProduct->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketProduct,true);
	}
	else {
		CMarketProduct *pNewMarketProduct;
		pNewMarketProduct = internalAdd(pMarketProduct,false);
		pTransaction->addResource(CMarketProductResource::alloc(CREATE_ACTION,this,pNewMarketProduct,NULL));
		return pNewMarketProduct;
	}
}

void CMarketProductFactory::internalUpdate(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pNewMarketProduct, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketProduct++;
	}
	else {
		updateWithoutIndexActionForMarketProduct++;
	}
#endif
	CWriteableMarketProduct theOldMarketProduct;
	beforeUpdate(pMarketProduct,pNewMarketProduct);
	if (bNoTransaction) {
		forceCopy(&theOldMarketProduct,pMarketProduct,sizeof(CMarketProduct));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketProduct,pNewMarketProduct,sizeof(CMarketProduct));
	pMem->updateObject(pMarketProduct);
	if (updateIndex) {
	}
	afterUpdate(pMarketProduct);
	if (bNoTransaction) {
		commitUpdate(pMarketProduct,&theOldMarketProduct);
	}
}

void CMarketProductFactory::update(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pNewMarketProduct, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketProduct->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketProduct,pNewMarketProduct,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketProductResource::alloc(UPDATE_ACTION,this,pMarketProduct,pNewMarketProduct,updateIndex));
		internalUpdate(pMarketProduct,pNewMarketProduct,updateIndex,false);
	}
}

void CMarketProductFactory::internalRemove(CMarketProduct *pMarketProduct, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketProduct++;
#endif
	CWriteableMarketProduct theOldMarketProduct;
	beforeRemove(pMarketProduct);
	if (bNoTransaction) {
		forceCopy(&theOldMarketProduct,pMarketProduct,sizeof(CMarketProduct));
	}
	if (runLevel>=0) {
		pProductIDIndex->removeObject(pMarketProduct);
	}
	pMem->free(pMarketProduct);
	if(bNoTransaction) {
		commitRemove(&theOldMarketProduct);
	}
}

void CMarketProductFactory::remove(CMarketProduct *pMarketProduct, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketProduct,true);
	}
	else {
		pTransaction->addResource(CMarketProductResource::alloc(DELETE_ACTION,this,pMarketProduct,NULL));
		internalRemove(pMarketProduct,false);		
	}
}

CMarketProduct* CMarketProductFactory::addOrUpdate(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pNewMarketProduct, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketProduct == NULL) {
		return add(pNewMarketProduct,pTransaction);
	}
	else {
		update(pMarketProduct,pNewMarketProduct,pTransaction,updateIndex);
		return pMarketProduct;
	}
}

void CMarketProductFactory::retrieve(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pTargetMarketProduct)
{
	forceCopy(pTargetMarketProduct, pMarketProduct, sizeof(CMarketProduct));
}
	
int CMarketProductFactory::addActionTrigger(CMarketProductActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketProductFactory::removeActionTrigger(CMarketProductActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketProductFactory::addCommitTrigger(CMarketProductCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketProductFactory::removeCommitTrigger(CMarketProductCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketProduct *CMarketProductFactory::getFirst(void)
{
	CMarketProduct *pResult=(CMarketProduct *)(pMem->getFirst());
	return pResult;
}
	
CMarketProduct *CMarketProductFactory::getNext(void)
{
	CMarketProduct *pResult=(CMarketProduct *)(pMem->getNext());
	return pResult;
}
	
void CMarketProductFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketProductFactory::beforeAdd(CWriteableMarketProduct *pMarketProduct)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketProduct);
	}
}
	
void CMarketProductFactory::afterAdd(CMarketProduct *pMarketProduct)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketProduct);
	}
}

void CMarketProductFactory::beforeUpdate(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pNewMarketProduct)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketProduct,pNewMarketProduct);
	}
}
	
void CMarketProductFactory::afterUpdate(CMarketProduct *pMarketProduct)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketProduct);
	}
}
	
void CMarketProductFactory::beforeRemove(CMarketProduct *pMarketProduct)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketProduct);
	}
}

void CMarketProductFactory::commitAdd(CMarketProduct *pMarketProduct)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketProduct++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketProduct);
	}
}

void CMarketProductFactory::commitUpdate(CMarketProduct *pMarketProduct, CWriteableMarketProduct *pOldMarketProduct)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketProduct++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketProduct,pOldMarketProduct);
	}
}
	
void CMarketProductFactory::commitRemove(CWriteableMarketProduct *pMarketProduct)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketProduct++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketProduct);
	}
}

void CMarketProductFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForProductGroupIDIndexinMarketProductGroup(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketProductGroup=0;
int updateWithIndexActionForMarketProductGroup=0;
int updateWithoutIndexActionForMarketProductGroup=0;
int removeActionForMarketProductGroup=0;
int addCommitForMarketProductGroup=0;
int updateCommitForMarketProductGroup=0;
int removeCommitForMarketProductGroup=0;
#endif
void CMarketProductGroupFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pProductGroupIDIndex=new CAVLTree(maxUnit,compareForProductGroupIDIndexinMarketProductGroup,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketProductGroup_ProductGroupIDIndex",pProductGroupIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketProductGroup_ProductGroupIDIndex");
			if(it != pIndexMap->end()) {
				pProductGroupIDIndex=new CAVLTree(maxUnit,compareForProductGroupIDIndexinMarketProductGroup,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductGroupIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByProductGroupID=NULL;
	pActionTriggers=new vector<CMarketProductGroupActionTrigger *>;
	pCommitTriggers=new vector<CMarketProductGroupCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketProductGroupFactory::CMarketProductGroupFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketProductGroup),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketProductGroupFactory::CMarketProductGroupFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketProductGroup),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketProductGroupFactory::~CMarketProductGroupFactory(void)
{
	if (runLevel>=0) {
		if (pProductGroupIDIndex!=NULL)
			delete pProductGroupIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketProductGroupFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketProductGroupFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pProductGroupIDIndex->output(pLogger,indent+1);
	}
}

int CMarketProductGroupFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketProductGroup thisMarketProductGroup;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketProductGroup.readCSV(input,pNames))
		add(&thisMarketProductGroup);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketProductGroupFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketProductGroup.csv");
	return readCSV(szFileName);
}

int CMarketProductGroupFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketProductGroup *pMarketProductGroup;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketProductGroup::writeCSVHead(output);
	pMarketProductGroup=(CWriteableMarketProductGroup *)(pMem->getFirst());
	while (pMarketProductGroup!=NULL) {
		if (!pMarketProductGroup->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketProductGroup=(CWriteableMarketProductGroup *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketProductGroupFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketProductGroup.csv");
	return writeCSV(szFileName);
}

void CMarketProductGroupFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketProductGroupFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketProductGroup *pMarketProductGroup;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketProductGroupFactory={       Total Count=%d\n", pMem->getCount());
	pMarketProductGroup=(CWriteableMarketProductGroup *)(pMem->getFirst());
	while (pMarketProductGroup!=NULL) {
		pMarketProductGroup->dump(fp,index++);
		pMarketProductGroup=(CWriteableMarketProductGroup *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketProductGroupFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pProductGroupIDIndex->removeAll();
	}
}

CMarketProductGroup *CMarketProductGroupFactory::internalAdd(CWriteableMarketProductGroup *pMarketProductGroup, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketProductGroup++;
#endif
	CMarketProductGroup *pTarget;	
	beforeAdd(pMarketProductGroup);
	pTarget=(CMarketProductGroup *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketProductGroup in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketProductGroup, sizeof(CMarketProductGroup));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pProductGroupIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketProductGroup *CMarketProductGroupFactory::add(CWriteableMarketProductGroup *pMarketProductGroup, CTransaction *pTransaction)
{
	pMarketProductGroup->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketProductGroup,true);
	}
	else {
		CMarketProductGroup *pNewMarketProductGroup;
		pNewMarketProductGroup = internalAdd(pMarketProductGroup,false);
		pTransaction->addResource(CMarketProductGroupResource::alloc(CREATE_ACTION,this,pNewMarketProductGroup,NULL));
		return pNewMarketProductGroup;
	}
}

void CMarketProductGroupFactory::internalUpdate(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pNewMarketProductGroup, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketProductGroup++;
	}
	else {
		updateWithoutIndexActionForMarketProductGroup++;
	}
#endif
	CWriteableMarketProductGroup theOldMarketProductGroup;
	beforeUpdate(pMarketProductGroup,pNewMarketProductGroup);
	if (bNoTransaction) {
		forceCopy(&theOldMarketProductGroup,pMarketProductGroup,sizeof(CMarketProductGroup));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketProductGroup,pNewMarketProductGroup,sizeof(CMarketProductGroup));
	pMem->updateObject(pMarketProductGroup);
	if (updateIndex) {
	}
	afterUpdate(pMarketProductGroup);
	if (bNoTransaction) {
		commitUpdate(pMarketProductGroup,&theOldMarketProductGroup);
	}
}

void CMarketProductGroupFactory::update(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pNewMarketProductGroup, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketProductGroup->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketProductGroup,pNewMarketProductGroup,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketProductGroupResource::alloc(UPDATE_ACTION,this,pMarketProductGroup,pNewMarketProductGroup,updateIndex));
		internalUpdate(pMarketProductGroup,pNewMarketProductGroup,updateIndex,false);
	}
}

void CMarketProductGroupFactory::internalRemove(CMarketProductGroup *pMarketProductGroup, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketProductGroup++;
#endif
	CWriteableMarketProductGroup theOldMarketProductGroup;
	beforeRemove(pMarketProductGroup);
	if (bNoTransaction) {
		forceCopy(&theOldMarketProductGroup,pMarketProductGroup,sizeof(CMarketProductGroup));
	}
	if (runLevel>=0) {
		pProductGroupIDIndex->removeObject(pMarketProductGroup);
	}
	pMem->free(pMarketProductGroup);
	if(bNoTransaction) {
		commitRemove(&theOldMarketProductGroup);
	}
}

void CMarketProductGroupFactory::remove(CMarketProductGroup *pMarketProductGroup, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketProductGroup,true);
	}
	else {
		pTransaction->addResource(CMarketProductGroupResource::alloc(DELETE_ACTION,this,pMarketProductGroup,NULL));
		internalRemove(pMarketProductGroup,false);		
	}
}

CMarketProductGroup* CMarketProductGroupFactory::addOrUpdate(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pNewMarketProductGroup, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketProductGroup == NULL) {
		return add(pNewMarketProductGroup,pTransaction);
	}
	else {
		update(pMarketProductGroup,pNewMarketProductGroup,pTransaction,updateIndex);
		return pMarketProductGroup;
	}
}

void CMarketProductGroupFactory::retrieve(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pTargetMarketProductGroup)
{
	forceCopy(pTargetMarketProductGroup, pMarketProductGroup, sizeof(CMarketProductGroup));
}
	
int CMarketProductGroupFactory::addActionTrigger(CMarketProductGroupActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketProductGroupFactory::removeActionTrigger(CMarketProductGroupActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketProductGroupFactory::addCommitTrigger(CMarketProductGroupCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketProductGroupFactory::removeCommitTrigger(CMarketProductGroupCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketProductGroup *CMarketProductGroupFactory::getFirst(void)
{
	CMarketProductGroup *pResult=(CMarketProductGroup *)(pMem->getFirst());
	return pResult;
}
	
CMarketProductGroup *CMarketProductGroupFactory::getNext(void)
{
	CMarketProductGroup *pResult=(CMarketProductGroup *)(pMem->getNext());
	return pResult;
}
	
void CMarketProductGroupFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketProductGroupFactory::beforeAdd(CWriteableMarketProductGroup *pMarketProductGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketProductGroup);
	}
}
	
void CMarketProductGroupFactory::afterAdd(CMarketProductGroup *pMarketProductGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketProductGroup);
	}
}

void CMarketProductGroupFactory::beforeUpdate(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pNewMarketProductGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketProductGroup,pNewMarketProductGroup);
	}
}
	
void CMarketProductGroupFactory::afterUpdate(CMarketProductGroup *pMarketProductGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketProductGroup);
	}
}
	
void CMarketProductGroupFactory::beforeRemove(CMarketProductGroup *pMarketProductGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketProductGroup);
	}
}

void CMarketProductGroupFactory::commitAdd(CMarketProductGroup *pMarketProductGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketProductGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketProductGroup);
	}
}

void CMarketProductGroupFactory::commitUpdate(CMarketProductGroup *pMarketProductGroup, CWriteableMarketProductGroup *pOldMarketProductGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketProductGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketProductGroup,pOldMarketProductGroup);
	}
}
	
void CMarketProductGroupFactory::commitRemove(CWriteableMarketProductGroup *pMarketProductGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketProductGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketProductGroup);
	}
}

void CMarketProductGroupFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForProductIDInstrumentStatusIndexinMdPubStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMdPubStatus=0;
int updateWithIndexActionForMdPubStatus=0;
int updateWithoutIndexActionForMdPubStatus=0;
int removeActionForMdPubStatus=0;
int addCommitForMdPubStatus=0;
int updateCommitForMdPubStatus=0;
int removeCommitForMdPubStatus=0;
#endif
void CMdPubStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pProductIDInstrumentStatusIndex=new CAVLTree(maxUnit,compareForProductIDInstrumentStatusIndexinMdPubStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MdPubStatus_ProductIDInstrumentStatusIndex",pProductIDInstrumentStatusIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MdPubStatus_ProductIDInstrumentStatusIndex");
			if(it != pIndexMap->end()) {
				pProductIDInstrumentStatusIndex=new CAVLTree(maxUnit,compareForProductIDInstrumentStatusIndexinMdPubStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductIDInstrumentStatusIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CMdPubStatusActionTrigger *>;
	pCommitTriggers=new vector<CMdPubStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMdPubStatusFactory::CMdPubStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMdPubStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMdPubStatusFactory::CMdPubStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMdPubStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMdPubStatusFactory::~CMdPubStatusFactory(void)
{
	if (runLevel>=0) {
		if (pProductIDInstrumentStatusIndex!=NULL)
			delete pProductIDInstrumentStatusIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMdPubStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMdPubStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pProductIDInstrumentStatusIndex->output(pLogger,indent+1);
	}
}

int CMdPubStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMdPubStatus thisMdPubStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMdPubStatus.readCSV(input,pNames))
		add(&thisMdPubStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CMdPubStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MdPubStatus.csv");
	return readCSV(szFileName);
}

int CMdPubStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMdPubStatus *pMdPubStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMdPubStatus::writeCSVHead(output);
	pMdPubStatus=(CWriteableMdPubStatus *)(pMem->getFirst());
	while (pMdPubStatus!=NULL) {
		if (!pMdPubStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMdPubStatus=(CWriteableMdPubStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMdPubStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MdPubStatus.csv");
	return writeCSV(szFileName);
}

void CMdPubStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMdPubStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMdPubStatus *pMdPubStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMdPubStatusFactory={       Total Count=%d\n", pMem->getCount());
	pMdPubStatus=(CWriteableMdPubStatus *)(pMem->getFirst());
	while (pMdPubStatus!=NULL) {
		pMdPubStatus->dump(fp,index++);
		pMdPubStatus=(CWriteableMdPubStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMdPubStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pProductIDInstrumentStatusIndex->removeAll();
	}
}

CMdPubStatus *CMdPubStatusFactory::internalAdd(CWriteableMdPubStatus *pMdPubStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMdPubStatus++;
#endif
	CMdPubStatus *pTarget;	
	beforeAdd(pMdPubStatus);
	pTarget=(CMdPubStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MdPubStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMdPubStatus, sizeof(CMdPubStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pProductIDInstrumentStatusIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMdPubStatus *CMdPubStatusFactory::add(CWriteableMdPubStatus *pMdPubStatus, CTransaction *pTransaction)
{
	pMdPubStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMdPubStatus,true);
	}
	else {
		CMdPubStatus *pNewMdPubStatus;
		pNewMdPubStatus = internalAdd(pMdPubStatus,false);
		pTransaction->addResource(CMdPubStatusResource::alloc(CREATE_ACTION,this,pNewMdPubStatus,NULL));
		return pNewMdPubStatus;
	}
}

void CMdPubStatusFactory::internalUpdate(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pNewMdPubStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMdPubStatus++;
	}
	else {
		updateWithoutIndexActionForMdPubStatus++;
	}
#endif
	CWriteableMdPubStatus theOldMdPubStatus;
	beforeUpdate(pMdPubStatus,pNewMdPubStatus);
	if (bNoTransaction) {
		forceCopy(&theOldMdPubStatus,pMdPubStatus,sizeof(CMdPubStatus));
	}
	CAVLNode *pProductIDInstrumentStatusIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pProductIDInstrumentStatusIndexNode=pProductIDInstrumentStatusIndex->findObject(pMdPubStatus);
		}
	}

	forceCopy(pMdPubStatus,pNewMdPubStatus,sizeof(CMdPubStatus));
	pMem->updateObject(pMdPubStatus);
	if (updateIndex) {
		if (runLevel>=0) {
			pProductIDInstrumentStatusIndex->updateNode(pProductIDInstrumentStatusIndexNode);
		}
	}
	afterUpdate(pMdPubStatus);
	if (bNoTransaction) {
		commitUpdate(pMdPubStatus,&theOldMdPubStatus);
	}
}

void CMdPubStatusFactory::update(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pNewMdPubStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewMdPubStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMdPubStatus,pNewMdPubStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMdPubStatusResource::alloc(UPDATE_ACTION,this,pMdPubStatus,pNewMdPubStatus,updateIndex));
		internalUpdate(pMdPubStatus,pNewMdPubStatus,updateIndex,false);
	}
}

void CMdPubStatusFactory::internalRemove(CMdPubStatus *pMdPubStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMdPubStatus++;
#endif
	CWriteableMdPubStatus theOldMdPubStatus;
	beforeRemove(pMdPubStatus);
	if (bNoTransaction) {
		forceCopy(&theOldMdPubStatus,pMdPubStatus,sizeof(CMdPubStatus));
	}
	if (runLevel>=0) {
		pProductIDInstrumentStatusIndex->removeObject(pMdPubStatus);
	}
	pMem->free(pMdPubStatus);
	if(bNoTransaction) {
		commitRemove(&theOldMdPubStatus);
	}
}

void CMdPubStatusFactory::remove(CMdPubStatus *pMdPubStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMdPubStatus,true);
	}
	else {
		pTransaction->addResource(CMdPubStatusResource::alloc(DELETE_ACTION,this,pMdPubStatus,NULL));
		internalRemove(pMdPubStatus,false);		
	}
}

CMdPubStatus* CMdPubStatusFactory::addOrUpdate(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pNewMdPubStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pMdPubStatus == NULL) {
		return add(pNewMdPubStatus,pTransaction);
	}
	else {
		update(pMdPubStatus,pNewMdPubStatus,pTransaction,updateIndex);
		return pMdPubStatus;
	}
}

void CMdPubStatusFactory::retrieve(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pTargetMdPubStatus)
{
	forceCopy(pTargetMdPubStatus, pMdPubStatus, sizeof(CMdPubStatus));
}
	
int CMdPubStatusFactory::addActionTrigger(CMdPubStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMdPubStatusFactory::removeActionTrigger(CMdPubStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMdPubStatusFactory::addCommitTrigger(CMdPubStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMdPubStatusFactory::removeCommitTrigger(CMdPubStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMdPubStatus *CMdPubStatusFactory::getFirst(void)
{
	CMdPubStatus *pResult=(CMdPubStatus *)(pMem->getFirst());
	return pResult;
}
	
CMdPubStatus *CMdPubStatusFactory::getNext(void)
{
	CMdPubStatus *pResult=(CMdPubStatus *)(pMem->getNext());
	return pResult;
}
	
void CMdPubStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CMdPubStatusFactory::beforeAdd(CWriteableMdPubStatus *pMdPubStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMdPubStatus);
	}
}
	
void CMdPubStatusFactory::afterAdd(CMdPubStatus *pMdPubStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMdPubStatus);
	}
}

void CMdPubStatusFactory::beforeUpdate(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pNewMdPubStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMdPubStatus,pNewMdPubStatus);
	}
}
	
void CMdPubStatusFactory::afterUpdate(CMdPubStatus *pMdPubStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMdPubStatus);
	}
}
	
void CMdPubStatusFactory::beforeRemove(CMdPubStatus *pMdPubStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMdPubStatus);
	}
}

void CMdPubStatusFactory::commitAdd(CMdPubStatus *pMdPubStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMdPubStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMdPubStatus);
	}
}

void CMdPubStatusFactory::commitUpdate(CMdPubStatus *pMdPubStatus, CWriteableMdPubStatus *pOldMdPubStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMdPubStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMdPubStatus,pOldMdPubStatus);
	}
}
	
void CMdPubStatusFactory::commitRemove(CWriteableMdPubStatus *pMdPubStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMdPubStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMdPubStatus);
	}
}

void CMdPubStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForTopicIDIndexinMarketDataTopic(const void *pV1, const void *pV2);
extern int compareForMarketIDIndexinMarketDataTopic(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketDataTopic=0;
int updateWithIndexActionForMarketDataTopic=0;
int updateWithoutIndexActionForMarketDataTopic=0;
int removeActionForMarketDataTopic=0;
int addCommitForMarketDataTopic=0;
int updateCommitForMarketDataTopic=0;
int removeCommitForMarketDataTopic=0;
#endif
void CMarketDataTopicFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pTopicIDIndex=new CAVLTree(maxUnit,compareForTopicIDIndexinMarketDataTopic,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketDataTopic_TopicIDIndex",pTopicIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketDataTopic_TopicIDIndex");
			if(it != pIndexMap->end()) {
				pTopicIDIndex=new CAVLTree(maxUnit,compareForTopicIDIndexinMarketDataTopic,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pTopicIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pMarketIDIndex=new CAVLTree(maxUnit,compareForMarketIDIndexinMarketDataTopic,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketDataTopic_MarketIDIndex",pMarketIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketDataTopic_MarketIDIndex");
			if(it != pIndexMap->end()) {
				pMarketIDIndex=new CAVLTree(maxUnit,compareForMarketIDIndexinMarketDataTopic,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pMarketIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByMarketID=NULL;
	pActionTriggers=new vector<CMarketDataTopicActionTrigger *>;
	pCommitTriggers=new vector<CMarketDataTopicCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketDataTopicFactory::CMarketDataTopicFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataTopic),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketDataTopicFactory::CMarketDataTopicFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataTopic),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketDataTopicFactory::~CMarketDataTopicFactory(void)
{
	if (runLevel>=0) {
		if (pTopicIDIndex!=NULL)
			delete pTopicIDIndex;
	}
	if (runLevel>=0) {
		if (pMarketIDIndex!=NULL)
			delete pMarketIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketDataTopicFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketDataTopicFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pTopicIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pMarketIDIndex->output(pLogger,indent+1);
	}
}

int CMarketDataTopicFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketDataTopic thisMarketDataTopic;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketDataTopic.readCSV(input,pNames))
		add(&thisMarketDataTopic);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketDataTopicFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketDataTopic.csv");
	return readCSV(szFileName);
}

int CMarketDataTopicFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketDataTopic *pMarketDataTopic;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketDataTopic::writeCSVHead(output);
	pMarketDataTopic=(CWriteableMarketDataTopic *)(pMem->getFirst());
	while (pMarketDataTopic!=NULL) {
		if (!pMarketDataTopic->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketDataTopic=(CWriteableMarketDataTopic *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketDataTopicFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketDataTopic.csv");
	return writeCSV(szFileName);
}

void CMarketDataTopicFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketDataTopicFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketDataTopic *pMarketDataTopic;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketDataTopicFactory={       Total Count=%d\n", pMem->getCount());
	pMarketDataTopic=(CWriteableMarketDataTopic *)(pMem->getFirst());
	while (pMarketDataTopic!=NULL) {
		pMarketDataTopic->dump(fp,index++);
		pMarketDataTopic=(CWriteableMarketDataTopic *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketDataTopicFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pTopicIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pMarketIDIndex->removeAll();
	}
}

CMarketDataTopic *CMarketDataTopicFactory::internalAdd(CWriteableMarketDataTopic *pMarketDataTopic, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketDataTopic++;
#endif
	CMarketDataTopic *pTarget;	
	beforeAdd(pMarketDataTopic);
	pTarget=(CMarketDataTopic *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketDataTopic in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketDataTopic, sizeof(CMarketDataTopic));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pTopicIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pMarketIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketDataTopic *CMarketDataTopicFactory::add(CWriteableMarketDataTopic *pMarketDataTopic, CTransaction *pTransaction)
{
	pMarketDataTopic->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketDataTopic,true);
	}
	else {
		CMarketDataTopic *pNewMarketDataTopic;
		pNewMarketDataTopic = internalAdd(pMarketDataTopic,false);
		pTransaction->addResource(CMarketDataTopicResource::alloc(CREATE_ACTION,this,pNewMarketDataTopic,NULL));
		return pNewMarketDataTopic;
	}
}

void CMarketDataTopicFactory::internalUpdate(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pNewMarketDataTopic, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketDataTopic++;
	}
	else {
		updateWithoutIndexActionForMarketDataTopic++;
	}
#endif
	CWriteableMarketDataTopic theOldMarketDataTopic;
	beforeUpdate(pMarketDataTopic,pNewMarketDataTopic);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataTopic,pMarketDataTopic,sizeof(CMarketDataTopic));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketDataTopic,pNewMarketDataTopic,sizeof(CMarketDataTopic));
	pMem->updateObject(pMarketDataTopic);
	if (updateIndex) {
	}
	afterUpdate(pMarketDataTopic);
	if (bNoTransaction) {
		commitUpdate(pMarketDataTopic,&theOldMarketDataTopic);
	}
}

void CMarketDataTopicFactory::update(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pNewMarketDataTopic, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketDataTopic->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketDataTopic,pNewMarketDataTopic,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketDataTopicResource::alloc(UPDATE_ACTION,this,pMarketDataTopic,pNewMarketDataTopic,updateIndex));
		internalUpdate(pMarketDataTopic,pNewMarketDataTopic,updateIndex,false);
	}
}

void CMarketDataTopicFactory::internalRemove(CMarketDataTopic *pMarketDataTopic, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketDataTopic++;
#endif
	CWriteableMarketDataTopic theOldMarketDataTopic;
	beforeRemove(pMarketDataTopic);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataTopic,pMarketDataTopic,sizeof(CMarketDataTopic));
	}
	if (runLevel>=0) {
		pTopicIDIndex->removeObject(pMarketDataTopic);
	}
	if (runLevel>=0) {
		pMarketIDIndex->removeObject(pMarketDataTopic);
	}
	pMem->free(pMarketDataTopic);
	if(bNoTransaction) {
		commitRemove(&theOldMarketDataTopic);
	}
}

void CMarketDataTopicFactory::remove(CMarketDataTopic *pMarketDataTopic, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketDataTopic,true);
	}
	else {
		pTransaction->addResource(CMarketDataTopicResource::alloc(DELETE_ACTION,this,pMarketDataTopic,NULL));
		internalRemove(pMarketDataTopic,false);		
	}
}

CMarketDataTopic* CMarketDataTopicFactory::addOrUpdate(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pNewMarketDataTopic, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketDataTopic == NULL) {
		return add(pNewMarketDataTopic,pTransaction);
	}
	else {
		update(pMarketDataTopic,pNewMarketDataTopic,pTransaction,updateIndex);
		return pMarketDataTopic;
	}
}

void CMarketDataTopicFactory::retrieve(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pTargetMarketDataTopic)
{
	forceCopy(pTargetMarketDataTopic, pMarketDataTopic, sizeof(CMarketDataTopic));
}
	
int CMarketDataTopicFactory::addActionTrigger(CMarketDataTopicActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketDataTopicFactory::removeActionTrigger(CMarketDataTopicActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketDataTopicFactory::addCommitTrigger(CMarketDataTopicCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketDataTopicFactory::removeCommitTrigger(CMarketDataTopicCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketDataTopic *CMarketDataTopicFactory::getFirst(void)
{
	CMarketDataTopic *pResult=(CMarketDataTopic *)(pMem->getFirst());
	return pResult;
}
	
CMarketDataTopic *CMarketDataTopicFactory::getNext(void)
{
	CMarketDataTopic *pResult=(CMarketDataTopic *)(pMem->getNext());
	return pResult;
}
	
void CMarketDataTopicFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketDataTopicFactory::beforeAdd(CWriteableMarketDataTopic *pMarketDataTopic)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketDataTopic);
	}
}
	
void CMarketDataTopicFactory::afterAdd(CMarketDataTopic *pMarketDataTopic)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketDataTopic);
	}
}

void CMarketDataTopicFactory::beforeUpdate(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pNewMarketDataTopic)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketDataTopic,pNewMarketDataTopic);
	}
}
	
void CMarketDataTopicFactory::afterUpdate(CMarketDataTopic *pMarketDataTopic)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketDataTopic);
	}
}
	
void CMarketDataTopicFactory::beforeRemove(CMarketDataTopic *pMarketDataTopic)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketDataTopic);
	}
}

void CMarketDataTopicFactory::commitAdd(CMarketDataTopic *pMarketDataTopic)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketDataTopic++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketDataTopic);
	}
}

void CMarketDataTopicFactory::commitUpdate(CMarketDataTopic *pMarketDataTopic, CWriteableMarketDataTopic *pOldMarketDataTopic)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketDataTopic++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketDataTopic,pOldMarketDataTopic);
	}
}
	
void CMarketDataTopicFactory::commitRemove(CWriteableMarketDataTopic *pMarketDataTopic)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketDataTopic++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketDataTopic);
	}
}

void CMarketDataTopicFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForPartIDTopicIDIndexinPartTopicSubscribe(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForPartTopicSubscribe=0;
int updateWithIndexActionForPartTopicSubscribe=0;
int updateWithoutIndexActionForPartTopicSubscribe=0;
int removeActionForPartTopicSubscribe=0;
int addCommitForPartTopicSubscribe=0;
int updateCommitForPartTopicSubscribe=0;
int removeCommitForPartTopicSubscribe=0;
#endif
void CPartTopicSubscribeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pPartIDTopicIDIndex=new CAVLTree(maxUnit,compareForPartIDTopicIDIndexinPartTopicSubscribe,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartTopicSubscribe_PartIDTopicIDIndex",pPartIDTopicIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartTopicSubscribe_PartIDTopicIDIndex");
			if(it != pIndexMap->end()) {
				pPartIDTopicIDIndex=new CAVLTree(maxUnit,compareForPartIDTopicIDIndexinPartTopicSubscribe,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartIDTopicIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByPartID=NULL;
	pActionTriggers=new vector<CPartTopicSubscribeActionTrigger *>;
	pCommitTriggers=new vector<CPartTopicSubscribeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartTopicSubscribeFactory::CPartTopicSubscribeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartTopicSubscribe),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartTopicSubscribeFactory::CPartTopicSubscribeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartTopicSubscribe),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartTopicSubscribeFactory::~CPartTopicSubscribeFactory(void)
{
	if (runLevel>=0) {
		if (pPartIDTopicIDIndex!=NULL)
			delete pPartIDTopicIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartTopicSubscribeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartTopicSubscribeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pPartIDTopicIDIndex->output(pLogger,indent+1);
	}
}

int CPartTopicSubscribeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartTopicSubscribe thisPartTopicSubscribe;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartTopicSubscribe.readCSV(input,pNames))
		add(&thisPartTopicSubscribe);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartTopicSubscribeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartTopicSubscribe.csv");
	return readCSV(szFileName);
}

int CPartTopicSubscribeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartTopicSubscribe *pPartTopicSubscribe;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartTopicSubscribe::writeCSVHead(output);
	pPartTopicSubscribe=(CWriteablePartTopicSubscribe *)(pMem->getFirst());
	while (pPartTopicSubscribe!=NULL) {
		if (!pPartTopicSubscribe->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartTopicSubscribe=(CWriteablePartTopicSubscribe *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartTopicSubscribeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartTopicSubscribe.csv");
	return writeCSV(szFileName);
}

void CPartTopicSubscribeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartTopicSubscribeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartTopicSubscribe *pPartTopicSubscribe;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartTopicSubscribeFactory={       Total Count=%d\n", pMem->getCount());
	pPartTopicSubscribe=(CWriteablePartTopicSubscribe *)(pMem->getFirst());
	while (pPartTopicSubscribe!=NULL) {
		pPartTopicSubscribe->dump(fp,index++);
		pPartTopicSubscribe=(CWriteablePartTopicSubscribe *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartTopicSubscribeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pPartIDTopicIDIndex->removeAll();
	}
}

CPartTopicSubscribe *CPartTopicSubscribeFactory::internalAdd(CWriteablePartTopicSubscribe *pPartTopicSubscribe, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartTopicSubscribe++;
#endif
	CPartTopicSubscribe *pTarget;	
	beforeAdd(pPartTopicSubscribe);
	pTarget=(CPartTopicSubscribe *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartTopicSubscribe in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartTopicSubscribe, sizeof(CPartTopicSubscribe));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pPartIDTopicIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartTopicSubscribe *CPartTopicSubscribeFactory::add(CWriteablePartTopicSubscribe *pPartTopicSubscribe, CTransaction *pTransaction)
{
	pPartTopicSubscribe->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartTopicSubscribe,true);
	}
	else {
		CPartTopicSubscribe *pNewPartTopicSubscribe;
		pNewPartTopicSubscribe = internalAdd(pPartTopicSubscribe,false);
		pTransaction->addResource(CPartTopicSubscribeResource::alloc(CREATE_ACTION,this,pNewPartTopicSubscribe,NULL));
		return pNewPartTopicSubscribe;
	}
}

void CPartTopicSubscribeFactory::internalUpdate(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pNewPartTopicSubscribe, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartTopicSubscribe++;
	}
	else {
		updateWithoutIndexActionForPartTopicSubscribe++;
	}
#endif
	CWriteablePartTopicSubscribe theOldPartTopicSubscribe;
	beforeUpdate(pPartTopicSubscribe,pNewPartTopicSubscribe);
	if (bNoTransaction) {
		forceCopy(&theOldPartTopicSubscribe,pPartTopicSubscribe,sizeof(CPartTopicSubscribe));
	}
	if (updateIndex) {
	}

	forceCopy(pPartTopicSubscribe,pNewPartTopicSubscribe,sizeof(CPartTopicSubscribe));
	pMem->updateObject(pPartTopicSubscribe);
	if (updateIndex) {
	}
	afterUpdate(pPartTopicSubscribe);
	if (bNoTransaction) {
		commitUpdate(pPartTopicSubscribe,&theOldPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::update(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pNewPartTopicSubscribe, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartTopicSubscribe->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartTopicSubscribe,pNewPartTopicSubscribe,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartTopicSubscribeResource::alloc(UPDATE_ACTION,this,pPartTopicSubscribe,pNewPartTopicSubscribe,updateIndex));
		internalUpdate(pPartTopicSubscribe,pNewPartTopicSubscribe,updateIndex,false);
	}
}

void CPartTopicSubscribeFactory::internalRemove(CPartTopicSubscribe *pPartTopicSubscribe, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartTopicSubscribe++;
#endif
	CWriteablePartTopicSubscribe theOldPartTopicSubscribe;
	beforeRemove(pPartTopicSubscribe);
	if (bNoTransaction) {
		forceCopy(&theOldPartTopicSubscribe,pPartTopicSubscribe,sizeof(CPartTopicSubscribe));
	}
	if (runLevel>=0) {
		pPartIDTopicIDIndex->removeObject(pPartTopicSubscribe);
	}
	pMem->free(pPartTopicSubscribe);
	if(bNoTransaction) {
		commitRemove(&theOldPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::remove(CPartTopicSubscribe *pPartTopicSubscribe, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartTopicSubscribe,true);
	}
	else {
		pTransaction->addResource(CPartTopicSubscribeResource::alloc(DELETE_ACTION,this,pPartTopicSubscribe,NULL));
		internalRemove(pPartTopicSubscribe,false);		
	}
}

CPartTopicSubscribe* CPartTopicSubscribeFactory::addOrUpdate(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pNewPartTopicSubscribe, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartTopicSubscribe == NULL) {
		return add(pNewPartTopicSubscribe,pTransaction);
	}
	else {
		update(pPartTopicSubscribe,pNewPartTopicSubscribe,pTransaction,updateIndex);
		return pPartTopicSubscribe;
	}
}

void CPartTopicSubscribeFactory::retrieve(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pTargetPartTopicSubscribe)
{
	forceCopy(pTargetPartTopicSubscribe, pPartTopicSubscribe, sizeof(CPartTopicSubscribe));
}
	
int CPartTopicSubscribeFactory::addActionTrigger(CPartTopicSubscribeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartTopicSubscribeFactory::removeActionTrigger(CPartTopicSubscribeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartTopicSubscribeFactory::addCommitTrigger(CPartTopicSubscribeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartTopicSubscribeFactory::removeCommitTrigger(CPartTopicSubscribeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartTopicSubscribe *CPartTopicSubscribeFactory::getFirst(void)
{
	CPartTopicSubscribe *pResult=(CPartTopicSubscribe *)(pMem->getFirst());
	return pResult;
}
	
CPartTopicSubscribe *CPartTopicSubscribeFactory::getNext(void)
{
	CPartTopicSubscribe *pResult=(CPartTopicSubscribe *)(pMem->getNext());
	return pResult;
}
	
void CPartTopicSubscribeFactory::endGet(void)
{
	pMem->endGet();
}

void CPartTopicSubscribeFactory::beforeAdd(CWriteablePartTopicSubscribe *pPartTopicSubscribe)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartTopicSubscribe);
	}
}
	
void CPartTopicSubscribeFactory::afterAdd(CPartTopicSubscribe *pPartTopicSubscribe)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::beforeUpdate(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pNewPartTopicSubscribe)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartTopicSubscribe,pNewPartTopicSubscribe);
	}
}
	
void CPartTopicSubscribeFactory::afterUpdate(CPartTopicSubscribe *pPartTopicSubscribe)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartTopicSubscribe);
	}
}
	
void CPartTopicSubscribeFactory::beforeRemove(CPartTopicSubscribe *pPartTopicSubscribe)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::commitAdd(CPartTopicSubscribe *pPartTopicSubscribe)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartTopicSubscribe++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::commitUpdate(CPartTopicSubscribe *pPartTopicSubscribe, CWriteablePartTopicSubscribe *pOldPartTopicSubscribe)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartTopicSubscribe++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartTopicSubscribe,pOldPartTopicSubscribe);
	}
}
	
void CPartTopicSubscribeFactory::commitRemove(CWriteablePartTopicSubscribe *pPartTopicSubscribe)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartTopicSubscribe++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartTopicSubscribe);
	}
}

void CPartTopicSubscribeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForParticipantIDIndexinParticipant(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForParticipant=0;
int updateWithIndexActionForParticipant=0;
int updateWithoutIndexActionForParticipant=0;
int removeActionForParticipant=0;
int addCommitForParticipant=0;
int updateCommitForParticipant=0;
int removeCommitForParticipant=0;
#endif
void CParticipantFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinParticipant,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Participant_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Participant_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinParticipant,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByParticipantID=NULL;
	pActionTriggers=new vector<CParticipantActionTrigger *>;
	pCommitTriggers=new vector<CParticipantCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CParticipantFactory::CParticipantFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CParticipant),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CParticipantFactory::CParticipantFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CParticipant),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CParticipantFactory::~CParticipantFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CParticipantFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CParticipantFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
}

int CParticipantFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableParticipant thisParticipant;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisParticipant.readCSV(input,pNames))
		add(&thisParticipant);
	fclose(input);
	delete pNames;
	return 1;
}

int CParticipantFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Participant.csv");
	return readCSV(szFileName);
}

int CParticipantFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableParticipant *pParticipant;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableParticipant::writeCSVHead(output);
	pParticipant=(CWriteableParticipant *)(pMem->getFirst());
	while (pParticipant!=NULL) {
		if (!pParticipant->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pParticipant=(CWriteableParticipant *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CParticipantFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Participant.csv");
	return writeCSV(szFileName);
}

void CParticipantFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CParticipantFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableParticipant *pParticipant;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CParticipantFactory={       Total Count=%d\n", pMem->getCount());
	pParticipant=(CWriteableParticipant *)(pMem->getFirst());
	while (pParticipant!=NULL) {
		pParticipant->dump(fp,index++);
		pParticipant=(CWriteableParticipant *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CParticipantFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantIDIndex->removeAll();
	}
}

CParticipant *CParticipantFactory::internalAdd(CWriteableParticipant *pParticipant, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForParticipant++;
#endif
	CParticipant *pTarget;	
	beforeAdd(pParticipant);
	pTarget=(CParticipant *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Participant in memory database");
		return NULL;
	}
	forceCopy(pTarget, pParticipant, sizeof(CParticipant));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CParticipant *CParticipantFactory::add(CWriteableParticipant *pParticipant, CTransaction *pTransaction)
{
	pParticipant->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pParticipant,true);
	}
	else {
		CParticipant *pNewParticipant;
		pNewParticipant = internalAdd(pParticipant,false);
		pTransaction->addResource(CParticipantResource::alloc(CREATE_ACTION,this,pNewParticipant,NULL));
		return pNewParticipant;
	}
}

void CParticipantFactory::internalUpdate(CParticipant *pParticipant, CWriteableParticipant *pNewParticipant, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForParticipant++;
	}
	else {
		updateWithoutIndexActionForParticipant++;
	}
#endif
	CWriteableParticipant theOldParticipant;
	beforeUpdate(pParticipant,pNewParticipant);
	if (bNoTransaction) {
		forceCopy(&theOldParticipant,pParticipant,sizeof(CParticipant));
	}
	if (updateIndex) {
	}

	forceCopy(pParticipant,pNewParticipant,sizeof(CParticipant));
	pMem->updateObject(pParticipant);
	if (updateIndex) {
	}
	afterUpdate(pParticipant);
	if (bNoTransaction) {
		commitUpdate(pParticipant,&theOldParticipant);
	}
}

void CParticipantFactory::update(CParticipant *pParticipant, CWriteableParticipant *pNewParticipant, CTransaction *pTransaction, bool updateIndex)
{
	pNewParticipant->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pParticipant,pNewParticipant,updateIndex,true);
	}
	else {
		pTransaction->addResource(CParticipantResource::alloc(UPDATE_ACTION,this,pParticipant,pNewParticipant,updateIndex));
		internalUpdate(pParticipant,pNewParticipant,updateIndex,false);
	}
}

void CParticipantFactory::internalRemove(CParticipant *pParticipant, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForParticipant++;
#endif
	CWriteableParticipant theOldParticipant;
	beforeRemove(pParticipant);
	if (bNoTransaction) {
		forceCopy(&theOldParticipant,pParticipant,sizeof(CParticipant));
	}
	if (runLevel>=0) {
		pParticipantIDIndex->removeObject(pParticipant);
	}
	pMem->free(pParticipant);
	if(bNoTransaction) {
		commitRemove(&theOldParticipant);
	}
}

void CParticipantFactory::remove(CParticipant *pParticipant, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pParticipant,true);
	}
	else {
		pTransaction->addResource(CParticipantResource::alloc(DELETE_ACTION,this,pParticipant,NULL));
		internalRemove(pParticipant,false);		
	}
}

CParticipant* CParticipantFactory::addOrUpdate(CParticipant *pParticipant, CWriteableParticipant *pNewParticipant, CTransaction *pTransaction, bool updateIndex)
{
	if(pParticipant == NULL) {
		return add(pNewParticipant,pTransaction);
	}
	else {
		update(pParticipant,pNewParticipant,pTransaction,updateIndex);
		return pParticipant;
	}
}

void CParticipantFactory::retrieve(CParticipant *pParticipant, CWriteableParticipant *pTargetParticipant)
{
	forceCopy(pTargetParticipant, pParticipant, sizeof(CParticipant));
}
	
int CParticipantFactory::addActionTrigger(CParticipantActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CParticipantFactory::removeActionTrigger(CParticipantActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CParticipantFactory::addCommitTrigger(CParticipantCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CParticipantFactory::removeCommitTrigger(CParticipantCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CParticipant *CParticipantFactory::getFirst(void)
{
	CParticipant *pResult=(CParticipant *)(pMem->getFirst());
	return pResult;
}
	
CParticipant *CParticipantFactory::getNext(void)
{
	CParticipant *pResult=(CParticipant *)(pMem->getNext());
	return pResult;
}
	
void CParticipantFactory::endGet(void)
{
	pMem->endGet();
}

void CParticipantFactory::beforeAdd(CWriteableParticipant *pParticipant)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pParticipant);
	}
}
	
void CParticipantFactory::afterAdd(CParticipant *pParticipant)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pParticipant);
	}
}

void CParticipantFactory::beforeUpdate(CParticipant *pParticipant, CWriteableParticipant *pNewParticipant)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pParticipant,pNewParticipant);
	}
}
	
void CParticipantFactory::afterUpdate(CParticipant *pParticipant)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pParticipant);
	}
}
	
void CParticipantFactory::beforeRemove(CParticipant *pParticipant)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pParticipant);
	}
}

void CParticipantFactory::commitAdd(CParticipant *pParticipant)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForParticipant++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pParticipant);
	}
}

void CParticipantFactory::commitUpdate(CParticipant *pParticipant, CWriteableParticipant *pOldParticipant)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForParticipant++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pParticipant,pOldParticipant);
	}
}
	
void CParticipantFactory::commitRemove(CWriteableParticipant *pParticipant)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForParticipant++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pParticipant);
	}
}

void CParticipantFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CParticipantFactory::linkAllClearingTradingPart(CClearingTradingPartFactory *pFactory)
{
	CParticipant *pParticipant;
	pParticipant=getFirst();
	while (pParticipant != NULL) {
		pParticipant->linkClearingTradingPart(pFactory);
		pParticipant=getNext();
	}
	endGet();
}

extern int compareForUserIDIndexinUser(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForUser=0;
int updateWithIndexActionForUser=0;
int updateWithoutIndexActionForUser=0;
int removeActionForUser=0;
int addCommitForUser=0;
int updateCommitForUser=0;
int removeCommitForUser=0;
#endif
void CUserFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pUserIDIndex=new CAVLTree(maxUnit,compareForUserIDIndexinUser,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("User_UserIDIndex",pUserIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("User_UserIDIndex");
			if(it != pIndexMap->end()) {
				pUserIDIndex=new CAVLTree(maxUnit,compareForUserIDIndexinUser,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByUserID=NULL;
	pActionTriggers=new vector<CUserActionTrigger *>;
	pCommitTriggers=new vector<CUserCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUserFactory::CUserFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUser),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUserFactory::CUserFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUser),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUserFactory::~CUserFactory(void)
{
	if (runLevel>=0) {
		if (pUserIDIndex!=NULL)
			delete pUserIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUserFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUserFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pUserIDIndex->output(pLogger,indent+1);
	}
}

int CUserFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUser thisUser;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUser.readCSV(input,pNames))
		add(&thisUser);
	fclose(input);
	delete pNames;
	return 1;
}

int CUserFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "User.csv");
	return readCSV(szFileName);
}

int CUserFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUser *pUser;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUser::writeCSVHead(output);
	pUser=(CWriteableUser *)(pMem->getFirst());
	while (pUser!=NULL) {
		if (!pUser->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUser=(CWriteableUser *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUserFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "User.csv");
	return writeCSV(szFileName);
}

void CUserFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUserFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUser *pUser;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUserFactory={       Total Count=%d\n", pMem->getCount());
	pUser=(CWriteableUser *)(pMem->getFirst());
	while (pUser!=NULL) {
		pUser->dump(fp,index++);
		pUser=(CWriteableUser *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUserFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pUserIDIndex->removeAll();
	}
}

CUser *CUserFactory::internalAdd(CWriteableUser *pUser, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUser++;
#endif
	CUser *pTarget;	
	beforeAdd(pUser);
	pTarget=(CUser *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough User in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUser, sizeof(CUser));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pUserIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUser *CUserFactory::add(CWriteableUser *pUser, CTransaction *pTransaction)
{
	pUser->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUser,true);
	}
	else {
		CUser *pNewUser;
		pNewUser = internalAdd(pUser,false);
		pTransaction->addResource(CUserResource::alloc(CREATE_ACTION,this,pNewUser,NULL));
		return pNewUser;
	}
}

void CUserFactory::internalUpdate(CUser *pUser, CWriteableUser *pNewUser, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUser++;
	}
	else {
		updateWithoutIndexActionForUser++;
	}
#endif
	CWriteableUser theOldUser;
	beforeUpdate(pUser,pNewUser);
	if (bNoTransaction) {
		forceCopy(&theOldUser,pUser,sizeof(CUser));
	}
	if (updateIndex) {
	}

	forceCopy(pUser,pNewUser,sizeof(CUser));
	pMem->updateObject(pUser);
	if (updateIndex) {
	}
	afterUpdate(pUser);
	if (bNoTransaction) {
		commitUpdate(pUser,&theOldUser);
	}
}

void CUserFactory::update(CUser *pUser, CWriteableUser *pNewUser, CTransaction *pTransaction, bool updateIndex)
{
	pNewUser->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUser,pNewUser,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUserResource::alloc(UPDATE_ACTION,this,pUser,pNewUser,updateIndex));
		internalUpdate(pUser,pNewUser,updateIndex,false);
	}
}

void CUserFactory::internalRemove(CUser *pUser, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUser++;
#endif
	CWriteableUser theOldUser;
	beforeRemove(pUser);
	if (bNoTransaction) {
		forceCopy(&theOldUser,pUser,sizeof(CUser));
	}
	if (runLevel>=0) {
		pUserIDIndex->removeObject(pUser);
	}
	pMem->free(pUser);
	if(bNoTransaction) {
		commitRemove(&theOldUser);
	}
}

void CUserFactory::remove(CUser *pUser, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUser,true);
	}
	else {
		pTransaction->addResource(CUserResource::alloc(DELETE_ACTION,this,pUser,NULL));
		internalRemove(pUser,false);		
	}
}

CUser* CUserFactory::addOrUpdate(CUser *pUser, CWriteableUser *pNewUser, CTransaction *pTransaction, bool updateIndex)
{
	if(pUser == NULL) {
		return add(pNewUser,pTransaction);
	}
	else {
		update(pUser,pNewUser,pTransaction,updateIndex);
		return pUser;
	}
}

void CUserFactory::retrieve(CUser *pUser, CWriteableUser *pTargetUser)
{
	forceCopy(pTargetUser, pUser, sizeof(CUser));
}
	
int CUserFactory::addActionTrigger(CUserActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUserFactory::removeActionTrigger(CUserActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUserFactory::addCommitTrigger(CUserCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUserFactory::removeCommitTrigger(CUserCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUser *CUserFactory::getFirst(void)
{
	CUser *pResult=(CUser *)(pMem->getFirst());
	return pResult;
}
	
CUser *CUserFactory::getNext(void)
{
	CUser *pResult=(CUser *)(pMem->getNext());
	return pResult;
}
	
void CUserFactory::endGet(void)
{
	pMem->endGet();
}

void CUserFactory::beforeAdd(CWriteableUser *pUser)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUser);
	}
}
	
void CUserFactory::afterAdd(CUser *pUser)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUser);
	}
}

void CUserFactory::beforeUpdate(CUser *pUser, CWriteableUser *pNewUser)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUser,pNewUser);
	}
}
	
void CUserFactory::afterUpdate(CUser *pUser)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUser);
	}
}
	
void CUserFactory::beforeRemove(CUser *pUser)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUser);
	}
}

void CUserFactory::commitAdd(CUser *pUser)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUser++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUser);
	}
}

void CUserFactory::commitUpdate(CUser *pUser, CWriteableUser *pOldUser)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUser++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUser,pOldUser);
	}
}
	
void CUserFactory::commitRemove(CWriteableUser *pUser)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUser++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUser);
	}
}

void CUserFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForClient=0;
int updateWithIndexActionForClient=0;
int updateWithoutIndexActionForClient=0;
int removeActionForClient=0;
int addCommitForClient=0;
int updateCommitForClient=0;
int removeCommitForClient=0;
#endif
void CClientFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=6151;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("Client.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pClientIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Client_ClientIDHashIndex",pClientIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Client_ClientIDHashIndex");
			if(it != pIndexMap->end()) {
				pClientIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CClientActionTrigger *>;
	pCommitTriggers=new vector<CClientCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClientFactory::CClientFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClient),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClientFactory::CClientFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClient),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClientFactory::~CClientFactory(void)
{
	if (runLevel>=0) {
		if (pClientIDHashIndex!=NULL)
			delete pClientIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClientFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClientFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CClientFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClient thisClient;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClient.readCSV(input,pNames))
		add(&thisClient);
	fclose(input);
	delete pNames;
	return 1;
}

int CClientFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Client.csv");
	return readCSV(szFileName);
}

int CClientFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClient *pClient;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClient::writeCSVHead(output);
	pClient=(CWriteableClient *)(pMem->getFirst());
	while (pClient!=NULL) {
		if (!pClient->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClient=(CWriteableClient *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClientFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Client.csv");
	return writeCSV(szFileName);
}

void CClientFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClientFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClient *pClient;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClientFactory={       Total Count=%d\n", pMem->getCount());
	pClient=(CWriteableClient *)(pMem->getFirst());
	while (pClient!=NULL) {
		pClient->dump(fp,index++);
		pClient=(CWriteableClient *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClientFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pClientIDHashIndex->removeAll();
	}
}

CClient *CClientFactory::internalAdd(CWriteableClient *pClient, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClient++;
#endif
	CClient *pTarget;	
	beforeAdd(pClient);
	pTarget=(CClient *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Client in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClient, sizeof(CClient));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pClientIDHashIndex->addObject(pTarget,pTarget->HashClientID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClient *CClientFactory::add(CWriteableClient *pClient, CTransaction *pTransaction)
{
	pClient->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClient,true);
	}
	else {
		CClient *pNewClient;
		pNewClient = internalAdd(pClient,false);
		pTransaction->addResource(CClientResource::alloc(CREATE_ACTION,this,pNewClient,NULL));
		return pNewClient;
	}
}

void CClientFactory::internalUpdate(CClient *pClient, CWriteableClient *pNewClient, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClient++;
	}
	else {
		updateWithoutIndexActionForClient++;
	}
#endif
	CWriteableClient theOldClient;
	beforeUpdate(pClient,pNewClient);
	if (bNoTransaction) {
		forceCopy(&theOldClient,pClient,sizeof(CClient));
	}
	if (updateIndex) {
		if (runLevel>=0) {
			pClientIDHashIndex->removeObject(pClient,pClient->HashClientID);
		}
	}

	forceCopy(pClient,pNewClient,sizeof(CClient));
	pMem->updateObject(pClient);
	if (updateIndex) {
		if (runLevel>=0) {
			pClientIDHashIndex->addObject(pClient,pClient->HashClientID);
		}
	}
	afterUpdate(pClient);
	if (bNoTransaction) {
		commitUpdate(pClient,&theOldClient);
	}
}

void CClientFactory::update(CClient *pClient, CWriteableClient *pNewClient, CTransaction *pTransaction, bool updateIndex)
{
	pNewClient->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClient,pNewClient,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClientResource::alloc(UPDATE_ACTION,this,pClient,pNewClient,updateIndex));
		internalUpdate(pClient,pNewClient,updateIndex,false);
	}
}

void CClientFactory::internalRemove(CClient *pClient, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClient++;
#endif
	CWriteableClient theOldClient;
	beforeRemove(pClient);
	if (bNoTransaction) {
		forceCopy(&theOldClient,pClient,sizeof(CClient));
	}
	if (runLevel>=0) {
		pClientIDHashIndex->removeObject(pClient,pClient->HashClientID);
	}	
	pMem->free(pClient);
	if(bNoTransaction) {
		commitRemove(&theOldClient);
	}
}

void CClientFactory::remove(CClient *pClient, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClient,true);
	}
	else {
		pTransaction->addResource(CClientResource::alloc(DELETE_ACTION,this,pClient,NULL));
		internalRemove(pClient,false);		
	}
}

CClient* CClientFactory::addOrUpdate(CClient *pClient, CWriteableClient *pNewClient, CTransaction *pTransaction, bool updateIndex)
{
	if(pClient == NULL) {
		return add(pNewClient,pTransaction);
	}
	else {
		update(pClient,pNewClient,pTransaction,updateIndex);
		return pClient;
	}
}

void CClientFactory::retrieve(CClient *pClient, CWriteableClient *pTargetClient)
{
	forceCopy(pTargetClient, pClient, sizeof(CClient));
}
	
int CClientFactory::addActionTrigger(CClientActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClientFactory::removeActionTrigger(CClientActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClientFactory::addCommitTrigger(CClientCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClientFactory::removeCommitTrigger(CClientCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClient *CClientFactory::getFirst(void)
{
	CClient *pResult=(CClient *)(pMem->getFirst());
	return pResult;
}
	
CClient *CClientFactory::getNext(void)
{
	CClient *pResult=(CClient *)(pMem->getNext());
	return pResult;
}
	
void CClientFactory::endGet(void)
{
	pMem->endGet();
}

void CClientFactory::beforeAdd(CWriteableClient *pClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClient);
	}
}
	
void CClientFactory::afterAdd(CClient *pClient)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClient);
	}
}

void CClientFactory::beforeUpdate(CClient *pClient, CWriteableClient *pNewClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClient,pNewClient);
	}
}
	
void CClientFactory::afterUpdate(CClient *pClient)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClient);
	}
}
	
void CClientFactory::beforeRemove(CClient *pClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClient);
	}
}

void CClientFactory::commitAdd(CClient *pClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClient);
	}
}

void CClientFactory::commitUpdate(CClient *pClient, CWriteableClient *pOldClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClient,pOldClient);
	}
}
	
void CClientFactory::commitRemove(CWriteableClient *pClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClient);
	}
}

void CClientFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForUserIPMaskIndexinUserIP(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForUserIP=0;
int updateWithIndexActionForUserIP=0;
int updateWithoutIndexActionForUserIP=0;
int removeActionForUserIP=0;
int addCommitForUserIP=0;
int updateCommitForUserIP=0;
int removeCommitForUserIP=0;
#endif
void CUserIPFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pUserIPMaskIndex=new CAVLTree(maxUnit,compareForUserIPMaskIndexinUserIP,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UserIP_UserIPMaskIndex",pUserIPMaskIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UserIP_UserIPMaskIndex");
			if(it != pIndexMap->end()) {
				pUserIPMaskIndex=new CAVLTree(maxUnit,compareForUserIPMaskIndexinUserIP,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIPMaskIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByUserID=NULL;
	pActionTriggers=new vector<CUserIPActionTrigger *>;
	pCommitTriggers=new vector<CUserIPCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUserIPFactory::CUserIPFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserIP),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUserIPFactory::CUserIPFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserIP),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUserIPFactory::~CUserIPFactory(void)
{
	if (runLevel>=0) {
		if (pUserIPMaskIndex!=NULL)
			delete pUserIPMaskIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUserIPFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUserIPFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pUserIPMaskIndex->output(pLogger,indent+1);
	}
}

int CUserIPFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUserIP thisUserIP;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUserIP.readCSV(input,pNames))
		add(&thisUserIP);
	fclose(input);
	delete pNames;
	return 1;
}

int CUserIPFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "UserIP.csv");
	return readCSV(szFileName);
}

int CUserIPFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUserIP *pUserIP;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUserIP::writeCSVHead(output);
	pUserIP=(CWriteableUserIP *)(pMem->getFirst());
	while (pUserIP!=NULL) {
		if (!pUserIP->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUserIP=(CWriteableUserIP *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUserIPFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "UserIP.csv");
	return writeCSV(szFileName);
}

void CUserIPFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUserIPFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUserIP *pUserIP;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUserIPFactory={       Total Count=%d\n", pMem->getCount());
	pUserIP=(CWriteableUserIP *)(pMem->getFirst());
	while (pUserIP!=NULL) {
		pUserIP->dump(fp,index++);
		pUserIP=(CWriteableUserIP *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUserIPFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pUserIPMaskIndex->removeAll();
	}
}

CUserIP *CUserIPFactory::internalAdd(CWriteableUserIP *pUserIP, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUserIP++;
#endif
	CUserIP *pTarget;	
	beforeAdd(pUserIP);
	pTarget=(CUserIP *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough UserIP in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUserIP, sizeof(CUserIP));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pUserIPMaskIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUserIP *CUserIPFactory::add(CWriteableUserIP *pUserIP, CTransaction *pTransaction)
{
	pUserIP->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUserIP,true);
	}
	else {
		CUserIP *pNewUserIP;
		pNewUserIP = internalAdd(pUserIP,false);
		pTransaction->addResource(CUserIPResource::alloc(CREATE_ACTION,this,pNewUserIP,NULL));
		return pNewUserIP;
	}
}

void CUserIPFactory::internalUpdate(CUserIP *pUserIP, CWriteableUserIP *pNewUserIP, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUserIP++;
	}
	else {
		updateWithoutIndexActionForUserIP++;
	}
#endif
	CWriteableUserIP theOldUserIP;
	beforeUpdate(pUserIP,pNewUserIP);
	if (bNoTransaction) {
		forceCopy(&theOldUserIP,pUserIP,sizeof(CUserIP));
	}
	if (updateIndex) {
	}

	forceCopy(pUserIP,pNewUserIP,sizeof(CUserIP));
	pMem->updateObject(pUserIP);
	if (updateIndex) {
	}
	afterUpdate(pUserIP);
	if (bNoTransaction) {
		commitUpdate(pUserIP,&theOldUserIP);
	}
}

void CUserIPFactory::update(CUserIP *pUserIP, CWriteableUserIP *pNewUserIP, CTransaction *pTransaction, bool updateIndex)
{
	pNewUserIP->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUserIP,pNewUserIP,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUserIPResource::alloc(UPDATE_ACTION,this,pUserIP,pNewUserIP,updateIndex));
		internalUpdate(pUserIP,pNewUserIP,updateIndex,false);
	}
}

void CUserIPFactory::internalRemove(CUserIP *pUserIP, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUserIP++;
#endif
	CWriteableUserIP theOldUserIP;
	beforeRemove(pUserIP);
	if (bNoTransaction) {
		forceCopy(&theOldUserIP,pUserIP,sizeof(CUserIP));
	}
	if (runLevel>=0) {
		pUserIPMaskIndex->removeObject(pUserIP);
	}
	pMem->free(pUserIP);
	if(bNoTransaction) {
		commitRemove(&theOldUserIP);
	}
}

void CUserIPFactory::remove(CUserIP *pUserIP, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUserIP,true);
	}
	else {
		pTransaction->addResource(CUserIPResource::alloc(DELETE_ACTION,this,pUserIP,NULL));
		internalRemove(pUserIP,false);		
	}
}

CUserIP* CUserIPFactory::addOrUpdate(CUserIP *pUserIP, CWriteableUserIP *pNewUserIP, CTransaction *pTransaction, bool updateIndex)
{
	if(pUserIP == NULL) {
		return add(pNewUserIP,pTransaction);
	}
	else {
		update(pUserIP,pNewUserIP,pTransaction,updateIndex);
		return pUserIP;
	}
}

void CUserIPFactory::retrieve(CUserIP *pUserIP, CWriteableUserIP *pTargetUserIP)
{
	forceCopy(pTargetUserIP, pUserIP, sizeof(CUserIP));
}
	
int CUserIPFactory::addActionTrigger(CUserIPActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUserIPFactory::removeActionTrigger(CUserIPActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUserIPFactory::addCommitTrigger(CUserIPCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUserIPFactory::removeCommitTrigger(CUserIPCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUserIP *CUserIPFactory::getFirst(void)
{
	CUserIP *pResult=(CUserIP *)(pMem->getFirst());
	return pResult;
}
	
CUserIP *CUserIPFactory::getNext(void)
{
	CUserIP *pResult=(CUserIP *)(pMem->getNext());
	return pResult;
}
	
void CUserIPFactory::endGet(void)
{
	pMem->endGet();
}

void CUserIPFactory::beforeAdd(CWriteableUserIP *pUserIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUserIP);
	}
}
	
void CUserIPFactory::afterAdd(CUserIP *pUserIP)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUserIP);
	}
}

void CUserIPFactory::beforeUpdate(CUserIP *pUserIP, CWriteableUserIP *pNewUserIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUserIP,pNewUserIP);
	}
}
	
void CUserIPFactory::afterUpdate(CUserIP *pUserIP)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUserIP);
	}
}
	
void CUserIPFactory::beforeRemove(CUserIP *pUserIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUserIP);
	}
}

void CUserIPFactory::commitAdd(CUserIP *pUserIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUserIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUserIP);
	}
}

void CUserIPFactory::commitUpdate(CUserIP *pUserIP, CWriteableUserIP *pOldUserIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUserIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUserIP,pOldUserIP);
	}
}
	
void CUserIPFactory::commitRemove(CWriteableUserIP *pUserIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUserIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUserIP);
	}
}

void CUserIPFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForPartClientIndexinPartClient(const void *pV1, const void *pV2);
extern int compareForClientIndexinPartClient(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForPartClient=0;
int updateWithIndexActionForPartClient=0;
int updateWithoutIndexActionForPartClient=0;
int removeActionForPartClient=0;
int addCommitForPartClient=0;
int updateCommitForPartClient=0;
int removeCommitForPartClient=0;
#endif
void CPartClientFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pPartClientIndex=new CAVLTree(maxUnit,compareForPartClientIndexinPartClient,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartClient_PartClientIndex",pPartClientIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartClient_PartClientIndex");
			if(it != pIndexMap->end()) {
				pPartClientIndex=new CAVLTree(maxUnit,compareForPartClientIndexinPartClient,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartClientIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pClientIndex=new CAVLTree(maxUnit,compareForClientIndexinPartClient,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartClient_ClientIndex",pClientIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartClient_ClientIndex");
			if(it != pIndexMap->end()) {
				pClientIndex=new CAVLTree(maxUnit,compareForClientIndexinPartClient,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=6151;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartClient.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pPartClientHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartClient_PartClientHashIndex",pPartClientHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartClient_PartClientHashIndex");
			if(it != pIndexMap->end()) {
				pPartClientHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartClientHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByParticipant=NULL;
	pLastFoundInSearchStartByClient=NULL;
	pActionTriggers=new vector<CPartClientActionTrigger *>;
	pCommitTriggers=new vector<CPartClientCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartClientFactory::CPartClientFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClient),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartClientFactory::CPartClientFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClient),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartClientFactory::~CPartClientFactory(void)
{
	if (runLevel>=1) {
		if (pPartClientIndex!=NULL)
			delete pPartClientIndex;
	}
	if (runLevel>=1) {
		if (pClientIndex!=NULL)
			delete pClientIndex;
	}
	if (runLevel>=0) {
		if (pPartClientHashIndex!=NULL)
			delete pPartClientHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartClientFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartClientFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pPartClientIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pClientIndex->output(pLogger,indent+1);
	}
}

int CPartClientFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartClient thisPartClient;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartClient.readCSV(input,pNames))
		add(&thisPartClient);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartClientFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartClient.csv");
	return readCSV(szFileName);
}

int CPartClientFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartClient *pPartClient;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartClient::writeCSVHead(output);
	pPartClient=(CWriteablePartClient *)(pMem->getFirst());
	while (pPartClient!=NULL) {
		if (!pPartClient->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartClient=(CWriteablePartClient *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartClientFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartClient.csv");
	return writeCSV(szFileName);
}

void CPartClientFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartClientFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartClient *pPartClient;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartClientFactory={       Total Count=%d\n", pMem->getCount());
	pPartClient=(CWriteablePartClient *)(pMem->getFirst());
	while (pPartClient!=NULL) {
		pPartClient->dump(fp,index++);
		pPartClient=(CWriteablePartClient *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartClientFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pPartClientIndex->removeAll();
	}
	if (runLevel>=1) {
		pClientIndex->removeAll();
	}
	if (runLevel>=0) {
		pPartClientHashIndex->removeAll();
	}
}

CPartClient *CPartClientFactory::internalAdd(CWriteablePartClient *pPartClient, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartClient++;
#endif
	CPartClient *pTarget;	
	beforeAdd(pPartClient);
	pTarget=(CPartClient *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartClient in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartClient, sizeof(CPartClient));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pPartClientIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pClientIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pPartClientHashIndex->addObject(pTarget,pTarget->HashPartClient);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartClient *CPartClientFactory::add(CWriteablePartClient *pPartClient, CTransaction *pTransaction)
{
	pPartClient->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartClient,true);
	}
	else {
		CPartClient *pNewPartClient;
		pNewPartClient = internalAdd(pPartClient,false);
		pTransaction->addResource(CPartClientResource::alloc(CREATE_ACTION,this,pNewPartClient,NULL));
		return pNewPartClient;
	}
}

void CPartClientFactory::internalUpdate(CPartClient *pPartClient, CWriteablePartClient *pNewPartClient, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartClient++;
	}
	else {
		updateWithoutIndexActionForPartClient++;
	}
#endif
	CWriteablePartClient theOldPartClient;
	beforeUpdate(pPartClient,pNewPartClient);
	if (bNoTransaction) {
		forceCopy(&theOldPartClient,pPartClient,sizeof(CPartClient));
	}
	if (updateIndex) {
	}

	forceCopy(pPartClient,pNewPartClient,sizeof(CPartClient));
	pMem->updateObject(pPartClient);
	if (updateIndex) {
	}
	afterUpdate(pPartClient);
	if (bNoTransaction) {
		commitUpdate(pPartClient,&theOldPartClient);
	}
}

void CPartClientFactory::update(CPartClient *pPartClient, CWriteablePartClient *pNewPartClient, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartClient->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartClient,pNewPartClient,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartClientResource::alloc(UPDATE_ACTION,this,pPartClient,pNewPartClient,updateIndex));
		internalUpdate(pPartClient,pNewPartClient,updateIndex,false);
	}
}

void CPartClientFactory::internalRemove(CPartClient *pPartClient, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartClient++;
#endif
	CWriteablePartClient theOldPartClient;
	beforeRemove(pPartClient);
	if (bNoTransaction) {
		forceCopy(&theOldPartClient,pPartClient,sizeof(CPartClient));
	}
	if (runLevel>=1) {
		pPartClientIndex->removeObject(pPartClient);
	}
	if (runLevel>=1) {
		pClientIndex->removeObject(pPartClient);
	}
	if (runLevel>=0) {
		pPartClientHashIndex->removeObject(pPartClient,pPartClient->HashPartClient);
	}	
	pMem->free(pPartClient);
	if(bNoTransaction) {
		commitRemove(&theOldPartClient);
	}
}

void CPartClientFactory::remove(CPartClient *pPartClient, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartClient,true);
	}
	else {
		pTransaction->addResource(CPartClientResource::alloc(DELETE_ACTION,this,pPartClient,NULL));
		internalRemove(pPartClient,false);		
	}
}

CPartClient* CPartClientFactory::addOrUpdate(CPartClient *pPartClient, CWriteablePartClient *pNewPartClient, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartClient == NULL) {
		return add(pNewPartClient,pTransaction);
	}
	else {
		update(pPartClient,pNewPartClient,pTransaction,updateIndex);
		return pPartClient;
	}
}

void CPartClientFactory::retrieve(CPartClient *pPartClient, CWriteablePartClient *pTargetPartClient)
{
	forceCopy(pTargetPartClient, pPartClient, sizeof(CPartClient));
}
	
int CPartClientFactory::addActionTrigger(CPartClientActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartClientFactory::removeActionTrigger(CPartClientActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartClientFactory::addCommitTrigger(CPartClientCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartClientFactory::removeCommitTrigger(CPartClientCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartClient *CPartClientFactory::getFirst(void)
{
	CPartClient *pResult=(CPartClient *)(pMem->getFirst());
	return pResult;
}
	
CPartClient *CPartClientFactory::getNext(void)
{
	CPartClient *pResult=(CPartClient *)(pMem->getNext());
	return pResult;
}
	
void CPartClientFactory::endGet(void)
{
	pMem->endGet();
}

void CPartClientFactory::beforeAdd(CWriteablePartClient *pPartClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartClient);
	}
}
	
void CPartClientFactory::afterAdd(CPartClient *pPartClient)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartClient);
	}
}

void CPartClientFactory::beforeUpdate(CPartClient *pPartClient, CWriteablePartClient *pNewPartClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartClient,pNewPartClient);
	}
}
	
void CPartClientFactory::afterUpdate(CPartClient *pPartClient)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartClient);
	}
}
	
void CPartClientFactory::beforeRemove(CPartClient *pPartClient)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartClient);
	}
}

void CPartClientFactory::commitAdd(CPartClient *pPartClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartClient);
	}
}

void CPartClientFactory::commitUpdate(CPartClient *pPartClient, CWriteablePartClient *pOldPartClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartClient,pOldPartClient);
	}
}
	
void CPartClientFactory::commitRemove(CWriteablePartClient *pPartClient)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartClient++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartClient);
	}
}

void CPartClientFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CPartClientFactory::linkAllParticipant(CParticipantFactory *pFactory)
{
	CPartClient *pPartClient;
	pPartClient=getFirst();
	while (pPartClient != NULL) {
		pPartClient->linkParticipant(pFactory);
		pPartClient=getNext();
	}
	endGet();
}

void CPartClientFactory::linkAllClient(CClientFactory *pFactory)
{
	CPartClient *pPartClient;
	pPartClient=getFirst();
	while (pPartClient != NULL) {
		pPartClient->linkClient(pFactory);
		pPartClient=getNext();
	}
	endGet();
}

#ifdef COUNT_OPERATION
int addActionForClearingTradingPart=0;
int updateWithIndexActionForClearingTradingPart=0;
int updateWithoutIndexActionForClearingTradingPart=0;
int removeActionForClearingTradingPart=0;
int addCommitForClearingTradingPart=0;
int updateCommitForClearingTradingPart=0;
int removeCommitForClearingTradingPart=0;
#endif
void CClearingTradingPartFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=6151;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("ClearingTradingPart.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClearingTradingPart_ParticipantIDHashIndex",pParticipantIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClearingTradingPart_ParticipantIDHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CClearingTradingPartActionTrigger *>;
	pCommitTriggers=new vector<CClearingTradingPartCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClearingTradingPartFactory::CClearingTradingPartFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClearingTradingPart),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClearingTradingPartFactory::CClearingTradingPartFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClearingTradingPart),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClearingTradingPartFactory::~CClearingTradingPartFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantIDHashIndex!=NULL)
			delete pParticipantIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClearingTradingPartFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClearingTradingPartFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CClearingTradingPartFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClearingTradingPart thisClearingTradingPart;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClearingTradingPart.readCSV(input,pNames))
		add(&thisClearingTradingPart);
	fclose(input);
	delete pNames;
	return 1;
}

int CClearingTradingPartFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ClearingTradingPart.csv");
	return readCSV(szFileName);
}

int CClearingTradingPartFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClearingTradingPart *pClearingTradingPart;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClearingTradingPart::writeCSVHead(output);
	pClearingTradingPart=(CWriteableClearingTradingPart *)(pMem->getFirst());
	while (pClearingTradingPart!=NULL) {
		if (!pClearingTradingPart->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClearingTradingPart=(CWriteableClearingTradingPart *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClearingTradingPartFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ClearingTradingPart.csv");
	return writeCSV(szFileName);
}

void CClearingTradingPartFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClearingTradingPartFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClearingTradingPart *pClearingTradingPart;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClearingTradingPartFactory={       Total Count=%d\n", pMem->getCount());
	pClearingTradingPart=(CWriteableClearingTradingPart *)(pMem->getFirst());
	while (pClearingTradingPart!=NULL) {
		pClearingTradingPart->dump(fp,index++);
		pClearingTradingPart=(CWriteableClearingTradingPart *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClearingTradingPartFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantIDHashIndex->removeAll();
	}
}

CClearingTradingPart *CClearingTradingPartFactory::internalAdd(CWriteableClearingTradingPart *pClearingTradingPart, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClearingTradingPart++;
#endif
	CClearingTradingPart *pTarget;	
	beforeAdd(pClearingTradingPart);
	pTarget=(CClearingTradingPart *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ClearingTradingPart in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClearingTradingPart, sizeof(CClearingTradingPart));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantIDHashIndex->addObject(pTarget,pTarget->HashParticipantID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClearingTradingPart *CClearingTradingPartFactory::add(CWriteableClearingTradingPart *pClearingTradingPart, CTransaction *pTransaction)
{
	pClearingTradingPart->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClearingTradingPart,true);
	}
	else {
		CClearingTradingPart *pNewClearingTradingPart;
		pNewClearingTradingPart = internalAdd(pClearingTradingPart,false);
		pTransaction->addResource(CClearingTradingPartResource::alloc(CREATE_ACTION,this,pNewClearingTradingPart,NULL));
		return pNewClearingTradingPart;
	}
}

void CClearingTradingPartFactory::internalUpdate(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pNewClearingTradingPart, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClearingTradingPart++;
	}
	else {
		updateWithoutIndexActionForClearingTradingPart++;
	}
#endif
	CWriteableClearingTradingPart theOldClearingTradingPart;
	beforeUpdate(pClearingTradingPart,pNewClearingTradingPart);
	if (bNoTransaction) {
		forceCopy(&theOldClearingTradingPart,pClearingTradingPart,sizeof(CClearingTradingPart));
	}
	if (updateIndex) {
	}

	forceCopy(pClearingTradingPart,pNewClearingTradingPart,sizeof(CClearingTradingPart));
	pMem->updateObject(pClearingTradingPart);
	if (updateIndex) {
	}
	afterUpdate(pClearingTradingPart);
	if (bNoTransaction) {
		commitUpdate(pClearingTradingPart,&theOldClearingTradingPart);
	}
}

void CClearingTradingPartFactory::update(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pNewClearingTradingPart, CTransaction *pTransaction, bool updateIndex)
{
	pNewClearingTradingPart->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClearingTradingPart,pNewClearingTradingPart,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClearingTradingPartResource::alloc(UPDATE_ACTION,this,pClearingTradingPart,pNewClearingTradingPart,updateIndex));
		internalUpdate(pClearingTradingPart,pNewClearingTradingPart,updateIndex,false);
	}
}

void CClearingTradingPartFactory::internalRemove(CClearingTradingPart *pClearingTradingPart, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClearingTradingPart++;
#endif
	CWriteableClearingTradingPart theOldClearingTradingPart;
	beforeRemove(pClearingTradingPart);
	if (bNoTransaction) {
		forceCopy(&theOldClearingTradingPart,pClearingTradingPart,sizeof(CClearingTradingPart));
	}
	if (runLevel>=0) {
		pParticipantIDHashIndex->removeObject(pClearingTradingPart,pClearingTradingPart->HashParticipantID);
	}	
	pMem->free(pClearingTradingPart);
	if(bNoTransaction) {
		commitRemove(&theOldClearingTradingPart);
	}
}

void CClearingTradingPartFactory::remove(CClearingTradingPart *pClearingTradingPart, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClearingTradingPart,true);
	}
	else {
		pTransaction->addResource(CClearingTradingPartResource::alloc(DELETE_ACTION,this,pClearingTradingPart,NULL));
		internalRemove(pClearingTradingPart,false);		
	}
}

CClearingTradingPart* CClearingTradingPartFactory::addOrUpdate(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pNewClearingTradingPart, CTransaction *pTransaction, bool updateIndex)
{
	if(pClearingTradingPart == NULL) {
		return add(pNewClearingTradingPart,pTransaction);
	}
	else {
		update(pClearingTradingPart,pNewClearingTradingPart,pTransaction,updateIndex);
		return pClearingTradingPart;
	}
}

void CClearingTradingPartFactory::retrieve(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pTargetClearingTradingPart)
{
	forceCopy(pTargetClearingTradingPart, pClearingTradingPart, sizeof(CClearingTradingPart));
}
	
int CClearingTradingPartFactory::addActionTrigger(CClearingTradingPartActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClearingTradingPartFactory::removeActionTrigger(CClearingTradingPartActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClearingTradingPartFactory::addCommitTrigger(CClearingTradingPartCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClearingTradingPartFactory::removeCommitTrigger(CClearingTradingPartCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClearingTradingPart *CClearingTradingPartFactory::getFirst(void)
{
	CClearingTradingPart *pResult=(CClearingTradingPart *)(pMem->getFirst());
	return pResult;
}
	
CClearingTradingPart *CClearingTradingPartFactory::getNext(void)
{
	CClearingTradingPart *pResult=(CClearingTradingPart *)(pMem->getNext());
	return pResult;
}
	
void CClearingTradingPartFactory::endGet(void)
{
	pMem->endGet();
}

void CClearingTradingPartFactory::beforeAdd(CWriteableClearingTradingPart *pClearingTradingPart)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClearingTradingPart);
	}
}
	
void CClearingTradingPartFactory::afterAdd(CClearingTradingPart *pClearingTradingPart)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClearingTradingPart);
	}
}

void CClearingTradingPartFactory::beforeUpdate(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pNewClearingTradingPart)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClearingTradingPart,pNewClearingTradingPart);
	}
}
	
void CClearingTradingPartFactory::afterUpdate(CClearingTradingPart *pClearingTradingPart)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClearingTradingPart);
	}
}
	
void CClearingTradingPartFactory::beforeRemove(CClearingTradingPart *pClearingTradingPart)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClearingTradingPart);
	}
}

void CClearingTradingPartFactory::commitAdd(CClearingTradingPart *pClearingTradingPart)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClearingTradingPart++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClearingTradingPart);
	}
}

void CClearingTradingPartFactory::commitUpdate(CClearingTradingPart *pClearingTradingPart, CWriteableClearingTradingPart *pOldClearingTradingPart)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClearingTradingPart++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClearingTradingPart,pOldClearingTradingPart);
	}
}
	
void CClearingTradingPartFactory::commitRemove(CWriteableClearingTradingPart *pClearingTradingPart)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClearingTradingPart++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClearingTradingPart);
	}
}

void CClearingTradingPartFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForAliasDefine=0;
int updateWithIndexActionForAliasDefine=0;
int updateWithoutIndexActionForAliasDefine=0;
int removeActionForAliasDefine=0;
int addCommitForAliasDefine=0;
int updateCommitForAliasDefine=0;
int removeCommitForAliasDefine=0;
#endif
void CAliasDefineFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pActionTriggers=new vector<CAliasDefineActionTrigger *>;
	pCommitTriggers=new vector<CAliasDefineCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CAliasDefineFactory::CAliasDefineFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CAliasDefine),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CAliasDefineFactory::CAliasDefineFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CAliasDefine),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CAliasDefineFactory::~CAliasDefineFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CAliasDefineFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CAliasDefineFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CAliasDefineFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableAliasDefine thisAliasDefine;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisAliasDefine.readCSV(input,pNames))
		add(&thisAliasDefine);
	fclose(input);
	delete pNames;
	return 1;
}

int CAliasDefineFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "AliasDefine.csv");
	return readCSV(szFileName);
}

int CAliasDefineFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableAliasDefine *pAliasDefine;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableAliasDefine::writeCSVHead(output);
	pAliasDefine=(CWriteableAliasDefine *)(pMem->getFirst());
	while (pAliasDefine!=NULL) {
		if (!pAliasDefine->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pAliasDefine=(CWriteableAliasDefine *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CAliasDefineFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "AliasDefine.csv");
	return writeCSV(szFileName);
}

void CAliasDefineFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CAliasDefineFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableAliasDefine *pAliasDefine;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CAliasDefineFactory={       Total Count=%d\n", pMem->getCount());
	pAliasDefine=(CWriteableAliasDefine *)(pMem->getFirst());
	while (pAliasDefine!=NULL) {
		pAliasDefine->dump(fp,index++);
		pAliasDefine=(CWriteableAliasDefine *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CAliasDefineFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CAliasDefine *CAliasDefineFactory::internalAdd(CWriteableAliasDefine *pAliasDefine, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForAliasDefine++;
#endif
	CAliasDefine *pTarget;	
	beforeAdd(pAliasDefine);
	pTarget=(CAliasDefine *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough AliasDefine in memory database");
		return NULL;
	}
	forceCopy(pTarget, pAliasDefine, sizeof(CAliasDefine));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CAliasDefine *CAliasDefineFactory::add(CWriteableAliasDefine *pAliasDefine, CTransaction *pTransaction)
{
	pAliasDefine->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pAliasDefine,true);
	}
	else {
		CAliasDefine *pNewAliasDefine;
		pNewAliasDefine = internalAdd(pAliasDefine,false);
		pTransaction->addResource(CAliasDefineResource::alloc(CREATE_ACTION,this,pNewAliasDefine,NULL));
		return pNewAliasDefine;
	}
}

void CAliasDefineFactory::internalUpdate(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pNewAliasDefine, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForAliasDefine++;
	}
	else {
		updateWithoutIndexActionForAliasDefine++;
	}
#endif
	CWriteableAliasDefine theOldAliasDefine;
	beforeUpdate(pAliasDefine,pNewAliasDefine);
	if (bNoTransaction) {
		forceCopy(&theOldAliasDefine,pAliasDefine,sizeof(CAliasDefine));
	}
	if (updateIndex) {
	}

	forceCopy(pAliasDefine,pNewAliasDefine,sizeof(CAliasDefine));
	pMem->updateObject(pAliasDefine);
	if (updateIndex) {
	}
	afterUpdate(pAliasDefine);
	if (bNoTransaction) {
		commitUpdate(pAliasDefine,&theOldAliasDefine);
	}
}

void CAliasDefineFactory::update(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pNewAliasDefine, CTransaction *pTransaction, bool updateIndex)
{
	pNewAliasDefine->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pAliasDefine,pNewAliasDefine,updateIndex,true);
	}
	else {
		pTransaction->addResource(CAliasDefineResource::alloc(UPDATE_ACTION,this,pAliasDefine,pNewAliasDefine,updateIndex));
		internalUpdate(pAliasDefine,pNewAliasDefine,updateIndex,false);
	}
}

void CAliasDefineFactory::internalRemove(CAliasDefine *pAliasDefine, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForAliasDefine++;
#endif
	CWriteableAliasDefine theOldAliasDefine;
	beforeRemove(pAliasDefine);
	if (bNoTransaction) {
		forceCopy(&theOldAliasDefine,pAliasDefine,sizeof(CAliasDefine));
	}
	pMem->free(pAliasDefine);
	if(bNoTransaction) {
		commitRemove(&theOldAliasDefine);
	}
}

void CAliasDefineFactory::remove(CAliasDefine *pAliasDefine, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pAliasDefine,true);
	}
	else {
		pTransaction->addResource(CAliasDefineResource::alloc(DELETE_ACTION,this,pAliasDefine,NULL));
		internalRemove(pAliasDefine,false);		
	}
}

CAliasDefine* CAliasDefineFactory::addOrUpdate(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pNewAliasDefine, CTransaction *pTransaction, bool updateIndex)
{
	if(pAliasDefine == NULL) {
		return add(pNewAliasDefine,pTransaction);
	}
	else {
		update(pAliasDefine,pNewAliasDefine,pTransaction,updateIndex);
		return pAliasDefine;
	}
}

void CAliasDefineFactory::retrieve(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pTargetAliasDefine)
{
	forceCopy(pTargetAliasDefine, pAliasDefine, sizeof(CAliasDefine));
}
	
int CAliasDefineFactory::addActionTrigger(CAliasDefineActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CAliasDefineFactory::removeActionTrigger(CAliasDefineActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CAliasDefineFactory::addCommitTrigger(CAliasDefineCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CAliasDefineFactory::removeCommitTrigger(CAliasDefineCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CAliasDefine *CAliasDefineFactory::getFirst(void)
{
	CAliasDefine *pResult=(CAliasDefine *)(pMem->getFirst());
	return pResult;
}
	
CAliasDefine *CAliasDefineFactory::getNext(void)
{
	CAliasDefine *pResult=(CAliasDefine *)(pMem->getNext());
	return pResult;
}
	
void CAliasDefineFactory::endGet(void)
{
	pMem->endGet();
}

void CAliasDefineFactory::beforeAdd(CWriteableAliasDefine *pAliasDefine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pAliasDefine);
	}
}
	
void CAliasDefineFactory::afterAdd(CAliasDefine *pAliasDefine)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pAliasDefine);
	}
}

void CAliasDefineFactory::beforeUpdate(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pNewAliasDefine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pAliasDefine,pNewAliasDefine);
	}
}
	
void CAliasDefineFactory::afterUpdate(CAliasDefine *pAliasDefine)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pAliasDefine);
	}
}
	
void CAliasDefineFactory::beforeRemove(CAliasDefine *pAliasDefine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pAliasDefine);
	}
}

void CAliasDefineFactory::commitAdd(CAliasDefine *pAliasDefine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForAliasDefine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pAliasDefine);
	}
}

void CAliasDefineFactory::commitUpdate(CAliasDefine *pAliasDefine, CWriteableAliasDefine *pOldAliasDefine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForAliasDefine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pAliasDefine,pOldAliasDefine);
	}
}
	
void CAliasDefineFactory::commitRemove(CWriteableAliasDefine *pAliasDefine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForAliasDefine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pAliasDefine);
	}
}

void CAliasDefineFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForUserFunctionRight=0;
int updateWithIndexActionForUserFunctionRight=0;
int updateWithoutIndexActionForUserFunctionRight=0;
int removeActionForUserFunctionRight=0;
int addCommitForUserFunctionRight=0;
int updateCommitForUserFunctionRight=0;
int removeCommitForUserFunctionRight=0;
#endif
void CUserFunctionRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=4000;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("UserFunctionRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pUserFunctionHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UserFunctionRight_UserFunctionHashIndex",pUserFunctionHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UserFunctionRight_UserFunctionHashIndex");
			if(it != pIndexMap->end()) {
				pUserFunctionHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserFunctionHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CUserFunctionRightActionTrigger *>;
	pCommitTriggers=new vector<CUserFunctionRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUserFunctionRightFactory::CUserFunctionRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserFunctionRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUserFunctionRightFactory::CUserFunctionRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserFunctionRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUserFunctionRightFactory::~CUserFunctionRightFactory(void)
{
	if (runLevel>=0) {
		if (pUserFunctionHashIndex!=NULL)
			delete pUserFunctionHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUserFunctionRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUserFunctionRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CUserFunctionRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUserFunctionRight thisUserFunctionRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUserFunctionRight.readCSV(input,pNames))
		add(&thisUserFunctionRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CUserFunctionRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "UserFunctionRight.csv");
	return readCSV(szFileName);
}

int CUserFunctionRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUserFunctionRight *pUserFunctionRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUserFunctionRight::writeCSVHead(output);
	pUserFunctionRight=(CWriteableUserFunctionRight *)(pMem->getFirst());
	while (pUserFunctionRight!=NULL) {
		if (!pUserFunctionRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUserFunctionRight=(CWriteableUserFunctionRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUserFunctionRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "UserFunctionRight.csv");
	return writeCSV(szFileName);
}

void CUserFunctionRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUserFunctionRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUserFunctionRight *pUserFunctionRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUserFunctionRightFactory={       Total Count=%d\n", pMem->getCount());
	pUserFunctionRight=(CWriteableUserFunctionRight *)(pMem->getFirst());
	while (pUserFunctionRight!=NULL) {
		pUserFunctionRight->dump(fp,index++);
		pUserFunctionRight=(CWriteableUserFunctionRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUserFunctionRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pUserFunctionHashIndex->removeAll();
	}
}

CUserFunctionRight *CUserFunctionRightFactory::internalAdd(CWriteableUserFunctionRight *pUserFunctionRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUserFunctionRight++;
#endif
	CUserFunctionRight *pTarget;	
	beforeAdd(pUserFunctionRight);
	pTarget=(CUserFunctionRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough UserFunctionRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUserFunctionRight, sizeof(CUserFunctionRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pUserFunctionHashIndex->addObject(pTarget,pTarget->HashUserFunction);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUserFunctionRight *CUserFunctionRightFactory::add(CWriteableUserFunctionRight *pUserFunctionRight, CTransaction *pTransaction)
{
	pUserFunctionRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUserFunctionRight,true);
	}
	else {
		CUserFunctionRight *pNewUserFunctionRight;
		pNewUserFunctionRight = internalAdd(pUserFunctionRight,false);
		pTransaction->addResource(CUserFunctionRightResource::alloc(CREATE_ACTION,this,pNewUserFunctionRight,NULL));
		return pNewUserFunctionRight;
	}
}

void CUserFunctionRightFactory::internalUpdate(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pNewUserFunctionRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUserFunctionRight++;
	}
	else {
		updateWithoutIndexActionForUserFunctionRight++;
	}
#endif
	CWriteableUserFunctionRight theOldUserFunctionRight;
	beforeUpdate(pUserFunctionRight,pNewUserFunctionRight);
	if (bNoTransaction) {
		forceCopy(&theOldUserFunctionRight,pUserFunctionRight,sizeof(CUserFunctionRight));
	}
	if (updateIndex) {
		if (runLevel>=0) {
			pUserFunctionHashIndex->removeObject(pUserFunctionRight,pUserFunctionRight->HashUserFunction);
		}
	}

	forceCopy(pUserFunctionRight,pNewUserFunctionRight,sizeof(CUserFunctionRight));
	pMem->updateObject(pUserFunctionRight);
	if (updateIndex) {
		if (runLevel>=0) {
			pUserFunctionHashIndex->addObject(pUserFunctionRight,pUserFunctionRight->HashUserFunction);
		}
	}
	afterUpdate(pUserFunctionRight);
	if (bNoTransaction) {
		commitUpdate(pUserFunctionRight,&theOldUserFunctionRight);
	}
}

void CUserFunctionRightFactory::update(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pNewUserFunctionRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewUserFunctionRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUserFunctionRight,pNewUserFunctionRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUserFunctionRightResource::alloc(UPDATE_ACTION,this,pUserFunctionRight,pNewUserFunctionRight,updateIndex));
		internalUpdate(pUserFunctionRight,pNewUserFunctionRight,updateIndex,false);
	}
}

void CUserFunctionRightFactory::internalRemove(CUserFunctionRight *pUserFunctionRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUserFunctionRight++;
#endif
	CWriteableUserFunctionRight theOldUserFunctionRight;
	beforeRemove(pUserFunctionRight);
	if (bNoTransaction) {
		forceCopy(&theOldUserFunctionRight,pUserFunctionRight,sizeof(CUserFunctionRight));
	}
	if (runLevel>=0) {
		pUserFunctionHashIndex->removeObject(pUserFunctionRight,pUserFunctionRight->HashUserFunction);
	}	
	pMem->free(pUserFunctionRight);
	if(bNoTransaction) {
		commitRemove(&theOldUserFunctionRight);
	}
}

void CUserFunctionRightFactory::remove(CUserFunctionRight *pUserFunctionRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUserFunctionRight,true);
	}
	else {
		pTransaction->addResource(CUserFunctionRightResource::alloc(DELETE_ACTION,this,pUserFunctionRight,NULL));
		internalRemove(pUserFunctionRight,false);		
	}
}

CUserFunctionRight* CUserFunctionRightFactory::addOrUpdate(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pNewUserFunctionRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pUserFunctionRight == NULL) {
		return add(pNewUserFunctionRight,pTransaction);
	}
	else {
		update(pUserFunctionRight,pNewUserFunctionRight,pTransaction,updateIndex);
		return pUserFunctionRight;
	}
}

void CUserFunctionRightFactory::retrieve(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pTargetUserFunctionRight)
{
	forceCopy(pTargetUserFunctionRight, pUserFunctionRight, sizeof(CUserFunctionRight));
}
	
int CUserFunctionRightFactory::addActionTrigger(CUserFunctionRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUserFunctionRightFactory::removeActionTrigger(CUserFunctionRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUserFunctionRightFactory::addCommitTrigger(CUserFunctionRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUserFunctionRightFactory::removeCommitTrigger(CUserFunctionRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUserFunctionRight *CUserFunctionRightFactory::getFirst(void)
{
	CUserFunctionRight *pResult=(CUserFunctionRight *)(pMem->getFirst());
	return pResult;
}
	
CUserFunctionRight *CUserFunctionRightFactory::getNext(void)
{
	CUserFunctionRight *pResult=(CUserFunctionRight *)(pMem->getNext());
	return pResult;
}
	
void CUserFunctionRightFactory::endGet(void)
{
	pMem->endGet();
}

void CUserFunctionRightFactory::beforeAdd(CWriteableUserFunctionRight *pUserFunctionRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUserFunctionRight);
	}
}
	
void CUserFunctionRightFactory::afterAdd(CUserFunctionRight *pUserFunctionRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUserFunctionRight);
	}
}

void CUserFunctionRightFactory::beforeUpdate(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pNewUserFunctionRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUserFunctionRight,pNewUserFunctionRight);
	}
}
	
void CUserFunctionRightFactory::afterUpdate(CUserFunctionRight *pUserFunctionRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUserFunctionRight);
	}
}
	
void CUserFunctionRightFactory::beforeRemove(CUserFunctionRight *pUserFunctionRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUserFunctionRight);
	}
}

void CUserFunctionRightFactory::commitAdd(CUserFunctionRight *pUserFunctionRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUserFunctionRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUserFunctionRight);
	}
}

void CUserFunctionRightFactory::commitUpdate(CUserFunctionRight *pUserFunctionRight, CWriteableUserFunctionRight *pOldUserFunctionRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUserFunctionRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUserFunctionRight,pOldUserFunctionRight);
	}
}
	
void CUserFunctionRightFactory::commitRemove(CWriteableUserFunctionRight *pUserFunctionRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUserFunctionRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUserFunctionRight);
	}
}

void CUserFunctionRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForAccountIDIndexinAccount(const void *pV1, const void *pV2);
extern int compareForParticipantIDIndexinAccount(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForAccount=0;
int updateWithIndexActionForAccount=0;
int updateWithoutIndexActionForAccount=0;
int removeActionForAccount=0;
int addCommitForAccount=0;
int updateCommitForAccount=0;
int removeCommitForAccount=0;
#endif
void CAccountFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinAccount,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Account_AccountIDIndex",pAccountIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Account_AccountIDIndex");
			if(it != pIndexMap->end()) {
				pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinAccount,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pAccountIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinAccount,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Account_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Account_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinAccount,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByParticipantID=NULL;
	pActionTriggers=new vector<CAccountActionTrigger *>;
	pCommitTriggers=new vector<CAccountCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CAccountFactory::CAccountFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CAccount),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CAccountFactory::CAccountFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CAccount),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CAccountFactory::~CAccountFactory(void)
{
	if (runLevel>=0) {
		if (pAccountIDIndex!=NULL)
			delete pAccountIDIndex;
	}
	if (runLevel>=1) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CAccountFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CAccountFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pAccountIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
}

int CAccountFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableAccount thisAccount;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisAccount.readCSV(input,pNames))
		add(&thisAccount);
	fclose(input);
	delete pNames;
	return 1;
}

int CAccountFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Account.csv");
	return readCSV(szFileName);
}

int CAccountFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableAccount *pAccount;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableAccount::writeCSVHead(output);
	pAccount=(CWriteableAccount *)(pMem->getFirst());
	while (pAccount!=NULL) {
		if (!pAccount->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pAccount=(CWriteableAccount *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CAccountFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Account.csv");
	return writeCSV(szFileName);
}

void CAccountFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CAccountFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableAccount *pAccount;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CAccountFactory={       Total Count=%d\n", pMem->getCount());
	pAccount=(CWriteableAccount *)(pMem->getFirst());
	while (pAccount!=NULL) {
		pAccount->dump(fp,index++);
		pAccount=(CWriteableAccount *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CAccountFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pAccountIDIndex->removeAll();
	}
	if (runLevel>=1) {
		pParticipantIDIndex->removeAll();
	}
}

CAccount *CAccountFactory::internalAdd(CWriteableAccount *pAccount, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForAccount++;
#endif
	CAccount *pTarget;	
	beforeAdd(pAccount);
	pTarget=(CAccount *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Account in memory database");
		return NULL;
	}
	forceCopy(pTarget, pAccount, sizeof(CAccount));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pAccountIDIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pParticipantIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CAccount *CAccountFactory::add(CWriteableAccount *pAccount, CTransaction *pTransaction)
{
	pAccount->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pAccount,true);
	}
	else {
		CAccount *pNewAccount;
		pNewAccount = internalAdd(pAccount,false);
		pTransaction->addResource(CAccountResource::alloc(CREATE_ACTION,this,pNewAccount,NULL));
		return pNewAccount;
	}
}

void CAccountFactory::internalUpdate(CAccount *pAccount, CWriteableAccount *pNewAccount, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForAccount++;
	}
	else {
		updateWithoutIndexActionForAccount++;
	}
#endif
	CWriteableAccount theOldAccount;
	beforeUpdate(pAccount,pNewAccount);
	if (bNoTransaction) {
		forceCopy(&theOldAccount,pAccount,sizeof(CAccount));
	}
	if (updateIndex) {
	}

	forceCopy(pAccount,pNewAccount,sizeof(CAccount));
	pMem->updateObject(pAccount);
	if (updateIndex) {
	}
	afterUpdate(pAccount);
	if (bNoTransaction) {
		commitUpdate(pAccount,&theOldAccount);
	}
}

void CAccountFactory::update(CAccount *pAccount, CWriteableAccount *pNewAccount, CTransaction *pTransaction, bool updateIndex)
{
	pNewAccount->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pAccount,pNewAccount,updateIndex,true);
	}
	else {
		pTransaction->addResource(CAccountResource::alloc(UPDATE_ACTION,this,pAccount,pNewAccount,updateIndex));
		internalUpdate(pAccount,pNewAccount,updateIndex,false);
	}
}

void CAccountFactory::internalRemove(CAccount *pAccount, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForAccount++;
#endif
	CWriteableAccount theOldAccount;
	beforeRemove(pAccount);
	if (bNoTransaction) {
		forceCopy(&theOldAccount,pAccount,sizeof(CAccount));
	}
	if (runLevel>=0) {
		pAccountIDIndex->removeObject(pAccount);
	}
	if (runLevel>=1) {
		pParticipantIDIndex->removeObject(pAccount);
	}
	pMem->free(pAccount);
	if(bNoTransaction) {
		commitRemove(&theOldAccount);
	}
}

void CAccountFactory::remove(CAccount *pAccount, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pAccount,true);
	}
	else {
		pTransaction->addResource(CAccountResource::alloc(DELETE_ACTION,this,pAccount,NULL));
		internalRemove(pAccount,false);		
	}
}

CAccount* CAccountFactory::addOrUpdate(CAccount *pAccount, CWriteableAccount *pNewAccount, CTransaction *pTransaction, bool updateIndex)
{
	if(pAccount == NULL) {
		return add(pNewAccount,pTransaction);
	}
	else {
		update(pAccount,pNewAccount,pTransaction,updateIndex);
		return pAccount;
	}
}

void CAccountFactory::retrieve(CAccount *pAccount, CWriteableAccount *pTargetAccount)
{
	forceCopy(pTargetAccount, pAccount, sizeof(CAccount));
}
	
int CAccountFactory::addActionTrigger(CAccountActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CAccountFactory::removeActionTrigger(CAccountActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CAccountFactory::addCommitTrigger(CAccountCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CAccountFactory::removeCommitTrigger(CAccountCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CAccount *CAccountFactory::getFirst(void)
{
	CAccount *pResult=(CAccount *)(pMem->getFirst());
	return pResult;
}
	
CAccount *CAccountFactory::getNext(void)
{
	CAccount *pResult=(CAccount *)(pMem->getNext());
	return pResult;
}
	
void CAccountFactory::endGet(void)
{
	pMem->endGet();
}

void CAccountFactory::beforeAdd(CWriteableAccount *pAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pAccount);
	}
}
	
void CAccountFactory::afterAdd(CAccount *pAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pAccount);
	}
}

void CAccountFactory::beforeUpdate(CAccount *pAccount, CWriteableAccount *pNewAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pAccount,pNewAccount);
	}
}
	
void CAccountFactory::afterUpdate(CAccount *pAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pAccount);
	}
}
	
void CAccountFactory::beforeRemove(CAccount *pAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pAccount);
	}
}

void CAccountFactory::commitAdd(CAccount *pAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pAccount);
	}
}

void CAccountFactory::commitUpdate(CAccount *pAccount, CWriteableAccount *pOldAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pAccount,pOldAccount);
	}
}
	
void CAccountFactory::commitRemove(CWriteableAccount *pAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pAccount);
	}
}

void CAccountFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CAccountFactory::linkAllTradingAccount(CTradingAccountFactory *pFactory)
{
	CAccount *pAccount;
	pAccount=getFirst();
	while (pAccount != NULL) {
		pAccount->linkTradingAccount(pFactory);
		pAccount=getNext();
	}
	endGet();
}

#ifdef COUNT_OPERATION
int addActionForUserCommFlux=0;
int updateWithIndexActionForUserCommFlux=0;
int updateWithoutIndexActionForUserCommFlux=0;
int removeActionForUserCommFlux=0;
int addCommitForUserCommFlux=0;
int updateCommitForUserCommFlux=0;
int removeCommitForUserCommFlux=0;
#endif
void CUserCommFluxFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=400;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("UserCommFlux.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pUserIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UserCommFlux_UserIDHashIndex",pUserIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UserCommFlux_UserIDHashIndex");
			if(it != pIndexMap->end()) {
				pUserIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CUserCommFluxActionTrigger *>;
	pCommitTriggers=new vector<CUserCommFluxCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUserCommFluxFactory::CUserCommFluxFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserCommFlux),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUserCommFluxFactory::CUserCommFluxFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserCommFlux),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUserCommFluxFactory::~CUserCommFluxFactory(void)
{
	if (runLevel>=0) {
		if (pUserIDHashIndex!=NULL)
			delete pUserIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUserCommFluxFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUserCommFluxFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CUserCommFluxFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUserCommFlux thisUserCommFlux;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUserCommFlux.readCSV(input,pNames))
		add(&thisUserCommFlux);
	fclose(input);
	delete pNames;
	return 1;
}

int CUserCommFluxFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "UserCommFlux.csv");
	return readCSV(szFileName);
}

int CUserCommFluxFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUserCommFlux *pUserCommFlux;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUserCommFlux::writeCSVHead(output);
	pUserCommFlux=(CWriteableUserCommFlux *)(pMem->getFirst());
	while (pUserCommFlux!=NULL) {
		if (!pUserCommFlux->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUserCommFlux=(CWriteableUserCommFlux *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUserCommFluxFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "UserCommFlux.csv");
	return writeCSV(szFileName);
}

void CUserCommFluxFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUserCommFluxFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUserCommFlux *pUserCommFlux;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUserCommFluxFactory={       Total Count=%d\n", pMem->getCount());
	pUserCommFlux=(CWriteableUserCommFlux *)(pMem->getFirst());
	while (pUserCommFlux!=NULL) {
		pUserCommFlux->dump(fp,index++);
		pUserCommFlux=(CWriteableUserCommFlux *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUserCommFluxFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pUserIDHashIndex->removeAll();
	}
}

CUserCommFlux *CUserCommFluxFactory::internalAdd(CWriteableUserCommFlux *pUserCommFlux, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUserCommFlux++;
#endif
	CUserCommFlux *pTarget;	
	beforeAdd(pUserCommFlux);
	pTarget=(CUserCommFlux *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough UserCommFlux in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUserCommFlux, sizeof(CUserCommFlux));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pUserIDHashIndex->addObject(pTarget,pTarget->HashUserID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUserCommFlux *CUserCommFluxFactory::add(CWriteableUserCommFlux *pUserCommFlux, CTransaction *pTransaction)
{
	pUserCommFlux->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUserCommFlux,true);
	}
	else {
		CUserCommFlux *pNewUserCommFlux;
		pNewUserCommFlux = internalAdd(pUserCommFlux,false);
		pTransaction->addResource(CUserCommFluxResource::alloc(CREATE_ACTION,this,pNewUserCommFlux,NULL));
		return pNewUserCommFlux;
	}
}

void CUserCommFluxFactory::internalUpdate(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pNewUserCommFlux, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUserCommFlux++;
	}
	else {
		updateWithoutIndexActionForUserCommFlux++;
	}
#endif
	CWriteableUserCommFlux theOldUserCommFlux;
	beforeUpdate(pUserCommFlux,pNewUserCommFlux);
	if (bNoTransaction) {
		forceCopy(&theOldUserCommFlux,pUserCommFlux,sizeof(CUserCommFlux));
	}
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIDHashIndex->removeObject(pUserCommFlux,pUserCommFlux->HashUserID);
		}
	}

	forceCopy(pUserCommFlux,pNewUserCommFlux,sizeof(CUserCommFlux));
	pMem->updateObject(pUserCommFlux);
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIDHashIndex->addObject(pUserCommFlux,pUserCommFlux->HashUserID);
		}
	}
	afterUpdate(pUserCommFlux);
	if (bNoTransaction) {
		commitUpdate(pUserCommFlux,&theOldUserCommFlux);
	}
}

void CUserCommFluxFactory::update(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pNewUserCommFlux, CTransaction *pTransaction, bool updateIndex)
{
	pNewUserCommFlux->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUserCommFlux,pNewUserCommFlux,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUserCommFluxResource::alloc(UPDATE_ACTION,this,pUserCommFlux,pNewUserCommFlux,updateIndex));
		internalUpdate(pUserCommFlux,pNewUserCommFlux,updateIndex,false);
	}
}

void CUserCommFluxFactory::internalRemove(CUserCommFlux *pUserCommFlux, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUserCommFlux++;
#endif
	CWriteableUserCommFlux theOldUserCommFlux;
	beforeRemove(pUserCommFlux);
	if (bNoTransaction) {
		forceCopy(&theOldUserCommFlux,pUserCommFlux,sizeof(CUserCommFlux));
	}
	if (runLevel>=0) {
		pUserIDHashIndex->removeObject(pUserCommFlux,pUserCommFlux->HashUserID);
	}	
	pMem->free(pUserCommFlux);
	if(bNoTransaction) {
		commitRemove(&theOldUserCommFlux);
	}
}

void CUserCommFluxFactory::remove(CUserCommFlux *pUserCommFlux, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUserCommFlux,true);
	}
	else {
		pTransaction->addResource(CUserCommFluxResource::alloc(DELETE_ACTION,this,pUserCommFlux,NULL));
		internalRemove(pUserCommFlux,false);		
	}
}

CUserCommFlux* CUserCommFluxFactory::addOrUpdate(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pNewUserCommFlux, CTransaction *pTransaction, bool updateIndex)
{
	if(pUserCommFlux == NULL) {
		return add(pNewUserCommFlux,pTransaction);
	}
	else {
		update(pUserCommFlux,pNewUserCommFlux,pTransaction,updateIndex);
		return pUserCommFlux;
	}
}

void CUserCommFluxFactory::retrieve(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pTargetUserCommFlux)
{
	forceCopy(pTargetUserCommFlux, pUserCommFlux, sizeof(CUserCommFlux));
}
	
int CUserCommFluxFactory::addActionTrigger(CUserCommFluxActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUserCommFluxFactory::removeActionTrigger(CUserCommFluxActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUserCommFluxFactory::addCommitTrigger(CUserCommFluxCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUserCommFluxFactory::removeCommitTrigger(CUserCommFluxCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUserCommFlux *CUserCommFluxFactory::getFirst(void)
{
	CUserCommFlux *pResult=(CUserCommFlux *)(pMem->getFirst());
	return pResult;
}
	
CUserCommFlux *CUserCommFluxFactory::getNext(void)
{
	CUserCommFlux *pResult=(CUserCommFlux *)(pMem->getNext());
	return pResult;
}
	
void CUserCommFluxFactory::endGet(void)
{
	pMem->endGet();
}

void CUserCommFluxFactory::beforeAdd(CWriteableUserCommFlux *pUserCommFlux)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUserCommFlux);
	}
}
	
void CUserCommFluxFactory::afterAdd(CUserCommFlux *pUserCommFlux)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUserCommFlux);
	}
}

void CUserCommFluxFactory::beforeUpdate(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pNewUserCommFlux)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUserCommFlux,pNewUserCommFlux);
	}
}
	
void CUserCommFluxFactory::afterUpdate(CUserCommFlux *pUserCommFlux)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUserCommFlux);
	}
}
	
void CUserCommFluxFactory::beforeRemove(CUserCommFlux *pUserCommFlux)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUserCommFlux);
	}
}

void CUserCommFluxFactory::commitAdd(CUserCommFlux *pUserCommFlux)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUserCommFlux++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUserCommFlux);
	}
}

void CUserCommFluxFactory::commitUpdate(CUserCommFlux *pUserCommFlux, CWriteableUserCommFlux *pOldUserCommFlux)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUserCommFlux++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUserCommFlux,pOldUserCommFlux);
	}
}
	
void CUserCommFluxFactory::commitRemove(CWriteableUserCommFlux *pUserCommFlux)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUserCommFlux++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUserCommFlux);
	}
}

void CUserCommFluxFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForMarketDataLogNoIndexinMarketDataLog(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketDataLog=0;
int updateWithIndexActionForMarketDataLog=0;
int updateWithoutIndexActionForMarketDataLog=0;
int removeActionForMarketDataLog=0;
int addCommitForMarketDataLog=0;
int updateCommitForMarketDataLog=0;
int removeCommitForMarketDataLog=0;
#endif
void CMarketDataLogFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pMarketDataLogNoIndex=new CAVLTree(maxUnit,compareForMarketDataLogNoIndexinMarketDataLog,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketDataLog_MarketDataLogNoIndex",pMarketDataLogNoIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketDataLog_MarketDataLogNoIndex");
			if(it != pIndexMap->end()) {
				pMarketDataLogNoIndex=new CAVLTree(maxUnit,compareForMarketDataLogNoIndexinMarketDataLog,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pMarketDataLogNoIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByMarketDataLogNo=NULL;
	pActionTriggers=new vector<CMarketDataLogActionTrigger *>;
	pCommitTriggers=new vector<CMarketDataLogCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketDataLogFactory::CMarketDataLogFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataLog),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketDataLogFactory::CMarketDataLogFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataLog),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketDataLogFactory::~CMarketDataLogFactory(void)
{
	if (runLevel>=0) {
		if (pMarketDataLogNoIndex!=NULL)
			delete pMarketDataLogNoIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketDataLogFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketDataLogFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pMarketDataLogNoIndex->output(pLogger,indent+1);
	}
}

int CMarketDataLogFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketDataLog thisMarketDataLog;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketDataLog.readCSV(input,pNames))
		add(&thisMarketDataLog);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketDataLogFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketDataLog.csv");
	return readCSV(szFileName);
}

int CMarketDataLogFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketDataLog *pMarketDataLog;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketDataLog::writeCSVHead(output);
	pMarketDataLog=(CWriteableMarketDataLog *)(pMem->getFirst());
	while (pMarketDataLog!=NULL) {
		if (!pMarketDataLog->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketDataLog=(CWriteableMarketDataLog *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketDataLogFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketDataLog.csv");
	return writeCSV(szFileName);
}

void CMarketDataLogFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketDataLogFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketDataLog *pMarketDataLog;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketDataLogFactory={       Total Count=%d\n", pMem->getCount());
	pMarketDataLog=(CWriteableMarketDataLog *)(pMem->getFirst());
	while (pMarketDataLog!=NULL) {
		pMarketDataLog->dump(fp,index++);
		pMarketDataLog=(CWriteableMarketDataLog *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketDataLogFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pMarketDataLogNoIndex->removeAll();
	}
}

CMarketDataLog *CMarketDataLogFactory::internalAdd(CWriteableMarketDataLog *pMarketDataLog, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketDataLog++;
#endif
	CMarketDataLog *pTarget;	
	beforeAdd(pMarketDataLog);
	pTarget=(CMarketDataLog *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketDataLog in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketDataLog, sizeof(CMarketDataLog));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pMarketDataLogNoIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketDataLog *CMarketDataLogFactory::add(CWriteableMarketDataLog *pMarketDataLog, CTransaction *pTransaction)
{
	pMarketDataLog->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketDataLog,true);
	}
	else {
		CMarketDataLog *pNewMarketDataLog;
		pNewMarketDataLog = internalAdd(pMarketDataLog,false);
		pTransaction->addResource(CMarketDataLogResource::alloc(CREATE_ACTION,this,pNewMarketDataLog,NULL));
		return pNewMarketDataLog;
	}
}

void CMarketDataLogFactory::internalUpdate(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pNewMarketDataLog, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketDataLog++;
	}
	else {
		updateWithoutIndexActionForMarketDataLog++;
	}
#endif
	CWriteableMarketDataLog theOldMarketDataLog;
	beforeUpdate(pMarketDataLog,pNewMarketDataLog);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataLog,pMarketDataLog,sizeof(CMarketDataLog));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketDataLog,pNewMarketDataLog,sizeof(CMarketDataLog));
	pMem->updateObject(pMarketDataLog);
	if (updateIndex) {
	}
	afterUpdate(pMarketDataLog);
	if (bNoTransaction) {
		commitUpdate(pMarketDataLog,&theOldMarketDataLog);
	}
}

void CMarketDataLogFactory::update(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pNewMarketDataLog, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketDataLog->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketDataLog,pNewMarketDataLog,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketDataLogResource::alloc(UPDATE_ACTION,this,pMarketDataLog,pNewMarketDataLog,updateIndex));
		internalUpdate(pMarketDataLog,pNewMarketDataLog,updateIndex,false);
	}
}

void CMarketDataLogFactory::internalRemove(CMarketDataLog *pMarketDataLog, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketDataLog++;
#endif
	CWriteableMarketDataLog theOldMarketDataLog;
	beforeRemove(pMarketDataLog);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataLog,pMarketDataLog,sizeof(CMarketDataLog));
	}
	if (runLevel>=0) {
		pMarketDataLogNoIndex->removeObject(pMarketDataLog);
	}
	pMem->free(pMarketDataLog);
	if(bNoTransaction) {
		commitRemove(&theOldMarketDataLog);
	}
}

void CMarketDataLogFactory::remove(CMarketDataLog *pMarketDataLog, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketDataLog,true);
	}
	else {
		pTransaction->addResource(CMarketDataLogResource::alloc(DELETE_ACTION,this,pMarketDataLog,NULL));
		internalRemove(pMarketDataLog,false);		
	}
}

CMarketDataLog* CMarketDataLogFactory::addOrUpdate(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pNewMarketDataLog, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketDataLog == NULL) {
		return add(pNewMarketDataLog,pTransaction);
	}
	else {
		update(pMarketDataLog,pNewMarketDataLog,pTransaction,updateIndex);
		return pMarketDataLog;
	}
}

void CMarketDataLogFactory::retrieve(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pTargetMarketDataLog)
{
	forceCopy(pTargetMarketDataLog, pMarketDataLog, sizeof(CMarketDataLog));
}
	
int CMarketDataLogFactory::addActionTrigger(CMarketDataLogActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketDataLogFactory::removeActionTrigger(CMarketDataLogActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketDataLogFactory::addCommitTrigger(CMarketDataLogCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketDataLogFactory::removeCommitTrigger(CMarketDataLogCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketDataLog *CMarketDataLogFactory::getFirst(void)
{
	CMarketDataLog *pResult=(CMarketDataLog *)(pMem->getFirst());
	return pResult;
}
	
CMarketDataLog *CMarketDataLogFactory::getNext(void)
{
	CMarketDataLog *pResult=(CMarketDataLog *)(pMem->getNext());
	return pResult;
}
	
void CMarketDataLogFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketDataLogFactory::beforeAdd(CWriteableMarketDataLog *pMarketDataLog)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketDataLog);
	}
}
	
void CMarketDataLogFactory::afterAdd(CMarketDataLog *pMarketDataLog)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketDataLog);
	}
}

void CMarketDataLogFactory::beforeUpdate(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pNewMarketDataLog)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketDataLog,pNewMarketDataLog);
	}
}
	
void CMarketDataLogFactory::afterUpdate(CMarketDataLog *pMarketDataLog)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketDataLog);
	}
}
	
void CMarketDataLogFactory::beforeRemove(CMarketDataLog *pMarketDataLog)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketDataLog);
	}
}

void CMarketDataLogFactory::commitAdd(CMarketDataLog *pMarketDataLog)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketDataLog++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketDataLog);
	}
}

void CMarketDataLogFactory::commitUpdate(CMarketDataLog *pMarketDataLog, CWriteableMarketDataLog *pOldMarketDataLog)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketDataLog++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketDataLog,pOldMarketDataLog);
	}
}
	
void CMarketDataLogFactory::commitRemove(CWriteableMarketDataLog *pMarketDataLog)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketDataLog++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketDataLog);
	}
}

void CMarketDataLogFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSessionIDIndexinUserSession(const void *pV1, const void *pV2);
extern int compareForUserIndexinUserSession(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForUserSession=0;
int updateWithIndexActionForUserSession=0;
int updateWithoutIndexActionForUserSession=0;
int removeActionForUserSession=0;
int addCommitForUserSession=0;
int updateCommitForUserSession=0;
int removeCommitForUserSession=0;
#endif
void CUserSessionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSessionIDIndex=new CAVLTree(maxUnit,compareForSessionIDIndexinUserSession,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UserSession_SessionIDIndex",pSessionIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UserSession_SessionIDIndex");
			if(it != pIndexMap->end()) {
				pSessionIDIndex=new CAVLTree(maxUnit,compareForSessionIDIndexinUserSession,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSessionIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pUserIndex=new CAVLTree(maxUnit,compareForUserIndexinUserSession,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UserSession_UserIndex",pUserIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UserSession_UserIndex");
			if(it != pIndexMap->end()) {
				pUserIndex=new CAVLTree(maxUnit,compareForUserIndexinUserSession,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByFrontID=NULL;
	pLastFoundInSearchStartByUserID=NULL;
	pActionTriggers=new vector<CUserSessionActionTrigger *>;
	pCommitTriggers=new vector<CUserSessionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUserSessionFactory::CUserSessionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserSession),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUserSessionFactory::CUserSessionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUserSession),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUserSessionFactory::~CUserSessionFactory(void)
{
	if (runLevel>=0) {
		if (pSessionIDIndex!=NULL)
			delete pSessionIDIndex;
	}
	if (runLevel>=0) {
		if (pUserIndex!=NULL)
			delete pUserIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUserSessionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUserSessionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSessionIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pUserIndex->output(pLogger,indent+1);
	}
}

int CUserSessionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUserSession thisUserSession;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUserSession.readCSV(input,pNames))
		add(&thisUserSession);
	fclose(input);
	delete pNames;
	return 1;
}

int CUserSessionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "UserSession.csv");
	return readCSV(szFileName);
}

int CUserSessionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUserSession *pUserSession;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUserSession::writeCSVHead(output);
	pUserSession=(CWriteableUserSession *)(pMem->getFirst());
	while (pUserSession!=NULL) {
		if (!pUserSession->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUserSession=(CWriteableUserSession *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUserSessionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "UserSession.csv");
	return writeCSV(szFileName);
}

void CUserSessionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUserSessionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUserSession *pUserSession;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUserSessionFactory={       Total Count=%d\n", pMem->getCount());
	pUserSession=(CWriteableUserSession *)(pMem->getFirst());
	while (pUserSession!=NULL) {
		pUserSession->dump(fp,index++);
		pUserSession=(CWriteableUserSession *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUserSessionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSessionIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pUserIndex->removeAll();
	}
}

CUserSession *CUserSessionFactory::internalAdd(CWriteableUserSession *pUserSession, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUserSession++;
#endif
	CUserSession *pTarget;	
	beforeAdd(pUserSession);
	pTarget=(CUserSession *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough UserSession in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUserSession, sizeof(CUserSession));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSessionIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pUserIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUserSession *CUserSessionFactory::add(CWriteableUserSession *pUserSession, CTransaction *pTransaction)
{
	pUserSession->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUserSession,true);
	}
	else {
		CUserSession *pNewUserSession;
		pNewUserSession = internalAdd(pUserSession,false);
		pTransaction->addResource(CUserSessionResource::alloc(CREATE_ACTION,this,pNewUserSession,NULL));
		return pNewUserSession;
	}
}

void CUserSessionFactory::internalUpdate(CUserSession *pUserSession, CWriteableUserSession *pNewUserSession, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUserSession++;
	}
	else {
		updateWithoutIndexActionForUserSession++;
	}
#endif
	CWriteableUserSession theOldUserSession;
	beforeUpdate(pUserSession,pNewUserSession);
	if (bNoTransaction) {
		forceCopy(&theOldUserSession,pUserSession,sizeof(CUserSession));
	}
	CAVLNode *pUserIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIndexNode=pUserIndex->findObject(pUserSession);
		}
	}

	forceCopy(pUserSession,pNewUserSession,sizeof(CUserSession));
	pMem->updateObject(pUserSession);
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIndex->updateNode(pUserIndexNode);
		}
	}
	afterUpdate(pUserSession);
	if (bNoTransaction) {
		commitUpdate(pUserSession,&theOldUserSession);
	}
}

void CUserSessionFactory::update(CUserSession *pUserSession, CWriteableUserSession *pNewUserSession, CTransaction *pTransaction, bool updateIndex)
{
	pNewUserSession->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUserSession,pNewUserSession,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUserSessionResource::alloc(UPDATE_ACTION,this,pUserSession,pNewUserSession,updateIndex));
		internalUpdate(pUserSession,pNewUserSession,updateIndex,false);
	}
}

void CUserSessionFactory::internalRemove(CUserSession *pUserSession, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUserSession++;
#endif
	CWriteableUserSession theOldUserSession;
	beforeRemove(pUserSession);
	if (bNoTransaction) {
		forceCopy(&theOldUserSession,pUserSession,sizeof(CUserSession));
	}
	if (runLevel>=0) {
		pSessionIDIndex->removeObject(pUserSession);
	}
	if (runLevel>=0) {
		pUserIndex->removeObject(pUserSession);
	}
	pMem->free(pUserSession);
	if(bNoTransaction) {
		commitRemove(&theOldUserSession);
	}
}

void CUserSessionFactory::remove(CUserSession *pUserSession, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUserSession,true);
	}
	else {
		pTransaction->addResource(CUserSessionResource::alloc(DELETE_ACTION,this,pUserSession,NULL));
		internalRemove(pUserSession,false);		
	}
}

CUserSession* CUserSessionFactory::addOrUpdate(CUserSession *pUserSession, CWriteableUserSession *pNewUserSession, CTransaction *pTransaction, bool updateIndex)
{
	if(pUserSession == NULL) {
		return add(pNewUserSession,pTransaction);
	}
	else {
		update(pUserSession,pNewUserSession,pTransaction,updateIndex);
		return pUserSession;
	}
}

void CUserSessionFactory::retrieve(CUserSession *pUserSession, CWriteableUserSession *pTargetUserSession)
{
	forceCopy(pTargetUserSession, pUserSession, sizeof(CUserSession));
}
	
int CUserSessionFactory::addActionTrigger(CUserSessionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUserSessionFactory::removeActionTrigger(CUserSessionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUserSessionFactory::addCommitTrigger(CUserSessionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUserSessionFactory::removeCommitTrigger(CUserSessionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUserSession *CUserSessionFactory::getFirst(void)
{
	CUserSession *pResult=(CUserSession *)(pMem->getFirst());
	return pResult;
}
	
CUserSession *CUserSessionFactory::getNext(void)
{
	CUserSession *pResult=(CUserSession *)(pMem->getNext());
	return pResult;
}
	
void CUserSessionFactory::endGet(void)
{
	pMem->endGet();
}

void CUserSessionFactory::beforeAdd(CWriteableUserSession *pUserSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUserSession);
	}
}
	
void CUserSessionFactory::afterAdd(CUserSession *pUserSession)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUserSession);
	}
}

void CUserSessionFactory::beforeUpdate(CUserSession *pUserSession, CWriteableUserSession *pNewUserSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUserSession,pNewUserSession);
	}
}
	
void CUserSessionFactory::afterUpdate(CUserSession *pUserSession)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUserSession);
	}
}
	
void CUserSessionFactory::beforeRemove(CUserSession *pUserSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUserSession);
	}
}

void CUserSessionFactory::commitAdd(CUserSession *pUserSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUserSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUserSession);
	}
}

void CUserSessionFactory::commitUpdate(CUserSession *pUserSession, CWriteableUserSession *pOldUserSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUserSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUserSession,pOldUserSession);
	}
}
	
void CUserSessionFactory::commitRemove(CWriteableUserSession *pUserSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUserSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUserSession);
	}
}

void CUserSessionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CUserSessionFactory::linkAllUser(CUserFactory *pFactory)
{
	CUserSession *pUserSession;
	pUserSession=getFirst();
	while (pUserSession != NULL) {
		pUserSession->linkUser(pFactory);
		pUserSession=getNext();
	}
	endGet();
}

extern int compareForSessionIDIndexinMDSession(const void *pV1, const void *pV2);
extern int compareForUserIndexinMDSession(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMDSession=0;
int updateWithIndexActionForMDSession=0;
int updateWithoutIndexActionForMDSession=0;
int removeActionForMDSession=0;
int addCommitForMDSession=0;
int updateCommitForMDSession=0;
int removeCommitForMDSession=0;
#endif
void CMDSessionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSessionIDIndex=new CAVLTree(maxUnit,compareForSessionIDIndexinMDSession,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MDSession_SessionIDIndex",pSessionIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MDSession_SessionIDIndex");
			if(it != pIndexMap->end()) {
				pSessionIDIndex=new CAVLTree(maxUnit,compareForSessionIDIndexinMDSession,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSessionIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pUserIndex=new CAVLTree(maxUnit,compareForUserIndexinMDSession,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MDSession_UserIndex",pUserIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MDSession_UserIndex");
			if(it != pIndexMap->end()) {
				pUserIndex=new CAVLTree(maxUnit,compareForUserIndexinMDSession,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CMDSessionActionTrigger *>;
	pCommitTriggers=new vector<CMDSessionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMDSessionFactory::CMDSessionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMDSession),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMDSessionFactory::CMDSessionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMDSession),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMDSessionFactory::~CMDSessionFactory(void)
{
	if (runLevel>=0) {
		if (pSessionIDIndex!=NULL)
			delete pSessionIDIndex;
	}
	if (runLevel>=0) {
		if (pUserIndex!=NULL)
			delete pUserIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMDSessionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMDSessionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSessionIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pUserIndex->output(pLogger,indent+1);
	}
}

int CMDSessionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMDSession thisMDSession;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMDSession.readCSV(input,pNames))
		add(&thisMDSession);
	fclose(input);
	delete pNames;
	return 1;
}

int CMDSessionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MDSession.csv");
	return readCSV(szFileName);
}

int CMDSessionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMDSession *pMDSession;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMDSession::writeCSVHead(output);
	pMDSession=(CWriteableMDSession *)(pMem->getFirst());
	while (pMDSession!=NULL) {
		if (!pMDSession->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMDSession=(CWriteableMDSession *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMDSessionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MDSession.csv");
	return writeCSV(szFileName);
}

void CMDSessionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMDSessionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMDSession *pMDSession;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMDSessionFactory={       Total Count=%d\n", pMem->getCount());
	pMDSession=(CWriteableMDSession *)(pMem->getFirst());
	while (pMDSession!=NULL) {
		pMDSession->dump(fp,index++);
		pMDSession=(CWriteableMDSession *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMDSessionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSessionIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pUserIndex->removeAll();
	}
}

CMDSession *CMDSessionFactory::internalAdd(CWriteableMDSession *pMDSession, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMDSession++;
#endif
	CMDSession *pTarget;	
	beforeAdd(pMDSession);
	pTarget=(CMDSession *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MDSession in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMDSession, sizeof(CMDSession));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSessionIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pUserIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMDSession *CMDSessionFactory::add(CWriteableMDSession *pMDSession, CTransaction *pTransaction)
{
	pMDSession->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMDSession,true);
	}
	else {
		CMDSession *pNewMDSession;
		pNewMDSession = internalAdd(pMDSession,false);
		pTransaction->addResource(CMDSessionResource::alloc(CREATE_ACTION,this,pNewMDSession,NULL));
		return pNewMDSession;
	}
}

void CMDSessionFactory::internalUpdate(CMDSession *pMDSession, CWriteableMDSession *pNewMDSession, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMDSession++;
	}
	else {
		updateWithoutIndexActionForMDSession++;
	}
#endif
	CWriteableMDSession theOldMDSession;
	beforeUpdate(pMDSession,pNewMDSession);
	if (bNoTransaction) {
		forceCopy(&theOldMDSession,pMDSession,sizeof(CMDSession));
	}
	CAVLNode *pUserIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIndexNode=pUserIndex->findObject(pMDSession);
		}
	}

	forceCopy(pMDSession,pNewMDSession,sizeof(CMDSession));
	pMem->updateObject(pMDSession);
	if (updateIndex) {
		if (runLevel>=0) {
			pUserIndex->updateNode(pUserIndexNode);
		}
	}
	afterUpdate(pMDSession);
	if (bNoTransaction) {
		commitUpdate(pMDSession,&theOldMDSession);
	}
}

void CMDSessionFactory::update(CMDSession *pMDSession, CWriteableMDSession *pNewMDSession, CTransaction *pTransaction, bool updateIndex)
{
	pNewMDSession->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMDSession,pNewMDSession,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMDSessionResource::alloc(UPDATE_ACTION,this,pMDSession,pNewMDSession,updateIndex));
		internalUpdate(pMDSession,pNewMDSession,updateIndex,false);
	}
}

void CMDSessionFactory::internalRemove(CMDSession *pMDSession, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMDSession++;
#endif
	CWriteableMDSession theOldMDSession;
	beforeRemove(pMDSession);
	if (bNoTransaction) {
		forceCopy(&theOldMDSession,pMDSession,sizeof(CMDSession));
	}
	if (runLevel>=0) {
		pSessionIDIndex->removeObject(pMDSession);
	}
	if (runLevel>=0) {
		pUserIndex->removeObject(pMDSession);
	}
	pMem->free(pMDSession);
	if(bNoTransaction) {
		commitRemove(&theOldMDSession);
	}
}

void CMDSessionFactory::remove(CMDSession *pMDSession, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMDSession,true);
	}
	else {
		pTransaction->addResource(CMDSessionResource::alloc(DELETE_ACTION,this,pMDSession,NULL));
		internalRemove(pMDSession,false);		
	}
}

CMDSession* CMDSessionFactory::addOrUpdate(CMDSession *pMDSession, CWriteableMDSession *pNewMDSession, CTransaction *pTransaction, bool updateIndex)
{
	if(pMDSession == NULL) {
		return add(pNewMDSession,pTransaction);
	}
	else {
		update(pMDSession,pNewMDSession,pTransaction,updateIndex);
		return pMDSession;
	}
}

void CMDSessionFactory::retrieve(CMDSession *pMDSession, CWriteableMDSession *pTargetMDSession)
{
	forceCopy(pTargetMDSession, pMDSession, sizeof(CMDSession));
}
	
int CMDSessionFactory::addActionTrigger(CMDSessionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMDSessionFactory::removeActionTrigger(CMDSessionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMDSessionFactory::addCommitTrigger(CMDSessionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMDSessionFactory::removeCommitTrigger(CMDSessionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMDSession *CMDSessionFactory::getFirst(void)
{
	CMDSession *pResult=(CMDSession *)(pMem->getFirst());
	return pResult;
}
	
CMDSession *CMDSessionFactory::getNext(void)
{
	CMDSession *pResult=(CMDSession *)(pMem->getNext());
	return pResult;
}
	
void CMDSessionFactory::endGet(void)
{
	pMem->endGet();
}

void CMDSessionFactory::beforeAdd(CWriteableMDSession *pMDSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMDSession);
	}
}
	
void CMDSessionFactory::afterAdd(CMDSession *pMDSession)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMDSession);
	}
}

void CMDSessionFactory::beforeUpdate(CMDSession *pMDSession, CWriteableMDSession *pNewMDSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMDSession,pNewMDSession);
	}
}
	
void CMDSessionFactory::afterUpdate(CMDSession *pMDSession)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMDSession);
	}
}
	
void CMDSessionFactory::beforeRemove(CMDSession *pMDSession)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMDSession);
	}
}

void CMDSessionFactory::commitAdd(CMDSession *pMDSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMDSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMDSession);
	}
}

void CMDSessionFactory::commitUpdate(CMDSession *pMDSession, CWriteableMDSession *pOldMDSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMDSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMDSession,pOldMDSession);
	}
}
	
void CMDSessionFactory::commitRemove(CWriteableMDSession *pMDSession)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMDSession++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMDSession);
	}
}

void CMDSessionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForPrimaryKeyIndexinLoginInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForLoginInfo=0;
int updateWithIndexActionForLoginInfo=0;
int updateWithoutIndexActionForLoginInfo=0;
int removeActionForLoginInfo=0;
int addCommitForLoginInfo=0;
int updateCommitForLoginInfo=0;
int removeCommitForLoginInfo=0;
#endif
void CLoginInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pPrimaryKeyIndex=new CAVLTree(maxUnit,compareForPrimaryKeyIndexinLoginInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("LoginInfo_PrimaryKeyIndex",pPrimaryKeyIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("LoginInfo_PrimaryKeyIndex");
			if(it != pIndexMap->end()) {
				pPrimaryKeyIndex=new CAVLTree(maxUnit,compareForPrimaryKeyIndexinLoginInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPrimaryKeyIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CLoginInfoActionTrigger *>;
	pCommitTriggers=new vector<CLoginInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CLoginInfoFactory::CLoginInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CLoginInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CLoginInfoFactory::CLoginInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CLoginInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CLoginInfoFactory::~CLoginInfoFactory(void)
{
	if (runLevel>=0) {
		if (pPrimaryKeyIndex!=NULL)
			delete pPrimaryKeyIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CLoginInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CLoginInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pPrimaryKeyIndex->output(pLogger,indent+1);
	}
}

int CLoginInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableLoginInfo thisLoginInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisLoginInfo.readCSV(input,pNames))
		add(&thisLoginInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CLoginInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "LoginInfo.csv");
	return readCSV(szFileName);
}

int CLoginInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableLoginInfo *pLoginInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableLoginInfo::writeCSVHead(output);
	pLoginInfo=(CWriteableLoginInfo *)(pMem->getFirst());
	while (pLoginInfo!=NULL) {
		if (!pLoginInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pLoginInfo=(CWriteableLoginInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CLoginInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "LoginInfo.csv");
	return writeCSV(szFileName);
}

void CLoginInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CLoginInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableLoginInfo *pLoginInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CLoginInfoFactory={       Total Count=%d\n", pMem->getCount());
	pLoginInfo=(CWriteableLoginInfo *)(pMem->getFirst());
	while (pLoginInfo!=NULL) {
		pLoginInfo->dump(fp,index++);
		pLoginInfo=(CWriteableLoginInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CLoginInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pPrimaryKeyIndex->removeAll();
	}
}

CLoginInfo *CLoginInfoFactory::internalAdd(CWriteableLoginInfo *pLoginInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForLoginInfo++;
#endif
	CLoginInfo *pTarget;	
	beforeAdd(pLoginInfo);
	pTarget=(CLoginInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough LoginInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pLoginInfo, sizeof(CLoginInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pPrimaryKeyIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CLoginInfo *CLoginInfoFactory::add(CWriteableLoginInfo *pLoginInfo, CTransaction *pTransaction)
{
	pLoginInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pLoginInfo,true);
	}
	else {
		CLoginInfo *pNewLoginInfo;
		pNewLoginInfo = internalAdd(pLoginInfo,false);
		pTransaction->addResource(CLoginInfoResource::alloc(CREATE_ACTION,this,pNewLoginInfo,NULL));
		return pNewLoginInfo;
	}
}

void CLoginInfoFactory::internalUpdate(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pNewLoginInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForLoginInfo++;
	}
	else {
		updateWithoutIndexActionForLoginInfo++;
	}
#endif
	CWriteableLoginInfo theOldLoginInfo;
	beforeUpdate(pLoginInfo,pNewLoginInfo);
	if (bNoTransaction) {
		forceCopy(&theOldLoginInfo,pLoginInfo,sizeof(CLoginInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pLoginInfo,pNewLoginInfo,sizeof(CLoginInfo));
	pMem->updateObject(pLoginInfo);
	if (updateIndex) {
	}
	afterUpdate(pLoginInfo);
	if (bNoTransaction) {
		commitUpdate(pLoginInfo,&theOldLoginInfo);
	}
}

void CLoginInfoFactory::update(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pNewLoginInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewLoginInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pLoginInfo,pNewLoginInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CLoginInfoResource::alloc(UPDATE_ACTION,this,pLoginInfo,pNewLoginInfo,updateIndex));
		internalUpdate(pLoginInfo,pNewLoginInfo,updateIndex,false);
	}
}

void CLoginInfoFactory::internalRemove(CLoginInfo *pLoginInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForLoginInfo++;
#endif
	CWriteableLoginInfo theOldLoginInfo;
	beforeRemove(pLoginInfo);
	if (bNoTransaction) {
		forceCopy(&theOldLoginInfo,pLoginInfo,sizeof(CLoginInfo));
	}
	if (runLevel>=0) {
		pPrimaryKeyIndex->removeObject(pLoginInfo);
	}
	pMem->free(pLoginInfo);
	if(bNoTransaction) {
		commitRemove(&theOldLoginInfo);
	}
}

void CLoginInfoFactory::remove(CLoginInfo *pLoginInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pLoginInfo,true);
	}
	else {
		pTransaction->addResource(CLoginInfoResource::alloc(DELETE_ACTION,this,pLoginInfo,NULL));
		internalRemove(pLoginInfo,false);		
	}
}

CLoginInfo* CLoginInfoFactory::addOrUpdate(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pNewLoginInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pLoginInfo == NULL) {
		return add(pNewLoginInfo,pTransaction);
	}
	else {
		update(pLoginInfo,pNewLoginInfo,pTransaction,updateIndex);
		return pLoginInfo;
	}
}

void CLoginInfoFactory::retrieve(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pTargetLoginInfo)
{
	forceCopy(pTargetLoginInfo, pLoginInfo, sizeof(CLoginInfo));
}
	
int CLoginInfoFactory::addActionTrigger(CLoginInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CLoginInfoFactory::removeActionTrigger(CLoginInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CLoginInfoFactory::addCommitTrigger(CLoginInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CLoginInfoFactory::removeCommitTrigger(CLoginInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CLoginInfo *CLoginInfoFactory::getFirst(void)
{
	CLoginInfo *pResult=(CLoginInfo *)(pMem->getFirst());
	return pResult;
}
	
CLoginInfo *CLoginInfoFactory::getNext(void)
{
	CLoginInfo *pResult=(CLoginInfo *)(pMem->getNext());
	return pResult;
}
	
void CLoginInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CLoginInfoFactory::beforeAdd(CWriteableLoginInfo *pLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pLoginInfo);
	}
}
	
void CLoginInfoFactory::afterAdd(CLoginInfo *pLoginInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pLoginInfo);
	}
}

void CLoginInfoFactory::beforeUpdate(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pNewLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pLoginInfo,pNewLoginInfo);
	}
}
	
void CLoginInfoFactory::afterUpdate(CLoginInfo *pLoginInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pLoginInfo);
	}
}
	
void CLoginInfoFactory::beforeRemove(CLoginInfo *pLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pLoginInfo);
	}
}

void CLoginInfoFactory::commitAdd(CLoginInfo *pLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pLoginInfo);
	}
}

void CLoginInfoFactory::commitUpdate(CLoginInfo *pLoginInfo, CWriteableLoginInfo *pOldLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pLoginInfo,pOldLoginInfo);
	}
}
	
void CLoginInfoFactory::commitRemove(CWriteableLoginInfo *pLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pLoginInfo);
	}
}

void CLoginInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForPrimaryKeyIndexinDepthMarketDataDetail(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForDepthMarketDataDetail=0;
int updateWithIndexActionForDepthMarketDataDetail=0;
int updateWithoutIndexActionForDepthMarketDataDetail=0;
int removeActionForDepthMarketDataDetail=0;
int addCommitForDepthMarketDataDetail=0;
int updateCommitForDepthMarketDataDetail=0;
int removeCommitForDepthMarketDataDetail=0;
#endif
void CDepthMarketDataDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pPrimaryKeyIndex=new CAVLTree(maxUnit,compareForPrimaryKeyIndexinDepthMarketDataDetail,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("DepthMarketDataDetail_PrimaryKeyIndex",pPrimaryKeyIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("DepthMarketDataDetail_PrimaryKeyIndex");
			if(it != pIndexMap->end()) {
				pPrimaryKeyIndex=new CAVLTree(maxUnit,compareForPrimaryKeyIndexinDepthMarketDataDetail,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPrimaryKeyIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CDepthMarketDataDetailActionTrigger *>;
	pCommitTriggers=new vector<CDepthMarketDataDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CDepthMarketDataDetailFactory::CDepthMarketDataDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDepthMarketDataDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CDepthMarketDataDetailFactory::CDepthMarketDataDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDepthMarketDataDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CDepthMarketDataDetailFactory::~CDepthMarketDataDetailFactory(void)
{
	if (runLevel>=0) {
		if (pPrimaryKeyIndex!=NULL)
			delete pPrimaryKeyIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CDepthMarketDataDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CDepthMarketDataDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pPrimaryKeyIndex->output(pLogger,indent+1);
	}
}

int CDepthMarketDataDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableDepthMarketDataDetail thisDepthMarketDataDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisDepthMarketDataDetail.readCSV(input,pNames))
		add(&thisDepthMarketDataDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CDepthMarketDataDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "DepthMarketDataDetail.csv");
	return readCSV(szFileName);
}

int CDepthMarketDataDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableDepthMarketDataDetail *pDepthMarketDataDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableDepthMarketDataDetail::writeCSVHead(output);
	pDepthMarketDataDetail=(CWriteableDepthMarketDataDetail *)(pMem->getFirst());
	while (pDepthMarketDataDetail!=NULL) {
		if (!pDepthMarketDataDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pDepthMarketDataDetail=(CWriteableDepthMarketDataDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CDepthMarketDataDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "DepthMarketDataDetail.csv");
	return writeCSV(szFileName);
}

void CDepthMarketDataDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CDepthMarketDataDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableDepthMarketDataDetail *pDepthMarketDataDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CDepthMarketDataDetailFactory={       Total Count=%d\n", pMem->getCount());
	pDepthMarketDataDetail=(CWriteableDepthMarketDataDetail *)(pMem->getFirst());
	while (pDepthMarketDataDetail!=NULL) {
		pDepthMarketDataDetail->dump(fp,index++);
		pDepthMarketDataDetail=(CWriteableDepthMarketDataDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CDepthMarketDataDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pPrimaryKeyIndex->removeAll();
	}
}

CDepthMarketDataDetail *CDepthMarketDataDetailFactory::internalAdd(CWriteableDepthMarketDataDetail *pDepthMarketDataDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForDepthMarketDataDetail++;
#endif
	CDepthMarketDataDetail *pTarget;	
	beforeAdd(pDepthMarketDataDetail);
	pTarget=(CDepthMarketDataDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough DepthMarketDataDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pDepthMarketDataDetail, sizeof(CDepthMarketDataDetail));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pPrimaryKeyIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CDepthMarketDataDetail *CDepthMarketDataDetailFactory::add(CWriteableDepthMarketDataDetail *pDepthMarketDataDetail, CTransaction *pTransaction)
{
	pDepthMarketDataDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pDepthMarketDataDetail,true);
	}
	else {
		CDepthMarketDataDetail *pNewDepthMarketDataDetail;
		pNewDepthMarketDataDetail = internalAdd(pDepthMarketDataDetail,false);
		pTransaction->addResource(CDepthMarketDataDetailResource::alloc(CREATE_ACTION,this,pNewDepthMarketDataDetail,NULL));
		return pNewDepthMarketDataDetail;
	}
}

void CDepthMarketDataDetailFactory::internalUpdate(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pNewDepthMarketDataDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForDepthMarketDataDetail++;
	}
	else {
		updateWithoutIndexActionForDepthMarketDataDetail++;
	}
#endif
	CWriteableDepthMarketDataDetail theOldDepthMarketDataDetail;
	beforeUpdate(pDepthMarketDataDetail,pNewDepthMarketDataDetail);
	if (bNoTransaction) {
		forceCopy(&theOldDepthMarketDataDetail,pDepthMarketDataDetail,sizeof(CDepthMarketDataDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pDepthMarketDataDetail,pNewDepthMarketDataDetail,sizeof(CDepthMarketDataDetail));
	pMem->updateObject(pDepthMarketDataDetail);
	if (updateIndex) {
	}
	afterUpdate(pDepthMarketDataDetail);
	if (bNoTransaction) {
		commitUpdate(pDepthMarketDataDetail,&theOldDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::update(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pNewDepthMarketDataDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewDepthMarketDataDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pDepthMarketDataDetail,pNewDepthMarketDataDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CDepthMarketDataDetailResource::alloc(UPDATE_ACTION,this,pDepthMarketDataDetail,pNewDepthMarketDataDetail,updateIndex));
		internalUpdate(pDepthMarketDataDetail,pNewDepthMarketDataDetail,updateIndex,false);
	}
}

void CDepthMarketDataDetailFactory::internalRemove(CDepthMarketDataDetail *pDepthMarketDataDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForDepthMarketDataDetail++;
#endif
	CWriteableDepthMarketDataDetail theOldDepthMarketDataDetail;
	beforeRemove(pDepthMarketDataDetail);
	if (bNoTransaction) {
		forceCopy(&theOldDepthMarketDataDetail,pDepthMarketDataDetail,sizeof(CDepthMarketDataDetail));
	}
	if (runLevel>=0) {
		pPrimaryKeyIndex->removeObject(pDepthMarketDataDetail);
	}
	pMem->free(pDepthMarketDataDetail);
	if(bNoTransaction) {
		commitRemove(&theOldDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::remove(CDepthMarketDataDetail *pDepthMarketDataDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pDepthMarketDataDetail,true);
	}
	else {
		pTransaction->addResource(CDepthMarketDataDetailResource::alloc(DELETE_ACTION,this,pDepthMarketDataDetail,NULL));
		internalRemove(pDepthMarketDataDetail,false);		
	}
}

CDepthMarketDataDetail* CDepthMarketDataDetailFactory::addOrUpdate(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pNewDepthMarketDataDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pDepthMarketDataDetail == NULL) {
		return add(pNewDepthMarketDataDetail,pTransaction);
	}
	else {
		update(pDepthMarketDataDetail,pNewDepthMarketDataDetail,pTransaction,updateIndex);
		return pDepthMarketDataDetail;
	}
}

void CDepthMarketDataDetailFactory::retrieve(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pTargetDepthMarketDataDetail)
{
	forceCopy(pTargetDepthMarketDataDetail, pDepthMarketDataDetail, sizeof(CDepthMarketDataDetail));
}
	
int CDepthMarketDataDetailFactory::addActionTrigger(CDepthMarketDataDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CDepthMarketDataDetailFactory::removeActionTrigger(CDepthMarketDataDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CDepthMarketDataDetailFactory::addCommitTrigger(CDepthMarketDataDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CDepthMarketDataDetailFactory::removeCommitTrigger(CDepthMarketDataDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CDepthMarketDataDetail *CDepthMarketDataDetailFactory::getFirst(void)
{
	CDepthMarketDataDetail *pResult=(CDepthMarketDataDetail *)(pMem->getFirst());
	return pResult;
}
	
CDepthMarketDataDetail *CDepthMarketDataDetailFactory::getNext(void)
{
	CDepthMarketDataDetail *pResult=(CDepthMarketDataDetail *)(pMem->getNext());
	return pResult;
}
	
void CDepthMarketDataDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CDepthMarketDataDetailFactory::beforeAdd(CWriteableDepthMarketDataDetail *pDepthMarketDataDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pDepthMarketDataDetail);
	}
}
	
void CDepthMarketDataDetailFactory::afterAdd(CDepthMarketDataDetail *pDepthMarketDataDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::beforeUpdate(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pNewDepthMarketDataDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pDepthMarketDataDetail,pNewDepthMarketDataDetail);
	}
}
	
void CDepthMarketDataDetailFactory::afterUpdate(CDepthMarketDataDetail *pDepthMarketDataDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pDepthMarketDataDetail);
	}
}
	
void CDepthMarketDataDetailFactory::beforeRemove(CDepthMarketDataDetail *pDepthMarketDataDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::commitAdd(CDepthMarketDataDetail *pDepthMarketDataDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForDepthMarketDataDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::commitUpdate(CDepthMarketDataDetail *pDepthMarketDataDetail, CWriteableDepthMarketDataDetail *pOldDepthMarketDataDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForDepthMarketDataDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pDepthMarketDataDetail,pOldDepthMarketDataDetail);
	}
}
	
void CDepthMarketDataDetailFactory::commitRemove(CWriteableDepthMarketDataDetail *pDepthMarketDataDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForDepthMarketDataDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pDepthMarketDataDetail);
	}
}

void CDepthMarketDataDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForInstrumentStatusDetail=0;
int updateWithIndexActionForInstrumentStatusDetail=0;
int updateWithoutIndexActionForInstrumentStatusDetail=0;
int removeActionForInstrumentStatusDetail=0;
int addCommitForInstrumentStatusDetail=0;
int updateCommitForInstrumentStatusDetail=0;
int removeCommitForInstrumentStatusDetail=0;
#endif
void CInstrumentStatusDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pActionTriggers=new vector<CInstrumentStatusDetailActionTrigger *>;
	pCommitTriggers=new vector<CInstrumentStatusDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CInstrumentStatusDetailFactory::CInstrumentStatusDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrumentStatusDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CInstrumentStatusDetailFactory::CInstrumentStatusDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrumentStatusDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CInstrumentStatusDetailFactory::~CInstrumentStatusDetailFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CInstrumentStatusDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CInstrumentStatusDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CInstrumentStatusDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableInstrumentStatusDetail thisInstrumentStatusDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisInstrumentStatusDetail.readCSV(input,pNames))
		add(&thisInstrumentStatusDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CInstrumentStatusDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "InstrumentStatusDetail.csv");
	return readCSV(szFileName);
}

int CInstrumentStatusDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableInstrumentStatusDetail *pInstrumentStatusDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableInstrumentStatusDetail::writeCSVHead(output);
	pInstrumentStatusDetail=(CWriteableInstrumentStatusDetail *)(pMem->getFirst());
	while (pInstrumentStatusDetail!=NULL) {
		if (!pInstrumentStatusDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pInstrumentStatusDetail=(CWriteableInstrumentStatusDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CInstrumentStatusDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "InstrumentStatusDetail.csv");
	return writeCSV(szFileName);
}

void CInstrumentStatusDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CInstrumentStatusDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableInstrumentStatusDetail *pInstrumentStatusDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CInstrumentStatusDetailFactory={       Total Count=%d\n", pMem->getCount());
	pInstrumentStatusDetail=(CWriteableInstrumentStatusDetail *)(pMem->getFirst());
	while (pInstrumentStatusDetail!=NULL) {
		pInstrumentStatusDetail->dump(fp,index++);
		pInstrumentStatusDetail=(CWriteableInstrumentStatusDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CInstrumentStatusDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CInstrumentStatusDetail *CInstrumentStatusDetailFactory::internalAdd(CWriteableInstrumentStatusDetail *pInstrumentStatusDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForInstrumentStatusDetail++;
#endif
	CInstrumentStatusDetail *pTarget;	
	beforeAdd(pInstrumentStatusDetail);
	pTarget=(CInstrumentStatusDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough InstrumentStatusDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pInstrumentStatusDetail, sizeof(CInstrumentStatusDetail));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CInstrumentStatusDetail *CInstrumentStatusDetailFactory::add(CWriteableInstrumentStatusDetail *pInstrumentStatusDetail, CTransaction *pTransaction)
{
	pInstrumentStatusDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pInstrumentStatusDetail,true);
	}
	else {
		CInstrumentStatusDetail *pNewInstrumentStatusDetail;
		pNewInstrumentStatusDetail = internalAdd(pInstrumentStatusDetail,false);
		pTransaction->addResource(CInstrumentStatusDetailResource::alloc(CREATE_ACTION,this,pNewInstrumentStatusDetail,NULL));
		return pNewInstrumentStatusDetail;
	}
}

void CInstrumentStatusDetailFactory::internalUpdate(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pNewInstrumentStatusDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForInstrumentStatusDetail++;
	}
	else {
		updateWithoutIndexActionForInstrumentStatusDetail++;
	}
#endif
	CWriteableInstrumentStatusDetail theOldInstrumentStatusDetail;
	beforeUpdate(pInstrumentStatusDetail,pNewInstrumentStatusDetail);
	if (bNoTransaction) {
		forceCopy(&theOldInstrumentStatusDetail,pInstrumentStatusDetail,sizeof(CInstrumentStatusDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pInstrumentStatusDetail,pNewInstrumentStatusDetail,sizeof(CInstrumentStatusDetail));
	pMem->updateObject(pInstrumentStatusDetail);
	if (updateIndex) {
	}
	afterUpdate(pInstrumentStatusDetail);
	if (bNoTransaction) {
		commitUpdate(pInstrumentStatusDetail,&theOldInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::update(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pNewInstrumentStatusDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewInstrumentStatusDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pInstrumentStatusDetail,pNewInstrumentStatusDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CInstrumentStatusDetailResource::alloc(UPDATE_ACTION,this,pInstrumentStatusDetail,pNewInstrumentStatusDetail,updateIndex));
		internalUpdate(pInstrumentStatusDetail,pNewInstrumentStatusDetail,updateIndex,false);
	}
}

void CInstrumentStatusDetailFactory::internalRemove(CInstrumentStatusDetail *pInstrumentStatusDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForInstrumentStatusDetail++;
#endif
	CWriteableInstrumentStatusDetail theOldInstrumentStatusDetail;
	beforeRemove(pInstrumentStatusDetail);
	if (bNoTransaction) {
		forceCopy(&theOldInstrumentStatusDetail,pInstrumentStatusDetail,sizeof(CInstrumentStatusDetail));
	}
	pMem->free(pInstrumentStatusDetail);
	if(bNoTransaction) {
		commitRemove(&theOldInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::remove(CInstrumentStatusDetail *pInstrumentStatusDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pInstrumentStatusDetail,true);
	}
	else {
		pTransaction->addResource(CInstrumentStatusDetailResource::alloc(DELETE_ACTION,this,pInstrumentStatusDetail,NULL));
		internalRemove(pInstrumentStatusDetail,false);		
	}
}

CInstrumentStatusDetail* CInstrumentStatusDetailFactory::addOrUpdate(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pNewInstrumentStatusDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pInstrumentStatusDetail == NULL) {
		return add(pNewInstrumentStatusDetail,pTransaction);
	}
	else {
		update(pInstrumentStatusDetail,pNewInstrumentStatusDetail,pTransaction,updateIndex);
		return pInstrumentStatusDetail;
	}
}

void CInstrumentStatusDetailFactory::retrieve(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pTargetInstrumentStatusDetail)
{
	forceCopy(pTargetInstrumentStatusDetail, pInstrumentStatusDetail, sizeof(CInstrumentStatusDetail));
}
	
int CInstrumentStatusDetailFactory::addActionTrigger(CInstrumentStatusDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CInstrumentStatusDetailFactory::removeActionTrigger(CInstrumentStatusDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CInstrumentStatusDetailFactory::addCommitTrigger(CInstrumentStatusDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CInstrumentStatusDetailFactory::removeCommitTrigger(CInstrumentStatusDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CInstrumentStatusDetail *CInstrumentStatusDetailFactory::getFirst(void)
{
	CInstrumentStatusDetail *pResult=(CInstrumentStatusDetail *)(pMem->getFirst());
	return pResult;
}
	
CInstrumentStatusDetail *CInstrumentStatusDetailFactory::getNext(void)
{
	CInstrumentStatusDetail *pResult=(CInstrumentStatusDetail *)(pMem->getNext());
	return pResult;
}
	
void CInstrumentStatusDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CInstrumentStatusDetailFactory::beforeAdd(CWriteableInstrumentStatusDetail *pInstrumentStatusDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pInstrumentStatusDetail);
	}
}
	
void CInstrumentStatusDetailFactory::afterAdd(CInstrumentStatusDetail *pInstrumentStatusDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::beforeUpdate(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pNewInstrumentStatusDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pInstrumentStatusDetail,pNewInstrumentStatusDetail);
	}
}
	
void CInstrumentStatusDetailFactory::afterUpdate(CInstrumentStatusDetail *pInstrumentStatusDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pInstrumentStatusDetail);
	}
}
	
void CInstrumentStatusDetailFactory::beforeRemove(CInstrumentStatusDetail *pInstrumentStatusDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::commitAdd(CInstrumentStatusDetail *pInstrumentStatusDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForInstrumentStatusDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::commitUpdate(CInstrumentStatusDetail *pInstrumentStatusDetail, CWriteableInstrumentStatusDetail *pOldInstrumentStatusDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForInstrumentStatusDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pInstrumentStatusDetail,pOldInstrumentStatusDetail);
	}
}
	
void CInstrumentStatusDetailFactory::commitRemove(CWriteableInstrumentStatusDetail *pInstrumentStatusDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForInstrumentStatusDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pInstrumentStatusDetail);
	}
}

void CInstrumentStatusDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForFrontIDIndexinFrontStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForFrontStatus=0;
int updateWithIndexActionForFrontStatus=0;
int updateWithoutIndexActionForFrontStatus=0;
int removeActionForFrontStatus=0;
int addCommitForFrontStatus=0;
int updateCommitForFrontStatus=0;
int removeCommitForFrontStatus=0;
#endif
void CFrontStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pFrontIDIndex=new CAVLTree(maxUnit,compareForFrontIDIndexinFrontStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("FrontStatus_FrontIDIndex",pFrontIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("FrontStatus_FrontIDIndex");
			if(it != pIndexMap->end()) {
				pFrontIDIndex=new CAVLTree(maxUnit,compareForFrontIDIndexinFrontStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pFrontIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CFrontStatusActionTrigger *>;
	pCommitTriggers=new vector<CFrontStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CFrontStatusFactory::CFrontStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CFrontStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CFrontStatusFactory::CFrontStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CFrontStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CFrontStatusFactory::~CFrontStatusFactory(void)
{
	if (runLevel>=0) {
		if (pFrontIDIndex!=NULL)
			delete pFrontIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CFrontStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CFrontStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pFrontIDIndex->output(pLogger,indent+1);
	}
}

int CFrontStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableFrontStatus thisFrontStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisFrontStatus.readCSV(input,pNames))
		add(&thisFrontStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CFrontStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "FrontStatus.csv");
	return readCSV(szFileName);
}

int CFrontStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableFrontStatus *pFrontStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableFrontStatus::writeCSVHead(output);
	pFrontStatus=(CWriteableFrontStatus *)(pMem->getFirst());
	while (pFrontStatus!=NULL) {
		if (!pFrontStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pFrontStatus=(CWriteableFrontStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CFrontStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "FrontStatus.csv");
	return writeCSV(szFileName);
}

void CFrontStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CFrontStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableFrontStatus *pFrontStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CFrontStatusFactory={       Total Count=%d\n", pMem->getCount());
	pFrontStatus=(CWriteableFrontStatus *)(pMem->getFirst());
	while (pFrontStatus!=NULL) {
		pFrontStatus->dump(fp,index++);
		pFrontStatus=(CWriteableFrontStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CFrontStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pFrontIDIndex->removeAll();
	}
}

CFrontStatus *CFrontStatusFactory::internalAdd(CWriteableFrontStatus *pFrontStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForFrontStatus++;
#endif
	CFrontStatus *pTarget;	
	beforeAdd(pFrontStatus);
	pTarget=(CFrontStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough FrontStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pFrontStatus, sizeof(CFrontStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pFrontIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CFrontStatus *CFrontStatusFactory::add(CWriteableFrontStatus *pFrontStatus, CTransaction *pTransaction)
{
	pFrontStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pFrontStatus,true);
	}
	else {
		CFrontStatus *pNewFrontStatus;
		pNewFrontStatus = internalAdd(pFrontStatus,false);
		pTransaction->addResource(CFrontStatusResource::alloc(CREATE_ACTION,this,pNewFrontStatus,NULL));
		return pNewFrontStatus;
	}
}

void CFrontStatusFactory::internalUpdate(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pNewFrontStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForFrontStatus++;
	}
	else {
		updateWithoutIndexActionForFrontStatus++;
	}
#endif
	CWriteableFrontStatus theOldFrontStatus;
	beforeUpdate(pFrontStatus,pNewFrontStatus);
	if (bNoTransaction) {
		forceCopy(&theOldFrontStatus,pFrontStatus,sizeof(CFrontStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pFrontStatus,pNewFrontStatus,sizeof(CFrontStatus));
	pMem->updateObject(pFrontStatus);
	if (updateIndex) {
	}
	afterUpdate(pFrontStatus);
	if (bNoTransaction) {
		commitUpdate(pFrontStatus,&theOldFrontStatus);
	}
}

void CFrontStatusFactory::update(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pNewFrontStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewFrontStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pFrontStatus,pNewFrontStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CFrontStatusResource::alloc(UPDATE_ACTION,this,pFrontStatus,pNewFrontStatus,updateIndex));
		internalUpdate(pFrontStatus,pNewFrontStatus,updateIndex,false);
	}
}

void CFrontStatusFactory::internalRemove(CFrontStatus *pFrontStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForFrontStatus++;
#endif
	CWriteableFrontStatus theOldFrontStatus;
	beforeRemove(pFrontStatus);
	if (bNoTransaction) {
		forceCopy(&theOldFrontStatus,pFrontStatus,sizeof(CFrontStatus));
	}
	if (runLevel>=0) {
		pFrontIDIndex->removeObject(pFrontStatus);
	}
	pMem->free(pFrontStatus);
	if(bNoTransaction) {
		commitRemove(&theOldFrontStatus);
	}
}

void CFrontStatusFactory::remove(CFrontStatus *pFrontStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pFrontStatus,true);
	}
	else {
		pTransaction->addResource(CFrontStatusResource::alloc(DELETE_ACTION,this,pFrontStatus,NULL));
		internalRemove(pFrontStatus,false);		
	}
}

CFrontStatus* CFrontStatusFactory::addOrUpdate(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pNewFrontStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pFrontStatus == NULL) {
		return add(pNewFrontStatus,pTransaction);
	}
	else {
		update(pFrontStatus,pNewFrontStatus,pTransaction,updateIndex);
		return pFrontStatus;
	}
}

void CFrontStatusFactory::retrieve(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pTargetFrontStatus)
{
	forceCopy(pTargetFrontStatus, pFrontStatus, sizeof(CFrontStatus));
}
	
int CFrontStatusFactory::addActionTrigger(CFrontStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CFrontStatusFactory::removeActionTrigger(CFrontStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CFrontStatusFactory::addCommitTrigger(CFrontStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CFrontStatusFactory::removeCommitTrigger(CFrontStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CFrontStatus *CFrontStatusFactory::getFirst(void)
{
	CFrontStatus *pResult=(CFrontStatus *)(pMem->getFirst());
	return pResult;
}
	
CFrontStatus *CFrontStatusFactory::getNext(void)
{
	CFrontStatus *pResult=(CFrontStatus *)(pMem->getNext());
	return pResult;
}
	
void CFrontStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CFrontStatusFactory::beforeAdd(CWriteableFrontStatus *pFrontStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pFrontStatus);
	}
}
	
void CFrontStatusFactory::afterAdd(CFrontStatus *pFrontStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pFrontStatus);
	}
}

void CFrontStatusFactory::beforeUpdate(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pNewFrontStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pFrontStatus,pNewFrontStatus);
	}
}
	
void CFrontStatusFactory::afterUpdate(CFrontStatus *pFrontStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pFrontStatus);
	}
}
	
void CFrontStatusFactory::beforeRemove(CFrontStatus *pFrontStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pFrontStatus);
	}
}

void CFrontStatusFactory::commitAdd(CFrontStatus *pFrontStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForFrontStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pFrontStatus);
	}
}

void CFrontStatusFactory::commitUpdate(CFrontStatus *pFrontStatus, CWriteableFrontStatus *pOldFrontStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForFrontStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pFrontStatus,pOldFrontStatus);
	}
}
	
void CFrontStatusFactory::commitRemove(CWriteableFrontStatus *pFrontStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForFrontStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pFrontStatus);
	}
}

void CFrontStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForMaxLocalID=0;
int updateWithIndexActionForMaxLocalID=0;
int updateWithoutIndexActionForMaxLocalID=0;
int removeActionForMaxLocalID=0;
int addCommitForMaxLocalID=0;
int updateCommitForMaxLocalID=0;
int removeCommitForMaxLocalID=0;
#endif
void CMaxLocalIDFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=769;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("MaxLocalID.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pUserIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MaxLocalID_UserIDHashIndex",pUserIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MaxLocalID_UserIDHashIndex");
			if(it != pIndexMap->end()) {
				pUserIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pUserIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<CMaxLocalIDActionTrigger *>;
	pCommitTriggers=new vector<CMaxLocalIDCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMaxLocalIDFactory::CMaxLocalIDFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMaxLocalID),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMaxLocalIDFactory::CMaxLocalIDFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMaxLocalID),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMaxLocalIDFactory::~CMaxLocalIDFactory(void)
{
	if (runLevel>=0) {
		if (pUserIDHashIndex!=NULL)
			delete pUserIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMaxLocalIDFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMaxLocalIDFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CMaxLocalIDFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMaxLocalID thisMaxLocalID;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMaxLocalID.readCSV(input,pNames))
		add(&thisMaxLocalID);
	fclose(input);
	delete pNames;
	return 1;
}

int CMaxLocalIDFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MaxLocalID.csv");
	return readCSV(szFileName);
}

int CMaxLocalIDFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMaxLocalID *pMaxLocalID;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMaxLocalID::writeCSVHead(output);
	pMaxLocalID=(CWriteableMaxLocalID *)(pMem->getFirst());
	while (pMaxLocalID!=NULL) {
		if (!pMaxLocalID->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMaxLocalID=(CWriteableMaxLocalID *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMaxLocalIDFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MaxLocalID.csv");
	return writeCSV(szFileName);
}

void CMaxLocalIDFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMaxLocalIDFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMaxLocalID *pMaxLocalID;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMaxLocalIDFactory={       Total Count=%d\n", pMem->getCount());
	pMaxLocalID=(CWriteableMaxLocalID *)(pMem->getFirst());
	while (pMaxLocalID!=NULL) {
		pMaxLocalID->dump(fp,index++);
		pMaxLocalID=(CWriteableMaxLocalID *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMaxLocalIDFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pUserIDHashIndex->removeAll();
	}
}

CMaxLocalID *CMaxLocalIDFactory::internalAdd(CWriteableMaxLocalID *pMaxLocalID, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMaxLocalID++;
#endif
	CMaxLocalID *pTarget;	
	beforeAdd(pMaxLocalID);
	pTarget=(CMaxLocalID *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MaxLocalID in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMaxLocalID, sizeof(CMaxLocalID));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pUserIDHashIndex->addObject(pTarget,pTarget->HashUserID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMaxLocalID *CMaxLocalIDFactory::add(CWriteableMaxLocalID *pMaxLocalID, CTransaction *pTransaction)
{
	pMaxLocalID->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMaxLocalID,true);
	}
	else {
		CMaxLocalID *pNewMaxLocalID;
		pNewMaxLocalID = internalAdd(pMaxLocalID,false);
		pTransaction->addResource(CMaxLocalIDResource::alloc(CREATE_ACTION,this,pNewMaxLocalID,NULL));
		return pNewMaxLocalID;
	}
}

void CMaxLocalIDFactory::internalUpdate(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pNewMaxLocalID, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMaxLocalID++;
	}
	else {
		updateWithoutIndexActionForMaxLocalID++;
	}
#endif
	CWriteableMaxLocalID theOldMaxLocalID;
	beforeUpdate(pMaxLocalID,pNewMaxLocalID);
	if (bNoTransaction) {
		forceCopy(&theOldMaxLocalID,pMaxLocalID,sizeof(CMaxLocalID));
	}
	if (updateIndex) {
	}

	forceCopy(pMaxLocalID,pNewMaxLocalID,sizeof(CMaxLocalID));
	pMem->updateObject(pMaxLocalID);
	if (updateIndex) {
	}
	afterUpdate(pMaxLocalID);
	if (bNoTransaction) {
		commitUpdate(pMaxLocalID,&theOldMaxLocalID);
	}
}

void CMaxLocalIDFactory::update(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pNewMaxLocalID, CTransaction *pTransaction, bool updateIndex)
{
	pNewMaxLocalID->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMaxLocalID,pNewMaxLocalID,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMaxLocalIDResource::alloc(UPDATE_ACTION,this,pMaxLocalID,pNewMaxLocalID,updateIndex));
		internalUpdate(pMaxLocalID,pNewMaxLocalID,updateIndex,false);
	}
}

void CMaxLocalIDFactory::internalRemove(CMaxLocalID *pMaxLocalID, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMaxLocalID++;
#endif
	CWriteableMaxLocalID theOldMaxLocalID;
	beforeRemove(pMaxLocalID);
	if (bNoTransaction) {
		forceCopy(&theOldMaxLocalID,pMaxLocalID,sizeof(CMaxLocalID));
	}
	if (runLevel>=0) {
		pUserIDHashIndex->removeObject(pMaxLocalID,pMaxLocalID->HashUserID);
	}	
	pMem->free(pMaxLocalID);
	if(bNoTransaction) {
		commitRemove(&theOldMaxLocalID);
	}
}

void CMaxLocalIDFactory::remove(CMaxLocalID *pMaxLocalID, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMaxLocalID,true);
	}
	else {
		pTransaction->addResource(CMaxLocalIDResource::alloc(DELETE_ACTION,this,pMaxLocalID,NULL));
		internalRemove(pMaxLocalID,false);		
	}
}

CMaxLocalID* CMaxLocalIDFactory::addOrUpdate(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pNewMaxLocalID, CTransaction *pTransaction, bool updateIndex)
{
	if(pMaxLocalID == NULL) {
		return add(pNewMaxLocalID,pTransaction);
	}
	else {
		update(pMaxLocalID,pNewMaxLocalID,pTransaction,updateIndex);
		return pMaxLocalID;
	}
}

void CMaxLocalIDFactory::retrieve(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pTargetMaxLocalID)
{
	forceCopy(pTargetMaxLocalID, pMaxLocalID, sizeof(CMaxLocalID));
}
	
int CMaxLocalIDFactory::addActionTrigger(CMaxLocalIDActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMaxLocalIDFactory::removeActionTrigger(CMaxLocalIDActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMaxLocalIDFactory::addCommitTrigger(CMaxLocalIDCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMaxLocalIDFactory::removeCommitTrigger(CMaxLocalIDCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMaxLocalID *CMaxLocalIDFactory::getFirst(void)
{
	CMaxLocalID *pResult=(CMaxLocalID *)(pMem->getFirst());
	return pResult;
}
	
CMaxLocalID *CMaxLocalIDFactory::getNext(void)
{
	CMaxLocalID *pResult=(CMaxLocalID *)(pMem->getNext());
	return pResult;
}
	
void CMaxLocalIDFactory::endGet(void)
{
	pMem->endGet();
}

void CMaxLocalIDFactory::beforeAdd(CWriteableMaxLocalID *pMaxLocalID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMaxLocalID);
	}
}
	
void CMaxLocalIDFactory::afterAdd(CMaxLocalID *pMaxLocalID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMaxLocalID);
	}
}

void CMaxLocalIDFactory::beforeUpdate(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pNewMaxLocalID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMaxLocalID,pNewMaxLocalID);
	}
}
	
void CMaxLocalIDFactory::afterUpdate(CMaxLocalID *pMaxLocalID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMaxLocalID);
	}
}
	
void CMaxLocalIDFactory::beforeRemove(CMaxLocalID *pMaxLocalID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMaxLocalID);
	}
}

void CMaxLocalIDFactory::commitAdd(CMaxLocalID *pMaxLocalID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMaxLocalID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMaxLocalID);
	}
}

void CMaxLocalIDFactory::commitUpdate(CMaxLocalID *pMaxLocalID, CWriteableMaxLocalID *pOldMaxLocalID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMaxLocalID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMaxLocalID,pOldMaxLocalID);
	}
}
	
void CMaxLocalIDFactory::commitRemove(CWriteableMaxLocalID *pMaxLocalID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMaxLocalID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMaxLocalID);
	}
}

void CMaxLocalIDFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForBulletinIDIndexinBulletin(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForBulletin=0;
int updateWithIndexActionForBulletin=0;
int updateWithoutIndexActionForBulletin=0;
int removeActionForBulletin=0;
int addCommitForBulletin=0;
int updateCommitForBulletin=0;
int removeCommitForBulletin=0;
#endif
void CBulletinFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pBulletinIDIndex=new CAVLTree(maxUnit,compareForBulletinIDIndexinBulletin,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Bulletin_BulletinIDIndex",pBulletinIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Bulletin_BulletinIDIndex");
			if(it != pIndexMap->end()) {
				pBulletinIDIndex=new CAVLTree(maxUnit,compareForBulletinIDIndexinBulletin,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pBulletinIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByBulletinID=NULL;
	pActionTriggers=new vector<CBulletinActionTrigger *>;
	pCommitTriggers=new vector<CBulletinCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CBulletinFactory::CBulletinFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBulletin),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CBulletinFactory::CBulletinFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBulletin),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CBulletinFactory::~CBulletinFactory(void)
{
	if (runLevel>=0) {
		if (pBulletinIDIndex!=NULL)
			delete pBulletinIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CBulletinFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CBulletinFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pBulletinIDIndex->output(pLogger,indent+1);
	}
}

int CBulletinFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableBulletin thisBulletin;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisBulletin.readCSV(input,pNames))
		add(&thisBulletin);
	fclose(input);
	delete pNames;
	return 1;
}

int CBulletinFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Bulletin.csv");
	return readCSV(szFileName);
}

int CBulletinFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableBulletin *pBulletin;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableBulletin::writeCSVHead(output);
	pBulletin=(CWriteableBulletin *)(pMem->getFirst());
	while (pBulletin!=NULL) {
		if (!pBulletin->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pBulletin=(CWriteableBulletin *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CBulletinFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Bulletin.csv");
	return writeCSV(szFileName);
}

void CBulletinFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CBulletinFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableBulletin *pBulletin;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CBulletinFactory={       Total Count=%d\n", pMem->getCount());
	pBulletin=(CWriteableBulletin *)(pMem->getFirst());
	while (pBulletin!=NULL) {
		pBulletin->dump(fp,index++);
		pBulletin=(CWriteableBulletin *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CBulletinFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pBulletinIDIndex->removeAll();
	}
}

CBulletin *CBulletinFactory::internalAdd(CWriteableBulletin *pBulletin, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForBulletin++;
#endif
	CBulletin *pTarget;	
	beforeAdd(pBulletin);
	pTarget=(CBulletin *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Bulletin in memory database");
		return NULL;
	}
	forceCopy(pTarget, pBulletin, sizeof(CBulletin));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pBulletinIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CBulletin *CBulletinFactory::add(CWriteableBulletin *pBulletin, CTransaction *pTransaction)
{
	pBulletin->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pBulletin,true);
	}
	else {
		CBulletin *pNewBulletin;
		pNewBulletin = internalAdd(pBulletin,false);
		pTransaction->addResource(CBulletinResource::alloc(CREATE_ACTION,this,pNewBulletin,NULL));
		return pNewBulletin;
	}
}

void CBulletinFactory::internalUpdate(CBulletin *pBulletin, CWriteableBulletin *pNewBulletin, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForBulletin++;
	}
	else {
		updateWithoutIndexActionForBulletin++;
	}
#endif
	CWriteableBulletin theOldBulletin;
	beforeUpdate(pBulletin,pNewBulletin);
	if (bNoTransaction) {
		forceCopy(&theOldBulletin,pBulletin,sizeof(CBulletin));
	}
	if (updateIndex) {
	}

	forceCopy(pBulletin,pNewBulletin,sizeof(CBulletin));
	pMem->updateObject(pBulletin);
	if (updateIndex) {
	}
	afterUpdate(pBulletin);
	if (bNoTransaction) {
		commitUpdate(pBulletin,&theOldBulletin);
	}
}

void CBulletinFactory::update(CBulletin *pBulletin, CWriteableBulletin *pNewBulletin, CTransaction *pTransaction, bool updateIndex)
{
	pNewBulletin->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pBulletin,pNewBulletin,updateIndex,true);
	}
	else {
		pTransaction->addResource(CBulletinResource::alloc(UPDATE_ACTION,this,pBulletin,pNewBulletin,updateIndex));
		internalUpdate(pBulletin,pNewBulletin,updateIndex,false);
	}
}

void CBulletinFactory::internalRemove(CBulletin *pBulletin, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForBulletin++;
#endif
	CWriteableBulletin theOldBulletin;
	beforeRemove(pBulletin);
	if (bNoTransaction) {
		forceCopy(&theOldBulletin,pBulletin,sizeof(CBulletin));
	}
	if (runLevel>=0) {
		pBulletinIDIndex->removeObject(pBulletin);
	}
	pMem->free(pBulletin);
	if(bNoTransaction) {
		commitRemove(&theOldBulletin);
	}
}

void CBulletinFactory::remove(CBulletin *pBulletin, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pBulletin,true);
	}
	else {
		pTransaction->addResource(CBulletinResource::alloc(DELETE_ACTION,this,pBulletin,NULL));
		internalRemove(pBulletin,false);		
	}
}

CBulletin* CBulletinFactory::addOrUpdate(CBulletin *pBulletin, CWriteableBulletin *pNewBulletin, CTransaction *pTransaction, bool updateIndex)
{
	if(pBulletin == NULL) {
		return add(pNewBulletin,pTransaction);
	}
	else {
		update(pBulletin,pNewBulletin,pTransaction,updateIndex);
		return pBulletin;
	}
}

void CBulletinFactory::retrieve(CBulletin *pBulletin, CWriteableBulletin *pTargetBulletin)
{
	forceCopy(pTargetBulletin, pBulletin, sizeof(CBulletin));
}
	
int CBulletinFactory::addActionTrigger(CBulletinActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CBulletinFactory::removeActionTrigger(CBulletinActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CBulletinFactory::addCommitTrigger(CBulletinCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CBulletinFactory::removeCommitTrigger(CBulletinCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CBulletin *CBulletinFactory::getFirst(void)
{
	CBulletin *pResult=(CBulletin *)(pMem->getFirst());
	return pResult;
}
	
CBulletin *CBulletinFactory::getNext(void)
{
	CBulletin *pResult=(CBulletin *)(pMem->getNext());
	return pResult;
}
	
void CBulletinFactory::endGet(void)
{
	pMem->endGet();
}

void CBulletinFactory::beforeAdd(CWriteableBulletin *pBulletin)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pBulletin);
	}
}
	
void CBulletinFactory::afterAdd(CBulletin *pBulletin)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pBulletin);
	}
}

void CBulletinFactory::beforeUpdate(CBulletin *pBulletin, CWriteableBulletin *pNewBulletin)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pBulletin,pNewBulletin);
	}
}
	
void CBulletinFactory::afterUpdate(CBulletin *pBulletin)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pBulletin);
	}
}
	
void CBulletinFactory::beforeRemove(CBulletin *pBulletin)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pBulletin);
	}
}

void CBulletinFactory::commitAdd(CBulletin *pBulletin)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForBulletin++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pBulletin);
	}
}

void CBulletinFactory::commitUpdate(CBulletin *pBulletin, CWriteableBulletin *pOldBulletin)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForBulletin++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pBulletin,pOldBulletin);
	}
}
	
void CBulletinFactory::commitRemove(CWriteableBulletin *pBulletin)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForBulletin++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pBulletin);
	}
}

void CBulletinFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinMarketDataModify(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketDataModify=0;
int updateWithIndexActionForMarketDataModify=0;
int updateWithoutIndexActionForMarketDataModify=0;
int removeActionForMarketDataModify=0;
int addCommitForMarketDataModify=0;
int updateCommitForMarketDataModify=0;
int removeCommitForMarketDataModify=0;
#endif
void CMarketDataModifyFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinMarketDataModify,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketDataModify_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketDataModify_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinMarketDataModify,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CMarketDataModifyActionTrigger *>;
	pCommitTriggers=new vector<CMarketDataModifyCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketDataModifyFactory::CMarketDataModifyFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataModify),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketDataModifyFactory::CMarketDataModifyFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketDataModify),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketDataModifyFactory::~CMarketDataModifyFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketDataModifyFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketDataModifyFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CMarketDataModifyFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketDataModify thisMarketDataModify;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketDataModify.readCSV(input,pNames))
		add(&thisMarketDataModify);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketDataModifyFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketDataModify.csv");
	return readCSV(szFileName);
}

int CMarketDataModifyFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketDataModify *pMarketDataModify;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketDataModify::writeCSVHead(output);
	pMarketDataModify=(CWriteableMarketDataModify *)(pMem->getFirst());
	while (pMarketDataModify!=NULL) {
		if (!pMarketDataModify->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketDataModify=(CWriteableMarketDataModify *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketDataModifyFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketDataModify.csv");
	return writeCSV(szFileName);
}

void CMarketDataModifyFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketDataModifyFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketDataModify *pMarketDataModify;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketDataModifyFactory={       Total Count=%d\n", pMem->getCount());
	pMarketDataModify=(CWriteableMarketDataModify *)(pMem->getFirst());
	while (pMarketDataModify!=NULL) {
		pMarketDataModify->dump(fp,index++);
		pMarketDataModify=(CWriteableMarketDataModify *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketDataModifyFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CMarketDataModify *CMarketDataModifyFactory::internalAdd(CWriteableMarketDataModify *pMarketDataModify, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketDataModify++;
#endif
	CMarketDataModify *pTarget;	
	beforeAdd(pMarketDataModify);
	pTarget=(CMarketDataModify *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketDataModify in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketDataModify, sizeof(CMarketDataModify));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketDataModify *CMarketDataModifyFactory::add(CWriteableMarketDataModify *pMarketDataModify, CTransaction *pTransaction)
{
	pMarketDataModify->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketDataModify,true);
	}
	else {
		CMarketDataModify *pNewMarketDataModify;
		pNewMarketDataModify = internalAdd(pMarketDataModify,false);
		pTransaction->addResource(CMarketDataModifyResource::alloc(CREATE_ACTION,this,pNewMarketDataModify,NULL));
		return pNewMarketDataModify;
	}
}

void CMarketDataModifyFactory::internalUpdate(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pNewMarketDataModify, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketDataModify++;
	}
	else {
		updateWithoutIndexActionForMarketDataModify++;
	}
#endif
	CWriteableMarketDataModify theOldMarketDataModify;
	beforeUpdate(pMarketDataModify,pNewMarketDataModify);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataModify,pMarketDataModify,sizeof(CMarketDataModify));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketDataModify,pNewMarketDataModify,sizeof(CMarketDataModify));
	pMem->updateObject(pMarketDataModify);
	if (updateIndex) {
	}
	afterUpdate(pMarketDataModify);
	if (bNoTransaction) {
		commitUpdate(pMarketDataModify,&theOldMarketDataModify);
	}
}

void CMarketDataModifyFactory::update(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pNewMarketDataModify, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketDataModify->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketDataModify,pNewMarketDataModify,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketDataModifyResource::alloc(UPDATE_ACTION,this,pMarketDataModify,pNewMarketDataModify,updateIndex));
		internalUpdate(pMarketDataModify,pNewMarketDataModify,updateIndex,false);
	}
}

void CMarketDataModifyFactory::internalRemove(CMarketDataModify *pMarketDataModify, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketDataModify++;
#endif
	CWriteableMarketDataModify theOldMarketDataModify;
	beforeRemove(pMarketDataModify);
	if (bNoTransaction) {
		forceCopy(&theOldMarketDataModify,pMarketDataModify,sizeof(CMarketDataModify));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pMarketDataModify);
	}
	pMem->free(pMarketDataModify);
	if(bNoTransaction) {
		commitRemove(&theOldMarketDataModify);
	}
}

void CMarketDataModifyFactory::remove(CMarketDataModify *pMarketDataModify, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketDataModify,true);
	}
	else {
		pTransaction->addResource(CMarketDataModifyResource::alloc(DELETE_ACTION,this,pMarketDataModify,NULL));
		internalRemove(pMarketDataModify,false);		
	}
}

CMarketDataModify* CMarketDataModifyFactory::addOrUpdate(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pNewMarketDataModify, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketDataModify == NULL) {
		return add(pNewMarketDataModify,pTransaction);
	}
	else {
		update(pMarketDataModify,pNewMarketDataModify,pTransaction,updateIndex);
		return pMarketDataModify;
	}
}

void CMarketDataModifyFactory::retrieve(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pTargetMarketDataModify)
{
	forceCopy(pTargetMarketDataModify, pMarketDataModify, sizeof(CMarketDataModify));
}
	
int CMarketDataModifyFactory::addActionTrigger(CMarketDataModifyActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketDataModifyFactory::removeActionTrigger(CMarketDataModifyActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketDataModifyFactory::addCommitTrigger(CMarketDataModifyCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketDataModifyFactory::removeCommitTrigger(CMarketDataModifyCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketDataModify *CMarketDataModifyFactory::getFirst(void)
{
	CMarketDataModify *pResult=(CMarketDataModify *)(pMem->getFirst());
	return pResult;
}
	
CMarketDataModify *CMarketDataModifyFactory::getNext(void)
{
	CMarketDataModify *pResult=(CMarketDataModify *)(pMem->getNext());
	return pResult;
}
	
void CMarketDataModifyFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketDataModifyFactory::beforeAdd(CWriteableMarketDataModify *pMarketDataModify)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketDataModify);
	}
}
	
void CMarketDataModifyFactory::afterAdd(CMarketDataModify *pMarketDataModify)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketDataModify);
	}
}

void CMarketDataModifyFactory::beforeUpdate(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pNewMarketDataModify)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketDataModify,pNewMarketDataModify);
	}
}
	
void CMarketDataModifyFactory::afterUpdate(CMarketDataModify *pMarketDataModify)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketDataModify);
	}
}
	
void CMarketDataModifyFactory::beforeRemove(CMarketDataModify *pMarketDataModify)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketDataModify);
	}
}

void CMarketDataModifyFactory::commitAdd(CMarketDataModify *pMarketDataModify)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketDataModify++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketDataModify);
	}
}

void CMarketDataModifyFactory::commitUpdate(CMarketDataModify *pMarketDataModify, CWriteableMarketDataModify *pOldMarketDataModify)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketDataModify++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketDataModify,pOldMarketDataModify);
	}
}
	
void CMarketDataModifyFactory::commitRemove(CWriteableMarketDataModify *pMarketDataModify)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketDataModify++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketDataModify);
	}
}

void CMarketDataModifyFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CMarketDataModifyFactory::linkAllDepthMarketData(CDepthMarketDataFactory *pFactory)
{
	CMarketDataModify *pMarketDataModify;
	pMarketDataModify=getFirst();
	while (pMarketDataModify != NULL) {
		pMarketDataModify->linkDepthMarketData(pFactory);
		pMarketDataModify=getNext();
	}
	endGet();
}

extern int compareForInstrumentIDIndexinDepthMarketData(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForDepthMarketData=0;
int updateWithIndexActionForDepthMarketData=0;
int updateWithoutIndexActionForDepthMarketData=0;
int removeActionForDepthMarketData=0;
int addCommitForDepthMarketData=0;
int updateCommitForDepthMarketData=0;
int removeCommitForDepthMarketData=0;
#endif
void CDepthMarketDataFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinDepthMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("DepthMarketData_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("DepthMarketData_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinDepthMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CDepthMarketDataActionTrigger *>;
	pCommitTriggers=new vector<CDepthMarketDataCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CDepthMarketDataFactory::CDepthMarketDataFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDepthMarketData),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CDepthMarketDataFactory::CDepthMarketDataFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CDepthMarketData),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CDepthMarketDataFactory::~CDepthMarketDataFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CDepthMarketDataFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CDepthMarketDataFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CDepthMarketDataFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableDepthMarketData thisDepthMarketData;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisDepthMarketData.readCSV(input,pNames))
		add(&thisDepthMarketData);
	fclose(input);
	delete pNames;
	return 1;
}

int CDepthMarketDataFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "DepthMarketData.csv");
	return readCSV(szFileName);
}

int CDepthMarketDataFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableDepthMarketData *pDepthMarketData;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableDepthMarketData::writeCSVHead(output);
	pDepthMarketData=(CWriteableDepthMarketData *)(pMem->getFirst());
	while (pDepthMarketData!=NULL) {
		if (!pDepthMarketData->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pDepthMarketData=(CWriteableDepthMarketData *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CDepthMarketDataFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "DepthMarketData.csv");
	return writeCSV(szFileName);
}

void CDepthMarketDataFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CDepthMarketDataFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableDepthMarketData *pDepthMarketData;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CDepthMarketDataFactory={       Total Count=%d\n", pMem->getCount());
	pDepthMarketData=(CWriteableDepthMarketData *)(pMem->getFirst());
	while (pDepthMarketData!=NULL) {
		pDepthMarketData->dump(fp,index++);
		pDepthMarketData=(CWriteableDepthMarketData *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CDepthMarketDataFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CDepthMarketData *CDepthMarketDataFactory::internalAdd(CWriteableDepthMarketData *pDepthMarketData, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForDepthMarketData++;
#endif
	CDepthMarketData *pTarget;	
	beforeAdd(pDepthMarketData);
	pTarget=(CDepthMarketData *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough DepthMarketData in memory database");
		return NULL;
	}
	forceCopy(pTarget, pDepthMarketData, sizeof(CDepthMarketData));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CDepthMarketData *CDepthMarketDataFactory::add(CWriteableDepthMarketData *pDepthMarketData, CTransaction *pTransaction)
{
	pDepthMarketData->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pDepthMarketData,true);
	}
	else {
		CDepthMarketData *pNewDepthMarketData;
		pNewDepthMarketData = internalAdd(pDepthMarketData,false);
		pTransaction->addResource(CDepthMarketDataResource::alloc(CREATE_ACTION,this,pNewDepthMarketData,NULL));
		return pNewDepthMarketData;
	}
}

void CDepthMarketDataFactory::internalUpdate(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pNewDepthMarketData, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForDepthMarketData++;
	}
	else {
		updateWithoutIndexActionForDepthMarketData++;
	}
#endif
	CWriteableDepthMarketData theOldDepthMarketData;
	beforeUpdate(pDepthMarketData,pNewDepthMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldDepthMarketData,pDepthMarketData,sizeof(CDepthMarketData));
	}
	if (updateIndex) {
	}

	forceCopy(pDepthMarketData,pNewDepthMarketData,sizeof(CDepthMarketData));
	pMem->updateObject(pDepthMarketData);
	if (updateIndex) {
	}
	afterUpdate(pDepthMarketData);
	if (bNoTransaction) {
		commitUpdate(pDepthMarketData,&theOldDepthMarketData);
	}
}

void CDepthMarketDataFactory::update(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pNewDepthMarketData, CTransaction *pTransaction, bool updateIndex)
{
	pNewDepthMarketData->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pDepthMarketData,pNewDepthMarketData,updateIndex,true);
	}
	else {
		pTransaction->addResource(CDepthMarketDataResource::alloc(UPDATE_ACTION,this,pDepthMarketData,pNewDepthMarketData,updateIndex));
		internalUpdate(pDepthMarketData,pNewDepthMarketData,updateIndex,false);
	}
}

void CDepthMarketDataFactory::internalRemove(CDepthMarketData *pDepthMarketData, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForDepthMarketData++;
#endif
	CWriteableDepthMarketData theOldDepthMarketData;
	beforeRemove(pDepthMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldDepthMarketData,pDepthMarketData,sizeof(CDepthMarketData));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pDepthMarketData);
	}
	pMem->free(pDepthMarketData);
	if(bNoTransaction) {
		commitRemove(&theOldDepthMarketData);
	}
}

void CDepthMarketDataFactory::remove(CDepthMarketData *pDepthMarketData, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pDepthMarketData,true);
	}
	else {
		pTransaction->addResource(CDepthMarketDataResource::alloc(DELETE_ACTION,this,pDepthMarketData,NULL));
		internalRemove(pDepthMarketData,false);		
	}
}

CDepthMarketData* CDepthMarketDataFactory::addOrUpdate(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pNewDepthMarketData, CTransaction *pTransaction, bool updateIndex)
{
	if(pDepthMarketData == NULL) {
		return add(pNewDepthMarketData,pTransaction);
	}
	else {
		update(pDepthMarketData,pNewDepthMarketData,pTransaction,updateIndex);
		return pDepthMarketData;
	}
}

void CDepthMarketDataFactory::retrieve(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pTargetDepthMarketData)
{
	forceCopy(pTargetDepthMarketData, pDepthMarketData, sizeof(CDepthMarketData));
}
	
int CDepthMarketDataFactory::addActionTrigger(CDepthMarketDataActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CDepthMarketDataFactory::removeActionTrigger(CDepthMarketDataActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CDepthMarketDataFactory::addCommitTrigger(CDepthMarketDataCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CDepthMarketDataFactory::removeCommitTrigger(CDepthMarketDataCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CDepthMarketData *CDepthMarketDataFactory::getFirst(void)
{
	CDepthMarketData *pResult=(CDepthMarketData *)(pMem->getFirst());
	return pResult;
}
	
CDepthMarketData *CDepthMarketDataFactory::getNext(void)
{
	CDepthMarketData *pResult=(CDepthMarketData *)(pMem->getNext());
	return pResult;
}
	
void CDepthMarketDataFactory::endGet(void)
{
	pMem->endGet();
}

void CDepthMarketDataFactory::beforeAdd(CWriteableDepthMarketData *pDepthMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pDepthMarketData);
	}
}
	
void CDepthMarketDataFactory::afterAdd(CDepthMarketData *pDepthMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pDepthMarketData);
	}
}

void CDepthMarketDataFactory::beforeUpdate(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pNewDepthMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pDepthMarketData,pNewDepthMarketData);
	}
}
	
void CDepthMarketDataFactory::afterUpdate(CDepthMarketData *pDepthMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pDepthMarketData);
	}
}
	
void CDepthMarketDataFactory::beforeRemove(CDepthMarketData *pDepthMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pDepthMarketData);
	}
}

void CDepthMarketDataFactory::commitAdd(CDepthMarketData *pDepthMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForDepthMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pDepthMarketData);
	}
}

void CDepthMarketDataFactory::commitUpdate(CDepthMarketData *pDepthMarketData, CWriteableDepthMarketData *pOldDepthMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForDepthMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pDepthMarketData,pOldDepthMarketData);
	}
}
	
void CDepthMarketDataFactory::commitRemove(CWriteableDepthMarketData *pDepthMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForDepthMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pDepthMarketData);
	}
}

void CDepthMarketDataFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CDepthMarketDataFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CDepthMarketData *pDepthMarketData;
	pDepthMarketData=getFirst();
	while (pDepthMarketData != NULL) {
		pDepthMarketData->linkInstrument(pFactory);
		pDepthMarketData=getNext();
	}
	endGet();
}

extern int compareForTopicAndInstrumentIndexinTopicMarketData(const void *pV1, const void *pV2);
extern int compareForInstrumentIndexinTopicMarketData(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForTopicMarketData=0;
int updateWithIndexActionForTopicMarketData=0;
int updateWithoutIndexActionForTopicMarketData=0;
int removeActionForTopicMarketData=0;
int addCommitForTopicMarketData=0;
int updateCommitForTopicMarketData=0;
int removeCommitForTopicMarketData=0;
#endif
void CTopicMarketDataFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pTopicAndInstrumentIndex=new CAVLTree(maxUnit,compareForTopicAndInstrumentIndexinTopicMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("TopicMarketData_TopicAndInstrumentIndex",pTopicAndInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("TopicMarketData_TopicAndInstrumentIndex");
			if(it != pIndexMap->end()) {
				pTopicAndInstrumentIndex=new CAVLTree(maxUnit,compareForTopicAndInstrumentIndexinTopicMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pTopicAndInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinTopicMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("TopicMarketData_InstrumentIndex",pInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("TopicMarketData_InstrumentIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinTopicMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTopicID=NULL;
	pLastFoundInSearchByInstrumentID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CTopicMarketDataActionTrigger *>;
	pCommitTriggers=new vector<CTopicMarketDataCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CTopicMarketDataFactory::CTopicMarketDataFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTopicMarketData),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CTopicMarketDataFactory::CTopicMarketDataFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTopicMarketData),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CTopicMarketDataFactory::~CTopicMarketDataFactory(void)
{
	if (runLevel>=0) {
		if (pTopicAndInstrumentIndex!=NULL)
			delete pTopicAndInstrumentIndex;
	}
	if (runLevel>=0) {
		if (pInstrumentIndex!=NULL)
			delete pInstrumentIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CTopicMarketDataFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CTopicMarketDataFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pTopicAndInstrumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pInstrumentIndex->output(pLogger,indent+1);
	}
}

int CTopicMarketDataFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableTopicMarketData thisTopicMarketData;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisTopicMarketData.readCSV(input,pNames))
		add(&thisTopicMarketData);
	fclose(input);
	delete pNames;
	return 1;
}

int CTopicMarketDataFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "TopicMarketData.csv");
	return readCSV(szFileName);
}

int CTopicMarketDataFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableTopicMarketData *pTopicMarketData;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableTopicMarketData::writeCSVHead(output);
	pTopicMarketData=(CWriteableTopicMarketData *)(pMem->getFirst());
	while (pTopicMarketData!=NULL) {
		if (!pTopicMarketData->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pTopicMarketData=(CWriteableTopicMarketData *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CTopicMarketDataFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "TopicMarketData.csv");
	return writeCSV(szFileName);
}

void CTopicMarketDataFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CTopicMarketDataFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableTopicMarketData *pTopicMarketData;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CTopicMarketDataFactory={       Total Count=%d\n", pMem->getCount());
	pTopicMarketData=(CWriteableTopicMarketData *)(pMem->getFirst());
	while (pTopicMarketData!=NULL) {
		pTopicMarketData->dump(fp,index++);
		pTopicMarketData=(CWriteableTopicMarketData *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CTopicMarketDataFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pTopicAndInstrumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pInstrumentIndex->removeAll();
	}
}

CTopicMarketData *CTopicMarketDataFactory::internalAdd(CWriteableTopicMarketData *pTopicMarketData, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForTopicMarketData++;
#endif
	CTopicMarketData *pTarget;	
	beforeAdd(pTopicMarketData);
	pTarget=(CTopicMarketData *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough TopicMarketData in memory database");
		return NULL;
	}
	forceCopy(pTarget, pTopicMarketData, sizeof(CTopicMarketData));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pTopicAndInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pInstrumentIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CTopicMarketData *CTopicMarketDataFactory::add(CWriteableTopicMarketData *pTopicMarketData, CTransaction *pTransaction)
{
	pTopicMarketData->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pTopicMarketData,true);
	}
	else {
		CTopicMarketData *pNewTopicMarketData;
		pNewTopicMarketData = internalAdd(pTopicMarketData,false);
		pTransaction->addResource(CTopicMarketDataResource::alloc(CREATE_ACTION,this,pNewTopicMarketData,NULL));
		return pNewTopicMarketData;
	}
}

void CTopicMarketDataFactory::internalUpdate(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pNewTopicMarketData, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForTopicMarketData++;
	}
	else {
		updateWithoutIndexActionForTopicMarketData++;
	}
#endif
	CWriteableTopicMarketData theOldTopicMarketData;
	beforeUpdate(pTopicMarketData,pNewTopicMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldTopicMarketData,pTopicMarketData,sizeof(CTopicMarketData));
	}
	if (updateIndex) {
	}

	forceCopy(pTopicMarketData,pNewTopicMarketData,sizeof(CTopicMarketData));
	pMem->updateObject(pTopicMarketData);
	if (updateIndex) {
	}
	afterUpdate(pTopicMarketData);
	if (bNoTransaction) {
		commitUpdate(pTopicMarketData,&theOldTopicMarketData);
	}
}

void CTopicMarketDataFactory::update(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pNewTopicMarketData, CTransaction *pTransaction, bool updateIndex)
{
	pNewTopicMarketData->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pTopicMarketData,pNewTopicMarketData,updateIndex,true);
	}
	else {
		pTransaction->addResource(CTopicMarketDataResource::alloc(UPDATE_ACTION,this,pTopicMarketData,pNewTopicMarketData,updateIndex));
		internalUpdate(pTopicMarketData,pNewTopicMarketData,updateIndex,false);
	}
}

void CTopicMarketDataFactory::internalRemove(CTopicMarketData *pTopicMarketData, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForTopicMarketData++;
#endif
	CWriteableTopicMarketData theOldTopicMarketData;
	beforeRemove(pTopicMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldTopicMarketData,pTopicMarketData,sizeof(CTopicMarketData));
	}
	if (runLevel>=0) {
		pTopicAndInstrumentIndex->removeObject(pTopicMarketData);
	}
	if (runLevel>=0) {
		pInstrumentIndex->removeObject(pTopicMarketData);
	}
	pMem->free(pTopicMarketData);
	if(bNoTransaction) {
		commitRemove(&theOldTopicMarketData);
	}
}

void CTopicMarketDataFactory::remove(CTopicMarketData *pTopicMarketData, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pTopicMarketData,true);
	}
	else {
		pTransaction->addResource(CTopicMarketDataResource::alloc(DELETE_ACTION,this,pTopicMarketData,NULL));
		internalRemove(pTopicMarketData,false);		
	}
}

CTopicMarketData* CTopicMarketDataFactory::addOrUpdate(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pNewTopicMarketData, CTransaction *pTransaction, bool updateIndex)
{
	if(pTopicMarketData == NULL) {
		return add(pNewTopicMarketData,pTransaction);
	}
	else {
		update(pTopicMarketData,pNewTopicMarketData,pTransaction,updateIndex);
		return pTopicMarketData;
	}
}

void CTopicMarketDataFactory::retrieve(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pTargetTopicMarketData)
{
	forceCopy(pTargetTopicMarketData, pTopicMarketData, sizeof(CTopicMarketData));
}
	
int CTopicMarketDataFactory::addActionTrigger(CTopicMarketDataActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CTopicMarketDataFactory::removeActionTrigger(CTopicMarketDataActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CTopicMarketDataFactory::addCommitTrigger(CTopicMarketDataCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CTopicMarketDataFactory::removeCommitTrigger(CTopicMarketDataCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CTopicMarketData *CTopicMarketDataFactory::getFirst(void)
{
	CTopicMarketData *pResult=(CTopicMarketData *)(pMem->getFirst());
	return pResult;
}
	
CTopicMarketData *CTopicMarketDataFactory::getNext(void)
{
	CTopicMarketData *pResult=(CTopicMarketData *)(pMem->getNext());
	return pResult;
}
	
void CTopicMarketDataFactory::endGet(void)
{
	pMem->endGet();
}

void CTopicMarketDataFactory::beforeAdd(CWriteableTopicMarketData *pTopicMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pTopicMarketData);
	}
}
	
void CTopicMarketDataFactory::afterAdd(CTopicMarketData *pTopicMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pTopicMarketData);
	}
}

void CTopicMarketDataFactory::beforeUpdate(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pNewTopicMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pTopicMarketData,pNewTopicMarketData);
	}
}
	
void CTopicMarketDataFactory::afterUpdate(CTopicMarketData *pTopicMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pTopicMarketData);
	}
}
	
void CTopicMarketDataFactory::beforeRemove(CTopicMarketData *pTopicMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pTopicMarketData);
	}
}

void CTopicMarketDataFactory::commitAdd(CTopicMarketData *pTopicMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForTopicMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pTopicMarketData);
	}
}

void CTopicMarketDataFactory::commitUpdate(CTopicMarketData *pTopicMarketData, CWriteableTopicMarketData *pOldTopicMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForTopicMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pTopicMarketData,pOldTopicMarketData);
	}
}
	
void CTopicMarketDataFactory::commitRemove(CWriteableTopicMarketData *pTopicMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForTopicMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pTopicMarketData);
	}
}

void CTopicMarketDataFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForTopicAndVersioninTopicMarketDataVersion(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForTopicMarketDataVersion=0;
int updateWithIndexActionForTopicMarketDataVersion=0;
int updateWithoutIndexActionForTopicMarketDataVersion=0;
int removeActionForTopicMarketDataVersion=0;
int addCommitForTopicMarketDataVersion=0;
int updateCommitForTopicMarketDataVersion=0;
int removeCommitForTopicMarketDataVersion=0;
#endif
void CTopicMarketDataVersionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pTopicAndVersion=new CAVLTree(maxUnit,compareForTopicAndVersioninTopicMarketDataVersion,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("TopicMarketDataVersion_TopicAndVersion",pTopicAndVersion->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("TopicMarketDataVersion_TopicAndVersion");
			if(it != pIndexMap->end()) {
				pTopicAndVersion=new CAVLTree(maxUnit,compareForTopicAndVersioninTopicMarketDataVersion,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pTopicAndVersion==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTopicAndVersion=NULL;
	pActionTriggers=new vector<CTopicMarketDataVersionActionTrigger *>;
	pCommitTriggers=new vector<CTopicMarketDataVersionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CTopicMarketDataVersionFactory::CTopicMarketDataVersionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTopicMarketDataVersion),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CTopicMarketDataVersionFactory::CTopicMarketDataVersionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTopicMarketDataVersion),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CTopicMarketDataVersionFactory::~CTopicMarketDataVersionFactory(void)
{
	if (runLevel>=0) {
		if (pTopicAndVersion!=NULL)
			delete pTopicAndVersion;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CTopicMarketDataVersionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CTopicMarketDataVersionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pTopicAndVersion->output(pLogger,indent+1);
	}
}

int CTopicMarketDataVersionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableTopicMarketDataVersion thisTopicMarketDataVersion;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisTopicMarketDataVersion.readCSV(input,pNames))
		add(&thisTopicMarketDataVersion);
	fclose(input);
	delete pNames;
	return 1;
}

int CTopicMarketDataVersionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "TopicMarketDataVersion.csv");
	return readCSV(szFileName);
}

int CTopicMarketDataVersionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableTopicMarketDataVersion *pTopicMarketDataVersion;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableTopicMarketDataVersion::writeCSVHead(output);
	pTopicMarketDataVersion=(CWriteableTopicMarketDataVersion *)(pMem->getFirst());
	while (pTopicMarketDataVersion!=NULL) {
		if (!pTopicMarketDataVersion->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pTopicMarketDataVersion=(CWriteableTopicMarketDataVersion *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CTopicMarketDataVersionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "TopicMarketDataVersion.csv");
	return writeCSV(szFileName);
}

void CTopicMarketDataVersionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CTopicMarketDataVersionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableTopicMarketDataVersion *pTopicMarketDataVersion;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CTopicMarketDataVersionFactory={       Total Count=%d\n", pMem->getCount());
	pTopicMarketDataVersion=(CWriteableTopicMarketDataVersion *)(pMem->getFirst());
	while (pTopicMarketDataVersion!=NULL) {
		pTopicMarketDataVersion->dump(fp,index++);
		pTopicMarketDataVersion=(CWriteableTopicMarketDataVersion *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CTopicMarketDataVersionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pTopicAndVersion->removeAll();
	}
}

CTopicMarketDataVersion *CTopicMarketDataVersionFactory::internalAdd(CWriteableTopicMarketDataVersion *pTopicMarketDataVersion, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForTopicMarketDataVersion++;
#endif
	CTopicMarketDataVersion *pTarget;	
	beforeAdd(pTopicMarketDataVersion);
	pTarget=(CTopicMarketDataVersion *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough TopicMarketDataVersion in memory database");
		return NULL;
	}
	forceCopy(pTarget, pTopicMarketDataVersion, sizeof(CTopicMarketDataVersion));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pTopicAndVersion->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CTopicMarketDataVersion *CTopicMarketDataVersionFactory::add(CWriteableTopicMarketDataVersion *pTopicMarketDataVersion, CTransaction *pTransaction)
{
	pTopicMarketDataVersion->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pTopicMarketDataVersion,true);
	}
	else {
		CTopicMarketDataVersion *pNewTopicMarketDataVersion;
		pNewTopicMarketDataVersion = internalAdd(pTopicMarketDataVersion,false);
		pTransaction->addResource(CTopicMarketDataVersionResource::alloc(CREATE_ACTION,this,pNewTopicMarketDataVersion,NULL));
		return pNewTopicMarketDataVersion;
	}
}

void CTopicMarketDataVersionFactory::internalUpdate(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pNewTopicMarketDataVersion, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForTopicMarketDataVersion++;
	}
	else {
		updateWithoutIndexActionForTopicMarketDataVersion++;
	}
#endif
	CWriteableTopicMarketDataVersion theOldTopicMarketDataVersion;
	beforeUpdate(pTopicMarketDataVersion,pNewTopicMarketDataVersion);
	if (bNoTransaction) {
		forceCopy(&theOldTopicMarketDataVersion,pTopicMarketDataVersion,sizeof(CTopicMarketDataVersion));
	}
	if (updateIndex) {
	}

	forceCopy(pTopicMarketDataVersion,pNewTopicMarketDataVersion,sizeof(CTopicMarketDataVersion));
	pMem->updateObject(pTopicMarketDataVersion);
	if (updateIndex) {
	}
	afterUpdate(pTopicMarketDataVersion);
	if (bNoTransaction) {
		commitUpdate(pTopicMarketDataVersion,&theOldTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::update(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pNewTopicMarketDataVersion, CTransaction *pTransaction, bool updateIndex)
{
	pNewTopicMarketDataVersion->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pTopicMarketDataVersion,pNewTopicMarketDataVersion,updateIndex,true);
	}
	else {
		pTransaction->addResource(CTopicMarketDataVersionResource::alloc(UPDATE_ACTION,this,pTopicMarketDataVersion,pNewTopicMarketDataVersion,updateIndex));
		internalUpdate(pTopicMarketDataVersion,pNewTopicMarketDataVersion,updateIndex,false);
	}
}

void CTopicMarketDataVersionFactory::internalRemove(CTopicMarketDataVersion *pTopicMarketDataVersion, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForTopicMarketDataVersion++;
#endif
	CWriteableTopicMarketDataVersion theOldTopicMarketDataVersion;
	beforeRemove(pTopicMarketDataVersion);
	if (bNoTransaction) {
		forceCopy(&theOldTopicMarketDataVersion,pTopicMarketDataVersion,sizeof(CTopicMarketDataVersion));
	}
	if (runLevel>=0) {
		pTopicAndVersion->removeObject(pTopicMarketDataVersion);
	}
	pMem->free(pTopicMarketDataVersion);
	if(bNoTransaction) {
		commitRemove(&theOldTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::remove(CTopicMarketDataVersion *pTopicMarketDataVersion, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pTopicMarketDataVersion,true);
	}
	else {
		pTransaction->addResource(CTopicMarketDataVersionResource::alloc(DELETE_ACTION,this,pTopicMarketDataVersion,NULL));
		internalRemove(pTopicMarketDataVersion,false);		
	}
}

CTopicMarketDataVersion* CTopicMarketDataVersionFactory::addOrUpdate(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pNewTopicMarketDataVersion, CTransaction *pTransaction, bool updateIndex)
{
	if(pTopicMarketDataVersion == NULL) {
		return add(pNewTopicMarketDataVersion,pTransaction);
	}
	else {
		update(pTopicMarketDataVersion,pNewTopicMarketDataVersion,pTransaction,updateIndex);
		return pTopicMarketDataVersion;
	}
}

void CTopicMarketDataVersionFactory::retrieve(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pTargetTopicMarketDataVersion)
{
	forceCopy(pTargetTopicMarketDataVersion, pTopicMarketDataVersion, sizeof(CTopicMarketDataVersion));
}
	
int CTopicMarketDataVersionFactory::addActionTrigger(CTopicMarketDataVersionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CTopicMarketDataVersionFactory::removeActionTrigger(CTopicMarketDataVersionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CTopicMarketDataVersionFactory::addCommitTrigger(CTopicMarketDataVersionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CTopicMarketDataVersionFactory::removeCommitTrigger(CTopicMarketDataVersionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CTopicMarketDataVersion *CTopicMarketDataVersionFactory::getFirst(void)
{
	CTopicMarketDataVersion *pResult=(CTopicMarketDataVersion *)(pMem->getFirst());
	return pResult;
}
	
CTopicMarketDataVersion *CTopicMarketDataVersionFactory::getNext(void)
{
	CTopicMarketDataVersion *pResult=(CTopicMarketDataVersion *)(pMem->getNext());
	return pResult;
}
	
void CTopicMarketDataVersionFactory::endGet(void)
{
	pMem->endGet();
}

void CTopicMarketDataVersionFactory::beforeAdd(CWriteableTopicMarketDataVersion *pTopicMarketDataVersion)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pTopicMarketDataVersion);
	}
}
	
void CTopicMarketDataVersionFactory::afterAdd(CTopicMarketDataVersion *pTopicMarketDataVersion)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::beforeUpdate(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pNewTopicMarketDataVersion)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pTopicMarketDataVersion,pNewTopicMarketDataVersion);
	}
}
	
void CTopicMarketDataVersionFactory::afterUpdate(CTopicMarketDataVersion *pTopicMarketDataVersion)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pTopicMarketDataVersion);
	}
}
	
void CTopicMarketDataVersionFactory::beforeRemove(CTopicMarketDataVersion *pTopicMarketDataVersion)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::commitAdd(CTopicMarketDataVersion *pTopicMarketDataVersion)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForTopicMarketDataVersion++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::commitUpdate(CTopicMarketDataVersion *pTopicMarketDataVersion, CWriteableTopicMarketDataVersion *pOldTopicMarketDataVersion)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForTopicMarketDataVersion++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pTopicMarketDataVersion,pOldTopicMarketDataVersion);
	}
}
	
void CTopicMarketDataVersionFactory::commitRemove(CWriteableTopicMarketDataVersion *pTopicMarketDataVersion)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForTopicMarketDataVersion++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pTopicMarketDataVersion);
	}
}

void CTopicMarketDataVersionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInformationIDIndexinInformation(const void *pV1, const void *pV2);
extern int compareForInformationIDLastIndexinInformation(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForInformation=0;
int updateWithIndexActionForInformation=0;
int updateWithoutIndexActionForInformation=0;
int removeActionForInformation=0;
int addCommitForInformation=0;
int updateCommitForInformation=0;
int removeCommitForInformation=0;
#endif
void CInformationFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInformationIDIndex=new CAVLTree(maxUnit,compareForInformationIDIndexinInformation,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Information_InformationIDIndex",pInformationIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Information_InformationIDIndex");
			if(it != pIndexMap->end()) {
				pInformationIDIndex=new CAVLTree(maxUnit,compareForInformationIDIndexinInformation,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInformationIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pInformationIDLastIndex=new CAVLTree(maxUnit,compareForInformationIDLastIndexinInformation,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Information_InformationIDLastIndex",pInformationIDLastIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Information_InformationIDLastIndex");
			if(it != pIndexMap->end()) {
				pInformationIDLastIndex=new CAVLTree(maxUnit,compareForInformationIDLastIndexinInformation,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInformationIDLastIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByInformationID=NULL;
	pActionTriggers=new vector<CInformationActionTrigger *>;
	pCommitTriggers=new vector<CInformationCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CInformationFactory::CInformationFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInformation),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CInformationFactory::CInformationFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInformation),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CInformationFactory::~CInformationFactory(void)
{
	if (runLevel>=0) {
		if (pInformationIDIndex!=NULL)
			delete pInformationIDIndex;
	}
	if (runLevel>=0) {
		if (pInformationIDLastIndex!=NULL)
			delete pInformationIDLastIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CInformationFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CInformationFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInformationIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pInformationIDLastIndex->output(pLogger,indent+1);
	}
}

int CInformationFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableInformation thisInformation;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisInformation.readCSV(input,pNames))
		add(&thisInformation);
	fclose(input);
	delete pNames;
	return 1;
}

int CInformationFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Information.csv");
	return readCSV(szFileName);
}

int CInformationFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableInformation *pInformation;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableInformation::writeCSVHead(output);
	pInformation=(CWriteableInformation *)(pMem->getFirst());
	while (pInformation!=NULL) {
		if (!pInformation->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pInformation=(CWriteableInformation *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CInformationFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Information.csv");
	return writeCSV(szFileName);
}

void CInformationFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CInformationFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableInformation *pInformation;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CInformationFactory={       Total Count=%d\n", pMem->getCount());
	pInformation=(CWriteableInformation *)(pMem->getFirst());
	while (pInformation!=NULL) {
		pInformation->dump(fp,index++);
		pInformation=(CWriteableInformation *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CInformationFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInformationIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pInformationIDLastIndex->removeAll();
	}
}

CInformation *CInformationFactory::internalAdd(CWriteableInformation *pInformation, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForInformation++;
#endif
	CInformation *pTarget;	
	beforeAdd(pInformation);
	pTarget=(CInformation *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Information in memory database");
		return NULL;
	}
	forceCopy(pTarget, pInformation, sizeof(CInformation));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInformationIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pInformationIDLastIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CInformation *CInformationFactory::add(CWriteableInformation *pInformation, CTransaction *pTransaction)
{
	pInformation->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pInformation,true);
	}
	else {
		CInformation *pNewInformation;
		pNewInformation = internalAdd(pInformation,false);
		pTransaction->addResource(CInformationResource::alloc(CREATE_ACTION,this,pNewInformation,NULL));
		return pNewInformation;
	}
}

void CInformationFactory::internalUpdate(CInformation *pInformation, CWriteableInformation *pNewInformation, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForInformation++;
	}
	else {
		updateWithoutIndexActionForInformation++;
	}
#endif
	CWriteableInformation theOldInformation;
	beforeUpdate(pInformation,pNewInformation);
	if (bNoTransaction) {
		forceCopy(&theOldInformation,pInformation,sizeof(CInformation));
	}
	if (updateIndex) {
	}

	forceCopy(pInformation,pNewInformation,sizeof(CInformation));
	pMem->updateObject(pInformation);
	if (updateIndex) {
	}
	afterUpdate(pInformation);
	if (bNoTransaction) {
		commitUpdate(pInformation,&theOldInformation);
	}
}

void CInformationFactory::update(CInformation *pInformation, CWriteableInformation *pNewInformation, CTransaction *pTransaction, bool updateIndex)
{
	pNewInformation->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pInformation,pNewInformation,updateIndex,true);
	}
	else {
		pTransaction->addResource(CInformationResource::alloc(UPDATE_ACTION,this,pInformation,pNewInformation,updateIndex));
		internalUpdate(pInformation,pNewInformation,updateIndex,false);
	}
}

void CInformationFactory::internalRemove(CInformation *pInformation, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForInformation++;
#endif
	CWriteableInformation theOldInformation;
	beforeRemove(pInformation);
	if (bNoTransaction) {
		forceCopy(&theOldInformation,pInformation,sizeof(CInformation));
	}
	if (runLevel>=0) {
		pInformationIDIndex->removeObject(pInformation);
	}
	if (runLevel>=0) {
		pInformationIDLastIndex->removeObject(pInformation);
	}
	pMem->free(pInformation);
	if(bNoTransaction) {
		commitRemove(&theOldInformation);
	}
}

void CInformationFactory::remove(CInformation *pInformation, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pInformation,true);
	}
	else {
		pTransaction->addResource(CInformationResource::alloc(DELETE_ACTION,this,pInformation,NULL));
		internalRemove(pInformation,false);		
	}
}

CInformation* CInformationFactory::addOrUpdate(CInformation *pInformation, CWriteableInformation *pNewInformation, CTransaction *pTransaction, bool updateIndex)
{
	if(pInformation == NULL) {
		return add(pNewInformation,pTransaction);
	}
	else {
		update(pInformation,pNewInformation,pTransaction,updateIndex);
		return pInformation;
	}
}

void CInformationFactory::retrieve(CInformation *pInformation, CWriteableInformation *pTargetInformation)
{
	forceCopy(pTargetInformation, pInformation, sizeof(CInformation));
}
	
int CInformationFactory::addActionTrigger(CInformationActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CInformationFactory::removeActionTrigger(CInformationActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CInformationFactory::addCommitTrigger(CInformationCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CInformationFactory::removeCommitTrigger(CInformationCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CInformation *CInformationFactory::getFirst(void)
{
	CInformation *pResult=(CInformation *)(pMem->getFirst());
	return pResult;
}
	
CInformation *CInformationFactory::getNext(void)
{
	CInformation *pResult=(CInformation *)(pMem->getNext());
	return pResult;
}
	
void CInformationFactory::endGet(void)
{
	pMem->endGet();
}

void CInformationFactory::beforeAdd(CWriteableInformation *pInformation)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pInformation);
	}
}
	
void CInformationFactory::afterAdd(CInformation *pInformation)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pInformation);
	}
}

void CInformationFactory::beforeUpdate(CInformation *pInformation, CWriteableInformation *pNewInformation)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pInformation,pNewInformation);
	}
}
	
void CInformationFactory::afterUpdate(CInformation *pInformation)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pInformation);
	}
}
	
void CInformationFactory::beforeRemove(CInformation *pInformation)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pInformation);
	}
}

void CInformationFactory::commitAdd(CInformation *pInformation)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForInformation++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pInformation);
	}
}

void CInformationFactory::commitUpdate(CInformation *pInformation, CWriteableInformation *pOldInformation)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForInformation++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pInformation,pOldInformation);
	}
}
	
void CInformationFactory::commitRemove(CWriteableInformation *pInformation)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForInformation++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pInformation);
	}
}

void CInformationFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForOrderCount=0;
int updateWithIndexActionForOrderCount=0;
int updateWithoutIndexActionForOrderCount=0;
int removeActionForOrderCount=0;
int addCommitForOrderCount=0;
int updateCommitForOrderCount=0;
int removeCommitForOrderCount=0;
#endif
void COrderCountFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=300;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("OrderCount.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pHashParticipantIDIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("OrderCount_HashParticipantIDIndex",pHashParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("OrderCount_HashParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pHashParticipantIDIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pHashParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pActionTriggers=new vector<COrderCountActionTrigger *>;
	pCommitTriggers=new vector<COrderCountCommitTrigger *>;
	m_activeCommitTrigger=true;
}

COrderCountFactory::COrderCountFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COrderCount),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

COrderCountFactory::COrderCountFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COrderCount),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

COrderCountFactory::~COrderCountFactory(void)
{
	if (runLevel>=0) {
		if (pHashParticipantIDIndex!=NULL)
			delete pHashParticipantIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void COrderCountFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"COrderCountFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int COrderCountFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableOrderCount thisOrderCount;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisOrderCount.readCSV(input,pNames))
		add(&thisOrderCount);
	fclose(input);
	delete pNames;
	return 1;
}

int COrderCountFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "OrderCount.csv");
	return readCSV(szFileName);
}

int COrderCountFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableOrderCount *pOrderCount;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableOrderCount::writeCSVHead(output);
	pOrderCount=(CWriteableOrderCount *)(pMem->getFirst());
	while (pOrderCount!=NULL) {
		if (!pOrderCount->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pOrderCount=(CWriteableOrderCount *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int COrderCountFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "OrderCount.csv");
	return writeCSV(szFileName);
}

void COrderCountFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void COrderCountFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableOrderCount *pOrderCount;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"COrderCountFactory={       Total Count=%d\n", pMem->getCount());
	pOrderCount=(CWriteableOrderCount *)(pMem->getFirst());
	while (pOrderCount!=NULL) {
		pOrderCount->dump(fp,index++);
		pOrderCount=(CWriteableOrderCount *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void COrderCountFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pHashParticipantIDIndex->removeAll();
	}
}

COrderCount *COrderCountFactory::internalAdd(CWriteableOrderCount *pOrderCount, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForOrderCount++;
#endif
	COrderCount *pTarget;	
	beforeAdd(pOrderCount);
	pTarget=(COrderCount *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough OrderCount in memory database");
		return NULL;
	}
	forceCopy(pTarget, pOrderCount, sizeof(COrderCount));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pHashParticipantIDIndex->addObject(pTarget,pTarget->HashHashParticipantID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

COrderCount *COrderCountFactory::add(CWriteableOrderCount *pOrderCount, CTransaction *pTransaction)
{
	pOrderCount->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pOrderCount,true);
	}
	else {
		COrderCount *pNewOrderCount;
		pNewOrderCount = internalAdd(pOrderCount,false);
		pTransaction->addResource(COrderCountResource::alloc(CREATE_ACTION,this,pNewOrderCount,NULL));
		return pNewOrderCount;
	}
}

void COrderCountFactory::internalUpdate(COrderCount *pOrderCount, CWriteableOrderCount *pNewOrderCount, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForOrderCount++;
	}
	else {
		updateWithoutIndexActionForOrderCount++;
	}
#endif
	CWriteableOrderCount theOldOrderCount;
	beforeUpdate(pOrderCount,pNewOrderCount);
	if (bNoTransaction) {
		forceCopy(&theOldOrderCount,pOrderCount,sizeof(COrderCount));
	}
	if (updateIndex) {
	}

	forceCopy(pOrderCount,pNewOrderCount,sizeof(COrderCount));
	pMem->updateObject(pOrderCount);
	if (updateIndex) {
	}
	afterUpdate(pOrderCount);
	if (bNoTransaction) {
		commitUpdate(pOrderCount,&theOldOrderCount);
	}
}

void COrderCountFactory::update(COrderCount *pOrderCount, CWriteableOrderCount *pNewOrderCount, CTransaction *pTransaction, bool updateIndex)
{
	pNewOrderCount->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pOrderCount,pNewOrderCount,updateIndex,true);
	}
	else {
		pTransaction->addResource(COrderCountResource::alloc(UPDATE_ACTION,this,pOrderCount,pNewOrderCount,updateIndex));
		internalUpdate(pOrderCount,pNewOrderCount,updateIndex,false);
	}
}

void COrderCountFactory::internalRemove(COrderCount *pOrderCount, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForOrderCount++;
#endif
	CWriteableOrderCount theOldOrderCount;
	beforeRemove(pOrderCount);
	if (bNoTransaction) {
		forceCopy(&theOldOrderCount,pOrderCount,sizeof(COrderCount));
	}
	if (runLevel>=0) {
		pHashParticipantIDIndex->removeObject(pOrderCount,pOrderCount->HashHashParticipantID);
	}	
	pMem->free(pOrderCount);
	if(bNoTransaction) {
		commitRemove(&theOldOrderCount);
	}
}

void COrderCountFactory::remove(COrderCount *pOrderCount, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pOrderCount,true);
	}
	else {
		pTransaction->addResource(COrderCountResource::alloc(DELETE_ACTION,this,pOrderCount,NULL));
		internalRemove(pOrderCount,false);		
	}
}

COrderCount* COrderCountFactory::addOrUpdate(COrderCount *pOrderCount, CWriteableOrderCount *pNewOrderCount, CTransaction *pTransaction, bool updateIndex)
{
	if(pOrderCount == NULL) {
		return add(pNewOrderCount,pTransaction);
	}
	else {
		update(pOrderCount,pNewOrderCount,pTransaction,updateIndex);
		return pOrderCount;
	}
}

void COrderCountFactory::retrieve(COrderCount *pOrderCount, CWriteableOrderCount *pTargetOrderCount)
{
	forceCopy(pTargetOrderCount, pOrderCount, sizeof(COrderCount));
}
	
int COrderCountFactory::addActionTrigger(COrderCountActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int COrderCountFactory::removeActionTrigger(COrderCountActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int COrderCountFactory::addCommitTrigger(COrderCountCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int COrderCountFactory::removeCommitTrigger(COrderCountCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

COrderCount *COrderCountFactory::getFirst(void)
{
	COrderCount *pResult=(COrderCount *)(pMem->getFirst());
	return pResult;
}
	
COrderCount *COrderCountFactory::getNext(void)
{
	COrderCount *pResult=(COrderCount *)(pMem->getNext());
	return pResult;
}
	
void COrderCountFactory::endGet(void)
{
	pMem->endGet();
}

void COrderCountFactory::beforeAdd(CWriteableOrderCount *pOrderCount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pOrderCount);
	}
}
	
void COrderCountFactory::afterAdd(COrderCount *pOrderCount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pOrderCount);
	}
}

void COrderCountFactory::beforeUpdate(COrderCount *pOrderCount, CWriteableOrderCount *pNewOrderCount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pOrderCount,pNewOrderCount);
	}
}
	
void COrderCountFactory::afterUpdate(COrderCount *pOrderCount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pOrderCount);
	}
}
	
void COrderCountFactory::beforeRemove(COrderCount *pOrderCount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pOrderCount);
	}
}

void COrderCountFactory::commitAdd(COrderCount *pOrderCount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForOrderCount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pOrderCount);
	}
}

void COrderCountFactory::commitUpdate(COrderCount *pOrderCount, CWriteableOrderCount *pOldOrderCount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForOrderCount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pOrderCount,pOldOrderCount);
	}
}
	
void COrderCountFactory::commitRemove(CWriteableOrderCount *pOrderCount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForOrderCount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pOrderCount);
	}
}

void COrderCountFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinInstrument(const void *pV1, const void *pV2);
extern int compareForProductIDIndexinInstrument(const void *pV1, const void *pV2);
extern int compareForProductGroupIDIndexinInstrument(const void *pV1, const void *pV2);
extern int compareForProductGroupIDRevIndexinInstrument(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForInstrument=0;
int updateWithIndexActionForInstrument=0;
int updateWithoutIndexActionForInstrument=0;
int removeActionForInstrument=0;
int addCommitForInstrument=0;
int updateCommitForInstrument=0;
int removeCommitForInstrument=0;
#endif
void CInstrumentFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinInstrument,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Instrument_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Instrument_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinInstrument,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinInstrument,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Instrument_ProductIDIndex",pProductIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Instrument_ProductIDIndex");
			if(it != pIndexMap->end()) {
				pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinInstrument,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pProductGroupIDIndex=new CAVLTree(maxUnit,compareForProductGroupIDIndexinInstrument,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Instrument_ProductGroupIDIndex",pProductGroupIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Instrument_ProductGroupIDIndex");
			if(it != pIndexMap->end()) {
				pProductGroupIDIndex=new CAVLTree(maxUnit,compareForProductGroupIDIndexinInstrument,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductGroupIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pProductGroupIDRevIndex=new CAVLTree(maxUnit,compareForProductGroupIDRevIndexinInstrument,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Instrument_ProductGroupIDRevIndex",pProductGroupIDRevIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Instrument_ProductGroupIDRevIndex");
			if(it != pIndexMap->end()) {
				pProductGroupIDRevIndex=new CAVLTree(maxUnit,compareForProductGroupIDRevIndexinInstrument,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductGroupIDRevIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=769;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("Instrument.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pInstrumentIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Instrument_InstrumentIDHashIndex",pInstrumentIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Instrument_InstrumentIDHashIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByInstrumentID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByProductID=NULL;
	pLastFoundInSearchByProductGroupID=NULL;
	pLastFoundInSearchByDeliveryMonth=NULL;
	pLastFoundInSearchByRevDeliveryMonth=NULL;
	pActionTriggers=new vector<CInstrumentActionTrigger *>;
	pCommitTriggers=new vector<CInstrumentCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CInstrumentFactory::CInstrumentFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrument),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CInstrumentFactory::CInstrumentFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrument),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CInstrumentFactory::~CInstrumentFactory(void)
{
	if (runLevel>=1) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (runLevel>=0) {
		if (pProductIDIndex!=NULL)
			delete pProductIDIndex;
	}
	if (runLevel>=0) {
		if (pProductGroupIDIndex!=NULL)
			delete pProductGroupIDIndex;
	}
	if (runLevel>=0) {
		if (pProductGroupIDRevIndex!=NULL)
			delete pProductGroupIDRevIndex;
	}
	if (runLevel>=0) {
		if (pInstrumentIDHashIndex!=NULL)
			delete pInstrumentIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CInstrumentFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CInstrumentFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pProductIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pProductGroupIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pProductGroupIDRevIndex->output(pLogger,indent+1);
	}
}

int CInstrumentFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableInstrument thisInstrument;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisInstrument.readCSV(input,pNames))
		add(&thisInstrument);
	fclose(input);
	delete pNames;
	return 1;
}

int CInstrumentFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Instrument.csv");
	return readCSV(szFileName);
}

int CInstrumentFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableInstrument *pInstrument;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableInstrument::writeCSVHead(output);
	pInstrument=(CWriteableInstrument *)(pMem->getFirst());
	while (pInstrument!=NULL) {
		if (!pInstrument->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pInstrument=(CWriteableInstrument *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CInstrumentFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Instrument.csv");
	return writeCSV(szFileName);
}

void CInstrumentFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CInstrumentFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableInstrument *pInstrument;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CInstrumentFactory={       Total Count=%d\n", pMem->getCount());
	pInstrument=(CWriteableInstrument *)(pMem->getFirst());
	while (pInstrument!=NULL) {
		pInstrument->dump(fp,index++);
		pInstrument=(CWriteableInstrument *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CInstrumentFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pInstrumentIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pProductIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pProductGroupIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pProductGroupIDRevIndex->removeAll();
	}
	if (runLevel>=0) {
		pInstrumentIDHashIndex->removeAll();
	}
}

CInstrument *CInstrumentFactory::internalAdd(CWriteableInstrument *pInstrument, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForInstrument++;
#endif
	CInstrument *pTarget;	
	beforeAdd(pInstrument);
	pTarget=(CInstrument *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Instrument in memory database");
		return NULL;
	}
	forceCopy(pTarget, pInstrument, sizeof(CInstrument));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pProductIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pProductGroupIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pProductGroupIDRevIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pInstrumentIDHashIndex->addObject(pTarget,pTarget->HashInstrumentID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CInstrument *CInstrumentFactory::add(CWriteableInstrument *pInstrument, CTransaction *pTransaction)
{
	pInstrument->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pInstrument,true);
	}
	else {
		CInstrument *pNewInstrument;
		pNewInstrument = internalAdd(pInstrument,false);
		pTransaction->addResource(CInstrumentResource::alloc(CREATE_ACTION,this,pNewInstrument,NULL));
		return pNewInstrument;
	}
}

void CInstrumentFactory::internalUpdate(CInstrument *pInstrument, CWriteableInstrument *pNewInstrument, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForInstrument++;
	}
	else {
		updateWithoutIndexActionForInstrument++;
	}
#endif
	CWriteableInstrument theOldInstrument;
	beforeUpdate(pInstrument,pNewInstrument);
	if (bNoTransaction) {
		forceCopy(&theOldInstrument,pInstrument,sizeof(CInstrument));
	}
	if (updateIndex) {
	}

	forceCopy(pInstrument,pNewInstrument,sizeof(CInstrument));
	pMem->updateObject(pInstrument);
	if (updateIndex) {
	}
	afterUpdate(pInstrument);
	if (bNoTransaction) {
		commitUpdate(pInstrument,&theOldInstrument);
	}
}

void CInstrumentFactory::update(CInstrument *pInstrument, CWriteableInstrument *pNewInstrument, CTransaction *pTransaction, bool updateIndex)
{
	pNewInstrument->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pInstrument,pNewInstrument,updateIndex,true);
	}
	else {
		pTransaction->addResource(CInstrumentResource::alloc(UPDATE_ACTION,this,pInstrument,pNewInstrument,updateIndex));
		internalUpdate(pInstrument,pNewInstrument,updateIndex,false);
	}
}

void CInstrumentFactory::internalRemove(CInstrument *pInstrument, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForInstrument++;
#endif
	CWriteableInstrument theOldInstrument;
	beforeRemove(pInstrument);
	if (bNoTransaction) {
		forceCopy(&theOldInstrument,pInstrument,sizeof(CInstrument));
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->removeObject(pInstrument);
	}
	if (runLevel>=0) {
		pProductIDIndex->removeObject(pInstrument);
	}
	if (runLevel>=0) {
		pProductGroupIDIndex->removeObject(pInstrument);
	}
	if (runLevel>=0) {
		pProductGroupIDRevIndex->removeObject(pInstrument);
	}
	if (runLevel>=0) {
		pInstrumentIDHashIndex->removeObject(pInstrument,pInstrument->HashInstrumentID);
	}	
	pMem->free(pInstrument);
	if(bNoTransaction) {
		commitRemove(&theOldInstrument);
	}
}

void CInstrumentFactory::remove(CInstrument *pInstrument, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pInstrument,true);
	}
	else {
		pTransaction->addResource(CInstrumentResource::alloc(DELETE_ACTION,this,pInstrument,NULL));
		internalRemove(pInstrument,false);		
	}
}

CInstrument* CInstrumentFactory::addOrUpdate(CInstrument *pInstrument, CWriteableInstrument *pNewInstrument, CTransaction *pTransaction, bool updateIndex)
{
	if(pInstrument == NULL) {
		return add(pNewInstrument,pTransaction);
	}
	else {
		update(pInstrument,pNewInstrument,pTransaction,updateIndex);
		return pInstrument;
	}
}

void CInstrumentFactory::retrieve(CInstrument *pInstrument, CWriteableInstrument *pTargetInstrument)
{
	forceCopy(pTargetInstrument, pInstrument, sizeof(CInstrument));
}
	
int CInstrumentFactory::addActionTrigger(CInstrumentActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CInstrumentFactory::removeActionTrigger(CInstrumentActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CInstrumentFactory::addCommitTrigger(CInstrumentCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CInstrumentFactory::removeCommitTrigger(CInstrumentCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CInstrument *CInstrumentFactory::getFirst(void)
{
	CInstrument *pResult=(CInstrument *)(pMem->getFirst());
	return pResult;
}
	
CInstrument *CInstrumentFactory::getNext(void)
{
	CInstrument *pResult=(CInstrument *)(pMem->getNext());
	return pResult;
}
	
void CInstrumentFactory::endGet(void)
{
	pMem->endGet();
}

void CInstrumentFactory::beforeAdd(CWriteableInstrument *pInstrument)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pInstrument);
	}
}
	
void CInstrumentFactory::afterAdd(CInstrument *pInstrument)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pInstrument);
	}
}

void CInstrumentFactory::beforeUpdate(CInstrument *pInstrument, CWriteableInstrument *pNewInstrument)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pInstrument,pNewInstrument);
	}
}
	
void CInstrumentFactory::afterUpdate(CInstrument *pInstrument)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pInstrument);
	}
}
	
void CInstrumentFactory::beforeRemove(CInstrument *pInstrument)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pInstrument);
	}
}

void CInstrumentFactory::commitAdd(CInstrument *pInstrument)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForInstrument++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pInstrument);
	}
}

void CInstrumentFactory::commitUpdate(CInstrument *pInstrument, CWriteableInstrument *pOldInstrument)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForInstrument++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pInstrument,pOldInstrument);
	}
}
	
void CInstrumentFactory::commitRemove(CWriteableInstrument *pInstrument)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForInstrument++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pInstrument);
	}
}

void CInstrumentFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CInstrumentFactory::linkAllBaseInstrument(CInstrumentFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkBaseInstrument(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllInstrumentProperty(CCurrInstrumentPropertyFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkInstrumentProperty(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllInstrumentStatus(CInstrumentStatusFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkInstrumentStatus(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllMarketData(CMarketDataFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkMarketData(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllCurrHedgeRule(CCurrHedgeRuleFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkCurrHedgeRule(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllCurrFuse(CCurrFuseFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkCurrFuse(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllFusePhase(CFusePhaseFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkFusePhase(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllBasePriceLimit(CBasePriceLimitFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkBasePriceLimit(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllUniPressure(CUniPressureFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkUniPressure(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

void CInstrumentFactory::linkAllSGDataSyncStatus(CSGDataSyncStatusFactory *pFactory)
{
	CInstrument *pInstrument;
	pInstrument=getFirst();
	while (pInstrument != NULL) {
		pInstrument->linkSGDataSyncStatus(pFactory);
		pInstrument=getNext();
	}
	endGet();
}

extern int compareForCombinationIndexinCombinationLeg(const void *pV1, const void *pV2);
extern int compareForLegIndexinCombinationLeg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCombinationLeg=0;
int updateWithIndexActionForCombinationLeg=0;
int updateWithoutIndexActionForCombinationLeg=0;
int removeActionForCombinationLeg=0;
int addCommitForCombinationLeg=0;
int updateCommitForCombinationLeg=0;
int removeCommitForCombinationLeg=0;
#endif
void CCombinationLegFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pCombinationIndex=new CAVLTree(maxUnit,compareForCombinationIndexinCombinationLeg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CombinationLeg_CombinationIndex",pCombinationIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CombinationLeg_CombinationIndex");
			if(it != pIndexMap->end()) {
				pCombinationIndex=new CAVLTree(maxUnit,compareForCombinationIndexinCombinationLeg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pCombinationIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pLegIndex=new CAVLTree(maxUnit,compareForLegIndexinCombinationLeg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CombinationLeg_LegIndex",pLegIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CombinationLeg_LegIndex");
			if(it != pIndexMap->end()) {
				pLegIndex=new CAVLTree(maxUnit,compareForLegIndexinCombinationLeg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pLegIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByCombination=NULL;
	pLastFoundInSearchByLeg=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCombinationLegActionTrigger *>;
	pCommitTriggers=new vector<CCombinationLegCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCombinationLegFactory::CCombinationLegFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCombinationLeg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCombinationLegFactory::CCombinationLegFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCombinationLeg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCombinationLegFactory::~CCombinationLegFactory(void)
{
	if (runLevel>=0) {
		if (pCombinationIndex!=NULL)
			delete pCombinationIndex;
	}
	if (runLevel>=0) {
		if (pLegIndex!=NULL)
			delete pLegIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCombinationLegFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCombinationLegFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pCombinationIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pLegIndex->output(pLogger,indent+1);
	}
}

int CCombinationLegFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCombinationLeg thisCombinationLeg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCombinationLeg.readCSV(input,pNames))
		add(&thisCombinationLeg);
	fclose(input);
	delete pNames;
	return 1;
}

int CCombinationLegFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CombinationLeg.csv");
	return readCSV(szFileName);
}

int CCombinationLegFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCombinationLeg *pCombinationLeg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCombinationLeg::writeCSVHead(output);
	pCombinationLeg=(CWriteableCombinationLeg *)(pMem->getFirst());
	while (pCombinationLeg!=NULL) {
		if (!pCombinationLeg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCombinationLeg=(CWriteableCombinationLeg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCombinationLegFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CombinationLeg.csv");
	return writeCSV(szFileName);
}

void CCombinationLegFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCombinationLegFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCombinationLeg *pCombinationLeg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCombinationLegFactory={       Total Count=%d\n", pMem->getCount());
	pCombinationLeg=(CWriteableCombinationLeg *)(pMem->getFirst());
	while (pCombinationLeg!=NULL) {
		pCombinationLeg->dump(fp,index++);
		pCombinationLeg=(CWriteableCombinationLeg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCombinationLegFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pCombinationIndex->removeAll();
	}
	if (runLevel>=0) {
		pLegIndex->removeAll();
	}
}

CCombinationLeg *CCombinationLegFactory::internalAdd(CWriteableCombinationLeg *pCombinationLeg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCombinationLeg++;
#endif
	CCombinationLeg *pTarget;	
	beforeAdd(pCombinationLeg);
	pTarget=(CCombinationLeg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CombinationLeg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCombinationLeg, sizeof(CCombinationLeg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pCombinationIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pLegIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCombinationLeg *CCombinationLegFactory::add(CWriteableCombinationLeg *pCombinationLeg, CTransaction *pTransaction)
{
	pCombinationLeg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCombinationLeg,true);
	}
	else {
		CCombinationLeg *pNewCombinationLeg;
		pNewCombinationLeg = internalAdd(pCombinationLeg,false);
		pTransaction->addResource(CCombinationLegResource::alloc(CREATE_ACTION,this,pNewCombinationLeg,NULL));
		return pNewCombinationLeg;
	}
}

void CCombinationLegFactory::internalUpdate(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pNewCombinationLeg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCombinationLeg++;
	}
	else {
		updateWithoutIndexActionForCombinationLeg++;
	}
#endif
	CWriteableCombinationLeg theOldCombinationLeg;
	beforeUpdate(pCombinationLeg,pNewCombinationLeg);
	if (bNoTransaction) {
		forceCopy(&theOldCombinationLeg,pCombinationLeg,sizeof(CCombinationLeg));
	}
	if (updateIndex) {
	}

	forceCopy(pCombinationLeg,pNewCombinationLeg,sizeof(CCombinationLeg));
	pMem->updateObject(pCombinationLeg);
	if (updateIndex) {
	}
	afterUpdate(pCombinationLeg);
	if (bNoTransaction) {
		commitUpdate(pCombinationLeg,&theOldCombinationLeg);
	}
}

void CCombinationLegFactory::update(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pNewCombinationLeg, CTransaction *pTransaction, bool updateIndex)
{
	pNewCombinationLeg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCombinationLeg,pNewCombinationLeg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCombinationLegResource::alloc(UPDATE_ACTION,this,pCombinationLeg,pNewCombinationLeg,updateIndex));
		internalUpdate(pCombinationLeg,pNewCombinationLeg,updateIndex,false);
	}
}

void CCombinationLegFactory::internalRemove(CCombinationLeg *pCombinationLeg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCombinationLeg++;
#endif
	CWriteableCombinationLeg theOldCombinationLeg;
	beforeRemove(pCombinationLeg);
	if (bNoTransaction) {
		forceCopy(&theOldCombinationLeg,pCombinationLeg,sizeof(CCombinationLeg));
	}
	if (runLevel>=0) {
		pCombinationIndex->removeObject(pCombinationLeg);
	}
	if (runLevel>=0) {
		pLegIndex->removeObject(pCombinationLeg);
	}
	pMem->free(pCombinationLeg);
	if(bNoTransaction) {
		commitRemove(&theOldCombinationLeg);
	}
}

void CCombinationLegFactory::remove(CCombinationLeg *pCombinationLeg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCombinationLeg,true);
	}
	else {
		pTransaction->addResource(CCombinationLegResource::alloc(DELETE_ACTION,this,pCombinationLeg,NULL));
		internalRemove(pCombinationLeg,false);		
	}
}

CCombinationLeg* CCombinationLegFactory::addOrUpdate(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pNewCombinationLeg, CTransaction *pTransaction, bool updateIndex)
{
	if(pCombinationLeg == NULL) {
		return add(pNewCombinationLeg,pTransaction);
	}
	else {
		update(pCombinationLeg,pNewCombinationLeg,pTransaction,updateIndex);
		return pCombinationLeg;
	}
}

void CCombinationLegFactory::retrieve(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pTargetCombinationLeg)
{
	forceCopy(pTargetCombinationLeg, pCombinationLeg, sizeof(CCombinationLeg));
}
	
int CCombinationLegFactory::addActionTrigger(CCombinationLegActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCombinationLegFactory::removeActionTrigger(CCombinationLegActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCombinationLegFactory::addCommitTrigger(CCombinationLegCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCombinationLegFactory::removeCommitTrigger(CCombinationLegCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCombinationLeg *CCombinationLegFactory::getFirst(void)
{
	CCombinationLeg *pResult=(CCombinationLeg *)(pMem->getFirst());
	return pResult;
}
	
CCombinationLeg *CCombinationLegFactory::getNext(void)
{
	CCombinationLeg *pResult=(CCombinationLeg *)(pMem->getNext());
	return pResult;
}
	
void CCombinationLegFactory::endGet(void)
{
	pMem->endGet();
}

void CCombinationLegFactory::beforeAdd(CWriteableCombinationLeg *pCombinationLeg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCombinationLeg);
	}
}
	
void CCombinationLegFactory::afterAdd(CCombinationLeg *pCombinationLeg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCombinationLeg);
	}
}

void CCombinationLegFactory::beforeUpdate(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pNewCombinationLeg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCombinationLeg,pNewCombinationLeg);
	}
}
	
void CCombinationLegFactory::afterUpdate(CCombinationLeg *pCombinationLeg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCombinationLeg);
	}
}
	
void CCombinationLegFactory::beforeRemove(CCombinationLeg *pCombinationLeg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCombinationLeg);
	}
}

void CCombinationLegFactory::commitAdd(CCombinationLeg *pCombinationLeg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCombinationLeg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCombinationLeg);
	}
}

void CCombinationLegFactory::commitUpdate(CCombinationLeg *pCombinationLeg, CWriteableCombinationLeg *pOldCombinationLeg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCombinationLeg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCombinationLeg,pOldCombinationLeg);
	}
}
	
void CCombinationLegFactory::commitRemove(CWriteableCombinationLeg *pCombinationLeg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCombinationLeg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCombinationLeg);
	}
}

void CCombinationLegFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CCombinationLegFactory::linkAllCombinationInstrument(CInstrumentFactory *pFactory)
{
	CCombinationLeg *pCombinationLeg;
	pCombinationLeg=getFirst();
	while (pCombinationLeg != NULL) {
		pCombinationLeg->linkCombinationInstrument(pFactory);
		pCombinationLeg=getNext();
	}
	endGet();
}

void CCombinationLegFactory::linkAllLegInstrument(CInstrumentFactory *pFactory)
{
	CCombinationLeg *pCombinationLeg;
	pCombinationLeg=getFirst();
	while (pCombinationLeg != NULL) {
		pCombinationLeg->linkLegInstrument(pFactory);
		pCombinationLeg=getNext();
	}
	endGet();
}

extern int compareForPartRoleAndSGIndexinPartRoleAccount(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForPartRoleAccount=0;
int updateWithIndexActionForPartRoleAccount=0;
int updateWithoutIndexActionForPartRoleAccount=0;
int removeActionForPartRoleAccount=0;
int addCommitForPartRoleAccount=0;
int updateCommitForPartRoleAccount=0;
int removeCommitForPartRoleAccount=0;
#endif
void CPartRoleAccountFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pPartRoleAndSGIndex=new CAVLTree(maxUnit,compareForPartRoleAndSGIndexinPartRoleAccount,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartRoleAccount_PartRoleAndSGIndex",pPartRoleAndSGIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartRoleAccount_PartRoleAndSGIndex");
			if(it != pIndexMap->end()) {
				pPartRoleAndSGIndex=new CAVLTree(maxUnit,compareForPartRoleAndSGIndexinPartRoleAccount,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartRoleAndSGIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=3079;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartRoleAccount.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pPartRoleAndSGHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartRoleAccount_PartRoleAndSGHashIndex",pPartRoleAndSGHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartRoleAccount_PartRoleAndSGHashIndex");
			if(it != pIndexMap->end()) {
				pPartRoleAndSGHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartRoleAndSGHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchStartByParticipantID=NULL;
	pActionTriggers=new vector<CPartRoleAccountActionTrigger *>;
	pCommitTriggers=new vector<CPartRoleAccountCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartRoleAccountFactory::CPartRoleAccountFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartRoleAccount),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartRoleAccountFactory::CPartRoleAccountFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartRoleAccount),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartRoleAccountFactory::~CPartRoleAccountFactory(void)
{
	if (runLevel>=1) {
		if (pPartRoleAndSGIndex!=NULL)
			delete pPartRoleAndSGIndex;
	}
	if (runLevel>=0) {
		if (pPartRoleAndSGHashIndex!=NULL)
			delete pPartRoleAndSGHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartRoleAccountFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartRoleAccountFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pPartRoleAndSGIndex->output(pLogger,indent+1);
	}
}

int CPartRoleAccountFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartRoleAccount thisPartRoleAccount;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartRoleAccount.readCSV(input,pNames))
		add(&thisPartRoleAccount);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartRoleAccountFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartRoleAccount.csv");
	return readCSV(szFileName);
}

int CPartRoleAccountFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartRoleAccount *pPartRoleAccount;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartRoleAccount::writeCSVHead(output);
	pPartRoleAccount=(CWriteablePartRoleAccount *)(pMem->getFirst());
	while (pPartRoleAccount!=NULL) {
		if (!pPartRoleAccount->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartRoleAccount=(CWriteablePartRoleAccount *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartRoleAccountFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartRoleAccount.csv");
	return writeCSV(szFileName);
}

void CPartRoleAccountFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartRoleAccountFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartRoleAccount *pPartRoleAccount;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartRoleAccountFactory={       Total Count=%d\n", pMem->getCount());
	pPartRoleAccount=(CWriteablePartRoleAccount *)(pMem->getFirst());
	while (pPartRoleAccount!=NULL) {
		pPartRoleAccount->dump(fp,index++);
		pPartRoleAccount=(CWriteablePartRoleAccount *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartRoleAccountFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pPartRoleAndSGIndex->removeAll();
	}
	if (runLevel>=0) {
		pPartRoleAndSGHashIndex->removeAll();
	}
}

CPartRoleAccount *CPartRoleAccountFactory::internalAdd(CWriteablePartRoleAccount *pPartRoleAccount, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartRoleAccount++;
#endif
	CPartRoleAccount *pTarget;	
	beforeAdd(pPartRoleAccount);
	pTarget=(CPartRoleAccount *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartRoleAccount in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartRoleAccount, sizeof(CPartRoleAccount));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pPartRoleAndSGIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pPartRoleAndSGHashIndex->addObject(pTarget,pTarget->HashPartRoleAndSG);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartRoleAccount *CPartRoleAccountFactory::add(CWriteablePartRoleAccount *pPartRoleAccount, CTransaction *pTransaction)
{
	pPartRoleAccount->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartRoleAccount,true);
	}
	else {
		CPartRoleAccount *pNewPartRoleAccount;
		pNewPartRoleAccount = internalAdd(pPartRoleAccount,false);
		pTransaction->addResource(CPartRoleAccountResource::alloc(CREATE_ACTION,this,pNewPartRoleAccount,NULL));
		return pNewPartRoleAccount;
	}
}

void CPartRoleAccountFactory::internalUpdate(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pNewPartRoleAccount, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartRoleAccount++;
	}
	else {
		updateWithoutIndexActionForPartRoleAccount++;
	}
#endif
	CWriteablePartRoleAccount theOldPartRoleAccount;
	beforeUpdate(pPartRoleAccount,pNewPartRoleAccount);
	if (bNoTransaction) {
		forceCopy(&theOldPartRoleAccount,pPartRoleAccount,sizeof(CPartRoleAccount));
	}
	if (updateIndex) {
	}

	forceCopy(pPartRoleAccount,pNewPartRoleAccount,sizeof(CPartRoleAccount));
	pMem->updateObject(pPartRoleAccount);
	if (updateIndex) {
	}
	afterUpdate(pPartRoleAccount);
	if (bNoTransaction) {
		commitUpdate(pPartRoleAccount,&theOldPartRoleAccount);
	}
}

void CPartRoleAccountFactory::update(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pNewPartRoleAccount, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartRoleAccount->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartRoleAccount,pNewPartRoleAccount,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartRoleAccountResource::alloc(UPDATE_ACTION,this,pPartRoleAccount,pNewPartRoleAccount,updateIndex));
		internalUpdate(pPartRoleAccount,pNewPartRoleAccount,updateIndex,false);
	}
}

void CPartRoleAccountFactory::internalRemove(CPartRoleAccount *pPartRoleAccount, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartRoleAccount++;
#endif
	CWriteablePartRoleAccount theOldPartRoleAccount;
	beforeRemove(pPartRoleAccount);
	if (bNoTransaction) {
		forceCopy(&theOldPartRoleAccount,pPartRoleAccount,sizeof(CPartRoleAccount));
	}
	if (runLevel>=1) {
		pPartRoleAndSGIndex->removeObject(pPartRoleAccount);
	}
	if (runLevel>=0) {
		pPartRoleAndSGHashIndex->removeObject(pPartRoleAccount,pPartRoleAccount->HashPartRoleAndSG);
	}	
	pMem->free(pPartRoleAccount);
	if(bNoTransaction) {
		commitRemove(&theOldPartRoleAccount);
	}
}

void CPartRoleAccountFactory::remove(CPartRoleAccount *pPartRoleAccount, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartRoleAccount,true);
	}
	else {
		pTransaction->addResource(CPartRoleAccountResource::alloc(DELETE_ACTION,this,pPartRoleAccount,NULL));
		internalRemove(pPartRoleAccount,false);		
	}
}

CPartRoleAccount* CPartRoleAccountFactory::addOrUpdate(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pNewPartRoleAccount, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartRoleAccount == NULL) {
		return add(pNewPartRoleAccount,pTransaction);
	}
	else {
		update(pPartRoleAccount,pNewPartRoleAccount,pTransaction,updateIndex);
		return pPartRoleAccount;
	}
}

void CPartRoleAccountFactory::retrieve(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pTargetPartRoleAccount)
{
	forceCopy(pTargetPartRoleAccount, pPartRoleAccount, sizeof(CPartRoleAccount));
}
	
int CPartRoleAccountFactory::addActionTrigger(CPartRoleAccountActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartRoleAccountFactory::removeActionTrigger(CPartRoleAccountActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartRoleAccountFactory::addCommitTrigger(CPartRoleAccountCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartRoleAccountFactory::removeCommitTrigger(CPartRoleAccountCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartRoleAccount *CPartRoleAccountFactory::getFirst(void)
{
	CPartRoleAccount *pResult=(CPartRoleAccount *)(pMem->getFirst());
	return pResult;
}
	
CPartRoleAccount *CPartRoleAccountFactory::getNext(void)
{
	CPartRoleAccount *pResult=(CPartRoleAccount *)(pMem->getNext());
	return pResult;
}
	
void CPartRoleAccountFactory::endGet(void)
{
	pMem->endGet();
}

void CPartRoleAccountFactory::beforeAdd(CWriteablePartRoleAccount *pPartRoleAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartRoleAccount);
	}
}
	
void CPartRoleAccountFactory::afterAdd(CPartRoleAccount *pPartRoleAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartRoleAccount);
	}
}

void CPartRoleAccountFactory::beforeUpdate(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pNewPartRoleAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartRoleAccount,pNewPartRoleAccount);
	}
}
	
void CPartRoleAccountFactory::afterUpdate(CPartRoleAccount *pPartRoleAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartRoleAccount);
	}
}
	
void CPartRoleAccountFactory::beforeRemove(CPartRoleAccount *pPartRoleAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartRoleAccount);
	}
}

void CPartRoleAccountFactory::commitAdd(CPartRoleAccount *pPartRoleAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartRoleAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartRoleAccount);
	}
}

void CPartRoleAccountFactory::commitUpdate(CPartRoleAccount *pPartRoleAccount, CWriteablePartRoleAccount *pOldPartRoleAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartRoleAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartRoleAccount,pOldPartRoleAccount);
	}
}
	
void CPartRoleAccountFactory::commitRemove(CWriteablePartRoleAccount *pPartRoleAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartRoleAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartRoleAccount);
	}
}

void CPartRoleAccountFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CPartRoleAccountFactory::linkAllTradingAccount(CTradingAccountFactory *pFactory)
{
	CPartRoleAccount *pPartRoleAccount;
	pPartRoleAccount=getFirst();
	while (pPartRoleAccount != NULL) {
		pPartRoleAccount->linkTradingAccount(pFactory);
		pPartRoleAccount=getNext();
	}
	endGet();
}

#ifdef COUNT_OPERATION
int addActionForPartProductRole=0;
int updateWithIndexActionForPartProductRole=0;
int updateWithoutIndexActionForPartProductRole=0;
int removeActionForPartProductRole=0;
int addCommitForPartProductRole=0;
int updateCommitForPartProductRole=0;
int removeCommitForPartProductRole=0;
#endif
void CPartProductRoleFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartProductRole.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantProductRoleHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartProductRole_ParticipantProductRoleHashIndex",pParticipantProductRoleHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartProductRole_ParticipantProductRoleHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantProductRoleHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantProductRoleHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartProductRoleActionTrigger *>;
	pCommitTriggers=new vector<CPartProductRoleCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartProductRoleFactory::CPartProductRoleFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartProductRole),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartProductRoleFactory::CPartProductRoleFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartProductRole),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartProductRoleFactory::~CPartProductRoleFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantProductRoleHashIndex!=NULL)
			delete pParticipantProductRoleHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartProductRoleFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartProductRoleFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CPartProductRoleFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartProductRole thisPartProductRole;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartProductRole.readCSV(input,pNames))
		add(&thisPartProductRole);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartProductRoleFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartProductRole.csv");
	return readCSV(szFileName);
}

int CPartProductRoleFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartProductRole *pPartProductRole;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartProductRole::writeCSVHead(output);
	pPartProductRole=(CWriteablePartProductRole *)(pMem->getFirst());
	while (pPartProductRole!=NULL) {
		if (!pPartProductRole->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartProductRole=(CWriteablePartProductRole *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartProductRoleFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartProductRole.csv");
	return writeCSV(szFileName);
}

void CPartProductRoleFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartProductRoleFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartProductRole *pPartProductRole;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartProductRoleFactory={       Total Count=%d\n", pMem->getCount());
	pPartProductRole=(CWriteablePartProductRole *)(pMem->getFirst());
	while (pPartProductRole!=NULL) {
		pPartProductRole->dump(fp,index++);
		pPartProductRole=(CWriteablePartProductRole *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartProductRoleFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantProductRoleHashIndex->removeAll();
	}
}

CPartProductRole *CPartProductRoleFactory::internalAdd(CWriteablePartProductRole *pPartProductRole, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartProductRole++;
#endif
	CPartProductRole *pTarget;	
	beforeAdd(pPartProductRole);
	pTarget=(CPartProductRole *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartProductRole in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartProductRole, sizeof(CPartProductRole));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantProductRoleHashIndex->addObject(pTarget,pTarget->HashParticipantProductRole);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartProductRole *CPartProductRoleFactory::add(CWriteablePartProductRole *pPartProductRole, CTransaction *pTransaction)
{
	pPartProductRole->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartProductRole,true);
	}
	else {
		CPartProductRole *pNewPartProductRole;
		pNewPartProductRole = internalAdd(pPartProductRole,false);
		pTransaction->addResource(CPartProductRoleResource::alloc(CREATE_ACTION,this,pNewPartProductRole,NULL));
		return pNewPartProductRole;
	}
}

void CPartProductRoleFactory::internalUpdate(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pNewPartProductRole, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartProductRole++;
	}
	else {
		updateWithoutIndexActionForPartProductRole++;
	}
#endif
	CWriteablePartProductRole theOldPartProductRole;
	beforeUpdate(pPartProductRole,pNewPartProductRole);
	if (bNoTransaction) {
		forceCopy(&theOldPartProductRole,pPartProductRole,sizeof(CPartProductRole));
	}
	if (updateIndex) {
	}

	forceCopy(pPartProductRole,pNewPartProductRole,sizeof(CPartProductRole));
	pMem->updateObject(pPartProductRole);
	if (updateIndex) {
	}
	afterUpdate(pPartProductRole);
	if (bNoTransaction) {
		commitUpdate(pPartProductRole,&theOldPartProductRole);
	}
}

void CPartProductRoleFactory::update(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pNewPartProductRole, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartProductRole->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartProductRole,pNewPartProductRole,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartProductRoleResource::alloc(UPDATE_ACTION,this,pPartProductRole,pNewPartProductRole,updateIndex));
		internalUpdate(pPartProductRole,pNewPartProductRole,updateIndex,false);
	}
}

void CPartProductRoleFactory::internalRemove(CPartProductRole *pPartProductRole, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartProductRole++;
#endif
	CWriteablePartProductRole theOldPartProductRole;
	beforeRemove(pPartProductRole);
	if (bNoTransaction) {
		forceCopy(&theOldPartProductRole,pPartProductRole,sizeof(CPartProductRole));
	}
	if (runLevel>=0) {
		pParticipantProductRoleHashIndex->removeObject(pPartProductRole,pPartProductRole->HashParticipantProductRole);
	}	
	pMem->free(pPartProductRole);
	if(bNoTransaction) {
		commitRemove(&theOldPartProductRole);
	}
}

void CPartProductRoleFactory::remove(CPartProductRole *pPartProductRole, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartProductRole,true);
	}
	else {
		pTransaction->addResource(CPartProductRoleResource::alloc(DELETE_ACTION,this,pPartProductRole,NULL));
		internalRemove(pPartProductRole,false);		
	}
}

CPartProductRole* CPartProductRoleFactory::addOrUpdate(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pNewPartProductRole, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartProductRole == NULL) {
		return add(pNewPartProductRole,pTransaction);
	}
	else {
		update(pPartProductRole,pNewPartProductRole,pTransaction,updateIndex);
		return pPartProductRole;
	}
}

void CPartProductRoleFactory::retrieve(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pTargetPartProductRole)
{
	forceCopy(pTargetPartProductRole, pPartProductRole, sizeof(CPartProductRole));
}
	
int CPartProductRoleFactory::addActionTrigger(CPartProductRoleActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartProductRoleFactory::removeActionTrigger(CPartProductRoleActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartProductRoleFactory::addCommitTrigger(CPartProductRoleCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartProductRoleFactory::removeCommitTrigger(CPartProductRoleCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartProductRole *CPartProductRoleFactory::getFirst(void)
{
	CPartProductRole *pResult=(CPartProductRole *)(pMem->getFirst());
	return pResult;
}
	
CPartProductRole *CPartProductRoleFactory::getNext(void)
{
	CPartProductRole *pResult=(CPartProductRole *)(pMem->getNext());
	return pResult;
}
	
void CPartProductRoleFactory::endGet(void)
{
	pMem->endGet();
}

void CPartProductRoleFactory::beforeAdd(CWriteablePartProductRole *pPartProductRole)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartProductRole);
	}
}
	
void CPartProductRoleFactory::afterAdd(CPartProductRole *pPartProductRole)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartProductRole);
	}
}

void CPartProductRoleFactory::beforeUpdate(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pNewPartProductRole)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartProductRole,pNewPartProductRole);
	}
}
	
void CPartProductRoleFactory::afterUpdate(CPartProductRole *pPartProductRole)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartProductRole);
	}
}
	
void CPartProductRoleFactory::beforeRemove(CPartProductRole *pPartProductRole)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartProductRole);
	}
}

void CPartProductRoleFactory::commitAdd(CPartProductRole *pPartProductRole)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartProductRole++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartProductRole);
	}
}

void CPartProductRoleFactory::commitUpdate(CPartProductRole *pPartProductRole, CWriteablePartProductRole *pOldPartProductRole)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartProductRole++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartProductRole,pOldPartProductRole);
	}
}
	
void CPartProductRoleFactory::commitRemove(CWriteablePartProductRole *pPartProductRole)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartProductRole++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartProductRole);
	}
}

void CPartProductRoleFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForPartProductRight=0;
int updateWithIndexActionForPartProductRight=0;
int updateWithoutIndexActionForPartProductRight=0;
int removeActionForPartProductRight=0;
int addCommitForPartProductRight=0;
int updateCommitForPartProductRight=0;
int removeCommitForPartProductRight=0;
#endif
void CPartProductRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartProductRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartProductRight_ParticipantAndProductHashIndex",pParticipantAndProductHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartProductRight_ParticipantAndProductHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantAndProductHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartProductRightActionTrigger *>;
	pCommitTriggers=new vector<CPartProductRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartProductRightFactory::CPartProductRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartProductRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartProductRightFactory::CPartProductRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartProductRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartProductRightFactory::~CPartProductRightFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantAndProductHashIndex!=NULL)
			delete pParticipantAndProductHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartProductRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartProductRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CPartProductRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartProductRight thisPartProductRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartProductRight.readCSV(input,pNames))
		add(&thisPartProductRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartProductRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartProductRight.csv");
	return readCSV(szFileName);
}

int CPartProductRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartProductRight *pPartProductRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartProductRight::writeCSVHead(output);
	pPartProductRight=(CWriteablePartProductRight *)(pMem->getFirst());
	while (pPartProductRight!=NULL) {
		if (!pPartProductRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartProductRight=(CWriteablePartProductRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartProductRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartProductRight.csv");
	return writeCSV(szFileName);
}

void CPartProductRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartProductRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartProductRight *pPartProductRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartProductRightFactory={       Total Count=%d\n", pMem->getCount());
	pPartProductRight=(CWriteablePartProductRight *)(pMem->getFirst());
	while (pPartProductRight!=NULL) {
		pPartProductRight->dump(fp,index++);
		pPartProductRight=(CWriteablePartProductRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartProductRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantAndProductHashIndex->removeAll();
	}
}

CPartProductRight *CPartProductRightFactory::internalAdd(CWriteablePartProductRight *pPartProductRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartProductRight++;
#endif
	CPartProductRight *pTarget;	
	beforeAdd(pPartProductRight);
	pTarget=(CPartProductRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartProductRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartProductRight, sizeof(CPartProductRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantAndProductHashIndex->addObject(pTarget,pTarget->HashParticipantAndProduct);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartProductRight *CPartProductRightFactory::add(CWriteablePartProductRight *pPartProductRight, CTransaction *pTransaction)
{
	pPartProductRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartProductRight,true);
	}
	else {
		CPartProductRight *pNewPartProductRight;
		pNewPartProductRight = internalAdd(pPartProductRight,false);
		pTransaction->addResource(CPartProductRightResource::alloc(CREATE_ACTION,this,pNewPartProductRight,NULL));
		return pNewPartProductRight;
	}
}

void CPartProductRightFactory::internalUpdate(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pNewPartProductRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartProductRight++;
	}
	else {
		updateWithoutIndexActionForPartProductRight++;
	}
#endif
	CWriteablePartProductRight theOldPartProductRight;
	beforeUpdate(pPartProductRight,pNewPartProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartProductRight,pPartProductRight,sizeof(CPartProductRight));
	}
	if (updateIndex) {
	}

	forceCopy(pPartProductRight,pNewPartProductRight,sizeof(CPartProductRight));
	pMem->updateObject(pPartProductRight);
	if (updateIndex) {
	}
	afterUpdate(pPartProductRight);
	if (bNoTransaction) {
		commitUpdate(pPartProductRight,&theOldPartProductRight);
	}
}

void CPartProductRightFactory::update(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pNewPartProductRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartProductRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartProductRight,pNewPartProductRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartProductRightResource::alloc(UPDATE_ACTION,this,pPartProductRight,pNewPartProductRight,updateIndex));
		internalUpdate(pPartProductRight,pNewPartProductRight,updateIndex,false);
	}
}

void CPartProductRightFactory::internalRemove(CPartProductRight *pPartProductRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartProductRight++;
#endif
	CWriteablePartProductRight theOldPartProductRight;
	beforeRemove(pPartProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartProductRight,pPartProductRight,sizeof(CPartProductRight));
	}
	if (runLevel>=0) {
		pParticipantAndProductHashIndex->removeObject(pPartProductRight,pPartProductRight->HashParticipantAndProduct);
	}	
	pMem->free(pPartProductRight);
	if(bNoTransaction) {
		commitRemove(&theOldPartProductRight);
	}
}

void CPartProductRightFactory::remove(CPartProductRight *pPartProductRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartProductRight,true);
	}
	else {
		pTransaction->addResource(CPartProductRightResource::alloc(DELETE_ACTION,this,pPartProductRight,NULL));
		internalRemove(pPartProductRight,false);		
	}
}

CPartProductRight* CPartProductRightFactory::addOrUpdate(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pNewPartProductRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartProductRight == NULL) {
		return add(pNewPartProductRight,pTransaction);
	}
	else {
		update(pPartProductRight,pNewPartProductRight,pTransaction,updateIndex);
		return pPartProductRight;
	}
}

void CPartProductRightFactory::retrieve(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pTargetPartProductRight)
{
	forceCopy(pTargetPartProductRight, pPartProductRight, sizeof(CPartProductRight));
}
	
int CPartProductRightFactory::addActionTrigger(CPartProductRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartProductRightFactory::removeActionTrigger(CPartProductRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartProductRightFactory::addCommitTrigger(CPartProductRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartProductRightFactory::removeCommitTrigger(CPartProductRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartProductRight *CPartProductRightFactory::getFirst(void)
{
	CPartProductRight *pResult=(CPartProductRight *)(pMem->getFirst());
	return pResult;
}
	
CPartProductRight *CPartProductRightFactory::getNext(void)
{
	CPartProductRight *pResult=(CPartProductRight *)(pMem->getNext());
	return pResult;
}
	
void CPartProductRightFactory::endGet(void)
{
	pMem->endGet();
}

void CPartProductRightFactory::beforeAdd(CWriteablePartProductRight *pPartProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartProductRight);
	}
}
	
void CPartProductRightFactory::afterAdd(CPartProductRight *pPartProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartProductRight);
	}
}

void CPartProductRightFactory::beforeUpdate(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pNewPartProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartProductRight,pNewPartProductRight);
	}
}
	
void CPartProductRightFactory::afterUpdate(CPartProductRight *pPartProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartProductRight);
	}
}
	
void CPartProductRightFactory::beforeRemove(CPartProductRight *pPartProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartProductRight);
	}
}

void CPartProductRightFactory::commitAdd(CPartProductRight *pPartProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartProductRight);
	}
}

void CPartProductRightFactory::commitUpdate(CPartProductRight *pPartProductRight, CWriteablePartProductRight *pOldPartProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartProductRight,pOldPartProductRight);
	}
}
	
void CPartProductRightFactory::commitRemove(CWriteablePartProductRight *pPartProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartProductRight);
	}
}

void CPartProductRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForPartInstrumentRight=0;
int updateWithIndexActionForPartInstrumentRight=0;
int updateWithoutIndexActionForPartInstrumentRight=0;
int removeActionForPartInstrumentRight=0;
int addCommitForPartInstrumentRight=0;
int updateCommitForPartInstrumentRight=0;
int removeCommitForPartInstrumentRight=0;
#endif
void CPartInstrumentRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartInstrumentRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartInstrumentRight_ParticipantAndInstrumentHashIndex",pParticipantAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartInstrumentRight_ParticipantAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartInstrumentRightActionTrigger *>;
	pCommitTriggers=new vector<CPartInstrumentRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartInstrumentRightFactory::CPartInstrumentRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartInstrumentRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartInstrumentRightFactory::CPartInstrumentRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartInstrumentRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartInstrumentRightFactory::~CPartInstrumentRightFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantAndInstrumentHashIndex!=NULL)
			delete pParticipantAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartInstrumentRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartInstrumentRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CPartInstrumentRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartInstrumentRight thisPartInstrumentRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartInstrumentRight.readCSV(input,pNames))
		add(&thisPartInstrumentRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartInstrumentRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartInstrumentRight.csv");
	return readCSV(szFileName);
}

int CPartInstrumentRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartInstrumentRight *pPartInstrumentRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartInstrumentRight::writeCSVHead(output);
	pPartInstrumentRight=(CWriteablePartInstrumentRight *)(pMem->getFirst());
	while (pPartInstrumentRight!=NULL) {
		if (!pPartInstrumentRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartInstrumentRight=(CWriteablePartInstrumentRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartInstrumentRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartInstrumentRight.csv");
	return writeCSV(szFileName);
}

void CPartInstrumentRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartInstrumentRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartInstrumentRight *pPartInstrumentRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartInstrumentRightFactory={       Total Count=%d\n", pMem->getCount());
	pPartInstrumentRight=(CWriteablePartInstrumentRight *)(pMem->getFirst());
	while (pPartInstrumentRight!=NULL) {
		pPartInstrumentRight->dump(fp,index++);
		pPartInstrumentRight=(CWriteablePartInstrumentRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartInstrumentRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantAndInstrumentHashIndex->removeAll();
	}
}

CPartInstrumentRight *CPartInstrumentRightFactory::internalAdd(CWriteablePartInstrumentRight *pPartInstrumentRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartInstrumentRight++;
#endif
	CPartInstrumentRight *pTarget;	
	beforeAdd(pPartInstrumentRight);
	pTarget=(CPartInstrumentRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartInstrumentRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartInstrumentRight, sizeof(CPartInstrumentRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantAndInstrumentHashIndex->addObject(pTarget,pTarget->HashParticipantAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartInstrumentRight *CPartInstrumentRightFactory::add(CWriteablePartInstrumentRight *pPartInstrumentRight, CTransaction *pTransaction)
{
	pPartInstrumentRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartInstrumentRight,true);
	}
	else {
		CPartInstrumentRight *pNewPartInstrumentRight;
		pNewPartInstrumentRight = internalAdd(pPartInstrumentRight,false);
		pTransaction->addResource(CPartInstrumentRightResource::alloc(CREATE_ACTION,this,pNewPartInstrumentRight,NULL));
		return pNewPartInstrumentRight;
	}
}

void CPartInstrumentRightFactory::internalUpdate(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pNewPartInstrumentRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartInstrumentRight++;
	}
	else {
		updateWithoutIndexActionForPartInstrumentRight++;
	}
#endif
	CWriteablePartInstrumentRight theOldPartInstrumentRight;
	beforeUpdate(pPartInstrumentRight,pNewPartInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartInstrumentRight,pPartInstrumentRight,sizeof(CPartInstrumentRight));
	}
	if (updateIndex) {
	}

	forceCopy(pPartInstrumentRight,pNewPartInstrumentRight,sizeof(CPartInstrumentRight));
	pMem->updateObject(pPartInstrumentRight);
	if (updateIndex) {
	}
	afterUpdate(pPartInstrumentRight);
	if (bNoTransaction) {
		commitUpdate(pPartInstrumentRight,&theOldPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::update(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pNewPartInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartInstrumentRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartInstrumentRight,pNewPartInstrumentRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartInstrumentRightResource::alloc(UPDATE_ACTION,this,pPartInstrumentRight,pNewPartInstrumentRight,updateIndex));
		internalUpdate(pPartInstrumentRight,pNewPartInstrumentRight,updateIndex,false);
	}
}

void CPartInstrumentRightFactory::internalRemove(CPartInstrumentRight *pPartInstrumentRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartInstrumentRight++;
#endif
	CWriteablePartInstrumentRight theOldPartInstrumentRight;
	beforeRemove(pPartInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartInstrumentRight,pPartInstrumentRight,sizeof(CPartInstrumentRight));
	}
	if (runLevel>=0) {
		pParticipantAndInstrumentHashIndex->removeObject(pPartInstrumentRight,pPartInstrumentRight->HashParticipantAndInstrument);
	}	
	pMem->free(pPartInstrumentRight);
	if(bNoTransaction) {
		commitRemove(&theOldPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::remove(CPartInstrumentRight *pPartInstrumentRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartInstrumentRight,true);
	}
	else {
		pTransaction->addResource(CPartInstrumentRightResource::alloc(DELETE_ACTION,this,pPartInstrumentRight,NULL));
		internalRemove(pPartInstrumentRight,false);		
	}
}

CPartInstrumentRight* CPartInstrumentRightFactory::addOrUpdate(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pNewPartInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartInstrumentRight == NULL) {
		return add(pNewPartInstrumentRight,pTransaction);
	}
	else {
		update(pPartInstrumentRight,pNewPartInstrumentRight,pTransaction,updateIndex);
		return pPartInstrumentRight;
	}
}

void CPartInstrumentRightFactory::retrieve(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pTargetPartInstrumentRight)
{
	forceCopy(pTargetPartInstrumentRight, pPartInstrumentRight, sizeof(CPartInstrumentRight));
}
	
int CPartInstrumentRightFactory::addActionTrigger(CPartInstrumentRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartInstrumentRightFactory::removeActionTrigger(CPartInstrumentRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartInstrumentRightFactory::addCommitTrigger(CPartInstrumentRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartInstrumentRightFactory::removeCommitTrigger(CPartInstrumentRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartInstrumentRight *CPartInstrumentRightFactory::getFirst(void)
{
	CPartInstrumentRight *pResult=(CPartInstrumentRight *)(pMem->getFirst());
	return pResult;
}
	
CPartInstrumentRight *CPartInstrumentRightFactory::getNext(void)
{
	CPartInstrumentRight *pResult=(CPartInstrumentRight *)(pMem->getNext());
	return pResult;
}
	
void CPartInstrumentRightFactory::endGet(void)
{
	pMem->endGet();
}

void CPartInstrumentRightFactory::beforeAdd(CWriteablePartInstrumentRight *pPartInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartInstrumentRight);
	}
}
	
void CPartInstrumentRightFactory::afterAdd(CPartInstrumentRight *pPartInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::beforeUpdate(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pNewPartInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartInstrumentRight,pNewPartInstrumentRight);
	}
}
	
void CPartInstrumentRightFactory::afterUpdate(CPartInstrumentRight *pPartInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartInstrumentRight);
	}
}
	
void CPartInstrumentRightFactory::beforeRemove(CPartInstrumentRight *pPartInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::commitAdd(CPartInstrumentRight *pPartInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::commitUpdate(CPartInstrumentRight *pPartInstrumentRight, CWriteablePartInstrumentRight *pOldPartInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartInstrumentRight,pOldPartInstrumentRight);
	}
}
	
void CPartInstrumentRightFactory::commitRemove(CWriteablePartInstrumentRight *pPartInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartInstrumentRight);
	}
}

void CPartInstrumentRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForClientProductRight=0;
int updateWithIndexActionForClientProductRight=0;
int updateWithoutIndexActionForClientProductRight=0;
int removeActionForClientProductRight=0;
int addCommitForClientProductRight=0;
int updateCommitForClientProductRight=0;
int removeCommitForClientProductRight=0;
#endif
void CClientProductRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("ClientProductRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pClientAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientProductRight_ClientAndProductHashIndex",pClientAndProductHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientProductRight_ClientAndProductHashIndex");
			if(it != pIndexMap->end()) {
				pClientAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientAndProductHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CClientProductRightActionTrigger *>;
	pCommitTriggers=new vector<CClientProductRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClientProductRightFactory::CClientProductRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientProductRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClientProductRightFactory::CClientProductRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientProductRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClientProductRightFactory::~CClientProductRightFactory(void)
{
	if (runLevel>=0) {
		if (pClientAndProductHashIndex!=NULL)
			delete pClientAndProductHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClientProductRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClientProductRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CClientProductRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClientProductRight thisClientProductRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClientProductRight.readCSV(input,pNames))
		add(&thisClientProductRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CClientProductRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ClientProductRight.csv");
	return readCSV(szFileName);
}

int CClientProductRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClientProductRight *pClientProductRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClientProductRight::writeCSVHead(output);
	pClientProductRight=(CWriteableClientProductRight *)(pMem->getFirst());
	while (pClientProductRight!=NULL) {
		if (!pClientProductRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClientProductRight=(CWriteableClientProductRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClientProductRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ClientProductRight.csv");
	return writeCSV(szFileName);
}

void CClientProductRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClientProductRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClientProductRight *pClientProductRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClientProductRightFactory={       Total Count=%d\n", pMem->getCount());
	pClientProductRight=(CWriteableClientProductRight *)(pMem->getFirst());
	while (pClientProductRight!=NULL) {
		pClientProductRight->dump(fp,index++);
		pClientProductRight=(CWriteableClientProductRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClientProductRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pClientAndProductHashIndex->removeAll();
	}
}

CClientProductRight *CClientProductRightFactory::internalAdd(CWriteableClientProductRight *pClientProductRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClientProductRight++;
#endif
	CClientProductRight *pTarget;	
	beforeAdd(pClientProductRight);
	pTarget=(CClientProductRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ClientProductRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClientProductRight, sizeof(CClientProductRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pClientAndProductHashIndex->addObject(pTarget,pTarget->HashClientAndProduct);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClientProductRight *CClientProductRightFactory::add(CWriteableClientProductRight *pClientProductRight, CTransaction *pTransaction)
{
	pClientProductRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClientProductRight,true);
	}
	else {
		CClientProductRight *pNewClientProductRight;
		pNewClientProductRight = internalAdd(pClientProductRight,false);
		pTransaction->addResource(CClientProductRightResource::alloc(CREATE_ACTION,this,pNewClientProductRight,NULL));
		return pNewClientProductRight;
	}
}

void CClientProductRightFactory::internalUpdate(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pNewClientProductRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClientProductRight++;
	}
	else {
		updateWithoutIndexActionForClientProductRight++;
	}
#endif
	CWriteableClientProductRight theOldClientProductRight;
	beforeUpdate(pClientProductRight,pNewClientProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldClientProductRight,pClientProductRight,sizeof(CClientProductRight));
	}
	if (updateIndex) {
	}

	forceCopy(pClientProductRight,pNewClientProductRight,sizeof(CClientProductRight));
	pMem->updateObject(pClientProductRight);
	if (updateIndex) {
	}
	afterUpdate(pClientProductRight);
	if (bNoTransaction) {
		commitUpdate(pClientProductRight,&theOldClientProductRight);
	}
}

void CClientProductRightFactory::update(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pNewClientProductRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewClientProductRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClientProductRight,pNewClientProductRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClientProductRightResource::alloc(UPDATE_ACTION,this,pClientProductRight,pNewClientProductRight,updateIndex));
		internalUpdate(pClientProductRight,pNewClientProductRight,updateIndex,false);
	}
}

void CClientProductRightFactory::internalRemove(CClientProductRight *pClientProductRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClientProductRight++;
#endif
	CWriteableClientProductRight theOldClientProductRight;
	beforeRemove(pClientProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldClientProductRight,pClientProductRight,sizeof(CClientProductRight));
	}
	if (runLevel>=0) {
		pClientAndProductHashIndex->removeObject(pClientProductRight,pClientProductRight->HashClientAndProduct);
	}	
	pMem->free(pClientProductRight);
	if(bNoTransaction) {
		commitRemove(&theOldClientProductRight);
	}
}

void CClientProductRightFactory::remove(CClientProductRight *pClientProductRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClientProductRight,true);
	}
	else {
		pTransaction->addResource(CClientProductRightResource::alloc(DELETE_ACTION,this,pClientProductRight,NULL));
		internalRemove(pClientProductRight,false);		
	}
}

CClientProductRight* CClientProductRightFactory::addOrUpdate(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pNewClientProductRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pClientProductRight == NULL) {
		return add(pNewClientProductRight,pTransaction);
	}
	else {
		update(pClientProductRight,pNewClientProductRight,pTransaction,updateIndex);
		return pClientProductRight;
	}
}

void CClientProductRightFactory::retrieve(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pTargetClientProductRight)
{
	forceCopy(pTargetClientProductRight, pClientProductRight, sizeof(CClientProductRight));
}
	
int CClientProductRightFactory::addActionTrigger(CClientProductRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClientProductRightFactory::removeActionTrigger(CClientProductRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClientProductRightFactory::addCommitTrigger(CClientProductRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClientProductRightFactory::removeCommitTrigger(CClientProductRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClientProductRight *CClientProductRightFactory::getFirst(void)
{
	CClientProductRight *pResult=(CClientProductRight *)(pMem->getFirst());
	return pResult;
}
	
CClientProductRight *CClientProductRightFactory::getNext(void)
{
	CClientProductRight *pResult=(CClientProductRight *)(pMem->getNext());
	return pResult;
}
	
void CClientProductRightFactory::endGet(void)
{
	pMem->endGet();
}

void CClientProductRightFactory::beforeAdd(CWriteableClientProductRight *pClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClientProductRight);
	}
}
	
void CClientProductRightFactory::afterAdd(CClientProductRight *pClientProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClientProductRight);
	}
}

void CClientProductRightFactory::beforeUpdate(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pNewClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClientProductRight,pNewClientProductRight);
	}
}
	
void CClientProductRightFactory::afterUpdate(CClientProductRight *pClientProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClientProductRight);
	}
}
	
void CClientProductRightFactory::beforeRemove(CClientProductRight *pClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClientProductRight);
	}
}

void CClientProductRightFactory::commitAdd(CClientProductRight *pClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClientProductRight);
	}
}

void CClientProductRightFactory::commitUpdate(CClientProductRight *pClientProductRight, CWriteableClientProductRight *pOldClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClientProductRight,pOldClientProductRight);
	}
}
	
void CClientProductRightFactory::commitRemove(CWriteableClientProductRight *pClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClientProductRight);
	}
}

void CClientProductRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForClientInstrumentRight=0;
int updateWithIndexActionForClientInstrumentRight=0;
int updateWithoutIndexActionForClientInstrumentRight=0;
int removeActionForClientInstrumentRight=0;
int addCommitForClientInstrumentRight=0;
int updateCommitForClientInstrumentRight=0;
int removeCommitForClientInstrumentRight=0;
#endif
void CClientInstrumentRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("ClientInstrumentRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientInstrumentRight_ClientAndInstrumentHashIndex",pClientAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientInstrumentRight_ClientAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CClientInstrumentRightActionTrigger *>;
	pCommitTriggers=new vector<CClientInstrumentRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClientInstrumentRightFactory::CClientInstrumentRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientInstrumentRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClientInstrumentRightFactory::CClientInstrumentRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientInstrumentRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClientInstrumentRightFactory::~CClientInstrumentRightFactory(void)
{
	if (runLevel>=0) {
		if (pClientAndInstrumentHashIndex!=NULL)
			delete pClientAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClientInstrumentRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClientInstrumentRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CClientInstrumentRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClientInstrumentRight thisClientInstrumentRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClientInstrumentRight.readCSV(input,pNames))
		add(&thisClientInstrumentRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CClientInstrumentRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ClientInstrumentRight.csv");
	return readCSV(szFileName);
}

int CClientInstrumentRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClientInstrumentRight *pClientInstrumentRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClientInstrumentRight::writeCSVHead(output);
	pClientInstrumentRight=(CWriteableClientInstrumentRight *)(pMem->getFirst());
	while (pClientInstrumentRight!=NULL) {
		if (!pClientInstrumentRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClientInstrumentRight=(CWriteableClientInstrumentRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClientInstrumentRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ClientInstrumentRight.csv");
	return writeCSV(szFileName);
}

void CClientInstrumentRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClientInstrumentRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClientInstrumentRight *pClientInstrumentRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClientInstrumentRightFactory={       Total Count=%d\n", pMem->getCount());
	pClientInstrumentRight=(CWriteableClientInstrumentRight *)(pMem->getFirst());
	while (pClientInstrumentRight!=NULL) {
		pClientInstrumentRight->dump(fp,index++);
		pClientInstrumentRight=(CWriteableClientInstrumentRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClientInstrumentRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->removeAll();
	}
}

CClientInstrumentRight *CClientInstrumentRightFactory::internalAdd(CWriteableClientInstrumentRight *pClientInstrumentRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClientInstrumentRight++;
#endif
	CClientInstrumentRight *pTarget;	
	beforeAdd(pClientInstrumentRight);
	pTarget=(CClientInstrumentRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ClientInstrumentRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClientInstrumentRight, sizeof(CClientInstrumentRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->addObject(pTarget,pTarget->HashClientAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClientInstrumentRight *CClientInstrumentRightFactory::add(CWriteableClientInstrumentRight *pClientInstrumentRight, CTransaction *pTransaction)
{
	pClientInstrumentRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClientInstrumentRight,true);
	}
	else {
		CClientInstrumentRight *pNewClientInstrumentRight;
		pNewClientInstrumentRight = internalAdd(pClientInstrumentRight,false);
		pTransaction->addResource(CClientInstrumentRightResource::alloc(CREATE_ACTION,this,pNewClientInstrumentRight,NULL));
		return pNewClientInstrumentRight;
	}
}

void CClientInstrumentRightFactory::internalUpdate(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pNewClientInstrumentRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClientInstrumentRight++;
	}
	else {
		updateWithoutIndexActionForClientInstrumentRight++;
	}
#endif
	CWriteableClientInstrumentRight theOldClientInstrumentRight;
	beforeUpdate(pClientInstrumentRight,pNewClientInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldClientInstrumentRight,pClientInstrumentRight,sizeof(CClientInstrumentRight));
	}
	if (updateIndex) {
	}

	forceCopy(pClientInstrumentRight,pNewClientInstrumentRight,sizeof(CClientInstrumentRight));
	pMem->updateObject(pClientInstrumentRight);
	if (updateIndex) {
	}
	afterUpdate(pClientInstrumentRight);
	if (bNoTransaction) {
		commitUpdate(pClientInstrumentRight,&theOldClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::update(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pNewClientInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewClientInstrumentRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClientInstrumentRight,pNewClientInstrumentRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClientInstrumentRightResource::alloc(UPDATE_ACTION,this,pClientInstrumentRight,pNewClientInstrumentRight,updateIndex));
		internalUpdate(pClientInstrumentRight,pNewClientInstrumentRight,updateIndex,false);
	}
}

void CClientInstrumentRightFactory::internalRemove(CClientInstrumentRight *pClientInstrumentRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClientInstrumentRight++;
#endif
	CWriteableClientInstrumentRight theOldClientInstrumentRight;
	beforeRemove(pClientInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldClientInstrumentRight,pClientInstrumentRight,sizeof(CClientInstrumentRight));
	}
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->removeObject(pClientInstrumentRight,pClientInstrumentRight->HashClientAndInstrument);
	}	
	pMem->free(pClientInstrumentRight);
	if(bNoTransaction) {
		commitRemove(&theOldClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::remove(CClientInstrumentRight *pClientInstrumentRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClientInstrumentRight,true);
	}
	else {
		pTransaction->addResource(CClientInstrumentRightResource::alloc(DELETE_ACTION,this,pClientInstrumentRight,NULL));
		internalRemove(pClientInstrumentRight,false);		
	}
}

CClientInstrumentRight* CClientInstrumentRightFactory::addOrUpdate(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pNewClientInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pClientInstrumentRight == NULL) {
		return add(pNewClientInstrumentRight,pTransaction);
	}
	else {
		update(pClientInstrumentRight,pNewClientInstrumentRight,pTransaction,updateIndex);
		return pClientInstrumentRight;
	}
}

void CClientInstrumentRightFactory::retrieve(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pTargetClientInstrumentRight)
{
	forceCopy(pTargetClientInstrumentRight, pClientInstrumentRight, sizeof(CClientInstrumentRight));
}
	
int CClientInstrumentRightFactory::addActionTrigger(CClientInstrumentRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClientInstrumentRightFactory::removeActionTrigger(CClientInstrumentRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClientInstrumentRightFactory::addCommitTrigger(CClientInstrumentRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClientInstrumentRightFactory::removeCommitTrigger(CClientInstrumentRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClientInstrumentRight *CClientInstrumentRightFactory::getFirst(void)
{
	CClientInstrumentRight *pResult=(CClientInstrumentRight *)(pMem->getFirst());
	return pResult;
}
	
CClientInstrumentRight *CClientInstrumentRightFactory::getNext(void)
{
	CClientInstrumentRight *pResult=(CClientInstrumentRight *)(pMem->getNext());
	return pResult;
}
	
void CClientInstrumentRightFactory::endGet(void)
{
	pMem->endGet();
}

void CClientInstrumentRightFactory::beforeAdd(CWriteableClientInstrumentRight *pClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClientInstrumentRight);
	}
}
	
void CClientInstrumentRightFactory::afterAdd(CClientInstrumentRight *pClientInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::beforeUpdate(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pNewClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClientInstrumentRight,pNewClientInstrumentRight);
	}
}
	
void CClientInstrumentRightFactory::afterUpdate(CClientInstrumentRight *pClientInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClientInstrumentRight);
	}
}
	
void CClientInstrumentRightFactory::beforeRemove(CClientInstrumentRight *pClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::commitAdd(CClientInstrumentRight *pClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::commitUpdate(CClientInstrumentRight *pClientInstrumentRight, CWriteableClientInstrumentRight *pOldClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClientInstrumentRight,pOldClientInstrumentRight);
	}
}
	
void CClientInstrumentRightFactory::commitRemove(CWriteableClientInstrumentRight *pClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClientInstrumentRight);
	}
}

void CClientInstrumentRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForPartClientProductRight=0;
int updateWithIndexActionForPartClientProductRight=0;
int updateWithoutIndexActionForPartClientProductRight=0;
int removeActionForPartClientProductRight=0;
int addCommitForPartClientProductRight=0;
int updateCommitForPartClientProductRight=0;
int removeCommitForPartClientProductRight=0;
#endif
void CPartClientProductRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartClientProductRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantAndClientAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartClientProductRight_ParticipantAndClientAndProductHashIndex",pParticipantAndClientAndProductHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartClientProductRight_ParticipantAndClientAndProductHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantAndClientAndProductHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantAndClientAndProductHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartClientProductRightActionTrigger *>;
	pCommitTriggers=new vector<CPartClientProductRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartClientProductRightFactory::CPartClientProductRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClientProductRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartClientProductRightFactory::CPartClientProductRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClientProductRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartClientProductRightFactory::~CPartClientProductRightFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantAndClientAndProductHashIndex!=NULL)
			delete pParticipantAndClientAndProductHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartClientProductRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartClientProductRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CPartClientProductRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartClientProductRight thisPartClientProductRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartClientProductRight.readCSV(input,pNames))
		add(&thisPartClientProductRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartClientProductRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartClientProductRight.csv");
	return readCSV(szFileName);
}

int CPartClientProductRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartClientProductRight *pPartClientProductRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartClientProductRight::writeCSVHead(output);
	pPartClientProductRight=(CWriteablePartClientProductRight *)(pMem->getFirst());
	while (pPartClientProductRight!=NULL) {
		if (!pPartClientProductRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartClientProductRight=(CWriteablePartClientProductRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartClientProductRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartClientProductRight.csv");
	return writeCSV(szFileName);
}

void CPartClientProductRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartClientProductRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartClientProductRight *pPartClientProductRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartClientProductRightFactory={       Total Count=%d\n", pMem->getCount());
	pPartClientProductRight=(CWriteablePartClientProductRight *)(pMem->getFirst());
	while (pPartClientProductRight!=NULL) {
		pPartClientProductRight->dump(fp,index++);
		pPartClientProductRight=(CWriteablePartClientProductRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartClientProductRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantAndClientAndProductHashIndex->removeAll();
	}
}

CPartClientProductRight *CPartClientProductRightFactory::internalAdd(CWriteablePartClientProductRight *pPartClientProductRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartClientProductRight++;
#endif
	CPartClientProductRight *pTarget;	
	beforeAdd(pPartClientProductRight);
	pTarget=(CPartClientProductRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartClientProductRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartClientProductRight, sizeof(CPartClientProductRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantAndClientAndProductHashIndex->addObject(pTarget,pTarget->HashParticipantAndClientAndProduct);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartClientProductRight *CPartClientProductRightFactory::add(CWriteablePartClientProductRight *pPartClientProductRight, CTransaction *pTransaction)
{
	pPartClientProductRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartClientProductRight,true);
	}
	else {
		CPartClientProductRight *pNewPartClientProductRight;
		pNewPartClientProductRight = internalAdd(pPartClientProductRight,false);
		pTransaction->addResource(CPartClientProductRightResource::alloc(CREATE_ACTION,this,pNewPartClientProductRight,NULL));
		return pNewPartClientProductRight;
	}
}

void CPartClientProductRightFactory::internalUpdate(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pNewPartClientProductRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartClientProductRight++;
	}
	else {
		updateWithoutIndexActionForPartClientProductRight++;
	}
#endif
	CWriteablePartClientProductRight theOldPartClientProductRight;
	beforeUpdate(pPartClientProductRight,pNewPartClientProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartClientProductRight,pPartClientProductRight,sizeof(CPartClientProductRight));
	}
	if (updateIndex) {
	}

	forceCopy(pPartClientProductRight,pNewPartClientProductRight,sizeof(CPartClientProductRight));
	pMem->updateObject(pPartClientProductRight);
	if (updateIndex) {
	}
	afterUpdate(pPartClientProductRight);
	if (bNoTransaction) {
		commitUpdate(pPartClientProductRight,&theOldPartClientProductRight);
	}
}

void CPartClientProductRightFactory::update(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pNewPartClientProductRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartClientProductRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartClientProductRight,pNewPartClientProductRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartClientProductRightResource::alloc(UPDATE_ACTION,this,pPartClientProductRight,pNewPartClientProductRight,updateIndex));
		internalUpdate(pPartClientProductRight,pNewPartClientProductRight,updateIndex,false);
	}
}

void CPartClientProductRightFactory::internalRemove(CPartClientProductRight *pPartClientProductRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartClientProductRight++;
#endif
	CWriteablePartClientProductRight theOldPartClientProductRight;
	beforeRemove(pPartClientProductRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartClientProductRight,pPartClientProductRight,sizeof(CPartClientProductRight));
	}
	if (runLevel>=0) {
		pParticipantAndClientAndProductHashIndex->removeObject(pPartClientProductRight,pPartClientProductRight->HashParticipantAndClientAndProduct);
	}	
	pMem->free(pPartClientProductRight);
	if(bNoTransaction) {
		commitRemove(&theOldPartClientProductRight);
	}
}

void CPartClientProductRightFactory::remove(CPartClientProductRight *pPartClientProductRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartClientProductRight,true);
	}
	else {
		pTransaction->addResource(CPartClientProductRightResource::alloc(DELETE_ACTION,this,pPartClientProductRight,NULL));
		internalRemove(pPartClientProductRight,false);		
	}
}

CPartClientProductRight* CPartClientProductRightFactory::addOrUpdate(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pNewPartClientProductRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartClientProductRight == NULL) {
		return add(pNewPartClientProductRight,pTransaction);
	}
	else {
		update(pPartClientProductRight,pNewPartClientProductRight,pTransaction,updateIndex);
		return pPartClientProductRight;
	}
}

void CPartClientProductRightFactory::retrieve(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pTargetPartClientProductRight)
{
	forceCopy(pTargetPartClientProductRight, pPartClientProductRight, sizeof(CPartClientProductRight));
}
	
int CPartClientProductRightFactory::addActionTrigger(CPartClientProductRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartClientProductRightFactory::removeActionTrigger(CPartClientProductRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartClientProductRightFactory::addCommitTrigger(CPartClientProductRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartClientProductRightFactory::removeCommitTrigger(CPartClientProductRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartClientProductRight *CPartClientProductRightFactory::getFirst(void)
{
	CPartClientProductRight *pResult=(CPartClientProductRight *)(pMem->getFirst());
	return pResult;
}
	
CPartClientProductRight *CPartClientProductRightFactory::getNext(void)
{
	CPartClientProductRight *pResult=(CPartClientProductRight *)(pMem->getNext());
	return pResult;
}
	
void CPartClientProductRightFactory::endGet(void)
{
	pMem->endGet();
}

void CPartClientProductRightFactory::beforeAdd(CWriteablePartClientProductRight *pPartClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartClientProductRight);
	}
}
	
void CPartClientProductRightFactory::afterAdd(CPartClientProductRight *pPartClientProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartClientProductRight);
	}
}

void CPartClientProductRightFactory::beforeUpdate(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pNewPartClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartClientProductRight,pNewPartClientProductRight);
	}
}
	
void CPartClientProductRightFactory::afterUpdate(CPartClientProductRight *pPartClientProductRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartClientProductRight);
	}
}
	
void CPartClientProductRightFactory::beforeRemove(CPartClientProductRight *pPartClientProductRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartClientProductRight);
	}
}

void CPartClientProductRightFactory::commitAdd(CPartClientProductRight *pPartClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartClientProductRight);
	}
}

void CPartClientProductRightFactory::commitUpdate(CPartClientProductRight *pPartClientProductRight, CWriteablePartClientProductRight *pOldPartClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartClientProductRight,pOldPartClientProductRight);
	}
}
	
void CPartClientProductRightFactory::commitRemove(CWriteablePartClientProductRight *pPartClientProductRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartClientProductRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartClientProductRight);
	}
}

void CPartClientProductRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForPartClientInstrumentRight=0;
int updateWithIndexActionForPartClientInstrumentRight=0;
int updateWithoutIndexActionForPartClientInstrumentRight=0;
int removeActionForPartClientInstrumentRight=0;
int addCommitForPartClientInstrumentRight=0;
int updateCommitForPartClientInstrumentRight=0;
int removeCommitForPartClientInstrumentRight=0;
#endif
void CPartClientInstrumentRightFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartClientInstrumentRight.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pParticipantAndClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartClientInstrumentRight_ParticipantAndClientAndInstrumentHashIndex",pParticipantAndClientAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartClientInstrumentRight_ParticipantAndClientAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pParticipantAndClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantAndClientAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartClientInstrumentRightActionTrigger *>;
	pCommitTriggers=new vector<CPartClientInstrumentRightCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartClientInstrumentRightFactory::CPartClientInstrumentRightFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClientInstrumentRight),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartClientInstrumentRightFactory::CPartClientInstrumentRightFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartClientInstrumentRight),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartClientInstrumentRightFactory::~CPartClientInstrumentRightFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantAndClientAndInstrumentHashIndex!=NULL)
			delete pParticipantAndClientAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartClientInstrumentRightFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartClientInstrumentRightFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CPartClientInstrumentRightFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartClientInstrumentRight thisPartClientInstrumentRight;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartClientInstrumentRight.readCSV(input,pNames))
		add(&thisPartClientInstrumentRight);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartClientInstrumentRightFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartClientInstrumentRight.csv");
	return readCSV(szFileName);
}

int CPartClientInstrumentRightFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartClientInstrumentRight *pPartClientInstrumentRight;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartClientInstrumentRight::writeCSVHead(output);
	pPartClientInstrumentRight=(CWriteablePartClientInstrumentRight *)(pMem->getFirst());
	while (pPartClientInstrumentRight!=NULL) {
		if (!pPartClientInstrumentRight->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartClientInstrumentRight=(CWriteablePartClientInstrumentRight *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartClientInstrumentRightFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartClientInstrumentRight.csv");
	return writeCSV(szFileName);
}

void CPartClientInstrumentRightFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartClientInstrumentRightFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartClientInstrumentRight *pPartClientInstrumentRight;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartClientInstrumentRightFactory={       Total Count=%d\n", pMem->getCount());
	pPartClientInstrumentRight=(CWriteablePartClientInstrumentRight *)(pMem->getFirst());
	while (pPartClientInstrumentRight!=NULL) {
		pPartClientInstrumentRight->dump(fp,index++);
		pPartClientInstrumentRight=(CWriteablePartClientInstrumentRight *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartClientInstrumentRightFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantAndClientAndInstrumentHashIndex->removeAll();
	}
}

CPartClientInstrumentRight *CPartClientInstrumentRightFactory::internalAdd(CWriteablePartClientInstrumentRight *pPartClientInstrumentRight, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartClientInstrumentRight++;
#endif
	CPartClientInstrumentRight *pTarget;	
	beforeAdd(pPartClientInstrumentRight);
	pTarget=(CPartClientInstrumentRight *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartClientInstrumentRight in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartClientInstrumentRight, sizeof(CPartClientInstrumentRight));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantAndClientAndInstrumentHashIndex->addObject(pTarget,pTarget->HashParticipantAndClientAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartClientInstrumentRight *CPartClientInstrumentRightFactory::add(CWriteablePartClientInstrumentRight *pPartClientInstrumentRight, CTransaction *pTransaction)
{
	pPartClientInstrumentRight->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartClientInstrumentRight,true);
	}
	else {
		CPartClientInstrumentRight *pNewPartClientInstrumentRight;
		pNewPartClientInstrumentRight = internalAdd(pPartClientInstrumentRight,false);
		pTransaction->addResource(CPartClientInstrumentRightResource::alloc(CREATE_ACTION,this,pNewPartClientInstrumentRight,NULL));
		return pNewPartClientInstrumentRight;
	}
}

void CPartClientInstrumentRightFactory::internalUpdate(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pNewPartClientInstrumentRight, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartClientInstrumentRight++;
	}
	else {
		updateWithoutIndexActionForPartClientInstrumentRight++;
	}
#endif
	CWriteablePartClientInstrumentRight theOldPartClientInstrumentRight;
	beforeUpdate(pPartClientInstrumentRight,pNewPartClientInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartClientInstrumentRight,pPartClientInstrumentRight,sizeof(CPartClientInstrumentRight));
	}
	if (updateIndex) {
	}

	forceCopy(pPartClientInstrumentRight,pNewPartClientInstrumentRight,sizeof(CPartClientInstrumentRight));
	pMem->updateObject(pPartClientInstrumentRight);
	if (updateIndex) {
	}
	afterUpdate(pPartClientInstrumentRight);
	if (bNoTransaction) {
		commitUpdate(pPartClientInstrumentRight,&theOldPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::update(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pNewPartClientInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartClientInstrumentRight->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartClientInstrumentRight,pNewPartClientInstrumentRight,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartClientInstrumentRightResource::alloc(UPDATE_ACTION,this,pPartClientInstrumentRight,pNewPartClientInstrumentRight,updateIndex));
		internalUpdate(pPartClientInstrumentRight,pNewPartClientInstrumentRight,updateIndex,false);
	}
}

void CPartClientInstrumentRightFactory::internalRemove(CPartClientInstrumentRight *pPartClientInstrumentRight, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartClientInstrumentRight++;
#endif
	CWriteablePartClientInstrumentRight theOldPartClientInstrumentRight;
	beforeRemove(pPartClientInstrumentRight);
	if (bNoTransaction) {
		forceCopy(&theOldPartClientInstrumentRight,pPartClientInstrumentRight,sizeof(CPartClientInstrumentRight));
	}
	if (runLevel>=0) {
		pParticipantAndClientAndInstrumentHashIndex->removeObject(pPartClientInstrumentRight,pPartClientInstrumentRight->HashParticipantAndClientAndInstrument);
	}	
	pMem->free(pPartClientInstrumentRight);
	if(bNoTransaction) {
		commitRemove(&theOldPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::remove(CPartClientInstrumentRight *pPartClientInstrumentRight, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartClientInstrumentRight,true);
	}
	else {
		pTransaction->addResource(CPartClientInstrumentRightResource::alloc(DELETE_ACTION,this,pPartClientInstrumentRight,NULL));
		internalRemove(pPartClientInstrumentRight,false);		
	}
}

CPartClientInstrumentRight* CPartClientInstrumentRightFactory::addOrUpdate(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pNewPartClientInstrumentRight, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartClientInstrumentRight == NULL) {
		return add(pNewPartClientInstrumentRight,pTransaction);
	}
	else {
		update(pPartClientInstrumentRight,pNewPartClientInstrumentRight,pTransaction,updateIndex);
		return pPartClientInstrumentRight;
	}
}

void CPartClientInstrumentRightFactory::retrieve(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pTargetPartClientInstrumentRight)
{
	forceCopy(pTargetPartClientInstrumentRight, pPartClientInstrumentRight, sizeof(CPartClientInstrumentRight));
}
	
int CPartClientInstrumentRightFactory::addActionTrigger(CPartClientInstrumentRightActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartClientInstrumentRightFactory::removeActionTrigger(CPartClientInstrumentRightActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartClientInstrumentRightFactory::addCommitTrigger(CPartClientInstrumentRightCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartClientInstrumentRightFactory::removeCommitTrigger(CPartClientInstrumentRightCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartClientInstrumentRight *CPartClientInstrumentRightFactory::getFirst(void)
{
	CPartClientInstrumentRight *pResult=(CPartClientInstrumentRight *)(pMem->getFirst());
	return pResult;
}
	
CPartClientInstrumentRight *CPartClientInstrumentRightFactory::getNext(void)
{
	CPartClientInstrumentRight *pResult=(CPartClientInstrumentRight *)(pMem->getNext());
	return pResult;
}
	
void CPartClientInstrumentRightFactory::endGet(void)
{
	pMem->endGet();
}

void CPartClientInstrumentRightFactory::beforeAdd(CWriteablePartClientInstrumentRight *pPartClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartClientInstrumentRight);
	}
}
	
void CPartClientInstrumentRightFactory::afterAdd(CPartClientInstrumentRight *pPartClientInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::beforeUpdate(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pNewPartClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartClientInstrumentRight,pNewPartClientInstrumentRight);
	}
}
	
void CPartClientInstrumentRightFactory::afterUpdate(CPartClientInstrumentRight *pPartClientInstrumentRight)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartClientInstrumentRight);
	}
}
	
void CPartClientInstrumentRightFactory::beforeRemove(CPartClientInstrumentRight *pPartClientInstrumentRight)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::commitAdd(CPartClientInstrumentRight *pPartClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::commitUpdate(CPartClientInstrumentRight *pPartClientInstrumentRight, CWriteablePartClientInstrumentRight *pOldPartClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartClientInstrumentRight,pOldPartClientInstrumentRight);
	}
}
	
void CPartClientInstrumentRightFactory::commitRemove(CWriteablePartClientInstrumentRight *pPartClientInstrumentRight)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartClientInstrumentRight++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartClientInstrumentRight);
	}
}

void CPartClientInstrumentRightFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForProductIDIndexinCurrProductProperty(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrProductProperty=0;
int updateWithIndexActionForCurrProductProperty=0;
int updateWithoutIndexActionForCurrProductProperty=0;
int removeActionForCurrProductProperty=0;
int addCommitForCurrProductProperty=0;
int updateCommitForCurrProductProperty=0;
int removeCommitForCurrProductProperty=0;
#endif
void CCurrProductPropertyFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinCurrProductProperty,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrProductProperty_ProductIDIndex",pProductIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrProductProperty_ProductIDIndex");
			if(it != pIndexMap->end()) {
				pProductIDIndex=new CAVLTree(maxUnit,compareForProductIDIndexinCurrProductProperty,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pProductIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrProductPropertyActionTrigger *>;
	pCommitTriggers=new vector<CCurrProductPropertyCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrProductPropertyFactory::CCurrProductPropertyFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrProductProperty),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrProductPropertyFactory::CCurrProductPropertyFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrProductProperty),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrProductPropertyFactory::~CCurrProductPropertyFactory(void)
{
	if (runLevel>=0) {
		if (pProductIDIndex!=NULL)
			delete pProductIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrProductPropertyFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrProductPropertyFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pProductIDIndex->output(pLogger,indent+1);
	}
}

int CCurrProductPropertyFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrProductProperty thisCurrProductProperty;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrProductProperty.readCSV(input,pNames))
		add(&thisCurrProductProperty);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrProductPropertyFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrProductProperty.csv");
	return readCSV(szFileName);
}

int CCurrProductPropertyFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrProductProperty *pCurrProductProperty;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrProductProperty::writeCSVHead(output);
	pCurrProductProperty=(CWriteableCurrProductProperty *)(pMem->getFirst());
	while (pCurrProductProperty!=NULL) {
		if (!pCurrProductProperty->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrProductProperty=(CWriteableCurrProductProperty *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrProductPropertyFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrProductProperty.csv");
	return writeCSV(szFileName);
}

void CCurrProductPropertyFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrProductPropertyFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrProductProperty *pCurrProductProperty;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrProductPropertyFactory={       Total Count=%d\n", pMem->getCount());
	pCurrProductProperty=(CWriteableCurrProductProperty *)(pMem->getFirst());
	while (pCurrProductProperty!=NULL) {
		pCurrProductProperty->dump(fp,index++);
		pCurrProductProperty=(CWriteableCurrProductProperty *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrProductPropertyFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pProductIDIndex->removeAll();
	}
}

CCurrProductProperty *CCurrProductPropertyFactory::internalAdd(CWriteableCurrProductProperty *pCurrProductProperty, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrProductProperty++;
#endif
	CCurrProductProperty *pTarget;	
	beforeAdd(pCurrProductProperty);
	pTarget=(CCurrProductProperty *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrProductProperty in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrProductProperty, sizeof(CCurrProductProperty));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pProductIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrProductProperty *CCurrProductPropertyFactory::add(CWriteableCurrProductProperty *pCurrProductProperty, CTransaction *pTransaction)
{
	pCurrProductProperty->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrProductProperty,true);
	}
	else {
		CCurrProductProperty *pNewCurrProductProperty;
		pNewCurrProductProperty = internalAdd(pCurrProductProperty,false);
		pTransaction->addResource(CCurrProductPropertyResource::alloc(CREATE_ACTION,this,pNewCurrProductProperty,NULL));
		return pNewCurrProductProperty;
	}
}

void CCurrProductPropertyFactory::internalUpdate(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pNewCurrProductProperty, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrProductProperty++;
	}
	else {
		updateWithoutIndexActionForCurrProductProperty++;
	}
#endif
	CWriteableCurrProductProperty theOldCurrProductProperty;
	beforeUpdate(pCurrProductProperty,pNewCurrProductProperty);
	if (bNoTransaction) {
		forceCopy(&theOldCurrProductProperty,pCurrProductProperty,sizeof(CCurrProductProperty));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrProductProperty,pNewCurrProductProperty,sizeof(CCurrProductProperty));
	pMem->updateObject(pCurrProductProperty);
	if (updateIndex) {
	}
	afterUpdate(pCurrProductProperty);
	if (bNoTransaction) {
		commitUpdate(pCurrProductProperty,&theOldCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::update(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pNewCurrProductProperty, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrProductProperty->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrProductProperty,pNewCurrProductProperty,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrProductPropertyResource::alloc(UPDATE_ACTION,this,pCurrProductProperty,pNewCurrProductProperty,updateIndex));
		internalUpdate(pCurrProductProperty,pNewCurrProductProperty,updateIndex,false);
	}
}

void CCurrProductPropertyFactory::internalRemove(CCurrProductProperty *pCurrProductProperty, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrProductProperty++;
#endif
	CWriteableCurrProductProperty theOldCurrProductProperty;
	beforeRemove(pCurrProductProperty);
	if (bNoTransaction) {
		forceCopy(&theOldCurrProductProperty,pCurrProductProperty,sizeof(CCurrProductProperty));
	}
	if (runLevel>=0) {
		pProductIDIndex->removeObject(pCurrProductProperty);
	}
	pMem->free(pCurrProductProperty);
	if(bNoTransaction) {
		commitRemove(&theOldCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::remove(CCurrProductProperty *pCurrProductProperty, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrProductProperty,true);
	}
	else {
		pTransaction->addResource(CCurrProductPropertyResource::alloc(DELETE_ACTION,this,pCurrProductProperty,NULL));
		internalRemove(pCurrProductProperty,false);		
	}
}

CCurrProductProperty* CCurrProductPropertyFactory::addOrUpdate(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pNewCurrProductProperty, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrProductProperty == NULL) {
		return add(pNewCurrProductProperty,pTransaction);
	}
	else {
		update(pCurrProductProperty,pNewCurrProductProperty,pTransaction,updateIndex);
		return pCurrProductProperty;
	}
}

void CCurrProductPropertyFactory::retrieve(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pTargetCurrProductProperty)
{
	forceCopy(pTargetCurrProductProperty, pCurrProductProperty, sizeof(CCurrProductProperty));
}
	
int CCurrProductPropertyFactory::addActionTrigger(CCurrProductPropertyActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrProductPropertyFactory::removeActionTrigger(CCurrProductPropertyActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrProductPropertyFactory::addCommitTrigger(CCurrProductPropertyCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrProductPropertyFactory::removeCommitTrigger(CCurrProductPropertyCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrProductProperty *CCurrProductPropertyFactory::getFirst(void)
{
	CCurrProductProperty *pResult=(CCurrProductProperty *)(pMem->getFirst());
	return pResult;
}
	
CCurrProductProperty *CCurrProductPropertyFactory::getNext(void)
{
	CCurrProductProperty *pResult=(CCurrProductProperty *)(pMem->getNext());
	return pResult;
}
	
void CCurrProductPropertyFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrProductPropertyFactory::beforeAdd(CWriteableCurrProductProperty *pCurrProductProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrProductProperty);
	}
}
	
void CCurrProductPropertyFactory::afterAdd(CCurrProductProperty *pCurrProductProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::beforeUpdate(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pNewCurrProductProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrProductProperty,pNewCurrProductProperty);
	}
}
	
void CCurrProductPropertyFactory::afterUpdate(CCurrProductProperty *pCurrProductProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrProductProperty);
	}
}
	
void CCurrProductPropertyFactory::beforeRemove(CCurrProductProperty *pCurrProductProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::commitAdd(CCurrProductProperty *pCurrProductProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrProductProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::commitUpdate(CCurrProductProperty *pCurrProductProperty, CWriteableCurrProductProperty *pOldCurrProductProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrProductProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrProductProperty,pOldCurrProductProperty);
	}
}
	
void CCurrProductPropertyFactory::commitRemove(CWriteableCurrProductProperty *pCurrProductProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrProductProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrProductProperty);
	}
}

void CCurrProductPropertyFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinCurrInstrumentProperty(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrInstrumentProperty=0;
int updateWithIndexActionForCurrInstrumentProperty=0;
int updateWithoutIndexActionForCurrInstrumentProperty=0;
int removeActionForCurrInstrumentProperty=0;
int addCommitForCurrInstrumentProperty=0;
int updateCommitForCurrInstrumentProperty=0;
int removeCommitForCurrInstrumentProperty=0;
#endif
void CCurrInstrumentPropertyFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrInstrumentProperty,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrInstrumentProperty_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrInstrumentProperty_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrInstrumentProperty,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrInstrumentPropertyActionTrigger *>;
	pCommitTriggers=new vector<CCurrInstrumentPropertyCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrInstrumentPropertyFactory::CCurrInstrumentPropertyFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrInstrumentProperty),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrInstrumentPropertyFactory::CCurrInstrumentPropertyFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrInstrumentProperty),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrInstrumentPropertyFactory::~CCurrInstrumentPropertyFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrInstrumentPropertyFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrInstrumentPropertyFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CCurrInstrumentPropertyFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrInstrumentProperty thisCurrInstrumentProperty;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrInstrumentProperty.readCSV(input,pNames))
		add(&thisCurrInstrumentProperty);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrInstrumentPropertyFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrInstrumentProperty.csv");
	return readCSV(szFileName);
}

int CCurrInstrumentPropertyFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrInstrumentProperty *pCurrInstrumentProperty;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrInstrumentProperty::writeCSVHead(output);
	pCurrInstrumentProperty=(CWriteableCurrInstrumentProperty *)(pMem->getFirst());
	while (pCurrInstrumentProperty!=NULL) {
		if (!pCurrInstrumentProperty->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrInstrumentProperty=(CWriteableCurrInstrumentProperty *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrInstrumentPropertyFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrInstrumentProperty.csv");
	return writeCSV(szFileName);
}

void CCurrInstrumentPropertyFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrInstrumentPropertyFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrInstrumentProperty *pCurrInstrumentProperty;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrInstrumentPropertyFactory={       Total Count=%d\n", pMem->getCount());
	pCurrInstrumentProperty=(CWriteableCurrInstrumentProperty *)(pMem->getFirst());
	while (pCurrInstrumentProperty!=NULL) {
		pCurrInstrumentProperty->dump(fp,index++);
		pCurrInstrumentProperty=(CWriteableCurrInstrumentProperty *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrInstrumentPropertyFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CCurrInstrumentProperty *CCurrInstrumentPropertyFactory::internalAdd(CWriteableCurrInstrumentProperty *pCurrInstrumentProperty, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrInstrumentProperty++;
#endif
	CCurrInstrumentProperty *pTarget;	
	beforeAdd(pCurrInstrumentProperty);
	pTarget=(CCurrInstrumentProperty *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrInstrumentProperty in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrInstrumentProperty, sizeof(CCurrInstrumentProperty));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrInstrumentProperty *CCurrInstrumentPropertyFactory::add(CWriteableCurrInstrumentProperty *pCurrInstrumentProperty, CTransaction *pTransaction)
{
	pCurrInstrumentProperty->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrInstrumentProperty,true);
	}
	else {
		CCurrInstrumentProperty *pNewCurrInstrumentProperty;
		pNewCurrInstrumentProperty = internalAdd(pCurrInstrumentProperty,false);
		pTransaction->addResource(CCurrInstrumentPropertyResource::alloc(CREATE_ACTION,this,pNewCurrInstrumentProperty,NULL));
		return pNewCurrInstrumentProperty;
	}
}

void CCurrInstrumentPropertyFactory::internalUpdate(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pNewCurrInstrumentProperty, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrInstrumentProperty++;
	}
	else {
		updateWithoutIndexActionForCurrInstrumentProperty++;
	}
#endif
	CWriteableCurrInstrumentProperty theOldCurrInstrumentProperty;
	beforeUpdate(pCurrInstrumentProperty,pNewCurrInstrumentProperty);
	if (bNoTransaction) {
		forceCopy(&theOldCurrInstrumentProperty,pCurrInstrumentProperty,sizeof(CCurrInstrumentProperty));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrInstrumentProperty,pNewCurrInstrumentProperty,sizeof(CCurrInstrumentProperty));
	pMem->updateObject(pCurrInstrumentProperty);
	if (updateIndex) {
	}
	afterUpdate(pCurrInstrumentProperty);
	if (bNoTransaction) {
		commitUpdate(pCurrInstrumentProperty,&theOldCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::update(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pNewCurrInstrumentProperty, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrInstrumentProperty->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrInstrumentProperty,pNewCurrInstrumentProperty,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrInstrumentPropertyResource::alloc(UPDATE_ACTION,this,pCurrInstrumentProperty,pNewCurrInstrumentProperty,updateIndex));
		internalUpdate(pCurrInstrumentProperty,pNewCurrInstrumentProperty,updateIndex,false);
	}
}

void CCurrInstrumentPropertyFactory::internalRemove(CCurrInstrumentProperty *pCurrInstrumentProperty, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrInstrumentProperty++;
#endif
	CWriteableCurrInstrumentProperty theOldCurrInstrumentProperty;
	beforeRemove(pCurrInstrumentProperty);
	if (bNoTransaction) {
		forceCopy(&theOldCurrInstrumentProperty,pCurrInstrumentProperty,sizeof(CCurrInstrumentProperty));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pCurrInstrumentProperty);
	}
	pMem->free(pCurrInstrumentProperty);
	if(bNoTransaction) {
		commitRemove(&theOldCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::remove(CCurrInstrumentProperty *pCurrInstrumentProperty, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrInstrumentProperty,true);
	}
	else {
		pTransaction->addResource(CCurrInstrumentPropertyResource::alloc(DELETE_ACTION,this,pCurrInstrumentProperty,NULL));
		internalRemove(pCurrInstrumentProperty,false);		
	}
}

CCurrInstrumentProperty* CCurrInstrumentPropertyFactory::addOrUpdate(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pNewCurrInstrumentProperty, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrInstrumentProperty == NULL) {
		return add(pNewCurrInstrumentProperty,pTransaction);
	}
	else {
		update(pCurrInstrumentProperty,pNewCurrInstrumentProperty,pTransaction,updateIndex);
		return pCurrInstrumentProperty;
	}
}

void CCurrInstrumentPropertyFactory::retrieve(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pTargetCurrInstrumentProperty)
{
	forceCopy(pTargetCurrInstrumentProperty, pCurrInstrumentProperty, sizeof(CCurrInstrumentProperty));
}
	
int CCurrInstrumentPropertyFactory::addActionTrigger(CCurrInstrumentPropertyActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrInstrumentPropertyFactory::removeActionTrigger(CCurrInstrumentPropertyActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrInstrumentPropertyFactory::addCommitTrigger(CCurrInstrumentPropertyCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrInstrumentPropertyFactory::removeCommitTrigger(CCurrInstrumentPropertyCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrInstrumentProperty *CCurrInstrumentPropertyFactory::getFirst(void)
{
	CCurrInstrumentProperty *pResult=(CCurrInstrumentProperty *)(pMem->getFirst());
	return pResult;
}
	
CCurrInstrumentProperty *CCurrInstrumentPropertyFactory::getNext(void)
{
	CCurrInstrumentProperty *pResult=(CCurrInstrumentProperty *)(pMem->getNext());
	return pResult;
}
	
void CCurrInstrumentPropertyFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrInstrumentPropertyFactory::beforeAdd(CWriteableCurrInstrumentProperty *pCurrInstrumentProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrInstrumentProperty);
	}
}
	
void CCurrInstrumentPropertyFactory::afterAdd(CCurrInstrumentProperty *pCurrInstrumentProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::beforeUpdate(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pNewCurrInstrumentProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrInstrumentProperty,pNewCurrInstrumentProperty);
	}
}
	
void CCurrInstrumentPropertyFactory::afterUpdate(CCurrInstrumentProperty *pCurrInstrumentProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrInstrumentProperty);
	}
}
	
void CCurrInstrumentPropertyFactory::beforeRemove(CCurrInstrumentProperty *pCurrInstrumentProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::commitAdd(CCurrInstrumentProperty *pCurrInstrumentProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrInstrumentProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::commitUpdate(CCurrInstrumentProperty *pCurrInstrumentProperty, CWriteableCurrInstrumentProperty *pOldCurrInstrumentProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrInstrumentProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrInstrumentProperty,pOldCurrInstrumentProperty);
	}
}
	
void CCurrInstrumentPropertyFactory::commitRemove(CWriteableCurrInstrumentProperty *pCurrInstrumentProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrInstrumentProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrInstrumentProperty);
	}
}

void CCurrInstrumentPropertyFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentAndSegmentIndexinCurrPriceBanding(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrPriceBanding=0;
int updateWithIndexActionForCurrPriceBanding=0;
int updateWithoutIndexActionForCurrPriceBanding=0;
int removeActionForCurrPriceBanding=0;
int addCommitForCurrPriceBanding=0;
int updateCommitForCurrPriceBanding=0;
int removeCommitForCurrPriceBanding=0;
#endif
void CCurrPriceBandingFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentAndSegmentIndex=new CAVLTree(maxUnit,compareForInstrumentAndSegmentIndexinCurrPriceBanding,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrPriceBanding_InstrumentAndSegmentIndex",pInstrumentAndSegmentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrPriceBanding_InstrumentAndSegmentIndex");
			if(it != pIndexMap->end()) {
				pInstrumentAndSegmentIndex=new CAVLTree(maxUnit,compareForInstrumentAndSegmentIndexinCurrPriceBanding,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentAndSegmentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrPriceBandingActionTrigger *>;
	pCommitTriggers=new vector<CCurrPriceBandingCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrPriceBandingFactory::CCurrPriceBandingFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPriceBanding),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrPriceBandingFactory::CCurrPriceBandingFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPriceBanding),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrPriceBandingFactory::~CCurrPriceBandingFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentAndSegmentIndex!=NULL)
			delete pInstrumentAndSegmentIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrPriceBandingFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrPriceBandingFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentAndSegmentIndex->output(pLogger,indent+1);
	}
}

int CCurrPriceBandingFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrPriceBanding thisCurrPriceBanding;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrPriceBanding.readCSV(input,pNames))
		add(&thisCurrPriceBanding);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrPriceBandingFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrPriceBanding.csv");
	return readCSV(szFileName);
}

int CCurrPriceBandingFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrPriceBanding *pCurrPriceBanding;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrPriceBanding::writeCSVHead(output);
	pCurrPriceBanding=(CWriteableCurrPriceBanding *)(pMem->getFirst());
	while (pCurrPriceBanding!=NULL) {
		if (!pCurrPriceBanding->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrPriceBanding=(CWriteableCurrPriceBanding *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrPriceBandingFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrPriceBanding.csv");
	return writeCSV(szFileName);
}

void CCurrPriceBandingFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrPriceBandingFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrPriceBanding *pCurrPriceBanding;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrPriceBandingFactory={       Total Count=%d\n", pMem->getCount());
	pCurrPriceBanding=(CWriteableCurrPriceBanding *)(pMem->getFirst());
	while (pCurrPriceBanding!=NULL) {
		pCurrPriceBanding->dump(fp,index++);
		pCurrPriceBanding=(CWriteableCurrPriceBanding *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrPriceBandingFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentAndSegmentIndex->removeAll();
	}
}

CCurrPriceBanding *CCurrPriceBandingFactory::internalAdd(CWriteableCurrPriceBanding *pCurrPriceBanding, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrPriceBanding++;
#endif
	CCurrPriceBanding *pTarget;	
	beforeAdd(pCurrPriceBanding);
	pTarget=(CCurrPriceBanding *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrPriceBanding in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrPriceBanding, sizeof(CCurrPriceBanding));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentAndSegmentIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrPriceBanding *CCurrPriceBandingFactory::add(CWriteableCurrPriceBanding *pCurrPriceBanding, CTransaction *pTransaction)
{
	pCurrPriceBanding->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrPriceBanding,true);
	}
	else {
		CCurrPriceBanding *pNewCurrPriceBanding;
		pNewCurrPriceBanding = internalAdd(pCurrPriceBanding,false);
		pTransaction->addResource(CCurrPriceBandingResource::alloc(CREATE_ACTION,this,pNewCurrPriceBanding,NULL));
		return pNewCurrPriceBanding;
	}
}

void CCurrPriceBandingFactory::internalUpdate(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pNewCurrPriceBanding, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrPriceBanding++;
	}
	else {
		updateWithoutIndexActionForCurrPriceBanding++;
	}
#endif
	CWriteableCurrPriceBanding theOldCurrPriceBanding;
	beforeUpdate(pCurrPriceBanding,pNewCurrPriceBanding);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPriceBanding,pCurrPriceBanding,sizeof(CCurrPriceBanding));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrPriceBanding,pNewCurrPriceBanding,sizeof(CCurrPriceBanding));
	pMem->updateObject(pCurrPriceBanding);
	if (updateIndex) {
	}
	afterUpdate(pCurrPriceBanding);
	if (bNoTransaction) {
		commitUpdate(pCurrPriceBanding,&theOldCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::update(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pNewCurrPriceBanding, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrPriceBanding->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrPriceBanding,pNewCurrPriceBanding,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrPriceBandingResource::alloc(UPDATE_ACTION,this,pCurrPriceBanding,pNewCurrPriceBanding,updateIndex));
		internalUpdate(pCurrPriceBanding,pNewCurrPriceBanding,updateIndex,false);
	}
}

void CCurrPriceBandingFactory::internalRemove(CCurrPriceBanding *pCurrPriceBanding, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrPriceBanding++;
#endif
	CWriteableCurrPriceBanding theOldCurrPriceBanding;
	beforeRemove(pCurrPriceBanding);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPriceBanding,pCurrPriceBanding,sizeof(CCurrPriceBanding));
	}
	if (runLevel>=0) {
		pInstrumentAndSegmentIndex->removeObject(pCurrPriceBanding);
	}
	pMem->free(pCurrPriceBanding);
	if(bNoTransaction) {
		commitRemove(&theOldCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::remove(CCurrPriceBanding *pCurrPriceBanding, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrPriceBanding,true);
	}
	else {
		pTransaction->addResource(CCurrPriceBandingResource::alloc(DELETE_ACTION,this,pCurrPriceBanding,NULL));
		internalRemove(pCurrPriceBanding,false);		
	}
}

CCurrPriceBanding* CCurrPriceBandingFactory::addOrUpdate(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pNewCurrPriceBanding, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrPriceBanding == NULL) {
		return add(pNewCurrPriceBanding,pTransaction);
	}
	else {
		update(pCurrPriceBanding,pNewCurrPriceBanding,pTransaction,updateIndex);
		return pCurrPriceBanding;
	}
}

void CCurrPriceBandingFactory::retrieve(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pTargetCurrPriceBanding)
{
	forceCopy(pTargetCurrPriceBanding, pCurrPriceBanding, sizeof(CCurrPriceBanding));
}
	
int CCurrPriceBandingFactory::addActionTrigger(CCurrPriceBandingActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrPriceBandingFactory::removeActionTrigger(CCurrPriceBandingActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrPriceBandingFactory::addCommitTrigger(CCurrPriceBandingCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrPriceBandingFactory::removeCommitTrigger(CCurrPriceBandingCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrPriceBanding *CCurrPriceBandingFactory::getFirst(void)
{
	CCurrPriceBanding *pResult=(CCurrPriceBanding *)(pMem->getFirst());
	return pResult;
}
	
CCurrPriceBanding *CCurrPriceBandingFactory::getNext(void)
{
	CCurrPriceBanding *pResult=(CCurrPriceBanding *)(pMem->getNext());
	return pResult;
}
	
void CCurrPriceBandingFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrPriceBandingFactory::beforeAdd(CWriteableCurrPriceBanding *pCurrPriceBanding)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrPriceBanding);
	}
}
	
void CCurrPriceBandingFactory::afterAdd(CCurrPriceBanding *pCurrPriceBanding)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::beforeUpdate(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pNewCurrPriceBanding)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrPriceBanding,pNewCurrPriceBanding);
	}
}
	
void CCurrPriceBandingFactory::afterUpdate(CCurrPriceBanding *pCurrPriceBanding)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrPriceBanding);
	}
}
	
void CCurrPriceBandingFactory::beforeRemove(CCurrPriceBanding *pCurrPriceBanding)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::commitAdd(CCurrPriceBanding *pCurrPriceBanding)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrPriceBanding++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::commitUpdate(CCurrPriceBanding *pCurrPriceBanding, CWriteableCurrPriceBanding *pOldCurrPriceBanding)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrPriceBanding++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrPriceBanding,pOldCurrPriceBanding);
	}
}
	
void CCurrPriceBandingFactory::commitRemove(CWriteableCurrPriceBanding *pCurrPriceBanding)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrPriceBanding++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrPriceBanding);
	}
}

void CCurrPriceBandingFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrMarginRate=0;
int updateWithIndexActionForCurrMarginRate=0;
int updateWithoutIndexActionForCurrMarginRate=0;
int removeActionForCurrMarginRate=0;
int addCommitForCurrMarginRate=0;
int updateCommitForCurrMarginRate=0;
int removeCommitForCurrMarginRate=0;
#endif
void CCurrMarginRateFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrMarginRateActionTrigger *>;
	pCommitTriggers=new vector<CCurrMarginRateCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrMarginRateFactory::CCurrMarginRateFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrMarginRate),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrMarginRateFactory::CCurrMarginRateFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrMarginRate),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrMarginRateFactory::~CCurrMarginRateFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrMarginRateFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrMarginRateFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrMarginRateFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrMarginRate thisCurrMarginRate;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrMarginRate.readCSV(input,pNames))
		add(&thisCurrMarginRate);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrMarginRateFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrMarginRate.csv");
	return readCSV(szFileName);
}

int CCurrMarginRateFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrMarginRate *pCurrMarginRate;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrMarginRate::writeCSVHead(output);
	pCurrMarginRate=(CWriteableCurrMarginRate *)(pMem->getFirst());
	while (pCurrMarginRate!=NULL) {
		if (!pCurrMarginRate->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrMarginRate=(CWriteableCurrMarginRate *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrMarginRateFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrMarginRate.csv");
	return writeCSV(szFileName);
}

void CCurrMarginRateFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrMarginRateFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrMarginRate *pCurrMarginRate;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrMarginRateFactory={       Total Count=%d\n", pMem->getCount());
	pCurrMarginRate=(CWriteableCurrMarginRate *)(pMem->getFirst());
	while (pCurrMarginRate!=NULL) {
		pCurrMarginRate->dump(fp,index++);
		pCurrMarginRate=(CWriteableCurrMarginRate *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrMarginRateFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CCurrMarginRate *CCurrMarginRateFactory::internalAdd(CWriteableCurrMarginRate *pCurrMarginRate, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrMarginRate++;
#endif
	CCurrMarginRate *pTarget;	
	beforeAdd(pCurrMarginRate);
	pTarget=(CCurrMarginRate *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrMarginRate in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrMarginRate, sizeof(CCurrMarginRate));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrMarginRate *CCurrMarginRateFactory::add(CWriteableCurrMarginRate *pCurrMarginRate, CTransaction *pTransaction)
{
	pCurrMarginRate->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrMarginRate,true);
	}
	else {
		CCurrMarginRate *pNewCurrMarginRate;
		pNewCurrMarginRate = internalAdd(pCurrMarginRate,false);
		pTransaction->addResource(CCurrMarginRateResource::alloc(CREATE_ACTION,this,pNewCurrMarginRate,NULL));
		return pNewCurrMarginRate;
	}
}

void CCurrMarginRateFactory::internalUpdate(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pNewCurrMarginRate, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrMarginRate++;
	}
	else {
		updateWithoutIndexActionForCurrMarginRate++;
	}
#endif
	CWriteableCurrMarginRate theOldCurrMarginRate;
	beforeUpdate(pCurrMarginRate,pNewCurrMarginRate);
	if (bNoTransaction) {
		forceCopy(&theOldCurrMarginRate,pCurrMarginRate,sizeof(CCurrMarginRate));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrMarginRate,pNewCurrMarginRate,sizeof(CCurrMarginRate));
	pMem->updateObject(pCurrMarginRate);
	if (updateIndex) {
	}
	afterUpdate(pCurrMarginRate);
	if (bNoTransaction) {
		commitUpdate(pCurrMarginRate,&theOldCurrMarginRate);
	}
}

void CCurrMarginRateFactory::update(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pNewCurrMarginRate, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrMarginRate->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrMarginRate,pNewCurrMarginRate,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrMarginRateResource::alloc(UPDATE_ACTION,this,pCurrMarginRate,pNewCurrMarginRate,updateIndex));
		internalUpdate(pCurrMarginRate,pNewCurrMarginRate,updateIndex,false);
	}
}

void CCurrMarginRateFactory::internalRemove(CCurrMarginRate *pCurrMarginRate, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrMarginRate++;
#endif
	CWriteableCurrMarginRate theOldCurrMarginRate;
	beforeRemove(pCurrMarginRate);
	if (bNoTransaction) {
		forceCopy(&theOldCurrMarginRate,pCurrMarginRate,sizeof(CCurrMarginRate));
	}
	pMem->free(pCurrMarginRate);
	if(bNoTransaction) {
		commitRemove(&theOldCurrMarginRate);
	}
}

void CCurrMarginRateFactory::remove(CCurrMarginRate *pCurrMarginRate, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrMarginRate,true);
	}
	else {
		pTransaction->addResource(CCurrMarginRateResource::alloc(DELETE_ACTION,this,pCurrMarginRate,NULL));
		internalRemove(pCurrMarginRate,false);		
	}
}

CCurrMarginRate* CCurrMarginRateFactory::addOrUpdate(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pNewCurrMarginRate, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrMarginRate == NULL) {
		return add(pNewCurrMarginRate,pTransaction);
	}
	else {
		update(pCurrMarginRate,pNewCurrMarginRate,pTransaction,updateIndex);
		return pCurrMarginRate;
	}
}

void CCurrMarginRateFactory::retrieve(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pTargetCurrMarginRate)
{
	forceCopy(pTargetCurrMarginRate, pCurrMarginRate, sizeof(CCurrMarginRate));
}
	
int CCurrMarginRateFactory::addActionTrigger(CCurrMarginRateActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrMarginRateFactory::removeActionTrigger(CCurrMarginRateActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrMarginRateFactory::addCommitTrigger(CCurrMarginRateCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrMarginRateFactory::removeCommitTrigger(CCurrMarginRateCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrMarginRate *CCurrMarginRateFactory::getFirst(void)
{
	CCurrMarginRate *pResult=(CCurrMarginRate *)(pMem->getFirst());
	return pResult;
}
	
CCurrMarginRate *CCurrMarginRateFactory::getNext(void)
{
	CCurrMarginRate *pResult=(CCurrMarginRate *)(pMem->getNext());
	return pResult;
}
	
void CCurrMarginRateFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrMarginRateFactory::beforeAdd(CWriteableCurrMarginRate *pCurrMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrMarginRate);
	}
}
	
void CCurrMarginRateFactory::afterAdd(CCurrMarginRate *pCurrMarginRate)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrMarginRate);
	}
}

void CCurrMarginRateFactory::beforeUpdate(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pNewCurrMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrMarginRate,pNewCurrMarginRate);
	}
}
	
void CCurrMarginRateFactory::afterUpdate(CCurrMarginRate *pCurrMarginRate)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrMarginRate);
	}
}
	
void CCurrMarginRateFactory::beforeRemove(CCurrMarginRate *pCurrMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrMarginRate);
	}
}

void CCurrMarginRateFactory::commitAdd(CCurrMarginRate *pCurrMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrMarginRate);
	}
}

void CCurrMarginRateFactory::commitUpdate(CCurrMarginRate *pCurrMarginRate, CWriteableCurrMarginRate *pOldCurrMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrMarginRate,pOldCurrMarginRate);
	}
}
	
void CCurrMarginRateFactory::commitRemove(CWriteableCurrMarginRate *pCurrMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrMarginRate);
	}
}

void CCurrMarginRateFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrMarginRateDetail=0;
int updateWithIndexActionForCurrMarginRateDetail=0;
int updateWithoutIndexActionForCurrMarginRateDetail=0;
int removeActionForCurrMarginRateDetail=0;
int addCommitForCurrMarginRateDetail=0;
int updateCommitForCurrMarginRateDetail=0;
int removeCommitForCurrMarginRateDetail=0;
#endif
void CCurrMarginRateDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=12289;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("CurrMarginRateDetail.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pInstrumentAndParticipantHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrMarginRateDetail_InstrumentAndParticipantHashIndex",pInstrumentAndParticipantHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrMarginRateDetail_InstrumentAndParticipantHashIndex");
			if(it != pIndexMap->end()) {
				pInstrumentAndParticipantHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentAndParticipantHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrMarginRateDetailActionTrigger *>;
	pCommitTriggers=new vector<CCurrMarginRateDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrMarginRateDetailFactory::CCurrMarginRateDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrMarginRateDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrMarginRateDetailFactory::CCurrMarginRateDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrMarginRateDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrMarginRateDetailFactory::~CCurrMarginRateDetailFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentAndParticipantHashIndex!=NULL)
			delete pInstrumentAndParticipantHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrMarginRateDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrMarginRateDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrMarginRateDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrMarginRateDetail thisCurrMarginRateDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrMarginRateDetail.readCSV(input,pNames))
		add(&thisCurrMarginRateDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrMarginRateDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrMarginRateDetail.csv");
	return readCSV(szFileName);
}

int CCurrMarginRateDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrMarginRateDetail *pCurrMarginRateDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrMarginRateDetail::writeCSVHead(output);
	pCurrMarginRateDetail=(CWriteableCurrMarginRateDetail *)(pMem->getFirst());
	while (pCurrMarginRateDetail!=NULL) {
		if (!pCurrMarginRateDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrMarginRateDetail=(CWriteableCurrMarginRateDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrMarginRateDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrMarginRateDetail.csv");
	return writeCSV(szFileName);
}

void CCurrMarginRateDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrMarginRateDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrMarginRateDetail *pCurrMarginRateDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrMarginRateDetailFactory={       Total Count=%d\n", pMem->getCount());
	pCurrMarginRateDetail=(CWriteableCurrMarginRateDetail *)(pMem->getFirst());
	while (pCurrMarginRateDetail!=NULL) {
		pCurrMarginRateDetail->dump(fp,index++);
		pCurrMarginRateDetail=(CWriteableCurrMarginRateDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrMarginRateDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentAndParticipantHashIndex->removeAll();
	}
}

CCurrMarginRateDetail *CCurrMarginRateDetailFactory::internalAdd(CWriteableCurrMarginRateDetail *pCurrMarginRateDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrMarginRateDetail++;
#endif
	CCurrMarginRateDetail *pTarget;	
	beforeAdd(pCurrMarginRateDetail);
	pTarget=(CCurrMarginRateDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrMarginRateDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrMarginRateDetail, sizeof(CCurrMarginRateDetail));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentAndParticipantHashIndex->addObject(pTarget,pTarget->HashInstrumentAndParticipant);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrMarginRateDetail *CCurrMarginRateDetailFactory::add(CWriteableCurrMarginRateDetail *pCurrMarginRateDetail, CTransaction *pTransaction)
{
	pCurrMarginRateDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrMarginRateDetail,true);
	}
	else {
		CCurrMarginRateDetail *pNewCurrMarginRateDetail;
		pNewCurrMarginRateDetail = internalAdd(pCurrMarginRateDetail,false);
		pTransaction->addResource(CCurrMarginRateDetailResource::alloc(CREATE_ACTION,this,pNewCurrMarginRateDetail,NULL));
		return pNewCurrMarginRateDetail;
	}
}

void CCurrMarginRateDetailFactory::internalUpdate(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pNewCurrMarginRateDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrMarginRateDetail++;
	}
	else {
		updateWithoutIndexActionForCurrMarginRateDetail++;
	}
#endif
	CWriteableCurrMarginRateDetail theOldCurrMarginRateDetail;
	beforeUpdate(pCurrMarginRateDetail,pNewCurrMarginRateDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrMarginRateDetail,pCurrMarginRateDetail,sizeof(CCurrMarginRateDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrMarginRateDetail,pNewCurrMarginRateDetail,sizeof(CCurrMarginRateDetail));
	pMem->updateObject(pCurrMarginRateDetail);
	if (updateIndex) {
	}
	afterUpdate(pCurrMarginRateDetail);
	if (bNoTransaction) {
		commitUpdate(pCurrMarginRateDetail,&theOldCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::update(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pNewCurrMarginRateDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrMarginRateDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrMarginRateDetail,pNewCurrMarginRateDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrMarginRateDetailResource::alloc(UPDATE_ACTION,this,pCurrMarginRateDetail,pNewCurrMarginRateDetail,updateIndex));
		internalUpdate(pCurrMarginRateDetail,pNewCurrMarginRateDetail,updateIndex,false);
	}
}

void CCurrMarginRateDetailFactory::internalRemove(CCurrMarginRateDetail *pCurrMarginRateDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrMarginRateDetail++;
#endif
	CWriteableCurrMarginRateDetail theOldCurrMarginRateDetail;
	beforeRemove(pCurrMarginRateDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrMarginRateDetail,pCurrMarginRateDetail,sizeof(CCurrMarginRateDetail));
	}
	if (runLevel>=0) {
		pInstrumentAndParticipantHashIndex->removeObject(pCurrMarginRateDetail,pCurrMarginRateDetail->HashInstrumentAndParticipant);
	}	
	pMem->free(pCurrMarginRateDetail);
	if(bNoTransaction) {
		commitRemove(&theOldCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::remove(CCurrMarginRateDetail *pCurrMarginRateDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrMarginRateDetail,true);
	}
	else {
		pTransaction->addResource(CCurrMarginRateDetailResource::alloc(DELETE_ACTION,this,pCurrMarginRateDetail,NULL));
		internalRemove(pCurrMarginRateDetail,false);		
	}
}

CCurrMarginRateDetail* CCurrMarginRateDetailFactory::addOrUpdate(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pNewCurrMarginRateDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrMarginRateDetail == NULL) {
		return add(pNewCurrMarginRateDetail,pTransaction);
	}
	else {
		update(pCurrMarginRateDetail,pNewCurrMarginRateDetail,pTransaction,updateIndex);
		return pCurrMarginRateDetail;
	}
}

void CCurrMarginRateDetailFactory::retrieve(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pTargetCurrMarginRateDetail)
{
	forceCopy(pTargetCurrMarginRateDetail, pCurrMarginRateDetail, sizeof(CCurrMarginRateDetail));
}
	
int CCurrMarginRateDetailFactory::addActionTrigger(CCurrMarginRateDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrMarginRateDetailFactory::removeActionTrigger(CCurrMarginRateDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrMarginRateDetailFactory::addCommitTrigger(CCurrMarginRateDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrMarginRateDetailFactory::removeCommitTrigger(CCurrMarginRateDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrMarginRateDetail *CCurrMarginRateDetailFactory::getFirst(void)
{
	CCurrMarginRateDetail *pResult=(CCurrMarginRateDetail *)(pMem->getFirst());
	return pResult;
}
	
CCurrMarginRateDetail *CCurrMarginRateDetailFactory::getNext(void)
{
	CCurrMarginRateDetail *pResult=(CCurrMarginRateDetail *)(pMem->getNext());
	return pResult;
}
	
void CCurrMarginRateDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrMarginRateDetailFactory::beforeAdd(CWriteableCurrMarginRateDetail *pCurrMarginRateDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrMarginRateDetail);
	}
}
	
void CCurrMarginRateDetailFactory::afterAdd(CCurrMarginRateDetail *pCurrMarginRateDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::beforeUpdate(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pNewCurrMarginRateDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrMarginRateDetail,pNewCurrMarginRateDetail);
	}
}
	
void CCurrMarginRateDetailFactory::afterUpdate(CCurrMarginRateDetail *pCurrMarginRateDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrMarginRateDetail);
	}
}
	
void CCurrMarginRateDetailFactory::beforeRemove(CCurrMarginRateDetail *pCurrMarginRateDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::commitAdd(CCurrMarginRateDetail *pCurrMarginRateDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrMarginRateDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::commitUpdate(CCurrMarginRateDetail *pCurrMarginRateDetail, CWriteableCurrMarginRateDetail *pOldCurrMarginRateDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrMarginRateDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrMarginRateDetail,pOldCurrMarginRateDetail);
	}
}
	
void CCurrMarginRateDetailFactory::commitRemove(CWriteableCurrMarginRateDetail *pCurrMarginRateDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrMarginRateDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrMarginRateDetail);
	}
}

void CCurrMarginRateDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrPartPosiLimit=0;
int updateWithIndexActionForCurrPartPosiLimit=0;
int updateWithoutIndexActionForCurrPartPosiLimit=0;
int removeActionForCurrPartPosiLimit=0;
int addCommitForCurrPartPosiLimit=0;
int updateCommitForCurrPartPosiLimit=0;
int removeCommitForCurrPartPosiLimit=0;
#endif
void CCurrPartPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrPartPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CCurrPartPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrPartPosiLimitFactory::CCurrPartPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPartPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrPartPosiLimitFactory::CCurrPartPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPartPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrPartPosiLimitFactory::~CCurrPartPosiLimitFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrPartPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrPartPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrPartPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrPartPosiLimit thisCurrPartPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrPartPosiLimit.readCSV(input,pNames))
		add(&thisCurrPartPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrPartPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrPartPosiLimit.csv");
	return readCSV(szFileName);
}

int CCurrPartPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrPartPosiLimit *pCurrPartPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrPartPosiLimit::writeCSVHead(output);
	pCurrPartPosiLimit=(CWriteableCurrPartPosiLimit *)(pMem->getFirst());
	while (pCurrPartPosiLimit!=NULL) {
		if (!pCurrPartPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrPartPosiLimit=(CWriteableCurrPartPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrPartPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrPartPosiLimit.csv");
	return writeCSV(szFileName);
}

void CCurrPartPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrPartPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrPartPosiLimit *pCurrPartPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrPartPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pCurrPartPosiLimit=(CWriteableCurrPartPosiLimit *)(pMem->getFirst());
	while (pCurrPartPosiLimit!=NULL) {
		pCurrPartPosiLimit->dump(fp,index++);
		pCurrPartPosiLimit=(CWriteableCurrPartPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrPartPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CCurrPartPosiLimit *CCurrPartPosiLimitFactory::internalAdd(CWriteableCurrPartPosiLimit *pCurrPartPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrPartPosiLimit++;
#endif
	CCurrPartPosiLimit *pTarget;	
	beforeAdd(pCurrPartPosiLimit);
	pTarget=(CCurrPartPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrPartPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrPartPosiLimit, sizeof(CCurrPartPosiLimit));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrPartPosiLimit *CCurrPartPosiLimitFactory::add(CWriteableCurrPartPosiLimit *pCurrPartPosiLimit, CTransaction *pTransaction)
{
	pCurrPartPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrPartPosiLimit,true);
	}
	else {
		CCurrPartPosiLimit *pNewCurrPartPosiLimit;
		pNewCurrPartPosiLimit = internalAdd(pCurrPartPosiLimit,false);
		pTransaction->addResource(CCurrPartPosiLimitResource::alloc(CREATE_ACTION,this,pNewCurrPartPosiLimit,NULL));
		return pNewCurrPartPosiLimit;
	}
}

void CCurrPartPosiLimitFactory::internalUpdate(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pNewCurrPartPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrPartPosiLimit++;
	}
	else {
		updateWithoutIndexActionForCurrPartPosiLimit++;
	}
#endif
	CWriteableCurrPartPosiLimit theOldCurrPartPosiLimit;
	beforeUpdate(pCurrPartPosiLimit,pNewCurrPartPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPartPosiLimit,pCurrPartPosiLimit,sizeof(CCurrPartPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrPartPosiLimit,pNewCurrPartPosiLimit,sizeof(CCurrPartPosiLimit));
	pMem->updateObject(pCurrPartPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pCurrPartPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pCurrPartPosiLimit,&theOldCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::update(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pNewCurrPartPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrPartPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrPartPosiLimit,pNewCurrPartPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrPartPosiLimitResource::alloc(UPDATE_ACTION,this,pCurrPartPosiLimit,pNewCurrPartPosiLimit,updateIndex));
		internalUpdate(pCurrPartPosiLimit,pNewCurrPartPosiLimit,updateIndex,false);
	}
}

void CCurrPartPosiLimitFactory::internalRemove(CCurrPartPosiLimit *pCurrPartPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrPartPosiLimit++;
#endif
	CWriteableCurrPartPosiLimit theOldCurrPartPosiLimit;
	beforeRemove(pCurrPartPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPartPosiLimit,pCurrPartPosiLimit,sizeof(CCurrPartPosiLimit));
	}
	pMem->free(pCurrPartPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::remove(CCurrPartPosiLimit *pCurrPartPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrPartPosiLimit,true);
	}
	else {
		pTransaction->addResource(CCurrPartPosiLimitResource::alloc(DELETE_ACTION,this,pCurrPartPosiLimit,NULL));
		internalRemove(pCurrPartPosiLimit,false);		
	}
}

CCurrPartPosiLimit* CCurrPartPosiLimitFactory::addOrUpdate(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pNewCurrPartPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrPartPosiLimit == NULL) {
		return add(pNewCurrPartPosiLimit,pTransaction);
	}
	else {
		update(pCurrPartPosiLimit,pNewCurrPartPosiLimit,pTransaction,updateIndex);
		return pCurrPartPosiLimit;
	}
}

void CCurrPartPosiLimitFactory::retrieve(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pTargetCurrPartPosiLimit)
{
	forceCopy(pTargetCurrPartPosiLimit, pCurrPartPosiLimit, sizeof(CCurrPartPosiLimit));
}
	
int CCurrPartPosiLimitFactory::addActionTrigger(CCurrPartPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrPartPosiLimitFactory::removeActionTrigger(CCurrPartPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrPartPosiLimitFactory::addCommitTrigger(CCurrPartPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrPartPosiLimitFactory::removeCommitTrigger(CCurrPartPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrPartPosiLimit *CCurrPartPosiLimitFactory::getFirst(void)
{
	CCurrPartPosiLimit *pResult=(CCurrPartPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CCurrPartPosiLimit *CCurrPartPosiLimitFactory::getNext(void)
{
	CCurrPartPosiLimit *pResult=(CCurrPartPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CCurrPartPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrPartPosiLimitFactory::beforeAdd(CWriteableCurrPartPosiLimit *pCurrPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrPartPosiLimit);
	}
}
	
void CCurrPartPosiLimitFactory::afterAdd(CCurrPartPosiLimit *pCurrPartPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::beforeUpdate(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pNewCurrPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrPartPosiLimit,pNewCurrPartPosiLimit);
	}
}
	
void CCurrPartPosiLimitFactory::afterUpdate(CCurrPartPosiLimit *pCurrPartPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrPartPosiLimit);
	}
}
	
void CCurrPartPosiLimitFactory::beforeRemove(CCurrPartPosiLimit *pCurrPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::commitAdd(CCurrPartPosiLimit *pCurrPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::commitUpdate(CCurrPartPosiLimit *pCurrPartPosiLimit, CWriteableCurrPartPosiLimit *pOldCurrPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrPartPosiLimit,pOldCurrPartPosiLimit);
	}
}
	
void CCurrPartPosiLimitFactory::commitRemove(CWriteableCurrPartPosiLimit *pCurrPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrPartPosiLimit);
	}
}

void CCurrPartPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentAndPartIndexinCurrPartPosiLimitDetail(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrPartPosiLimitDetail=0;
int updateWithIndexActionForCurrPartPosiLimitDetail=0;
int updateWithoutIndexActionForCurrPartPosiLimitDetail=0;
int removeActionForCurrPartPosiLimitDetail=0;
int addCommitForCurrPartPosiLimitDetail=0;
int updateCommitForCurrPartPosiLimitDetail=0;
int removeCommitForCurrPartPosiLimitDetail=0;
#endif
void CCurrPartPosiLimitDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentAndPartIndex=new CAVLTree(maxUnit,compareForInstrumentAndPartIndexinCurrPartPosiLimitDetail,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrPartPosiLimitDetail_InstrumentAndPartIndex",pInstrumentAndPartIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrPartPosiLimitDetail_InstrumentAndPartIndex");
			if(it != pIndexMap->end()) {
				pInstrumentAndPartIndex=new CAVLTree(maxUnit,compareForInstrumentAndPartIndexinCurrPartPosiLimitDetail,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentAndPartIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrPartPosiLimitDetailActionTrigger *>;
	pCommitTriggers=new vector<CCurrPartPosiLimitDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrPartPosiLimitDetailFactory::CCurrPartPosiLimitDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPartPosiLimitDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrPartPosiLimitDetailFactory::CCurrPartPosiLimitDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrPartPosiLimitDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrPartPosiLimitDetailFactory::~CCurrPartPosiLimitDetailFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentAndPartIndex!=NULL)
			delete pInstrumentAndPartIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrPartPosiLimitDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrPartPosiLimitDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentAndPartIndex->output(pLogger,indent+1);
	}
}

int CCurrPartPosiLimitDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrPartPosiLimitDetail thisCurrPartPosiLimitDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrPartPosiLimitDetail.readCSV(input,pNames))
		add(&thisCurrPartPosiLimitDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrPartPosiLimitDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrPartPosiLimitDetail.csv");
	return readCSV(szFileName);
}

int CCurrPartPosiLimitDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrPartPosiLimitDetail::writeCSVHead(output);
	pCurrPartPosiLimitDetail=(CWriteableCurrPartPosiLimitDetail *)(pMem->getFirst());
	while (pCurrPartPosiLimitDetail!=NULL) {
		if (!pCurrPartPosiLimitDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrPartPosiLimitDetail=(CWriteableCurrPartPosiLimitDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrPartPosiLimitDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrPartPosiLimitDetail.csv");
	return writeCSV(szFileName);
}

void CCurrPartPosiLimitDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrPartPosiLimitDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrPartPosiLimitDetailFactory={       Total Count=%d\n", pMem->getCount());
	pCurrPartPosiLimitDetail=(CWriteableCurrPartPosiLimitDetail *)(pMem->getFirst());
	while (pCurrPartPosiLimitDetail!=NULL) {
		pCurrPartPosiLimitDetail->dump(fp,index++);
		pCurrPartPosiLimitDetail=(CWriteableCurrPartPosiLimitDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrPartPosiLimitDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentAndPartIndex->removeAll();
	}
}

CCurrPartPosiLimitDetail *CCurrPartPosiLimitDetailFactory::internalAdd(CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrPartPosiLimitDetail++;
#endif
	CCurrPartPosiLimitDetail *pTarget;	
	beforeAdd(pCurrPartPosiLimitDetail);
	pTarget=(CCurrPartPosiLimitDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrPartPosiLimitDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrPartPosiLimitDetail, sizeof(CCurrPartPosiLimitDetail));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentAndPartIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrPartPosiLimitDetail *CCurrPartPosiLimitDetailFactory::add(CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CTransaction *pTransaction)
{
	pCurrPartPosiLimitDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrPartPosiLimitDetail,true);
	}
	else {
		CCurrPartPosiLimitDetail *pNewCurrPartPosiLimitDetail;
		pNewCurrPartPosiLimitDetail = internalAdd(pCurrPartPosiLimitDetail,false);
		pTransaction->addResource(CCurrPartPosiLimitDetailResource::alloc(CREATE_ACTION,this,pNewCurrPartPosiLimitDetail,NULL));
		return pNewCurrPartPosiLimitDetail;
	}
}

void CCurrPartPosiLimitDetailFactory::internalUpdate(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pNewCurrPartPosiLimitDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrPartPosiLimitDetail++;
	}
	else {
		updateWithoutIndexActionForCurrPartPosiLimitDetail++;
	}
#endif
	CWriteableCurrPartPosiLimitDetail theOldCurrPartPosiLimitDetail;
	beforeUpdate(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPartPosiLimitDetail,pCurrPartPosiLimitDetail,sizeof(CCurrPartPosiLimitDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail,sizeof(CCurrPartPosiLimitDetail));
	pMem->updateObject(pCurrPartPosiLimitDetail);
	if (updateIndex) {
	}
	afterUpdate(pCurrPartPosiLimitDetail);
	if (bNoTransaction) {
		commitUpdate(pCurrPartPosiLimitDetail,&theOldCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::update(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pNewCurrPartPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrPartPosiLimitDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrPartPosiLimitDetailResource::alloc(UPDATE_ACTION,this,pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail,updateIndex));
		internalUpdate(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail,updateIndex,false);
	}
}

void CCurrPartPosiLimitDetailFactory::internalRemove(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrPartPosiLimitDetail++;
#endif
	CWriteableCurrPartPosiLimitDetail theOldCurrPartPosiLimitDetail;
	beforeRemove(pCurrPartPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrPartPosiLimitDetail,pCurrPartPosiLimitDetail,sizeof(CCurrPartPosiLimitDetail));
	}
	if (runLevel>=0) {
		pInstrumentAndPartIndex->removeObject(pCurrPartPosiLimitDetail);
	}
	pMem->free(pCurrPartPosiLimitDetail);
	if(bNoTransaction) {
		commitRemove(&theOldCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::remove(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrPartPosiLimitDetail,true);
	}
	else {
		pTransaction->addResource(CCurrPartPosiLimitDetailResource::alloc(DELETE_ACTION,this,pCurrPartPosiLimitDetail,NULL));
		internalRemove(pCurrPartPosiLimitDetail,false);		
	}
}

CCurrPartPosiLimitDetail* CCurrPartPosiLimitDetailFactory::addOrUpdate(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pNewCurrPartPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrPartPosiLimitDetail == NULL) {
		return add(pNewCurrPartPosiLimitDetail,pTransaction);
	}
	else {
		update(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail,pTransaction,updateIndex);
		return pCurrPartPosiLimitDetail;
	}
}

void CCurrPartPosiLimitDetailFactory::retrieve(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pTargetCurrPartPosiLimitDetail)
{
	forceCopy(pTargetCurrPartPosiLimitDetail, pCurrPartPosiLimitDetail, sizeof(CCurrPartPosiLimitDetail));
}
	
int CCurrPartPosiLimitDetailFactory::addActionTrigger(CCurrPartPosiLimitDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrPartPosiLimitDetailFactory::removeActionTrigger(CCurrPartPosiLimitDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrPartPosiLimitDetailFactory::addCommitTrigger(CCurrPartPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrPartPosiLimitDetailFactory::removeCommitTrigger(CCurrPartPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrPartPosiLimitDetail *CCurrPartPosiLimitDetailFactory::getFirst(void)
{
	CCurrPartPosiLimitDetail *pResult=(CCurrPartPosiLimitDetail *)(pMem->getFirst());
	return pResult;
}
	
CCurrPartPosiLimitDetail *CCurrPartPosiLimitDetailFactory::getNext(void)
{
	CCurrPartPosiLimitDetail *pResult=(CCurrPartPosiLimitDetail *)(pMem->getNext());
	return pResult;
}
	
void CCurrPartPosiLimitDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrPartPosiLimitDetailFactory::beforeAdd(CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrPartPosiLimitDetail);
	}
}
	
void CCurrPartPosiLimitDetailFactory::afterAdd(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::beforeUpdate(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pNewCurrPartPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrPartPosiLimitDetail,pNewCurrPartPosiLimitDetail);
	}
}
	
void CCurrPartPosiLimitDetailFactory::afterUpdate(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrPartPosiLimitDetail);
	}
}
	
void CCurrPartPosiLimitDetailFactory::beforeRemove(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::commitAdd(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrPartPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::commitUpdate(CCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail, CWriteableCurrPartPosiLimitDetail *pOldCurrPartPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrPartPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrPartPosiLimitDetail,pOldCurrPartPosiLimitDetail);
	}
}
	
void CCurrPartPosiLimitDetailFactory::commitRemove(CWriteableCurrPartPosiLimitDetail *pCurrPartPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrPartPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrPartPosiLimitDetail);
	}
}

void CCurrPartPosiLimitDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrClientPosiLimit=0;
int updateWithIndexActionForCurrClientPosiLimit=0;
int updateWithoutIndexActionForCurrClientPosiLimit=0;
int removeActionForCurrClientPosiLimit=0;
int addCommitForCurrClientPosiLimit=0;
int updateCommitForCurrClientPosiLimit=0;
int removeCommitForCurrClientPosiLimit=0;
#endif
void CCurrClientPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrClientPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CCurrClientPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrClientPosiLimitFactory::CCurrClientPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrClientPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrClientPosiLimitFactory::CCurrClientPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrClientPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrClientPosiLimitFactory::~CCurrClientPosiLimitFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrClientPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrClientPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrClientPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrClientPosiLimit thisCurrClientPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrClientPosiLimit.readCSV(input,pNames))
		add(&thisCurrClientPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrClientPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrClientPosiLimit.csv");
	return readCSV(szFileName);
}

int CCurrClientPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrClientPosiLimit *pCurrClientPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrClientPosiLimit::writeCSVHead(output);
	pCurrClientPosiLimit=(CWriteableCurrClientPosiLimit *)(pMem->getFirst());
	while (pCurrClientPosiLimit!=NULL) {
		if (!pCurrClientPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrClientPosiLimit=(CWriteableCurrClientPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrClientPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrClientPosiLimit.csv");
	return writeCSV(szFileName);
}

void CCurrClientPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrClientPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrClientPosiLimit *pCurrClientPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrClientPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pCurrClientPosiLimit=(CWriteableCurrClientPosiLimit *)(pMem->getFirst());
	while (pCurrClientPosiLimit!=NULL) {
		pCurrClientPosiLimit->dump(fp,index++);
		pCurrClientPosiLimit=(CWriteableCurrClientPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrClientPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CCurrClientPosiLimit *CCurrClientPosiLimitFactory::internalAdd(CWriteableCurrClientPosiLimit *pCurrClientPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrClientPosiLimit++;
#endif
	CCurrClientPosiLimit *pTarget;	
	beforeAdd(pCurrClientPosiLimit);
	pTarget=(CCurrClientPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrClientPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrClientPosiLimit, sizeof(CCurrClientPosiLimit));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrClientPosiLimit *CCurrClientPosiLimitFactory::add(CWriteableCurrClientPosiLimit *pCurrClientPosiLimit, CTransaction *pTransaction)
{
	pCurrClientPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrClientPosiLimit,true);
	}
	else {
		CCurrClientPosiLimit *pNewCurrClientPosiLimit;
		pNewCurrClientPosiLimit = internalAdd(pCurrClientPosiLimit,false);
		pTransaction->addResource(CCurrClientPosiLimitResource::alloc(CREATE_ACTION,this,pNewCurrClientPosiLimit,NULL));
		return pNewCurrClientPosiLimit;
	}
}

void CCurrClientPosiLimitFactory::internalUpdate(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pNewCurrClientPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrClientPosiLimit++;
	}
	else {
		updateWithoutIndexActionForCurrClientPosiLimit++;
	}
#endif
	CWriteableCurrClientPosiLimit theOldCurrClientPosiLimit;
	beforeUpdate(pCurrClientPosiLimit,pNewCurrClientPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrClientPosiLimit,pCurrClientPosiLimit,sizeof(CCurrClientPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrClientPosiLimit,pNewCurrClientPosiLimit,sizeof(CCurrClientPosiLimit));
	pMem->updateObject(pCurrClientPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pCurrClientPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pCurrClientPosiLimit,&theOldCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::update(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pNewCurrClientPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrClientPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrClientPosiLimit,pNewCurrClientPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrClientPosiLimitResource::alloc(UPDATE_ACTION,this,pCurrClientPosiLimit,pNewCurrClientPosiLimit,updateIndex));
		internalUpdate(pCurrClientPosiLimit,pNewCurrClientPosiLimit,updateIndex,false);
	}
}

void CCurrClientPosiLimitFactory::internalRemove(CCurrClientPosiLimit *pCurrClientPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrClientPosiLimit++;
#endif
	CWriteableCurrClientPosiLimit theOldCurrClientPosiLimit;
	beforeRemove(pCurrClientPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrClientPosiLimit,pCurrClientPosiLimit,sizeof(CCurrClientPosiLimit));
	}
	pMem->free(pCurrClientPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::remove(CCurrClientPosiLimit *pCurrClientPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrClientPosiLimit,true);
	}
	else {
		pTransaction->addResource(CCurrClientPosiLimitResource::alloc(DELETE_ACTION,this,pCurrClientPosiLimit,NULL));
		internalRemove(pCurrClientPosiLimit,false);		
	}
}

CCurrClientPosiLimit* CCurrClientPosiLimitFactory::addOrUpdate(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pNewCurrClientPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrClientPosiLimit == NULL) {
		return add(pNewCurrClientPosiLimit,pTransaction);
	}
	else {
		update(pCurrClientPosiLimit,pNewCurrClientPosiLimit,pTransaction,updateIndex);
		return pCurrClientPosiLimit;
	}
}

void CCurrClientPosiLimitFactory::retrieve(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pTargetCurrClientPosiLimit)
{
	forceCopy(pTargetCurrClientPosiLimit, pCurrClientPosiLimit, sizeof(CCurrClientPosiLimit));
}
	
int CCurrClientPosiLimitFactory::addActionTrigger(CCurrClientPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrClientPosiLimitFactory::removeActionTrigger(CCurrClientPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrClientPosiLimitFactory::addCommitTrigger(CCurrClientPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrClientPosiLimitFactory::removeCommitTrigger(CCurrClientPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrClientPosiLimit *CCurrClientPosiLimitFactory::getFirst(void)
{
	CCurrClientPosiLimit *pResult=(CCurrClientPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CCurrClientPosiLimit *CCurrClientPosiLimitFactory::getNext(void)
{
	CCurrClientPosiLimit *pResult=(CCurrClientPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CCurrClientPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrClientPosiLimitFactory::beforeAdd(CWriteableCurrClientPosiLimit *pCurrClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrClientPosiLimit);
	}
}
	
void CCurrClientPosiLimitFactory::afterAdd(CCurrClientPosiLimit *pCurrClientPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::beforeUpdate(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pNewCurrClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrClientPosiLimit,pNewCurrClientPosiLimit);
	}
}
	
void CCurrClientPosiLimitFactory::afterUpdate(CCurrClientPosiLimit *pCurrClientPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrClientPosiLimit);
	}
}
	
void CCurrClientPosiLimitFactory::beforeRemove(CCurrClientPosiLimit *pCurrClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::commitAdd(CCurrClientPosiLimit *pCurrClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::commitUpdate(CCurrClientPosiLimit *pCurrClientPosiLimit, CWriteableCurrClientPosiLimit *pOldCurrClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrClientPosiLimit,pOldCurrClientPosiLimit);
	}
}
	
void CCurrClientPosiLimitFactory::commitRemove(CWriteableCurrClientPosiLimit *pCurrClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrClientPosiLimit);
	}
}

void CCurrClientPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentAndClientTypeIndexinCurrClientPosiLimitDetail(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrClientPosiLimitDetail=0;
int updateWithIndexActionForCurrClientPosiLimitDetail=0;
int updateWithoutIndexActionForCurrClientPosiLimitDetail=0;
int removeActionForCurrClientPosiLimitDetail=0;
int addCommitForCurrClientPosiLimitDetail=0;
int updateCommitForCurrClientPosiLimitDetail=0;
int removeCommitForCurrClientPosiLimitDetail=0;
#endif
void CCurrClientPosiLimitDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentAndClientTypeIndex=new CAVLTree(maxUnit,compareForInstrumentAndClientTypeIndexinCurrClientPosiLimitDetail,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrClientPosiLimitDetail_InstrumentAndClientTypeIndex",pInstrumentAndClientTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrClientPosiLimitDetail_InstrumentAndClientTypeIndex");
			if(it != pIndexMap->end()) {
				pInstrumentAndClientTypeIndex=new CAVLTree(maxUnit,compareForInstrumentAndClientTypeIndexinCurrClientPosiLimitDetail,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentAndClientTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrClientPosiLimitDetailActionTrigger *>;
	pCommitTriggers=new vector<CCurrClientPosiLimitDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrClientPosiLimitDetailFactory::CCurrClientPosiLimitDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrClientPosiLimitDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrClientPosiLimitDetailFactory::CCurrClientPosiLimitDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrClientPosiLimitDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrClientPosiLimitDetailFactory::~CCurrClientPosiLimitDetailFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentAndClientTypeIndex!=NULL)
			delete pInstrumentAndClientTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrClientPosiLimitDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrClientPosiLimitDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentAndClientTypeIndex->output(pLogger,indent+1);
	}
}

int CCurrClientPosiLimitDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrClientPosiLimitDetail thisCurrClientPosiLimitDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrClientPosiLimitDetail.readCSV(input,pNames))
		add(&thisCurrClientPosiLimitDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrClientPosiLimitDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrClientPosiLimitDetail.csv");
	return readCSV(szFileName);
}

int CCurrClientPosiLimitDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrClientPosiLimitDetail::writeCSVHead(output);
	pCurrClientPosiLimitDetail=(CWriteableCurrClientPosiLimitDetail *)(pMem->getFirst());
	while (pCurrClientPosiLimitDetail!=NULL) {
		if (!pCurrClientPosiLimitDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrClientPosiLimitDetail=(CWriteableCurrClientPosiLimitDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrClientPosiLimitDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrClientPosiLimitDetail.csv");
	return writeCSV(szFileName);
}

void CCurrClientPosiLimitDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrClientPosiLimitDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrClientPosiLimitDetailFactory={       Total Count=%d\n", pMem->getCount());
	pCurrClientPosiLimitDetail=(CWriteableCurrClientPosiLimitDetail *)(pMem->getFirst());
	while (pCurrClientPosiLimitDetail!=NULL) {
		pCurrClientPosiLimitDetail->dump(fp,index++);
		pCurrClientPosiLimitDetail=(CWriteableCurrClientPosiLimitDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrClientPosiLimitDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentAndClientTypeIndex->removeAll();
	}
}

CCurrClientPosiLimitDetail *CCurrClientPosiLimitDetailFactory::internalAdd(CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrClientPosiLimitDetail++;
#endif
	CCurrClientPosiLimitDetail *pTarget;	
	beforeAdd(pCurrClientPosiLimitDetail);
	pTarget=(CCurrClientPosiLimitDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrClientPosiLimitDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrClientPosiLimitDetail, sizeof(CCurrClientPosiLimitDetail));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentAndClientTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrClientPosiLimitDetail *CCurrClientPosiLimitDetailFactory::add(CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CTransaction *pTransaction)
{
	pCurrClientPosiLimitDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrClientPosiLimitDetail,true);
	}
	else {
		CCurrClientPosiLimitDetail *pNewCurrClientPosiLimitDetail;
		pNewCurrClientPosiLimitDetail = internalAdd(pCurrClientPosiLimitDetail,false);
		pTransaction->addResource(CCurrClientPosiLimitDetailResource::alloc(CREATE_ACTION,this,pNewCurrClientPosiLimitDetail,NULL));
		return pNewCurrClientPosiLimitDetail;
	}
}

void CCurrClientPosiLimitDetailFactory::internalUpdate(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pNewCurrClientPosiLimitDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrClientPosiLimitDetail++;
	}
	else {
		updateWithoutIndexActionForCurrClientPosiLimitDetail++;
	}
#endif
	CWriteableCurrClientPosiLimitDetail theOldCurrClientPosiLimitDetail;
	beforeUpdate(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrClientPosiLimitDetail,pCurrClientPosiLimitDetail,sizeof(CCurrClientPosiLimitDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail,sizeof(CCurrClientPosiLimitDetail));
	pMem->updateObject(pCurrClientPosiLimitDetail);
	if (updateIndex) {
	}
	afterUpdate(pCurrClientPosiLimitDetail);
	if (bNoTransaction) {
		commitUpdate(pCurrClientPosiLimitDetail,&theOldCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::update(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pNewCurrClientPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrClientPosiLimitDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrClientPosiLimitDetailResource::alloc(UPDATE_ACTION,this,pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail,updateIndex));
		internalUpdate(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail,updateIndex,false);
	}
}

void CCurrClientPosiLimitDetailFactory::internalRemove(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrClientPosiLimitDetail++;
#endif
	CWriteableCurrClientPosiLimitDetail theOldCurrClientPosiLimitDetail;
	beforeRemove(pCurrClientPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrClientPosiLimitDetail,pCurrClientPosiLimitDetail,sizeof(CCurrClientPosiLimitDetail));
	}
	if (runLevel>=0) {
		pInstrumentAndClientTypeIndex->removeObject(pCurrClientPosiLimitDetail);
	}
	pMem->free(pCurrClientPosiLimitDetail);
	if(bNoTransaction) {
		commitRemove(&theOldCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::remove(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrClientPosiLimitDetail,true);
	}
	else {
		pTransaction->addResource(CCurrClientPosiLimitDetailResource::alloc(DELETE_ACTION,this,pCurrClientPosiLimitDetail,NULL));
		internalRemove(pCurrClientPosiLimitDetail,false);		
	}
}

CCurrClientPosiLimitDetail* CCurrClientPosiLimitDetailFactory::addOrUpdate(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pNewCurrClientPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrClientPosiLimitDetail == NULL) {
		return add(pNewCurrClientPosiLimitDetail,pTransaction);
	}
	else {
		update(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail,pTransaction,updateIndex);
		return pCurrClientPosiLimitDetail;
	}
}

void CCurrClientPosiLimitDetailFactory::retrieve(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pTargetCurrClientPosiLimitDetail)
{
	forceCopy(pTargetCurrClientPosiLimitDetail, pCurrClientPosiLimitDetail, sizeof(CCurrClientPosiLimitDetail));
}
	
int CCurrClientPosiLimitDetailFactory::addActionTrigger(CCurrClientPosiLimitDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrClientPosiLimitDetailFactory::removeActionTrigger(CCurrClientPosiLimitDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrClientPosiLimitDetailFactory::addCommitTrigger(CCurrClientPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrClientPosiLimitDetailFactory::removeCommitTrigger(CCurrClientPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrClientPosiLimitDetail *CCurrClientPosiLimitDetailFactory::getFirst(void)
{
	CCurrClientPosiLimitDetail *pResult=(CCurrClientPosiLimitDetail *)(pMem->getFirst());
	return pResult;
}
	
CCurrClientPosiLimitDetail *CCurrClientPosiLimitDetailFactory::getNext(void)
{
	CCurrClientPosiLimitDetail *pResult=(CCurrClientPosiLimitDetail *)(pMem->getNext());
	return pResult;
}
	
void CCurrClientPosiLimitDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrClientPosiLimitDetailFactory::beforeAdd(CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrClientPosiLimitDetail);
	}
}
	
void CCurrClientPosiLimitDetailFactory::afterAdd(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::beforeUpdate(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pNewCurrClientPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrClientPosiLimitDetail,pNewCurrClientPosiLimitDetail);
	}
}
	
void CCurrClientPosiLimitDetailFactory::afterUpdate(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrClientPosiLimitDetail);
	}
}
	
void CCurrClientPosiLimitDetailFactory::beforeRemove(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::commitAdd(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrClientPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::commitUpdate(CCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail, CWriteableCurrClientPosiLimitDetail *pOldCurrClientPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrClientPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrClientPosiLimitDetail,pOldCurrClientPosiLimitDetail);
	}
}
	
void CCurrClientPosiLimitDetailFactory::commitRemove(CWriteableCurrClientPosiLimitDetail *pCurrClientPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrClientPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrClientPosiLimitDetail);
	}
}

void CCurrClientPosiLimitDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForCurrSpecialPosiLimit=0;
int updateWithIndexActionForCurrSpecialPosiLimit=0;
int updateWithoutIndexActionForCurrSpecialPosiLimit=0;
int removeActionForCurrSpecialPosiLimit=0;
int addCommitForCurrSpecialPosiLimit=0;
int updateCommitForCurrSpecialPosiLimit=0;
int removeCommitForCurrSpecialPosiLimit=0;
#endif
void CCurrSpecialPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrSpecialPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CCurrSpecialPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrSpecialPosiLimitFactory::CCurrSpecialPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrSpecialPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrSpecialPosiLimitFactory::CCurrSpecialPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrSpecialPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrSpecialPosiLimitFactory::~CCurrSpecialPosiLimitFactory(void)
{
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrSpecialPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrSpecialPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CCurrSpecialPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrSpecialPosiLimit thisCurrSpecialPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrSpecialPosiLimit.readCSV(input,pNames))
		add(&thisCurrSpecialPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrSpecialPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrSpecialPosiLimit.csv");
	return readCSV(szFileName);
}

int CCurrSpecialPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrSpecialPosiLimit::writeCSVHead(output);
	pCurrSpecialPosiLimit=(CWriteableCurrSpecialPosiLimit *)(pMem->getFirst());
	while (pCurrSpecialPosiLimit!=NULL) {
		if (!pCurrSpecialPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrSpecialPosiLimit=(CWriteableCurrSpecialPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrSpecialPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrSpecialPosiLimit.csv");
	return writeCSV(szFileName);
}

void CCurrSpecialPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrSpecialPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrSpecialPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pCurrSpecialPosiLimit=(CWriteableCurrSpecialPosiLimit *)(pMem->getFirst());
	while (pCurrSpecialPosiLimit!=NULL) {
		pCurrSpecialPosiLimit->dump(fp,index++);
		pCurrSpecialPosiLimit=(CWriteableCurrSpecialPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrSpecialPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
}

CCurrSpecialPosiLimit *CCurrSpecialPosiLimitFactory::internalAdd(CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrSpecialPosiLimit++;
#endif
	CCurrSpecialPosiLimit *pTarget;	
	beforeAdd(pCurrSpecialPosiLimit);
	pTarget=(CCurrSpecialPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrSpecialPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrSpecialPosiLimit, sizeof(CCurrSpecialPosiLimit));
	pMem->updateObject(pTarget);
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrSpecialPosiLimit *CCurrSpecialPosiLimitFactory::add(CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CTransaction *pTransaction)
{
	pCurrSpecialPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrSpecialPosiLimit,true);
	}
	else {
		CCurrSpecialPosiLimit *pNewCurrSpecialPosiLimit;
		pNewCurrSpecialPosiLimit = internalAdd(pCurrSpecialPosiLimit,false);
		pTransaction->addResource(CCurrSpecialPosiLimitResource::alloc(CREATE_ACTION,this,pNewCurrSpecialPosiLimit,NULL));
		return pNewCurrSpecialPosiLimit;
	}
}

void CCurrSpecialPosiLimitFactory::internalUpdate(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pNewCurrSpecialPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrSpecialPosiLimit++;
	}
	else {
		updateWithoutIndexActionForCurrSpecialPosiLimit++;
	}
#endif
	CWriteableCurrSpecialPosiLimit theOldCurrSpecialPosiLimit;
	beforeUpdate(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrSpecialPosiLimit,pCurrSpecialPosiLimit,sizeof(CCurrSpecialPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit,sizeof(CCurrSpecialPosiLimit));
	pMem->updateObject(pCurrSpecialPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pCurrSpecialPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pCurrSpecialPosiLimit,&theOldCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::update(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pNewCurrSpecialPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrSpecialPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrSpecialPosiLimitResource::alloc(UPDATE_ACTION,this,pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit,updateIndex));
		internalUpdate(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit,updateIndex,false);
	}
}

void CCurrSpecialPosiLimitFactory::internalRemove(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrSpecialPosiLimit++;
#endif
	CWriteableCurrSpecialPosiLimit theOldCurrSpecialPosiLimit;
	beforeRemove(pCurrSpecialPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCurrSpecialPosiLimit,pCurrSpecialPosiLimit,sizeof(CCurrSpecialPosiLimit));
	}
	pMem->free(pCurrSpecialPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::remove(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrSpecialPosiLimit,true);
	}
	else {
		pTransaction->addResource(CCurrSpecialPosiLimitResource::alloc(DELETE_ACTION,this,pCurrSpecialPosiLimit,NULL));
		internalRemove(pCurrSpecialPosiLimit,false);		
	}
}

CCurrSpecialPosiLimit* CCurrSpecialPosiLimitFactory::addOrUpdate(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pNewCurrSpecialPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrSpecialPosiLimit == NULL) {
		return add(pNewCurrSpecialPosiLimit,pTransaction);
	}
	else {
		update(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit,pTransaction,updateIndex);
		return pCurrSpecialPosiLimit;
	}
}

void CCurrSpecialPosiLimitFactory::retrieve(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pTargetCurrSpecialPosiLimit)
{
	forceCopy(pTargetCurrSpecialPosiLimit, pCurrSpecialPosiLimit, sizeof(CCurrSpecialPosiLimit));
}
	
int CCurrSpecialPosiLimitFactory::addActionTrigger(CCurrSpecialPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrSpecialPosiLimitFactory::removeActionTrigger(CCurrSpecialPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrSpecialPosiLimitFactory::addCommitTrigger(CCurrSpecialPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrSpecialPosiLimitFactory::removeCommitTrigger(CCurrSpecialPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrSpecialPosiLimit *CCurrSpecialPosiLimitFactory::getFirst(void)
{
	CCurrSpecialPosiLimit *pResult=(CCurrSpecialPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CCurrSpecialPosiLimit *CCurrSpecialPosiLimitFactory::getNext(void)
{
	CCurrSpecialPosiLimit *pResult=(CCurrSpecialPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CCurrSpecialPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrSpecialPosiLimitFactory::beforeAdd(CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrSpecialPosiLimit);
	}
}
	
void CCurrSpecialPosiLimitFactory::afterAdd(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::beforeUpdate(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pNewCurrSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrSpecialPosiLimit,pNewCurrSpecialPosiLimit);
	}
}
	
void CCurrSpecialPosiLimitFactory::afterUpdate(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrSpecialPosiLimit);
	}
}
	
void CCurrSpecialPosiLimitFactory::beforeRemove(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::commitAdd(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::commitUpdate(CCurrSpecialPosiLimit *pCurrSpecialPosiLimit, CWriteableCurrSpecialPosiLimit *pOldCurrSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrSpecialPosiLimit,pOldCurrSpecialPosiLimit);
	}
}
	
void CCurrSpecialPosiLimitFactory::commitRemove(CWriteableCurrSpecialPosiLimit *pCurrSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrSpecialPosiLimit);
	}
}

void CCurrSpecialPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentAndClientIndexinCurrSpecialPosiLimitDetail(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrSpecialPosiLimitDetail=0;
int updateWithIndexActionForCurrSpecialPosiLimitDetail=0;
int updateWithoutIndexActionForCurrSpecialPosiLimitDetail=0;
int removeActionForCurrSpecialPosiLimitDetail=0;
int addCommitForCurrSpecialPosiLimitDetail=0;
int updateCommitForCurrSpecialPosiLimitDetail=0;
int removeCommitForCurrSpecialPosiLimitDetail=0;
#endif
void CCurrSpecialPosiLimitDetailFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentAndClientIndex=new CAVLTree(maxUnit,compareForInstrumentAndClientIndexinCurrSpecialPosiLimitDetail,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrSpecialPosiLimitDetail_InstrumentAndClientIndex",pInstrumentAndClientIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrSpecialPosiLimitDetail_InstrumentAndClientIndex");
			if(it != pIndexMap->end()) {
				pInstrumentAndClientIndex=new CAVLTree(maxUnit,compareForInstrumentAndClientIndexinCurrSpecialPosiLimitDetail,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentAndClientIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrSpecialPosiLimitDetailActionTrigger *>;
	pCommitTriggers=new vector<CCurrSpecialPosiLimitDetailCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrSpecialPosiLimitDetailFactory::CCurrSpecialPosiLimitDetailFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrSpecialPosiLimitDetail),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrSpecialPosiLimitDetailFactory::CCurrSpecialPosiLimitDetailFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrSpecialPosiLimitDetail),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrSpecialPosiLimitDetailFactory::~CCurrSpecialPosiLimitDetailFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentAndClientIndex!=NULL)
			delete pInstrumentAndClientIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrSpecialPosiLimitDetailFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrSpecialPosiLimitDetailFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentAndClientIndex->output(pLogger,indent+1);
	}
}

int CCurrSpecialPosiLimitDetailFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrSpecialPosiLimitDetail thisCurrSpecialPosiLimitDetail;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrSpecialPosiLimitDetail.readCSV(input,pNames))
		add(&thisCurrSpecialPosiLimitDetail);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrSpecialPosiLimitDetailFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrSpecialPosiLimitDetail.csv");
	return readCSV(szFileName);
}

int CCurrSpecialPosiLimitDetailFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrSpecialPosiLimitDetail::writeCSVHead(output);
	pCurrSpecialPosiLimitDetail=(CWriteableCurrSpecialPosiLimitDetail *)(pMem->getFirst());
	while (pCurrSpecialPosiLimitDetail!=NULL) {
		if (!pCurrSpecialPosiLimitDetail->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrSpecialPosiLimitDetail=(CWriteableCurrSpecialPosiLimitDetail *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrSpecialPosiLimitDetailFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrSpecialPosiLimitDetail.csv");
	return writeCSV(szFileName);
}

void CCurrSpecialPosiLimitDetailFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrSpecialPosiLimitDetailFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrSpecialPosiLimitDetailFactory={       Total Count=%d\n", pMem->getCount());
	pCurrSpecialPosiLimitDetail=(CWriteableCurrSpecialPosiLimitDetail *)(pMem->getFirst());
	while (pCurrSpecialPosiLimitDetail!=NULL) {
		pCurrSpecialPosiLimitDetail->dump(fp,index++);
		pCurrSpecialPosiLimitDetail=(CWriteableCurrSpecialPosiLimitDetail *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrSpecialPosiLimitDetailFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentAndClientIndex->removeAll();
	}
}

CCurrSpecialPosiLimitDetail *CCurrSpecialPosiLimitDetailFactory::internalAdd(CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrSpecialPosiLimitDetail++;
#endif
	CCurrSpecialPosiLimitDetail *pTarget;	
	beforeAdd(pCurrSpecialPosiLimitDetail);
	pTarget=(CCurrSpecialPosiLimitDetail *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrSpecialPosiLimitDetail in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrSpecialPosiLimitDetail, sizeof(CCurrSpecialPosiLimitDetail));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentAndClientIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrSpecialPosiLimitDetail *CCurrSpecialPosiLimitDetailFactory::add(CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CTransaction *pTransaction)
{
	pCurrSpecialPosiLimitDetail->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrSpecialPosiLimitDetail,true);
	}
	else {
		CCurrSpecialPosiLimitDetail *pNewCurrSpecialPosiLimitDetail;
		pNewCurrSpecialPosiLimitDetail = internalAdd(pCurrSpecialPosiLimitDetail,false);
		pTransaction->addResource(CCurrSpecialPosiLimitDetailResource::alloc(CREATE_ACTION,this,pNewCurrSpecialPosiLimitDetail,NULL));
		return pNewCurrSpecialPosiLimitDetail;
	}
}

void CCurrSpecialPosiLimitDetailFactory::internalUpdate(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pNewCurrSpecialPosiLimitDetail, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrSpecialPosiLimitDetail++;
	}
	else {
		updateWithoutIndexActionForCurrSpecialPosiLimitDetail++;
	}
#endif
	CWriteableCurrSpecialPosiLimitDetail theOldCurrSpecialPosiLimitDetail;
	beforeUpdate(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrSpecialPosiLimitDetail,pCurrSpecialPosiLimitDetail,sizeof(CCurrSpecialPosiLimitDetail));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail,sizeof(CCurrSpecialPosiLimitDetail));
	pMem->updateObject(pCurrSpecialPosiLimitDetail);
	if (updateIndex) {
	}
	afterUpdate(pCurrSpecialPosiLimitDetail);
	if (bNoTransaction) {
		commitUpdate(pCurrSpecialPosiLimitDetail,&theOldCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::update(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pNewCurrSpecialPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrSpecialPosiLimitDetail->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrSpecialPosiLimitDetailResource::alloc(UPDATE_ACTION,this,pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail,updateIndex));
		internalUpdate(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail,updateIndex,false);
	}
}

void CCurrSpecialPosiLimitDetailFactory::internalRemove(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrSpecialPosiLimitDetail++;
#endif
	CWriteableCurrSpecialPosiLimitDetail theOldCurrSpecialPosiLimitDetail;
	beforeRemove(pCurrSpecialPosiLimitDetail);
	if (bNoTransaction) {
		forceCopy(&theOldCurrSpecialPosiLimitDetail,pCurrSpecialPosiLimitDetail,sizeof(CCurrSpecialPosiLimitDetail));
	}
	if (runLevel>=0) {
		pInstrumentAndClientIndex->removeObject(pCurrSpecialPosiLimitDetail);
	}
	pMem->free(pCurrSpecialPosiLimitDetail);
	if(bNoTransaction) {
		commitRemove(&theOldCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::remove(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrSpecialPosiLimitDetail,true);
	}
	else {
		pTransaction->addResource(CCurrSpecialPosiLimitDetailResource::alloc(DELETE_ACTION,this,pCurrSpecialPosiLimitDetail,NULL));
		internalRemove(pCurrSpecialPosiLimitDetail,false);		
	}
}

CCurrSpecialPosiLimitDetail* CCurrSpecialPosiLimitDetailFactory::addOrUpdate(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pNewCurrSpecialPosiLimitDetail, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrSpecialPosiLimitDetail == NULL) {
		return add(pNewCurrSpecialPosiLimitDetail,pTransaction);
	}
	else {
		update(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail,pTransaction,updateIndex);
		return pCurrSpecialPosiLimitDetail;
	}
}

void CCurrSpecialPosiLimitDetailFactory::retrieve(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pTargetCurrSpecialPosiLimitDetail)
{
	forceCopy(pTargetCurrSpecialPosiLimitDetail, pCurrSpecialPosiLimitDetail, sizeof(CCurrSpecialPosiLimitDetail));
}
	
int CCurrSpecialPosiLimitDetailFactory::addActionTrigger(CCurrSpecialPosiLimitDetailActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrSpecialPosiLimitDetailFactory::removeActionTrigger(CCurrSpecialPosiLimitDetailActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrSpecialPosiLimitDetailFactory::addCommitTrigger(CCurrSpecialPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrSpecialPosiLimitDetailFactory::removeCommitTrigger(CCurrSpecialPosiLimitDetailCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrSpecialPosiLimitDetail *CCurrSpecialPosiLimitDetailFactory::getFirst(void)
{
	CCurrSpecialPosiLimitDetail *pResult=(CCurrSpecialPosiLimitDetail *)(pMem->getFirst());
	return pResult;
}
	
CCurrSpecialPosiLimitDetail *CCurrSpecialPosiLimitDetailFactory::getNext(void)
{
	CCurrSpecialPosiLimitDetail *pResult=(CCurrSpecialPosiLimitDetail *)(pMem->getNext());
	return pResult;
}
	
void CCurrSpecialPosiLimitDetailFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrSpecialPosiLimitDetailFactory::beforeAdd(CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrSpecialPosiLimitDetail);
	}
}
	
void CCurrSpecialPosiLimitDetailFactory::afterAdd(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::beforeUpdate(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pNewCurrSpecialPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrSpecialPosiLimitDetail,pNewCurrSpecialPosiLimitDetail);
	}
}
	
void CCurrSpecialPosiLimitDetailFactory::afterUpdate(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrSpecialPosiLimitDetail);
	}
}
	
void CCurrSpecialPosiLimitDetailFactory::beforeRemove(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::commitAdd(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrSpecialPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::commitUpdate(CCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail, CWriteableCurrSpecialPosiLimitDetail *pOldCurrSpecialPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrSpecialPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrSpecialPosiLimitDetail,pOldCurrSpecialPosiLimitDetail);
	}
}
	
void CCurrSpecialPosiLimitDetailFactory::commitRemove(CWriteableCurrSpecialPosiLimitDetail *pCurrSpecialPosiLimitDetail)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrSpecialPosiLimitDetail++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrSpecialPosiLimitDetail);
	}
}

void CCurrSpecialPosiLimitDetailFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinCurrHedgeRule(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrHedgeRule=0;
int updateWithIndexActionForCurrHedgeRule=0;
int updateWithoutIndexActionForCurrHedgeRule=0;
int removeActionForCurrHedgeRule=0;
int addCommitForCurrHedgeRule=0;
int updateCommitForCurrHedgeRule=0;
int removeCommitForCurrHedgeRule=0;
#endif
void CCurrHedgeRuleFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrHedgeRule,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrHedgeRule_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrHedgeRule_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrHedgeRule,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrHedgeRuleActionTrigger *>;
	pCommitTriggers=new vector<CCurrHedgeRuleCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrHedgeRuleFactory::CCurrHedgeRuleFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrHedgeRule),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrHedgeRuleFactory::CCurrHedgeRuleFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrHedgeRule),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrHedgeRuleFactory::~CCurrHedgeRuleFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrHedgeRuleFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrHedgeRuleFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CCurrHedgeRuleFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrHedgeRule thisCurrHedgeRule;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrHedgeRule.readCSV(input,pNames))
		add(&thisCurrHedgeRule);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrHedgeRuleFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrHedgeRule.csv");
	return readCSV(szFileName);
}

int CCurrHedgeRuleFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrHedgeRule *pCurrHedgeRule;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrHedgeRule::writeCSVHead(output);
	pCurrHedgeRule=(CWriteableCurrHedgeRule *)(pMem->getFirst());
	while (pCurrHedgeRule!=NULL) {
		if (!pCurrHedgeRule->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrHedgeRule=(CWriteableCurrHedgeRule *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrHedgeRuleFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrHedgeRule.csv");
	return writeCSV(szFileName);
}

void CCurrHedgeRuleFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrHedgeRuleFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrHedgeRule *pCurrHedgeRule;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrHedgeRuleFactory={       Total Count=%d\n", pMem->getCount());
	pCurrHedgeRule=(CWriteableCurrHedgeRule *)(pMem->getFirst());
	while (pCurrHedgeRule!=NULL) {
		pCurrHedgeRule->dump(fp,index++);
		pCurrHedgeRule=(CWriteableCurrHedgeRule *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrHedgeRuleFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CCurrHedgeRule *CCurrHedgeRuleFactory::internalAdd(CWriteableCurrHedgeRule *pCurrHedgeRule, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrHedgeRule++;
#endif
	CCurrHedgeRule *pTarget;	
	beforeAdd(pCurrHedgeRule);
	pTarget=(CCurrHedgeRule *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrHedgeRule in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrHedgeRule, sizeof(CCurrHedgeRule));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrHedgeRule *CCurrHedgeRuleFactory::add(CWriteableCurrHedgeRule *pCurrHedgeRule, CTransaction *pTransaction)
{
	pCurrHedgeRule->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrHedgeRule,true);
	}
	else {
		CCurrHedgeRule *pNewCurrHedgeRule;
		pNewCurrHedgeRule = internalAdd(pCurrHedgeRule,false);
		pTransaction->addResource(CCurrHedgeRuleResource::alloc(CREATE_ACTION,this,pNewCurrHedgeRule,NULL));
		return pNewCurrHedgeRule;
	}
}

void CCurrHedgeRuleFactory::internalUpdate(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pNewCurrHedgeRule, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrHedgeRule++;
	}
	else {
		updateWithoutIndexActionForCurrHedgeRule++;
	}
#endif
	CWriteableCurrHedgeRule theOldCurrHedgeRule;
	beforeUpdate(pCurrHedgeRule,pNewCurrHedgeRule);
	if (bNoTransaction) {
		forceCopy(&theOldCurrHedgeRule,pCurrHedgeRule,sizeof(CCurrHedgeRule));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrHedgeRule,pNewCurrHedgeRule,sizeof(CCurrHedgeRule));
	pMem->updateObject(pCurrHedgeRule);
	if (updateIndex) {
	}
	afterUpdate(pCurrHedgeRule);
	if (bNoTransaction) {
		commitUpdate(pCurrHedgeRule,&theOldCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::update(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pNewCurrHedgeRule, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrHedgeRule->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrHedgeRule,pNewCurrHedgeRule,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrHedgeRuleResource::alloc(UPDATE_ACTION,this,pCurrHedgeRule,pNewCurrHedgeRule,updateIndex));
		internalUpdate(pCurrHedgeRule,pNewCurrHedgeRule,updateIndex,false);
	}
}

void CCurrHedgeRuleFactory::internalRemove(CCurrHedgeRule *pCurrHedgeRule, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrHedgeRule++;
#endif
	CWriteableCurrHedgeRule theOldCurrHedgeRule;
	beforeRemove(pCurrHedgeRule);
	if (bNoTransaction) {
		forceCopy(&theOldCurrHedgeRule,pCurrHedgeRule,sizeof(CCurrHedgeRule));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pCurrHedgeRule);
	}
	pMem->free(pCurrHedgeRule);
	if(bNoTransaction) {
		commitRemove(&theOldCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::remove(CCurrHedgeRule *pCurrHedgeRule, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrHedgeRule,true);
	}
	else {
		pTransaction->addResource(CCurrHedgeRuleResource::alloc(DELETE_ACTION,this,pCurrHedgeRule,NULL));
		internalRemove(pCurrHedgeRule,false);		
	}
}

CCurrHedgeRule* CCurrHedgeRuleFactory::addOrUpdate(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pNewCurrHedgeRule, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrHedgeRule == NULL) {
		return add(pNewCurrHedgeRule,pTransaction);
	}
	else {
		update(pCurrHedgeRule,pNewCurrHedgeRule,pTransaction,updateIndex);
		return pCurrHedgeRule;
	}
}

void CCurrHedgeRuleFactory::retrieve(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pTargetCurrHedgeRule)
{
	forceCopy(pTargetCurrHedgeRule, pCurrHedgeRule, sizeof(CCurrHedgeRule));
}
	
int CCurrHedgeRuleFactory::addActionTrigger(CCurrHedgeRuleActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrHedgeRuleFactory::removeActionTrigger(CCurrHedgeRuleActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrHedgeRuleFactory::addCommitTrigger(CCurrHedgeRuleCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrHedgeRuleFactory::removeCommitTrigger(CCurrHedgeRuleCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrHedgeRule *CCurrHedgeRuleFactory::getFirst(void)
{
	CCurrHedgeRule *pResult=(CCurrHedgeRule *)(pMem->getFirst());
	return pResult;
}
	
CCurrHedgeRule *CCurrHedgeRuleFactory::getNext(void)
{
	CCurrHedgeRule *pResult=(CCurrHedgeRule *)(pMem->getNext());
	return pResult;
}
	
void CCurrHedgeRuleFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrHedgeRuleFactory::beforeAdd(CWriteableCurrHedgeRule *pCurrHedgeRule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrHedgeRule);
	}
}
	
void CCurrHedgeRuleFactory::afterAdd(CCurrHedgeRule *pCurrHedgeRule)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::beforeUpdate(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pNewCurrHedgeRule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrHedgeRule,pNewCurrHedgeRule);
	}
}
	
void CCurrHedgeRuleFactory::afterUpdate(CCurrHedgeRule *pCurrHedgeRule)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrHedgeRule);
	}
}
	
void CCurrHedgeRuleFactory::beforeRemove(CCurrHedgeRule *pCurrHedgeRule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::commitAdd(CCurrHedgeRule *pCurrHedgeRule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrHedgeRule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::commitUpdate(CCurrHedgeRule *pCurrHedgeRule, CWriteableCurrHedgeRule *pOldCurrHedgeRule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrHedgeRule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrHedgeRule,pOldCurrHedgeRule);
	}
}
	
void CCurrHedgeRuleFactory::commitRemove(CWriteableCurrHedgeRule *pCurrHedgeRule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrHedgeRule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrHedgeRule);
	}
}

void CCurrHedgeRuleFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForTimeIndexinCurrTradingSegmentAttr(const void *pV1, const void *pV2);
extern int compareForInstrumentIndexinCurrTradingSegmentAttr(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrTradingSegmentAttr=0;
int updateWithIndexActionForCurrTradingSegmentAttr=0;
int updateWithoutIndexActionForCurrTradingSegmentAttr=0;
int removeActionForCurrTradingSegmentAttr=0;
int addCommitForCurrTradingSegmentAttr=0;
int updateCommitForCurrTradingSegmentAttr=0;
int removeCommitForCurrTradingSegmentAttr=0;
#endif
void CCurrTradingSegmentAttrFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pTimeIndex=new CAVLTree(maxUnit,compareForTimeIndexinCurrTradingSegmentAttr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrTradingSegmentAttr_TimeIndex",pTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrTradingSegmentAttr_TimeIndex");
			if(it != pIndexMap->end()) {
				pTimeIndex=new CAVLTree(maxUnit,compareForTimeIndexinCurrTradingSegmentAttr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinCurrTradingSegmentAttr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrTradingSegmentAttr_InstrumentIndex",pInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrTradingSegmentAttr_InstrumentIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinCurrTradingSegmentAttr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByTime=NULL;
	pLastFoundInSearchByInstrument=NULL;
	pActionTriggers=new vector<CCurrTradingSegmentAttrActionTrigger *>;
	pCommitTriggers=new vector<CCurrTradingSegmentAttrCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrTradingSegmentAttrFactory::CCurrTradingSegmentAttrFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrTradingSegmentAttr),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrTradingSegmentAttrFactory::CCurrTradingSegmentAttrFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrTradingSegmentAttr),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrTradingSegmentAttrFactory::~CCurrTradingSegmentAttrFactory(void)
{
	if (runLevel>=0) {
		if (pTimeIndex!=NULL)
			delete pTimeIndex;
	}
	if (runLevel>=0) {
		if (pInstrumentIndex!=NULL)
			delete pInstrumentIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrTradingSegmentAttrFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrTradingSegmentAttrFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pTimeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pInstrumentIndex->output(pLogger,indent+1);
	}
}

int CCurrTradingSegmentAttrFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrTradingSegmentAttr thisCurrTradingSegmentAttr;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrTradingSegmentAttr.readCSV(input,pNames))
		add(&thisCurrTradingSegmentAttr);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrTradingSegmentAttrFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrTradingSegmentAttr.csv");
	return readCSV(szFileName);
}

int CCurrTradingSegmentAttrFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrTradingSegmentAttr::writeCSVHead(output);
	pCurrTradingSegmentAttr=(CWriteableCurrTradingSegmentAttr *)(pMem->getFirst());
	while (pCurrTradingSegmentAttr!=NULL) {
		if (!pCurrTradingSegmentAttr->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrTradingSegmentAttr=(CWriteableCurrTradingSegmentAttr *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrTradingSegmentAttrFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrTradingSegmentAttr.csv");
	return writeCSV(szFileName);
}

void CCurrTradingSegmentAttrFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrTradingSegmentAttrFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrTradingSegmentAttrFactory={       Total Count=%d\n", pMem->getCount());
	pCurrTradingSegmentAttr=(CWriteableCurrTradingSegmentAttr *)(pMem->getFirst());
	while (pCurrTradingSegmentAttr!=NULL) {
		pCurrTradingSegmentAttr->dump(fp,index++);
		pCurrTradingSegmentAttr=(CWriteableCurrTradingSegmentAttr *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrTradingSegmentAttrFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pTimeIndex->removeAll();
	}
	if (runLevel>=0) {
		pInstrumentIndex->removeAll();
	}
}

CCurrTradingSegmentAttr *CCurrTradingSegmentAttrFactory::internalAdd(CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrTradingSegmentAttr++;
#endif
	CCurrTradingSegmentAttr *pTarget;	
	beforeAdd(pCurrTradingSegmentAttr);
	pTarget=(CCurrTradingSegmentAttr *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrTradingSegmentAttr in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrTradingSegmentAttr, sizeof(CCurrTradingSegmentAttr));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pTimeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pInstrumentIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrTradingSegmentAttr *CCurrTradingSegmentAttrFactory::add(CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CTransaction *pTransaction)
{
	pCurrTradingSegmentAttr->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrTradingSegmentAttr,true);
	}
	else {
		CCurrTradingSegmentAttr *pNewCurrTradingSegmentAttr;
		pNewCurrTradingSegmentAttr = internalAdd(pCurrTradingSegmentAttr,false);
		pTransaction->addResource(CCurrTradingSegmentAttrResource::alloc(CREATE_ACTION,this,pNewCurrTradingSegmentAttr,NULL));
		return pNewCurrTradingSegmentAttr;
	}
}

void CCurrTradingSegmentAttrFactory::internalUpdate(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pNewCurrTradingSegmentAttr, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrTradingSegmentAttr++;
	}
	else {
		updateWithoutIndexActionForCurrTradingSegmentAttr++;
	}
#endif
	CWriteableCurrTradingSegmentAttr theOldCurrTradingSegmentAttr;
	beforeUpdate(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr);
	if (bNoTransaction) {
		forceCopy(&theOldCurrTradingSegmentAttr,pCurrTradingSegmentAttr,sizeof(CCurrTradingSegmentAttr));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr,sizeof(CCurrTradingSegmentAttr));
	pMem->updateObject(pCurrTradingSegmentAttr);
	if (updateIndex) {
	}
	afterUpdate(pCurrTradingSegmentAttr);
	if (bNoTransaction) {
		commitUpdate(pCurrTradingSegmentAttr,&theOldCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::update(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pNewCurrTradingSegmentAttr, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrTradingSegmentAttr->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrTradingSegmentAttrResource::alloc(UPDATE_ACTION,this,pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr,updateIndex));
		internalUpdate(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr,updateIndex,false);
	}
}

void CCurrTradingSegmentAttrFactory::internalRemove(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrTradingSegmentAttr++;
#endif
	CWriteableCurrTradingSegmentAttr theOldCurrTradingSegmentAttr;
	beforeRemove(pCurrTradingSegmentAttr);
	if (bNoTransaction) {
		forceCopy(&theOldCurrTradingSegmentAttr,pCurrTradingSegmentAttr,sizeof(CCurrTradingSegmentAttr));
	}
	if (runLevel>=0) {
		pTimeIndex->removeObject(pCurrTradingSegmentAttr);
	}
	if (runLevel>=0) {
		pInstrumentIndex->removeObject(pCurrTradingSegmentAttr);
	}
	pMem->free(pCurrTradingSegmentAttr);
	if(bNoTransaction) {
		commitRemove(&theOldCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::remove(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrTradingSegmentAttr,true);
	}
	else {
		pTransaction->addResource(CCurrTradingSegmentAttrResource::alloc(DELETE_ACTION,this,pCurrTradingSegmentAttr,NULL));
		internalRemove(pCurrTradingSegmentAttr,false);		
	}
}

CCurrTradingSegmentAttr* CCurrTradingSegmentAttrFactory::addOrUpdate(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pNewCurrTradingSegmentAttr, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrTradingSegmentAttr == NULL) {
		return add(pNewCurrTradingSegmentAttr,pTransaction);
	}
	else {
		update(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr,pTransaction,updateIndex);
		return pCurrTradingSegmentAttr;
	}
}

void CCurrTradingSegmentAttrFactory::retrieve(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pTargetCurrTradingSegmentAttr)
{
	forceCopy(pTargetCurrTradingSegmentAttr, pCurrTradingSegmentAttr, sizeof(CCurrTradingSegmentAttr));
}
	
int CCurrTradingSegmentAttrFactory::addActionTrigger(CCurrTradingSegmentAttrActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrTradingSegmentAttrFactory::removeActionTrigger(CCurrTradingSegmentAttrActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrTradingSegmentAttrFactory::addCommitTrigger(CCurrTradingSegmentAttrCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrTradingSegmentAttrFactory::removeCommitTrigger(CCurrTradingSegmentAttrCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrTradingSegmentAttr *CCurrTradingSegmentAttrFactory::getFirst(void)
{
	CCurrTradingSegmentAttr *pResult=(CCurrTradingSegmentAttr *)(pMem->getFirst());
	return pResult;
}
	
CCurrTradingSegmentAttr *CCurrTradingSegmentAttrFactory::getNext(void)
{
	CCurrTradingSegmentAttr *pResult=(CCurrTradingSegmentAttr *)(pMem->getNext());
	return pResult;
}
	
void CCurrTradingSegmentAttrFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrTradingSegmentAttrFactory::beforeAdd(CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrTradingSegmentAttr);
	}
}
	
void CCurrTradingSegmentAttrFactory::afterAdd(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::beforeUpdate(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pNewCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrTradingSegmentAttr,pNewCurrTradingSegmentAttr);
	}
}
	
void CCurrTradingSegmentAttrFactory::afterUpdate(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrTradingSegmentAttr);
	}
}
	
void CCurrTradingSegmentAttrFactory::beforeRemove(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::commitAdd(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::commitUpdate(CCurrTradingSegmentAttr *pCurrTradingSegmentAttr, CWriteableCurrTradingSegmentAttr *pOldCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrTradingSegmentAttr,pOldCurrTradingSegmentAttr);
	}
}
	
void CCurrTradingSegmentAttrFactory::commitRemove(CWriteableCurrTradingSegmentAttr *pCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrTradingSegmentAttr);
	}
}

void CCurrTradingSegmentAttrFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinCurrFuse(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrFuse=0;
int updateWithIndexActionForCurrFuse=0;
int updateWithoutIndexActionForCurrFuse=0;
int removeActionForCurrFuse=0;
int addCommitForCurrFuse=0;
int updateCommitForCurrFuse=0;
int removeCommitForCurrFuse=0;
#endif
void CCurrFuseFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrFuse,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrFuse_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrFuse_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrFuse,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrFuseActionTrigger *>;
	pCommitTriggers=new vector<CCurrFuseCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrFuseFactory::CCurrFuseFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrFuse),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrFuseFactory::CCurrFuseFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrFuse),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrFuseFactory::~CCurrFuseFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrFuseFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrFuseFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CCurrFuseFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrFuse thisCurrFuse;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrFuse.readCSV(input,pNames))
		add(&thisCurrFuse);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrFuseFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrFuse.csv");
	return readCSV(szFileName);
}

int CCurrFuseFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrFuse *pCurrFuse;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrFuse::writeCSVHead(output);
	pCurrFuse=(CWriteableCurrFuse *)(pMem->getFirst());
	while (pCurrFuse!=NULL) {
		if (!pCurrFuse->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrFuse=(CWriteableCurrFuse *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrFuseFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrFuse.csv");
	return writeCSV(szFileName);
}

void CCurrFuseFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrFuseFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrFuse *pCurrFuse;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrFuseFactory={       Total Count=%d\n", pMem->getCount());
	pCurrFuse=(CWriteableCurrFuse *)(pMem->getFirst());
	while (pCurrFuse!=NULL) {
		pCurrFuse->dump(fp,index++);
		pCurrFuse=(CWriteableCurrFuse *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrFuseFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CCurrFuse *CCurrFuseFactory::internalAdd(CWriteableCurrFuse *pCurrFuse, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrFuse++;
#endif
	CCurrFuse *pTarget;	
	beforeAdd(pCurrFuse);
	pTarget=(CCurrFuse *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrFuse in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrFuse, sizeof(CCurrFuse));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrFuse *CCurrFuseFactory::add(CWriteableCurrFuse *pCurrFuse, CTransaction *pTransaction)
{
	pCurrFuse->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrFuse,true);
	}
	else {
		CCurrFuse *pNewCurrFuse;
		pNewCurrFuse = internalAdd(pCurrFuse,false);
		pTransaction->addResource(CCurrFuseResource::alloc(CREATE_ACTION,this,pNewCurrFuse,NULL));
		return pNewCurrFuse;
	}
}

void CCurrFuseFactory::internalUpdate(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pNewCurrFuse, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrFuse++;
	}
	else {
		updateWithoutIndexActionForCurrFuse++;
	}
#endif
	CWriteableCurrFuse theOldCurrFuse;
	beforeUpdate(pCurrFuse,pNewCurrFuse);
	if (bNoTransaction) {
		forceCopy(&theOldCurrFuse,pCurrFuse,sizeof(CCurrFuse));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrFuse,pNewCurrFuse,sizeof(CCurrFuse));
	pMem->updateObject(pCurrFuse);
	if (updateIndex) {
	}
	afterUpdate(pCurrFuse);
	if (bNoTransaction) {
		commitUpdate(pCurrFuse,&theOldCurrFuse);
	}
}

void CCurrFuseFactory::update(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pNewCurrFuse, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrFuse->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrFuse,pNewCurrFuse,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrFuseResource::alloc(UPDATE_ACTION,this,pCurrFuse,pNewCurrFuse,updateIndex));
		internalUpdate(pCurrFuse,pNewCurrFuse,updateIndex,false);
	}
}

void CCurrFuseFactory::internalRemove(CCurrFuse *pCurrFuse, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrFuse++;
#endif
	CWriteableCurrFuse theOldCurrFuse;
	beforeRemove(pCurrFuse);
	if (bNoTransaction) {
		forceCopy(&theOldCurrFuse,pCurrFuse,sizeof(CCurrFuse));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pCurrFuse);
	}
	pMem->free(pCurrFuse);
	if(bNoTransaction) {
		commitRemove(&theOldCurrFuse);
	}
}

void CCurrFuseFactory::remove(CCurrFuse *pCurrFuse, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrFuse,true);
	}
	else {
		pTransaction->addResource(CCurrFuseResource::alloc(DELETE_ACTION,this,pCurrFuse,NULL));
		internalRemove(pCurrFuse,false);		
	}
}

CCurrFuse* CCurrFuseFactory::addOrUpdate(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pNewCurrFuse, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrFuse == NULL) {
		return add(pNewCurrFuse,pTransaction);
	}
	else {
		update(pCurrFuse,pNewCurrFuse,pTransaction,updateIndex);
		return pCurrFuse;
	}
}

void CCurrFuseFactory::retrieve(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pTargetCurrFuse)
{
	forceCopy(pTargetCurrFuse, pCurrFuse, sizeof(CCurrFuse));
}
	
int CCurrFuseFactory::addActionTrigger(CCurrFuseActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrFuseFactory::removeActionTrigger(CCurrFuseActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrFuseFactory::addCommitTrigger(CCurrFuseCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrFuseFactory::removeCommitTrigger(CCurrFuseCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrFuse *CCurrFuseFactory::getFirst(void)
{
	CCurrFuse *pResult=(CCurrFuse *)(pMem->getFirst());
	return pResult;
}
	
CCurrFuse *CCurrFuseFactory::getNext(void)
{
	CCurrFuse *pResult=(CCurrFuse *)(pMem->getNext());
	return pResult;
}
	
void CCurrFuseFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrFuseFactory::beforeAdd(CWriteableCurrFuse *pCurrFuse)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrFuse);
	}
}
	
void CCurrFuseFactory::afterAdd(CCurrFuse *pCurrFuse)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrFuse);
	}
}

void CCurrFuseFactory::beforeUpdate(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pNewCurrFuse)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrFuse,pNewCurrFuse);
	}
}
	
void CCurrFuseFactory::afterUpdate(CCurrFuse *pCurrFuse)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrFuse);
	}
}
	
void CCurrFuseFactory::beforeRemove(CCurrFuse *pCurrFuse)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrFuse);
	}
}

void CCurrFuseFactory::commitAdd(CCurrFuse *pCurrFuse)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrFuse++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrFuse);
	}
}

void CCurrFuseFactory::commitUpdate(CCurrFuse *pCurrFuse, CWriteableCurrFuse *pOldCurrFuse)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrFuse++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrFuse,pOldCurrFuse);
	}
}
	
void CCurrFuseFactory::commitRemove(CWriteableCurrFuse *pCurrFuse)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrFuse++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrFuse);
	}
}

void CCurrFuseFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForAccountIDIndexinTradingAccount(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForTradingAccount=0;
int updateWithIndexActionForTradingAccount=0;
int updateWithoutIndexActionForTradingAccount=0;
int removeActionForTradingAccount=0;
int addCommitForTradingAccount=0;
int updateCommitForTradingAccount=0;
int removeCommitForTradingAccount=0;
#endif
void CTradingAccountFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinTradingAccount,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("TradingAccount_AccountIDIndex",pAccountIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("TradingAccount_AccountIDIndex");
			if(it != pIndexMap->end()) {
				pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinTradingAccount,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pAccountIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CTradingAccountActionTrigger *>;
	pCommitTriggers=new vector<CTradingAccountCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CTradingAccountFactory::CTradingAccountFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTradingAccount),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CTradingAccountFactory::CTradingAccountFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTradingAccount),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CTradingAccountFactory::~CTradingAccountFactory(void)
{
	if (runLevel>=0) {
		if (pAccountIDIndex!=NULL)
			delete pAccountIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CTradingAccountFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CTradingAccountFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pAccountIDIndex->output(pLogger,indent+1);
	}
}

int CTradingAccountFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableTradingAccount thisTradingAccount;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisTradingAccount.readCSV(input,pNames))
		add(&thisTradingAccount);
	fclose(input);
	delete pNames;
	return 1;
}

int CTradingAccountFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "TradingAccount.csv");
	return readCSV(szFileName);
}

int CTradingAccountFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableTradingAccount *pTradingAccount;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableTradingAccount::writeCSVHead(output);
	pTradingAccount=(CWriteableTradingAccount *)(pMem->getFirst());
	while (pTradingAccount!=NULL) {
		if (!pTradingAccount->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pTradingAccount=(CWriteableTradingAccount *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CTradingAccountFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "TradingAccount.csv");
	return writeCSV(szFileName);
}

void CTradingAccountFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CTradingAccountFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableTradingAccount *pTradingAccount;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CTradingAccountFactory={       Total Count=%d\n", pMem->getCount());
	pTradingAccount=(CWriteableTradingAccount *)(pMem->getFirst());
	while (pTradingAccount!=NULL) {
		pTradingAccount->dump(fp,index++);
		pTradingAccount=(CWriteableTradingAccount *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CTradingAccountFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pAccountIDIndex->removeAll();
	}
}

CTradingAccount *CTradingAccountFactory::internalAdd(CWriteableTradingAccount *pTradingAccount, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForTradingAccount++;
#endif
	CTradingAccount *pTarget;	
	beforeAdd(pTradingAccount);
	pTarget=(CTradingAccount *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough TradingAccount in memory database");
		return NULL;
	}
	forceCopy(pTarget, pTradingAccount, sizeof(CTradingAccount));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pAccountIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CTradingAccount *CTradingAccountFactory::add(CWriteableTradingAccount *pTradingAccount, CTransaction *pTransaction)
{
	pTradingAccount->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pTradingAccount,true);
	}
	else {
		CTradingAccount *pNewTradingAccount;
		pNewTradingAccount = internalAdd(pTradingAccount,false);
		pTransaction->addResource(CTradingAccountResource::alloc(CREATE_ACTION,this,pNewTradingAccount,NULL));
		return pNewTradingAccount;
	}
}

void CTradingAccountFactory::internalUpdate(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pNewTradingAccount, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForTradingAccount++;
	}
	else {
		updateWithoutIndexActionForTradingAccount++;
	}
#endif
	CWriteableTradingAccount theOldTradingAccount;
	beforeUpdate(pTradingAccount,pNewTradingAccount);
	if (bNoTransaction) {
		forceCopy(&theOldTradingAccount,pTradingAccount,sizeof(CTradingAccount));
	}
	if (updateIndex) {
	}

	forceCopy(pTradingAccount,pNewTradingAccount,sizeof(CTradingAccount));
	pMem->updateObject(pTradingAccount);
	if (updateIndex) {
	}
	afterUpdate(pTradingAccount);
	if (bNoTransaction) {
		commitUpdate(pTradingAccount,&theOldTradingAccount);
	}
}

void CTradingAccountFactory::update(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pNewTradingAccount, CTransaction *pTransaction, bool updateIndex)
{
	pNewTradingAccount->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pTradingAccount,pNewTradingAccount,updateIndex,true);
	}
	else {
		pTransaction->addResource(CTradingAccountResource::alloc(UPDATE_ACTION,this,pTradingAccount,pNewTradingAccount,updateIndex));
		internalUpdate(pTradingAccount,pNewTradingAccount,updateIndex,false);
	}
}

void CTradingAccountFactory::internalRemove(CTradingAccount *pTradingAccount, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForTradingAccount++;
#endif
	CWriteableTradingAccount theOldTradingAccount;
	beforeRemove(pTradingAccount);
	if (bNoTransaction) {
		forceCopy(&theOldTradingAccount,pTradingAccount,sizeof(CTradingAccount));
	}
	if (runLevel>=0) {
		pAccountIDIndex->removeObject(pTradingAccount);
	}
	pMem->free(pTradingAccount);
	if(bNoTransaction) {
		commitRemove(&theOldTradingAccount);
	}
}

void CTradingAccountFactory::remove(CTradingAccount *pTradingAccount, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pTradingAccount,true);
	}
	else {
		pTransaction->addResource(CTradingAccountResource::alloc(DELETE_ACTION,this,pTradingAccount,NULL));
		internalRemove(pTradingAccount,false);		
	}
}

CTradingAccount* CTradingAccountFactory::addOrUpdate(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pNewTradingAccount, CTransaction *pTransaction, bool updateIndex)
{
	if(pTradingAccount == NULL) {
		return add(pNewTradingAccount,pTransaction);
	}
	else {
		update(pTradingAccount,pNewTradingAccount,pTransaction,updateIndex);
		return pTradingAccount;
	}
}

void CTradingAccountFactory::retrieve(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pTargetTradingAccount)
{
	forceCopy(pTargetTradingAccount, pTradingAccount, sizeof(CTradingAccount));
}
	
int CTradingAccountFactory::addActionTrigger(CTradingAccountActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CTradingAccountFactory::removeActionTrigger(CTradingAccountActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CTradingAccountFactory::addCommitTrigger(CTradingAccountCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CTradingAccountFactory::removeCommitTrigger(CTradingAccountCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CTradingAccount *CTradingAccountFactory::getFirst(void)
{
	CTradingAccount *pResult=(CTradingAccount *)(pMem->getFirst());
	return pResult;
}
	
CTradingAccount *CTradingAccountFactory::getNext(void)
{
	CTradingAccount *pResult=(CTradingAccount *)(pMem->getNext());
	return pResult;
}
	
void CTradingAccountFactory::endGet(void)
{
	pMem->endGet();
}

void CTradingAccountFactory::beforeAdd(CWriteableTradingAccount *pTradingAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pTradingAccount);
	}
}
	
void CTradingAccountFactory::afterAdd(CTradingAccount *pTradingAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pTradingAccount);
	}
}

void CTradingAccountFactory::beforeUpdate(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pNewTradingAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pTradingAccount,pNewTradingAccount);
	}
}
	
void CTradingAccountFactory::afterUpdate(CTradingAccount *pTradingAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pTradingAccount);
	}
}
	
void CTradingAccountFactory::beforeRemove(CTradingAccount *pTradingAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pTradingAccount);
	}
}

void CTradingAccountFactory::commitAdd(CTradingAccount *pTradingAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForTradingAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pTradingAccount);
	}
}

void CTradingAccountFactory::commitUpdate(CTradingAccount *pTradingAccount, CWriteableTradingAccount *pOldTradingAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForTradingAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pTradingAccount,pOldTradingAccount);
	}
}
	
void CTradingAccountFactory::commitRemove(CWriteableTradingAccount *pTradingAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForTradingAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pTradingAccount);
	}
}

void CTradingAccountFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CTradingAccountFactory::linkAllBaseReserveAccount(CBaseReserveAccountFactory *pFactory)
{
	CTradingAccount *pTradingAccount;
	pTradingAccount=getFirst();
	while (pTradingAccount != NULL) {
		pTradingAccount->linkBaseReserveAccount(pFactory);
		pTradingAccount=getNext();
	}
	endGet();
}

extern int compareForAccountIDIndexinBaseReserveAccount(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForBaseReserveAccount=0;
int updateWithIndexActionForBaseReserveAccount=0;
int updateWithoutIndexActionForBaseReserveAccount=0;
int removeActionForBaseReserveAccount=0;
int addCommitForBaseReserveAccount=0;
int updateCommitForBaseReserveAccount=0;
int removeCommitForBaseReserveAccount=0;
#endif
void CBaseReserveAccountFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinBaseReserveAccount,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("BaseReserveAccount_AccountIDIndex",pAccountIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("BaseReserveAccount_AccountIDIndex");
			if(it != pIndexMap->end()) {
				pAccountIDIndex=new CAVLTree(maxUnit,compareForAccountIDIndexinBaseReserveAccount,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pAccountIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CBaseReserveAccountActionTrigger *>;
	pCommitTriggers=new vector<CBaseReserveAccountCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CBaseReserveAccountFactory::CBaseReserveAccountFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBaseReserveAccount),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CBaseReserveAccountFactory::CBaseReserveAccountFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBaseReserveAccount),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CBaseReserveAccountFactory::~CBaseReserveAccountFactory(void)
{
	if (runLevel>=0) {
		if (pAccountIDIndex!=NULL)
			delete pAccountIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CBaseReserveAccountFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CBaseReserveAccountFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pAccountIDIndex->output(pLogger,indent+1);
	}
}

int CBaseReserveAccountFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableBaseReserveAccount thisBaseReserveAccount;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisBaseReserveAccount.readCSV(input,pNames))
		add(&thisBaseReserveAccount);
	fclose(input);
	delete pNames;
	return 1;
}

int CBaseReserveAccountFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "BaseReserveAccount.csv");
	return readCSV(szFileName);
}

int CBaseReserveAccountFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableBaseReserveAccount *pBaseReserveAccount;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableBaseReserveAccount::writeCSVHead(output);
	pBaseReserveAccount=(CWriteableBaseReserveAccount *)(pMem->getFirst());
	while (pBaseReserveAccount!=NULL) {
		if (!pBaseReserveAccount->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pBaseReserveAccount=(CWriteableBaseReserveAccount *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CBaseReserveAccountFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "BaseReserveAccount.csv");
	return writeCSV(szFileName);
}

void CBaseReserveAccountFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CBaseReserveAccountFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableBaseReserveAccount *pBaseReserveAccount;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CBaseReserveAccountFactory={       Total Count=%d\n", pMem->getCount());
	pBaseReserveAccount=(CWriteableBaseReserveAccount *)(pMem->getFirst());
	while (pBaseReserveAccount!=NULL) {
		pBaseReserveAccount->dump(fp,index++);
		pBaseReserveAccount=(CWriteableBaseReserveAccount *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CBaseReserveAccountFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pAccountIDIndex->removeAll();
	}
}

CBaseReserveAccount *CBaseReserveAccountFactory::internalAdd(CWriteableBaseReserveAccount *pBaseReserveAccount, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForBaseReserveAccount++;
#endif
	CBaseReserveAccount *pTarget;	
	beforeAdd(pBaseReserveAccount);
	pTarget=(CBaseReserveAccount *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough BaseReserveAccount in memory database");
		return NULL;
	}
	forceCopy(pTarget, pBaseReserveAccount, sizeof(CBaseReserveAccount));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pAccountIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CBaseReserveAccount *CBaseReserveAccountFactory::add(CWriteableBaseReserveAccount *pBaseReserveAccount, CTransaction *pTransaction)
{
	pBaseReserveAccount->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pBaseReserveAccount,true);
	}
	else {
		CBaseReserveAccount *pNewBaseReserveAccount;
		pNewBaseReserveAccount = internalAdd(pBaseReserveAccount,false);
		pTransaction->addResource(CBaseReserveAccountResource::alloc(CREATE_ACTION,this,pNewBaseReserveAccount,NULL));
		return pNewBaseReserveAccount;
	}
}

void CBaseReserveAccountFactory::internalUpdate(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pNewBaseReserveAccount, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForBaseReserveAccount++;
	}
	else {
		updateWithoutIndexActionForBaseReserveAccount++;
	}
#endif
	CWriteableBaseReserveAccount theOldBaseReserveAccount;
	beforeUpdate(pBaseReserveAccount,pNewBaseReserveAccount);
	if (bNoTransaction) {
		forceCopy(&theOldBaseReserveAccount,pBaseReserveAccount,sizeof(CBaseReserveAccount));
	}
	if (updateIndex) {
	}

	forceCopy(pBaseReserveAccount,pNewBaseReserveAccount,sizeof(CBaseReserveAccount));
	pMem->updateObject(pBaseReserveAccount);
	if (updateIndex) {
	}
	afterUpdate(pBaseReserveAccount);
	if (bNoTransaction) {
		commitUpdate(pBaseReserveAccount,&theOldBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::update(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pNewBaseReserveAccount, CTransaction *pTransaction, bool updateIndex)
{
	pNewBaseReserveAccount->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pBaseReserveAccount,pNewBaseReserveAccount,updateIndex,true);
	}
	else {
		pTransaction->addResource(CBaseReserveAccountResource::alloc(UPDATE_ACTION,this,pBaseReserveAccount,pNewBaseReserveAccount,updateIndex));
		internalUpdate(pBaseReserveAccount,pNewBaseReserveAccount,updateIndex,false);
	}
}

void CBaseReserveAccountFactory::internalRemove(CBaseReserveAccount *pBaseReserveAccount, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForBaseReserveAccount++;
#endif
	CWriteableBaseReserveAccount theOldBaseReserveAccount;
	beforeRemove(pBaseReserveAccount);
	if (bNoTransaction) {
		forceCopy(&theOldBaseReserveAccount,pBaseReserveAccount,sizeof(CBaseReserveAccount));
	}
	if (runLevel>=0) {
		pAccountIDIndex->removeObject(pBaseReserveAccount);
	}
	pMem->free(pBaseReserveAccount);
	if(bNoTransaction) {
		commitRemove(&theOldBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::remove(CBaseReserveAccount *pBaseReserveAccount, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pBaseReserveAccount,true);
	}
	else {
		pTransaction->addResource(CBaseReserveAccountResource::alloc(DELETE_ACTION,this,pBaseReserveAccount,NULL));
		internalRemove(pBaseReserveAccount,false);		
	}
}

CBaseReserveAccount* CBaseReserveAccountFactory::addOrUpdate(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pNewBaseReserveAccount, CTransaction *pTransaction, bool updateIndex)
{
	if(pBaseReserveAccount == NULL) {
		return add(pNewBaseReserveAccount,pTransaction);
	}
	else {
		update(pBaseReserveAccount,pNewBaseReserveAccount,pTransaction,updateIndex);
		return pBaseReserveAccount;
	}
}

void CBaseReserveAccountFactory::retrieve(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pTargetBaseReserveAccount)
{
	forceCopy(pTargetBaseReserveAccount, pBaseReserveAccount, sizeof(CBaseReserveAccount));
}
	
int CBaseReserveAccountFactory::addActionTrigger(CBaseReserveAccountActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CBaseReserveAccountFactory::removeActionTrigger(CBaseReserveAccountActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CBaseReserveAccountFactory::addCommitTrigger(CBaseReserveAccountCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CBaseReserveAccountFactory::removeCommitTrigger(CBaseReserveAccountCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CBaseReserveAccount *CBaseReserveAccountFactory::getFirst(void)
{
	CBaseReserveAccount *pResult=(CBaseReserveAccount *)(pMem->getFirst());
	return pResult;
}
	
CBaseReserveAccount *CBaseReserveAccountFactory::getNext(void)
{
	CBaseReserveAccount *pResult=(CBaseReserveAccount *)(pMem->getNext());
	return pResult;
}
	
void CBaseReserveAccountFactory::endGet(void)
{
	pMem->endGet();
}

void CBaseReserveAccountFactory::beforeAdd(CWriteableBaseReserveAccount *pBaseReserveAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pBaseReserveAccount);
	}
}
	
void CBaseReserveAccountFactory::afterAdd(CBaseReserveAccount *pBaseReserveAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::beforeUpdate(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pNewBaseReserveAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pBaseReserveAccount,pNewBaseReserveAccount);
	}
}
	
void CBaseReserveAccountFactory::afterUpdate(CBaseReserveAccount *pBaseReserveAccount)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pBaseReserveAccount);
	}
}
	
void CBaseReserveAccountFactory::beforeRemove(CBaseReserveAccount *pBaseReserveAccount)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::commitAdd(CBaseReserveAccount *pBaseReserveAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForBaseReserveAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::commitUpdate(CBaseReserveAccount *pBaseReserveAccount, CWriteableBaseReserveAccount *pOldBaseReserveAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForBaseReserveAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pBaseReserveAccount,pOldBaseReserveAccount);
	}
}
	
void CBaseReserveAccountFactory::commitRemove(CWriteableBaseReserveAccount *pBaseReserveAccount)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForBaseReserveAccount++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pBaseReserveAccount);
	}
}

void CBaseReserveAccountFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIndexinPartPosition(const void *pV1, const void *pV2);
extern int compareForPartInstrumentIndexinPartPosition(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForPartPosition=0;
int updateWithIndexActionForPartPosition=0;
int updateWithoutIndexActionForPartPosition=0;
int removeActionForPartPosition=0;
int addCommitForPartPosition=0;
int updateCommitForPartPosition=0;
int removeCommitForPartPosition=0;
#endif
void CPartPositionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinPartPosition,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartPosition_InstrumentIndex",pInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartPosition_InstrumentIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIndex=new CAVLTree(maxUnit,compareForInstrumentIndexinPartPosition,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pPartInstrumentIndex=new CAVLTree(maxUnit,compareForPartInstrumentIndexinPartPosition,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartPosition_PartInstrumentIndex",pPartInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartPosition_PartInstrumentIndex");
			if(it != pIndexMap->end()) {
				pPartInstrumentIndex=new CAVLTree(maxUnit,compareForPartInstrumentIndexinPartPosition,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=98317;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("PartPosition.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pPartAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("PartPosition_PartAndInstrumentHashIndex",pPartAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("PartPosition_PartAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pPartAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByInstrument=NULL;
	pLastFoundInSearchStartByParticipant=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CPartPositionActionTrigger *>;
	pCommitTriggers=new vector<CPartPositionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CPartPositionFactory::CPartPositionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartPosition),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CPartPositionFactory::CPartPositionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CPartPosition),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CPartPositionFactory::~CPartPositionFactory(void)
{
	if (runLevel>=1) {
		if (pInstrumentIndex!=NULL)
			delete pInstrumentIndex;
	}
	if (runLevel>=1) {
		if (pPartInstrumentIndex!=NULL)
			delete pPartInstrumentIndex;
	}
	if (runLevel>=0) {
		if (pPartAndInstrumentHashIndex!=NULL)
			delete pPartAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CPartPositionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CPartPositionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pInstrumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pPartInstrumentIndex->output(pLogger,indent+1);
	}
}

int CPartPositionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteablePartPosition thisPartPosition;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisPartPosition.readCSV(input,pNames))
		add(&thisPartPosition);
	fclose(input);
	delete pNames;
	return 1;
}

int CPartPositionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "PartPosition.csv");
	return readCSV(szFileName);
}

int CPartPositionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteablePartPosition *pPartPosition;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteablePartPosition::writeCSVHead(output);
	pPartPosition=(CWriteablePartPosition *)(pMem->getFirst());
	while (pPartPosition!=NULL) {
		if (!pPartPosition->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pPartPosition=(CWriteablePartPosition *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CPartPositionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "PartPosition.csv");
	return writeCSV(szFileName);
}

void CPartPositionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CPartPositionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteablePartPosition *pPartPosition;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CPartPositionFactory={       Total Count=%d\n", pMem->getCount());
	pPartPosition=(CWriteablePartPosition *)(pMem->getFirst());
	while (pPartPosition!=NULL) {
		pPartPosition->dump(fp,index++);
		pPartPosition=(CWriteablePartPosition *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CPartPositionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pInstrumentIndex->removeAll();
	}
	if (runLevel>=1) {
		pPartInstrumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->removeAll();
	}
}

CPartPosition *CPartPositionFactory::internalAdd(CWriteablePartPosition *pPartPosition, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForPartPosition++;
#endif
	CPartPosition *pTarget;	
	beforeAdd(pPartPosition);
	pTarget=(CPartPosition *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough PartPosition in memory database");
		return NULL;
	}
	forceCopy(pTarget, pPartPosition, sizeof(CPartPosition));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pPartInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->addObject(pTarget,pTarget->HashPartAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CPartPosition *CPartPositionFactory::add(CWriteablePartPosition *pPartPosition, CTransaction *pTransaction)
{
	pPartPosition->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pPartPosition,true);
	}
	else {
		CPartPosition *pNewPartPosition;
		pNewPartPosition = internalAdd(pPartPosition,false);
		pTransaction->addResource(CPartPositionResource::alloc(CREATE_ACTION,this,pNewPartPosition,NULL));
		return pNewPartPosition;
	}
}

void CPartPositionFactory::internalUpdate(CPartPosition *pPartPosition, CWriteablePartPosition *pNewPartPosition, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForPartPosition++;
	}
	else {
		updateWithoutIndexActionForPartPosition++;
	}
#endif
	CWriteablePartPosition theOldPartPosition;
	beforeUpdate(pPartPosition,pNewPartPosition);
	if (bNoTransaction) {
		forceCopy(&theOldPartPosition,pPartPosition,sizeof(CPartPosition));
	}
	if (updateIndex) {
	}

	forceCopy(pPartPosition,pNewPartPosition,sizeof(CPartPosition));
	pMem->updateObject(pPartPosition);
	if (updateIndex) {
	}
	afterUpdate(pPartPosition);
	if (bNoTransaction) {
		commitUpdate(pPartPosition,&theOldPartPosition);
	}
}

void CPartPositionFactory::update(CPartPosition *pPartPosition, CWriteablePartPosition *pNewPartPosition, CTransaction *pTransaction, bool updateIndex)
{
	pNewPartPosition->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pPartPosition,pNewPartPosition,updateIndex,true);
	}
	else {
		pTransaction->addResource(CPartPositionResource::alloc(UPDATE_ACTION,this,pPartPosition,pNewPartPosition,updateIndex));
		internalUpdate(pPartPosition,pNewPartPosition,updateIndex,false);
	}
}

void CPartPositionFactory::internalRemove(CPartPosition *pPartPosition, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForPartPosition++;
#endif
	CWriteablePartPosition theOldPartPosition;
	beforeRemove(pPartPosition);
	if (bNoTransaction) {
		forceCopy(&theOldPartPosition,pPartPosition,sizeof(CPartPosition));
	}
	if (runLevel>=1) {
		pInstrumentIndex->removeObject(pPartPosition);
	}
	if (runLevel>=1) {
		pPartInstrumentIndex->removeObject(pPartPosition);
	}
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->removeObject(pPartPosition,pPartPosition->HashPartAndInstrument);
	}	
	pMem->free(pPartPosition);
	if(bNoTransaction) {
		commitRemove(&theOldPartPosition);
	}
}

void CPartPositionFactory::remove(CPartPosition *pPartPosition, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pPartPosition,true);
	}
	else {
		pTransaction->addResource(CPartPositionResource::alloc(DELETE_ACTION,this,pPartPosition,NULL));
		internalRemove(pPartPosition,false);		
	}
}

CPartPosition* CPartPositionFactory::addOrUpdate(CPartPosition *pPartPosition, CWriteablePartPosition *pNewPartPosition, CTransaction *pTransaction, bool updateIndex)
{
	if(pPartPosition == NULL) {
		return add(pNewPartPosition,pTransaction);
	}
	else {
		update(pPartPosition,pNewPartPosition,pTransaction,updateIndex);
		return pPartPosition;
	}
}

void CPartPositionFactory::retrieve(CPartPosition *pPartPosition, CWriteablePartPosition *pTargetPartPosition)
{
	forceCopy(pTargetPartPosition, pPartPosition, sizeof(CPartPosition));
}
	
int CPartPositionFactory::addActionTrigger(CPartPositionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CPartPositionFactory::removeActionTrigger(CPartPositionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CPartPositionFactory::addCommitTrigger(CPartPositionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CPartPositionFactory::removeCommitTrigger(CPartPositionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CPartPosition *CPartPositionFactory::getFirst(void)
{
	CPartPosition *pResult=(CPartPosition *)(pMem->getFirst());
	return pResult;
}
	
CPartPosition *CPartPositionFactory::getNext(void)
{
	CPartPosition *pResult=(CPartPosition *)(pMem->getNext());
	return pResult;
}
	
void CPartPositionFactory::endGet(void)
{
	pMem->endGet();
}

void CPartPositionFactory::beforeAdd(CWriteablePartPosition *pPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pPartPosition);
	}
}
	
void CPartPositionFactory::afterAdd(CPartPosition *pPartPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pPartPosition);
	}
}

void CPartPositionFactory::beforeUpdate(CPartPosition *pPartPosition, CWriteablePartPosition *pNewPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pPartPosition,pNewPartPosition);
	}
}
	
void CPartPositionFactory::afterUpdate(CPartPosition *pPartPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pPartPosition);
	}
}
	
void CPartPositionFactory::beforeRemove(CPartPosition *pPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pPartPosition);
	}
}

void CPartPositionFactory::commitAdd(CPartPosition *pPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pPartPosition);
	}
}

void CPartPositionFactory::commitUpdate(CPartPosition *pPartPosition, CWriteablePartPosition *pOldPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pPartPosition,pOldPartPosition);
	}
}
	
void CPartPositionFactory::commitRemove(CWriteablePartPosition *pPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pPartPosition);
	}
}

void CPartPositionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForPartClientAndInstumentIndexinClientPosition(const void *pV1, const void *pV2);
extern int compareForClientAndInstumentIndexinClientPosition(const void *pV1, const void *pV2);
extern int compareForInstumentIndexinClientPosition(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForClientPosition=0;
int updateWithIndexActionForClientPosition=0;
int updateWithoutIndexActionForClientPosition=0;
int removeActionForClientPosition=0;
int addCommitForClientPosition=0;
int updateCommitForClientPosition=0;
int removeCommitForClientPosition=0;
#endif
void CClientPositionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pPartClientAndInstumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstumentIndexinClientPosition,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientPosition_PartClientAndInstumentIndex",pPartClientAndInstumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientPosition_PartClientAndInstumentIndex");
			if(it != pIndexMap->end()) {
				pPartClientAndInstumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstumentIndexinClientPosition,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartClientAndInstumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pClientAndInstumentIndex=new CAVLTree(maxUnit,compareForClientAndInstumentIndexinClientPosition,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientPosition_ClientAndInstumentIndex",pClientAndInstumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientPosition_ClientAndInstumentIndex");
			if(it != pIndexMap->end()) {
				pClientAndInstumentIndex=new CAVLTree(maxUnit,compareForClientAndInstumentIndexinClientPosition,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientAndInstumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pInstumentIndex=new CAVLTree(maxUnit,compareForInstumentIndexinClientPosition,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientPosition_InstumentIndex",pInstumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientPosition_InstumentIndex");
			if(it != pIndexMap->end()) {
				pInstumentIndex=new CAVLTree(maxUnit,compareForInstumentIndexinClientPosition,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=1572869;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("ClientPosition.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClientPosition_ClientAndInstrumentHashIndex",pClientAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClientPosition_ClientAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pClientAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByClientAndInstrument=NULL;
	pLastFoundInSearchStartByParticipant=NULL;
	pLastFoundInSearchStartByClient=NULL;
	pLastFoundInSearchStartByInstrument=NULL;
	pLastFoundInSearchByInstrumentID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CClientPositionActionTrigger *>;
	pCommitTriggers=new vector<CClientPositionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClientPositionFactory::CClientPositionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientPosition),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClientPositionFactory::CClientPositionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClientPosition),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClientPositionFactory::~CClientPositionFactory(void)
{
	if (runLevel>=1) {
		if (pPartClientAndInstumentIndex!=NULL)
			delete pPartClientAndInstumentIndex;
	}
	if (runLevel>=1) {
		if (pClientAndInstumentIndex!=NULL)
			delete pClientAndInstumentIndex;
	}
	if (runLevel>=1) {
		if (pInstumentIndex!=NULL)
			delete pInstumentIndex;
	}
	if (runLevel>=0) {
		if (pClientAndInstrumentHashIndex!=NULL)
			delete pClientAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClientPositionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClientPositionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pPartClientAndInstumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pClientAndInstumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pInstumentIndex->output(pLogger,indent+1);
	}
}

int CClientPositionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClientPosition thisClientPosition;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClientPosition.readCSV(input,pNames))
		add(&thisClientPosition);
	fclose(input);
	delete pNames;
	return 1;
}

int CClientPositionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ClientPosition.csv");
	return readCSV(szFileName);
}

int CClientPositionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClientPosition *pClientPosition;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClientPosition::writeCSVHead(output);
	pClientPosition=(CWriteableClientPosition *)(pMem->getFirst());
	while (pClientPosition!=NULL) {
		if (!pClientPosition->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClientPosition=(CWriteableClientPosition *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClientPositionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ClientPosition.csv");
	return writeCSV(szFileName);
}

void CClientPositionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClientPositionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClientPosition *pClientPosition;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClientPositionFactory={       Total Count=%d\n", pMem->getCount());
	pClientPosition=(CWriteableClientPosition *)(pMem->getFirst());
	while (pClientPosition!=NULL) {
		pClientPosition->dump(fp,index++);
		pClientPosition=(CWriteableClientPosition *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClientPositionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pPartClientAndInstumentIndex->removeAll();
	}
	if (runLevel>=1) {
		pClientAndInstumentIndex->removeAll();
	}
	if (runLevel>=1) {
		pInstumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->removeAll();
	}
}

CClientPosition *CClientPositionFactory::internalAdd(CWriteableClientPosition *pClientPosition, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClientPosition++;
#endif
	CClientPosition *pTarget;	
	beforeAdd(pClientPosition);
	pTarget=(CClientPosition *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ClientPosition in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClientPosition, sizeof(CClientPosition));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pPartClientAndInstumentIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pClientAndInstumentIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pInstumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->addObject(pTarget,pTarget->HashClientAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClientPosition *CClientPositionFactory::add(CWriteableClientPosition *pClientPosition, CTransaction *pTransaction)
{
	pClientPosition->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClientPosition,true);
	}
	else {
		CClientPosition *pNewClientPosition;
		pNewClientPosition = internalAdd(pClientPosition,false);
		pTransaction->addResource(CClientPositionResource::alloc(CREATE_ACTION,this,pNewClientPosition,NULL));
		return pNewClientPosition;
	}
}

void CClientPositionFactory::internalUpdate(CClientPosition *pClientPosition, CWriteableClientPosition *pNewClientPosition, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClientPosition++;
	}
	else {
		updateWithoutIndexActionForClientPosition++;
	}
#endif
	CWriteableClientPosition theOldClientPosition;
	beforeUpdate(pClientPosition,pNewClientPosition);
	if (bNoTransaction) {
		forceCopy(&theOldClientPosition,pClientPosition,sizeof(CClientPosition));
	}
	if (updateIndex) {
	}

	forceCopy(pClientPosition,pNewClientPosition,sizeof(CClientPosition));
	pMem->updateObject(pClientPosition);
	if (updateIndex) {
	}
	afterUpdate(pClientPosition);
	if (bNoTransaction) {
		commitUpdate(pClientPosition,&theOldClientPosition);
	}
}

void CClientPositionFactory::update(CClientPosition *pClientPosition, CWriteableClientPosition *pNewClientPosition, CTransaction *pTransaction, bool updateIndex)
{
	pNewClientPosition->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClientPosition,pNewClientPosition,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClientPositionResource::alloc(UPDATE_ACTION,this,pClientPosition,pNewClientPosition,updateIndex));
		internalUpdate(pClientPosition,pNewClientPosition,updateIndex,false);
	}
}

void CClientPositionFactory::internalRemove(CClientPosition *pClientPosition, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClientPosition++;
#endif
	CWriteableClientPosition theOldClientPosition;
	beforeRemove(pClientPosition);
	if (bNoTransaction) {
		forceCopy(&theOldClientPosition,pClientPosition,sizeof(CClientPosition));
	}
	if (runLevel>=1) {
		pPartClientAndInstumentIndex->removeObject(pClientPosition);
	}
	if (runLevel>=1) {
		pClientAndInstumentIndex->removeObject(pClientPosition);
	}
	if (runLevel>=1) {
		pInstumentIndex->removeObject(pClientPosition);
	}
	if (runLevel>=0) {
		pClientAndInstrumentHashIndex->removeObject(pClientPosition,pClientPosition->HashClientAndInstrument);
	}	
	pMem->free(pClientPosition);
	if(bNoTransaction) {
		commitRemove(&theOldClientPosition);
	}
}

void CClientPositionFactory::remove(CClientPosition *pClientPosition, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClientPosition,true);
	}
	else {
		pTransaction->addResource(CClientPositionResource::alloc(DELETE_ACTION,this,pClientPosition,NULL));
		internalRemove(pClientPosition,false);		
	}
}

CClientPosition* CClientPositionFactory::addOrUpdate(CClientPosition *pClientPosition, CWriteableClientPosition *pNewClientPosition, CTransaction *pTransaction, bool updateIndex)
{
	if(pClientPosition == NULL) {
		return add(pNewClientPosition,pTransaction);
	}
	else {
		update(pClientPosition,pNewClientPosition,pTransaction,updateIndex);
		return pClientPosition;
	}
}

void CClientPositionFactory::retrieve(CClientPosition *pClientPosition, CWriteableClientPosition *pTargetClientPosition)
{
	forceCopy(pTargetClientPosition, pClientPosition, sizeof(CClientPosition));
}
	
int CClientPositionFactory::addActionTrigger(CClientPositionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClientPositionFactory::removeActionTrigger(CClientPositionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClientPositionFactory::addCommitTrigger(CClientPositionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClientPositionFactory::removeCommitTrigger(CClientPositionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClientPosition *CClientPositionFactory::getFirst(void)
{
	CClientPosition *pResult=(CClientPosition *)(pMem->getFirst());
	return pResult;
}
	
CClientPosition *CClientPositionFactory::getNext(void)
{
	CClientPosition *pResult=(CClientPosition *)(pMem->getNext());
	return pResult;
}
	
void CClientPositionFactory::endGet(void)
{
	pMem->endGet();
}

void CClientPositionFactory::beforeAdd(CWriteableClientPosition *pClientPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClientPosition);
	}
}
	
void CClientPositionFactory::afterAdd(CClientPosition *pClientPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClientPosition);
	}
}

void CClientPositionFactory::beforeUpdate(CClientPosition *pClientPosition, CWriteableClientPosition *pNewClientPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClientPosition,pNewClientPosition);
	}
}
	
void CClientPositionFactory::afterUpdate(CClientPosition *pClientPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClientPosition);
	}
}
	
void CClientPositionFactory::beforeRemove(CClientPosition *pClientPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClientPosition);
	}
}

void CClientPositionFactory::commitAdd(CClientPosition *pClientPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClientPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClientPosition);
	}
}

void CClientPositionFactory::commitUpdate(CClientPosition *pClientPosition, CWriteableClientPosition *pOldClientPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClientPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClientPosition,pOldClientPosition);
	}
}
	
void CClientPositionFactory::commitRemove(CWriteableClientPosition *pClientPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClientPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClientPosition);
	}
}

void CClientPositionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CClientPositionFactory::linkAllCreditLimit(CCreditLimitFactory *pFactory)
{
	CClientPosition *pClientPosition;
	pClientPosition=getFirst();
	while (pClientPosition != NULL) {
		pClientPosition->linkCreditLimit(pFactory);
		pClientPosition=getNext();
	}
	endGet();
}

void CClientPositionFactory::linkAllPartRoleAccount(CPartRoleAccountFactory *pFactory)
{
	CClientPosition *pClientPosition;
	pClientPosition=getFirst();
	while (pClientPosition != NULL) {
		pClientPosition->linkPartRoleAccount(pFactory);
		pClientPosition=getNext();
	}
	endGet();
}

extern int compareForPartClientAndInstrumentIndexinHedgeVolume(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForHedgeVolume=0;
int updateWithIndexActionForHedgeVolume=0;
int updateWithoutIndexActionForHedgeVolume=0;
int removeActionForHedgeVolume=0;
int addCommitForHedgeVolume=0;
int updateCommitForHedgeVolume=0;
int removeCommitForHedgeVolume=0;
#endif
void CHedgeVolumeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pPartClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstrumentIndexinHedgeVolume,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("HedgeVolume_PartClientAndInstrumentIndex",pPartClientAndInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("HedgeVolume_PartClientAndInstrumentIndex");
			if(it != pIndexMap->end()) {
				pPartClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstrumentIndexinHedgeVolume,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartClientAndInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchStartByPartClientAndInstrument=NULL;
	pActionTriggers=new vector<CHedgeVolumeActionTrigger *>;
	pCommitTriggers=new vector<CHedgeVolumeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CHedgeVolumeFactory::CHedgeVolumeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CHedgeVolume),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CHedgeVolumeFactory::CHedgeVolumeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CHedgeVolume),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CHedgeVolumeFactory::~CHedgeVolumeFactory(void)
{
	if (runLevel>=0) {
		if (pPartClientAndInstrumentIndex!=NULL)
			delete pPartClientAndInstrumentIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CHedgeVolumeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CHedgeVolumeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->output(pLogger,indent+1);
	}
}

int CHedgeVolumeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableHedgeVolume thisHedgeVolume;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisHedgeVolume.readCSV(input,pNames))
		add(&thisHedgeVolume);
	fclose(input);
	delete pNames;
	return 1;
}

int CHedgeVolumeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "HedgeVolume.csv");
	return readCSV(szFileName);
}

int CHedgeVolumeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableHedgeVolume *pHedgeVolume;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableHedgeVolume::writeCSVHead(output);
	pHedgeVolume=(CWriteableHedgeVolume *)(pMem->getFirst());
	while (pHedgeVolume!=NULL) {
		if (!pHedgeVolume->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pHedgeVolume=(CWriteableHedgeVolume *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CHedgeVolumeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "HedgeVolume.csv");
	return writeCSV(szFileName);
}

void CHedgeVolumeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CHedgeVolumeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableHedgeVolume *pHedgeVolume;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CHedgeVolumeFactory={       Total Count=%d\n", pMem->getCount());
	pHedgeVolume=(CWriteableHedgeVolume *)(pMem->getFirst());
	while (pHedgeVolume!=NULL) {
		pHedgeVolume->dump(fp,index++);
		pHedgeVolume=(CWriteableHedgeVolume *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CHedgeVolumeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->removeAll();
	}
}

CHedgeVolume *CHedgeVolumeFactory::internalAdd(CWriteableHedgeVolume *pHedgeVolume, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForHedgeVolume++;
#endif
	CHedgeVolume *pTarget;	
	beforeAdd(pHedgeVolume);
	pTarget=(CHedgeVolume *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough HedgeVolume in memory database");
		return NULL;
	}
	forceCopy(pTarget, pHedgeVolume, sizeof(CHedgeVolume));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CHedgeVolume *CHedgeVolumeFactory::add(CWriteableHedgeVolume *pHedgeVolume, CTransaction *pTransaction)
{
	pHedgeVolume->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pHedgeVolume,true);
	}
	else {
		CHedgeVolume *pNewHedgeVolume;
		pNewHedgeVolume = internalAdd(pHedgeVolume,false);
		pTransaction->addResource(CHedgeVolumeResource::alloc(CREATE_ACTION,this,pNewHedgeVolume,NULL));
		return pNewHedgeVolume;
	}
}

void CHedgeVolumeFactory::internalUpdate(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pNewHedgeVolume, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForHedgeVolume++;
	}
	else {
		updateWithoutIndexActionForHedgeVolume++;
	}
#endif
	CWriteableHedgeVolume theOldHedgeVolume;
	beforeUpdate(pHedgeVolume,pNewHedgeVolume);
	if (bNoTransaction) {
		forceCopy(&theOldHedgeVolume,pHedgeVolume,sizeof(CHedgeVolume));
	}
	if (updateIndex) {
	}

	forceCopy(pHedgeVolume,pNewHedgeVolume,sizeof(CHedgeVolume));
	pMem->updateObject(pHedgeVolume);
	if (updateIndex) {
	}
	afterUpdate(pHedgeVolume);
	if (bNoTransaction) {
		commitUpdate(pHedgeVolume,&theOldHedgeVolume);
	}
}

void CHedgeVolumeFactory::update(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pNewHedgeVolume, CTransaction *pTransaction, bool updateIndex)
{
	pNewHedgeVolume->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pHedgeVolume,pNewHedgeVolume,updateIndex,true);
	}
	else {
		pTransaction->addResource(CHedgeVolumeResource::alloc(UPDATE_ACTION,this,pHedgeVolume,pNewHedgeVolume,updateIndex));
		internalUpdate(pHedgeVolume,pNewHedgeVolume,updateIndex,false);
	}
}

void CHedgeVolumeFactory::internalRemove(CHedgeVolume *pHedgeVolume, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForHedgeVolume++;
#endif
	CWriteableHedgeVolume theOldHedgeVolume;
	beforeRemove(pHedgeVolume);
	if (bNoTransaction) {
		forceCopy(&theOldHedgeVolume,pHedgeVolume,sizeof(CHedgeVolume));
	}
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->removeObject(pHedgeVolume);
	}
	pMem->free(pHedgeVolume);
	if(bNoTransaction) {
		commitRemove(&theOldHedgeVolume);
	}
}

void CHedgeVolumeFactory::remove(CHedgeVolume *pHedgeVolume, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pHedgeVolume,true);
	}
	else {
		pTransaction->addResource(CHedgeVolumeResource::alloc(DELETE_ACTION,this,pHedgeVolume,NULL));
		internalRemove(pHedgeVolume,false);		
	}
}

CHedgeVolume* CHedgeVolumeFactory::addOrUpdate(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pNewHedgeVolume, CTransaction *pTransaction, bool updateIndex)
{
	if(pHedgeVolume == NULL) {
		return add(pNewHedgeVolume,pTransaction);
	}
	else {
		update(pHedgeVolume,pNewHedgeVolume,pTransaction,updateIndex);
		return pHedgeVolume;
	}
}

void CHedgeVolumeFactory::retrieve(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pTargetHedgeVolume)
{
	forceCopy(pTargetHedgeVolume, pHedgeVolume, sizeof(CHedgeVolume));
}
	
int CHedgeVolumeFactory::addActionTrigger(CHedgeVolumeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CHedgeVolumeFactory::removeActionTrigger(CHedgeVolumeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CHedgeVolumeFactory::addCommitTrigger(CHedgeVolumeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CHedgeVolumeFactory::removeCommitTrigger(CHedgeVolumeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CHedgeVolume *CHedgeVolumeFactory::getFirst(void)
{
	CHedgeVolume *pResult=(CHedgeVolume *)(pMem->getFirst());
	return pResult;
}
	
CHedgeVolume *CHedgeVolumeFactory::getNext(void)
{
	CHedgeVolume *pResult=(CHedgeVolume *)(pMem->getNext());
	return pResult;
}
	
void CHedgeVolumeFactory::endGet(void)
{
	pMem->endGet();
}

void CHedgeVolumeFactory::beforeAdd(CWriteableHedgeVolume *pHedgeVolume)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pHedgeVolume);
	}
}
	
void CHedgeVolumeFactory::afterAdd(CHedgeVolume *pHedgeVolume)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pHedgeVolume);
	}
}

void CHedgeVolumeFactory::beforeUpdate(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pNewHedgeVolume)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pHedgeVolume,pNewHedgeVolume);
	}
}
	
void CHedgeVolumeFactory::afterUpdate(CHedgeVolume *pHedgeVolume)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pHedgeVolume);
	}
}
	
void CHedgeVolumeFactory::beforeRemove(CHedgeVolume *pHedgeVolume)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pHedgeVolume);
	}
}

void CHedgeVolumeFactory::commitAdd(CHedgeVolume *pHedgeVolume)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForHedgeVolume++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pHedgeVolume);
	}
}

void CHedgeVolumeFactory::commitUpdate(CHedgeVolume *pHedgeVolume, CWriteableHedgeVolume *pOldHedgeVolume)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForHedgeVolume++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pHedgeVolume,pOldHedgeVolume);
	}
}
	
void CHedgeVolumeFactory::commitRemove(CWriteableHedgeVolume *pHedgeVolume)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForHedgeVolume++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pHedgeVolume);
	}
}

void CHedgeVolumeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinRemainOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRemainOrder=0;
int updateWithIndexActionForRemainOrder=0;
int updateWithoutIndexActionForRemainOrder=0;
int removeActionForRemainOrder=0;
int addCommitForRemainOrder=0;
int updateCommitForRemainOrder=0;
int removeCommitForRemainOrder=0;
#endif
void CRemainOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinRemainOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RemainOrder_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RemainOrder_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinRemainOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByInstrumentID=NULL;
	pActionTriggers=new vector<CRemainOrderActionTrigger *>;
	pCommitTriggers=new vector<CRemainOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRemainOrderFactory::CRemainOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRemainOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRemainOrderFactory::CRemainOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRemainOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRemainOrderFactory::~CRemainOrderFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRemainOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRemainOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CRemainOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRemainOrder thisRemainOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRemainOrder.readCSV(input,pNames))
		add(&thisRemainOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CRemainOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RemainOrder.csv");
	return readCSV(szFileName);
}

int CRemainOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRemainOrder *pRemainOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRemainOrder::writeCSVHead(output);
	pRemainOrder=(CWriteableRemainOrder *)(pMem->getFirst());
	while (pRemainOrder!=NULL) {
		if (!pRemainOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRemainOrder=(CWriteableRemainOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRemainOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RemainOrder.csv");
	return writeCSV(szFileName);
}

void CRemainOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRemainOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRemainOrder *pRemainOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRemainOrderFactory={       Total Count=%d\n", pMem->getCount());
	pRemainOrder=(CWriteableRemainOrder *)(pMem->getFirst());
	while (pRemainOrder!=NULL) {
		pRemainOrder->dump(fp,index++);
		pRemainOrder=(CWriteableRemainOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRemainOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CRemainOrder *CRemainOrderFactory::internalAdd(CWriteableRemainOrder *pRemainOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRemainOrder++;
#endif
	CRemainOrder *pTarget;	
	beforeAdd(pRemainOrder);
	pTarget=(CRemainOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RemainOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRemainOrder, sizeof(CRemainOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRemainOrder *CRemainOrderFactory::add(CWriteableRemainOrder *pRemainOrder, CTransaction *pTransaction)
{
	pRemainOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRemainOrder,true);
	}
	else {
		CRemainOrder *pNewRemainOrder;
		pNewRemainOrder = internalAdd(pRemainOrder,false);
		pTransaction->addResource(CRemainOrderResource::alloc(CREATE_ACTION,this,pNewRemainOrder,NULL));
		return pNewRemainOrder;
	}
}

void CRemainOrderFactory::internalUpdate(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pNewRemainOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRemainOrder++;
	}
	else {
		updateWithoutIndexActionForRemainOrder++;
	}
#endif
	CWriteableRemainOrder theOldRemainOrder;
	beforeUpdate(pRemainOrder,pNewRemainOrder);
	if (bNoTransaction) {
		forceCopy(&theOldRemainOrder,pRemainOrder,sizeof(CRemainOrder));
	}
	CAVLNode *pInstrumentIDIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pInstrumentIDIndexNode=pInstrumentIDIndex->findObject(pRemainOrder);
		}
	}

	forceCopy(pRemainOrder,pNewRemainOrder,sizeof(CRemainOrder));
	pMem->updateObject(pRemainOrder);
	if (updateIndex) {
		if (runLevel>=0) {
			pInstrumentIDIndex->updateNode(pInstrumentIDIndexNode);
		}
	}
	afterUpdate(pRemainOrder);
	if (bNoTransaction) {
		commitUpdate(pRemainOrder,&theOldRemainOrder);
	}
}

void CRemainOrderFactory::update(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pNewRemainOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewRemainOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRemainOrder,pNewRemainOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRemainOrderResource::alloc(UPDATE_ACTION,this,pRemainOrder,pNewRemainOrder,updateIndex));
		internalUpdate(pRemainOrder,pNewRemainOrder,updateIndex,false);
	}
}

void CRemainOrderFactory::internalRemove(CRemainOrder *pRemainOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRemainOrder++;
#endif
	CWriteableRemainOrder theOldRemainOrder;
	beforeRemove(pRemainOrder);
	if (bNoTransaction) {
		forceCopy(&theOldRemainOrder,pRemainOrder,sizeof(CRemainOrder));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pRemainOrder);
	}
	pMem->free(pRemainOrder);
	if(bNoTransaction) {
		commitRemove(&theOldRemainOrder);
	}
}

void CRemainOrderFactory::remove(CRemainOrder *pRemainOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRemainOrder,true);
	}
	else {
		pTransaction->addResource(CRemainOrderResource::alloc(DELETE_ACTION,this,pRemainOrder,NULL));
		internalRemove(pRemainOrder,false);		
	}
}

CRemainOrder* CRemainOrderFactory::addOrUpdate(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pNewRemainOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pRemainOrder == NULL) {
		return add(pNewRemainOrder,pTransaction);
	}
	else {
		update(pRemainOrder,pNewRemainOrder,pTransaction,updateIndex);
		return pRemainOrder;
	}
}

void CRemainOrderFactory::retrieve(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pTargetRemainOrder)
{
	forceCopy(pTargetRemainOrder, pRemainOrder, sizeof(CRemainOrder));
}
	
int CRemainOrderFactory::addActionTrigger(CRemainOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRemainOrderFactory::removeActionTrigger(CRemainOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRemainOrderFactory::addCommitTrigger(CRemainOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRemainOrderFactory::removeCommitTrigger(CRemainOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRemainOrder *CRemainOrderFactory::getFirst(void)
{
	CRemainOrder *pResult=(CRemainOrder *)(pMem->getFirst());
	return pResult;
}
	
CRemainOrder *CRemainOrderFactory::getNext(void)
{
	CRemainOrder *pResult=(CRemainOrder *)(pMem->getNext());
	return pResult;
}
	
void CRemainOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CRemainOrderFactory::beforeAdd(CWriteableRemainOrder *pRemainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRemainOrder);
	}
}
	
void CRemainOrderFactory::afterAdd(CRemainOrder *pRemainOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRemainOrder);
	}
}

void CRemainOrderFactory::beforeUpdate(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pNewRemainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRemainOrder,pNewRemainOrder);
	}
}
	
void CRemainOrderFactory::afterUpdate(CRemainOrder *pRemainOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRemainOrder);
	}
}
	
void CRemainOrderFactory::beforeRemove(CRemainOrder *pRemainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRemainOrder);
	}
}

void CRemainOrderFactory::commitAdd(CRemainOrder *pRemainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRemainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRemainOrder);
	}
}

void CRemainOrderFactory::commitUpdate(CRemainOrder *pRemainOrder, CWriteableRemainOrder *pOldRemainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRemainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRemainOrder,pOldRemainOrder);
	}
}
	
void CRemainOrderFactory::commitRemove(CWriteableRemainOrder *pRemainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRemainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRemainOrder);
	}
}

void CRemainOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinMarketData(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMarketData=0;
int updateWithIndexActionForMarketData=0;
int updateWithoutIndexActionForMarketData=0;
int removeActionForMarketData=0;
int addCommitForMarketData=0;
int updateCommitForMarketData=0;
int removeCommitForMarketData=0;
#endif
void CMarketDataFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MarketData_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MarketData_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CMarketDataActionTrigger *>;
	pCommitTriggers=new vector<CMarketDataCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMarketDataFactory::CMarketDataFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketData),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMarketDataFactory::CMarketDataFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMarketData),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMarketDataFactory::~CMarketDataFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMarketDataFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMarketDataFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CMarketDataFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMarketData thisMarketData;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMarketData.readCSV(input,pNames))
		add(&thisMarketData);
	fclose(input);
	delete pNames;
	return 1;
}

int CMarketDataFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MarketData.csv");
	return readCSV(szFileName);
}

int CMarketDataFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMarketData *pMarketData;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMarketData::writeCSVHead(output);
	pMarketData=(CWriteableMarketData *)(pMem->getFirst());
	while (pMarketData!=NULL) {
		if (!pMarketData->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMarketData=(CWriteableMarketData *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMarketDataFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MarketData.csv");
	return writeCSV(szFileName);
}

void CMarketDataFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMarketDataFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMarketData *pMarketData;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMarketDataFactory={       Total Count=%d\n", pMem->getCount());
	pMarketData=(CWriteableMarketData *)(pMem->getFirst());
	while (pMarketData!=NULL) {
		pMarketData->dump(fp,index++);
		pMarketData=(CWriteableMarketData *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMarketDataFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CMarketData *CMarketDataFactory::internalAdd(CWriteableMarketData *pMarketData, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMarketData++;
#endif
	CMarketData *pTarget;	
	beforeAdd(pMarketData);
	pTarget=(CMarketData *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MarketData in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMarketData, sizeof(CMarketData));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMarketData *CMarketDataFactory::add(CWriteableMarketData *pMarketData, CTransaction *pTransaction)
{
	pMarketData->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMarketData,true);
	}
	else {
		CMarketData *pNewMarketData;
		pNewMarketData = internalAdd(pMarketData,false);
		pTransaction->addResource(CMarketDataResource::alloc(CREATE_ACTION,this,pNewMarketData,NULL));
		return pNewMarketData;
	}
}

void CMarketDataFactory::internalUpdate(CMarketData *pMarketData, CWriteableMarketData *pNewMarketData, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMarketData++;
	}
	else {
		updateWithoutIndexActionForMarketData++;
	}
#endif
	CWriteableMarketData theOldMarketData;
	beforeUpdate(pMarketData,pNewMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldMarketData,pMarketData,sizeof(CMarketData));
	}
	if (updateIndex) {
	}

	forceCopy(pMarketData,pNewMarketData,sizeof(CMarketData));
	pMem->updateObject(pMarketData);
	if (updateIndex) {
	}
	afterUpdate(pMarketData);
	if (bNoTransaction) {
		commitUpdate(pMarketData,&theOldMarketData);
	}
}

void CMarketDataFactory::update(CMarketData *pMarketData, CWriteableMarketData *pNewMarketData, CTransaction *pTransaction, bool updateIndex)
{
	pNewMarketData->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMarketData,pNewMarketData,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMarketDataResource::alloc(UPDATE_ACTION,this,pMarketData,pNewMarketData,updateIndex));
		internalUpdate(pMarketData,pNewMarketData,updateIndex,false);
	}
}

void CMarketDataFactory::internalRemove(CMarketData *pMarketData, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMarketData++;
#endif
	CWriteableMarketData theOldMarketData;
	beforeRemove(pMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldMarketData,pMarketData,sizeof(CMarketData));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pMarketData);
	}
	pMem->free(pMarketData);
	if(bNoTransaction) {
		commitRemove(&theOldMarketData);
	}
}

void CMarketDataFactory::remove(CMarketData *pMarketData, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMarketData,true);
	}
	else {
		pTransaction->addResource(CMarketDataResource::alloc(DELETE_ACTION,this,pMarketData,NULL));
		internalRemove(pMarketData,false);		
	}
}

CMarketData* CMarketDataFactory::addOrUpdate(CMarketData *pMarketData, CWriteableMarketData *pNewMarketData, CTransaction *pTransaction, bool updateIndex)
{
	if(pMarketData == NULL) {
		return add(pNewMarketData,pTransaction);
	}
	else {
		update(pMarketData,pNewMarketData,pTransaction,updateIndex);
		return pMarketData;
	}
}

void CMarketDataFactory::retrieve(CMarketData *pMarketData, CWriteableMarketData *pTargetMarketData)
{
	forceCopy(pTargetMarketData, pMarketData, sizeof(CMarketData));
}
	
int CMarketDataFactory::addActionTrigger(CMarketDataActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMarketDataFactory::removeActionTrigger(CMarketDataActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMarketDataFactory::addCommitTrigger(CMarketDataCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMarketDataFactory::removeCommitTrigger(CMarketDataCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMarketData *CMarketDataFactory::getFirst(void)
{
	CMarketData *pResult=(CMarketData *)(pMem->getFirst());
	return pResult;
}
	
CMarketData *CMarketDataFactory::getNext(void)
{
	CMarketData *pResult=(CMarketData *)(pMem->getNext());
	return pResult;
}
	
void CMarketDataFactory::endGet(void)
{
	pMem->endGet();
}

void CMarketDataFactory::beforeAdd(CWriteableMarketData *pMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMarketData);
	}
}
	
void CMarketDataFactory::afterAdd(CMarketData *pMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMarketData);
	}
}

void CMarketDataFactory::beforeUpdate(CMarketData *pMarketData, CWriteableMarketData *pNewMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMarketData,pNewMarketData);
	}
}
	
void CMarketDataFactory::afterUpdate(CMarketData *pMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMarketData);
	}
}
	
void CMarketDataFactory::beforeRemove(CMarketData *pMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMarketData);
	}
}

void CMarketDataFactory::commitAdd(CMarketData *pMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMarketData);
	}
}

void CMarketDataFactory::commitUpdate(CMarketData *pMarketData, CWriteableMarketData *pOldMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMarketData,pOldMarketData);
	}
}
	
void CMarketDataFactory::commitRemove(CWriteableMarketData *pMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMarketData);
	}
}

void CMarketDataFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

#ifdef COUNT_OPERATION
int addActionForClearingPartPosition=0;
int updateWithIndexActionForClearingPartPosition=0;
int updateWithoutIndexActionForClearingPartPosition=0;
int removeActionForClearingPartPosition=0;
int addCommitForClearingPartPosition=0;
int updateCommitForClearingPartPosition=0;
int removeCommitForClearingPartPosition=0;
#endif
void CClearingPartPositionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		int hashKeySize=10000;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("ClearingPartPosition.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pPartAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ClearingPartPosition_PartAndInstrumentHashIndex",pPartAndInstrumentHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ClearingPartPosition_PartAndInstrumentHashIndex");
			if(it != pIndexMap->end()) {
				pPartAndInstrumentHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartAndInstrumentHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CClearingPartPositionActionTrigger *>;
	pCommitTriggers=new vector<CClearingPartPositionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CClearingPartPositionFactory::CClearingPartPositionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClearingPartPosition),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CClearingPartPositionFactory::CClearingPartPositionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CClearingPartPosition),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CClearingPartPositionFactory::~CClearingPartPositionFactory(void)
{
	if (runLevel>=0) {
		if (pPartAndInstrumentHashIndex!=NULL)
			delete pPartAndInstrumentHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CClearingPartPositionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CClearingPartPositionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
}

int CClearingPartPositionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableClearingPartPosition thisClearingPartPosition;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisClearingPartPosition.readCSV(input,pNames))
		add(&thisClearingPartPosition);
	fclose(input);
	delete pNames;
	return 1;
}

int CClearingPartPositionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ClearingPartPosition.csv");
	return readCSV(szFileName);
}

int CClearingPartPositionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableClearingPartPosition *pClearingPartPosition;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableClearingPartPosition::writeCSVHead(output);
	pClearingPartPosition=(CWriteableClearingPartPosition *)(pMem->getFirst());
	while (pClearingPartPosition!=NULL) {
		if (!pClearingPartPosition->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pClearingPartPosition=(CWriteableClearingPartPosition *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CClearingPartPositionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ClearingPartPosition.csv");
	return writeCSV(szFileName);
}

void CClearingPartPositionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CClearingPartPositionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableClearingPartPosition *pClearingPartPosition;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CClearingPartPositionFactory={       Total Count=%d\n", pMem->getCount());
	pClearingPartPosition=(CWriteableClearingPartPosition *)(pMem->getFirst());
	while (pClearingPartPosition!=NULL) {
		pClearingPartPosition->dump(fp,index++);
		pClearingPartPosition=(CWriteableClearingPartPosition *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CClearingPartPositionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->removeAll();
	}
}

CClearingPartPosition *CClearingPartPositionFactory::internalAdd(CWriteableClearingPartPosition *pClearingPartPosition, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForClearingPartPosition++;
#endif
	CClearingPartPosition *pTarget;	
	beforeAdd(pClearingPartPosition);
	pTarget=(CClearingPartPosition *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ClearingPartPosition in memory database");
		return NULL;
	}
	forceCopy(pTarget, pClearingPartPosition, sizeof(CClearingPartPosition));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->addObject(pTarget,pTarget->HashPartAndInstrument);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CClearingPartPosition *CClearingPartPositionFactory::add(CWriteableClearingPartPosition *pClearingPartPosition, CTransaction *pTransaction)
{
	pClearingPartPosition->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pClearingPartPosition,true);
	}
	else {
		CClearingPartPosition *pNewClearingPartPosition;
		pNewClearingPartPosition = internalAdd(pClearingPartPosition,false);
		pTransaction->addResource(CClearingPartPositionResource::alloc(CREATE_ACTION,this,pNewClearingPartPosition,NULL));
		return pNewClearingPartPosition;
	}
}

void CClearingPartPositionFactory::internalUpdate(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pNewClearingPartPosition, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForClearingPartPosition++;
	}
	else {
		updateWithoutIndexActionForClearingPartPosition++;
	}
#endif
	CWriteableClearingPartPosition theOldClearingPartPosition;
	beforeUpdate(pClearingPartPosition,pNewClearingPartPosition);
	if (bNoTransaction) {
		forceCopy(&theOldClearingPartPosition,pClearingPartPosition,sizeof(CClearingPartPosition));
	}
	if (updateIndex) {
	}

	forceCopy(pClearingPartPosition,pNewClearingPartPosition,sizeof(CClearingPartPosition));
	pMem->updateObject(pClearingPartPosition);
	if (updateIndex) {
	}
	afterUpdate(pClearingPartPosition);
	if (bNoTransaction) {
		commitUpdate(pClearingPartPosition,&theOldClearingPartPosition);
	}
}

void CClearingPartPositionFactory::update(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pNewClearingPartPosition, CTransaction *pTransaction, bool updateIndex)
{
	pNewClearingPartPosition->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pClearingPartPosition,pNewClearingPartPosition,updateIndex,true);
	}
	else {
		pTransaction->addResource(CClearingPartPositionResource::alloc(UPDATE_ACTION,this,pClearingPartPosition,pNewClearingPartPosition,updateIndex));
		internalUpdate(pClearingPartPosition,pNewClearingPartPosition,updateIndex,false);
	}
}

void CClearingPartPositionFactory::internalRemove(CClearingPartPosition *pClearingPartPosition, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForClearingPartPosition++;
#endif
	CWriteableClearingPartPosition theOldClearingPartPosition;
	beforeRemove(pClearingPartPosition);
	if (bNoTransaction) {
		forceCopy(&theOldClearingPartPosition,pClearingPartPosition,sizeof(CClearingPartPosition));
	}
	if (runLevel>=0) {
		pPartAndInstrumentHashIndex->removeObject(pClearingPartPosition,pClearingPartPosition->HashPartAndInstrument);
	}	
	pMem->free(pClearingPartPosition);
	if(bNoTransaction) {
		commitRemove(&theOldClearingPartPosition);
	}
}

void CClearingPartPositionFactory::remove(CClearingPartPosition *pClearingPartPosition, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pClearingPartPosition,true);
	}
	else {
		pTransaction->addResource(CClearingPartPositionResource::alloc(DELETE_ACTION,this,pClearingPartPosition,NULL));
		internalRemove(pClearingPartPosition,false);		
	}
}

CClearingPartPosition* CClearingPartPositionFactory::addOrUpdate(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pNewClearingPartPosition, CTransaction *pTransaction, bool updateIndex)
{
	if(pClearingPartPosition == NULL) {
		return add(pNewClearingPartPosition,pTransaction);
	}
	else {
		update(pClearingPartPosition,pNewClearingPartPosition,pTransaction,updateIndex);
		return pClearingPartPosition;
	}
}

void CClearingPartPositionFactory::retrieve(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pTargetClearingPartPosition)
{
	forceCopy(pTargetClearingPartPosition, pClearingPartPosition, sizeof(CClearingPartPosition));
}
	
int CClearingPartPositionFactory::addActionTrigger(CClearingPartPositionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CClearingPartPositionFactory::removeActionTrigger(CClearingPartPositionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CClearingPartPositionFactory::addCommitTrigger(CClearingPartPositionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CClearingPartPositionFactory::removeCommitTrigger(CClearingPartPositionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CClearingPartPosition *CClearingPartPositionFactory::getFirst(void)
{
	CClearingPartPosition *pResult=(CClearingPartPosition *)(pMem->getFirst());
	return pResult;
}
	
CClearingPartPosition *CClearingPartPositionFactory::getNext(void)
{
	CClearingPartPosition *pResult=(CClearingPartPosition *)(pMem->getNext());
	return pResult;
}
	
void CClearingPartPositionFactory::endGet(void)
{
	pMem->endGet();
}

void CClearingPartPositionFactory::beforeAdd(CWriteableClearingPartPosition *pClearingPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pClearingPartPosition);
	}
}
	
void CClearingPartPositionFactory::afterAdd(CClearingPartPosition *pClearingPartPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pClearingPartPosition);
	}
}

void CClearingPartPositionFactory::beforeUpdate(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pNewClearingPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pClearingPartPosition,pNewClearingPartPosition);
	}
}
	
void CClearingPartPositionFactory::afterUpdate(CClearingPartPosition *pClearingPartPosition)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pClearingPartPosition);
	}
}
	
void CClearingPartPositionFactory::beforeRemove(CClearingPartPosition *pClearingPartPosition)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pClearingPartPosition);
	}
}

void CClearingPartPositionFactory::commitAdd(CClearingPartPosition *pClearingPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForClearingPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pClearingPartPosition);
	}
}

void CClearingPartPositionFactory::commitUpdate(CClearingPartPosition *pClearingPartPosition, CWriteableClearingPartPosition *pOldClearingPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForClearingPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pClearingPartPosition,pOldClearingPartPosition);
	}
}
	
void CClearingPartPositionFactory::commitRemove(CWriteableClearingPartPosition *pClearingPartPosition)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForClearingPartPosition++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pClearingPartPosition);
	}
}

void CClearingPartPositionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinInstrumentStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForInstrumentStatus=0;
int updateWithIndexActionForInstrumentStatus=0;
int updateWithoutIndexActionForInstrumentStatus=0;
int removeActionForInstrumentStatus=0;
int addCommitForInstrumentStatus=0;
int updateCommitForInstrumentStatus=0;
int removeCommitForInstrumentStatus=0;
#endif
void CInstrumentStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinInstrumentStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("InstrumentStatus_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("InstrumentStatus_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinInstrumentStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByInstrumentID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CInstrumentStatusActionTrigger *>;
	pCommitTriggers=new vector<CInstrumentStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CInstrumentStatusFactory::CInstrumentStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrumentStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CInstrumentStatusFactory::CInstrumentStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CInstrumentStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CInstrumentStatusFactory::~CInstrumentStatusFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CInstrumentStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CInstrumentStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CInstrumentStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableInstrumentStatus thisInstrumentStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisInstrumentStatus.readCSV(input,pNames))
		add(&thisInstrumentStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CInstrumentStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "InstrumentStatus.csv");
	return readCSV(szFileName);
}

int CInstrumentStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableInstrumentStatus *pInstrumentStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableInstrumentStatus::writeCSVHead(output);
	pInstrumentStatus=(CWriteableInstrumentStatus *)(pMem->getFirst());
	while (pInstrumentStatus!=NULL) {
		if (!pInstrumentStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pInstrumentStatus=(CWriteableInstrumentStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CInstrumentStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "InstrumentStatus.csv");
	return writeCSV(szFileName);
}

void CInstrumentStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CInstrumentStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableInstrumentStatus *pInstrumentStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CInstrumentStatusFactory={       Total Count=%d\n", pMem->getCount());
	pInstrumentStatus=(CWriteableInstrumentStatus *)(pMem->getFirst());
	while (pInstrumentStatus!=NULL) {
		pInstrumentStatus->dump(fp,index++);
		pInstrumentStatus=(CWriteableInstrumentStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CInstrumentStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CInstrumentStatus *CInstrumentStatusFactory::internalAdd(CWriteableInstrumentStatus *pInstrumentStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForInstrumentStatus++;
#endif
	CInstrumentStatus *pTarget;	
	beforeAdd(pInstrumentStatus);
	pTarget=(CInstrumentStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough InstrumentStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pInstrumentStatus, sizeof(CInstrumentStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CInstrumentStatus *CInstrumentStatusFactory::add(CWriteableInstrumentStatus *pInstrumentStatus, CTransaction *pTransaction)
{
	pInstrumentStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pInstrumentStatus,true);
	}
	else {
		CInstrumentStatus *pNewInstrumentStatus;
		pNewInstrumentStatus = internalAdd(pInstrumentStatus,false);
		pTransaction->addResource(CInstrumentStatusResource::alloc(CREATE_ACTION,this,pNewInstrumentStatus,NULL));
		return pNewInstrumentStatus;
	}
}

void CInstrumentStatusFactory::internalUpdate(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pNewInstrumentStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForInstrumentStatus++;
	}
	else {
		updateWithoutIndexActionForInstrumentStatus++;
	}
#endif
	CWriteableInstrumentStatus theOldInstrumentStatus;
	beforeUpdate(pInstrumentStatus,pNewInstrumentStatus);
	if (bNoTransaction) {
		forceCopy(&theOldInstrumentStatus,pInstrumentStatus,sizeof(CInstrumentStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pInstrumentStatus,pNewInstrumentStatus,sizeof(CInstrumentStatus));
	pMem->updateObject(pInstrumentStatus);
	if (updateIndex) {
	}
	afterUpdate(pInstrumentStatus);
	if (bNoTransaction) {
		commitUpdate(pInstrumentStatus,&theOldInstrumentStatus);
	}
}

void CInstrumentStatusFactory::update(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pNewInstrumentStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewInstrumentStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pInstrumentStatus,pNewInstrumentStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CInstrumentStatusResource::alloc(UPDATE_ACTION,this,pInstrumentStatus,pNewInstrumentStatus,updateIndex));
		internalUpdate(pInstrumentStatus,pNewInstrumentStatus,updateIndex,false);
	}
}

void CInstrumentStatusFactory::internalRemove(CInstrumentStatus *pInstrumentStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForInstrumentStatus++;
#endif
	CWriteableInstrumentStatus theOldInstrumentStatus;
	beforeRemove(pInstrumentStatus);
	if (bNoTransaction) {
		forceCopy(&theOldInstrumentStatus,pInstrumentStatus,sizeof(CInstrumentStatus));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pInstrumentStatus);
	}
	pMem->free(pInstrumentStatus);
	if(bNoTransaction) {
		commitRemove(&theOldInstrumentStatus);
	}
}

void CInstrumentStatusFactory::remove(CInstrumentStatus *pInstrumentStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pInstrumentStatus,true);
	}
	else {
		pTransaction->addResource(CInstrumentStatusResource::alloc(DELETE_ACTION,this,pInstrumentStatus,NULL));
		internalRemove(pInstrumentStatus,false);		
	}
}

CInstrumentStatus* CInstrumentStatusFactory::addOrUpdate(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pNewInstrumentStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pInstrumentStatus == NULL) {
		return add(pNewInstrumentStatus,pTransaction);
	}
	else {
		update(pInstrumentStatus,pNewInstrumentStatus,pTransaction,updateIndex);
		return pInstrumentStatus;
	}
}

void CInstrumentStatusFactory::retrieve(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pTargetInstrumentStatus)
{
	forceCopy(pTargetInstrumentStatus, pInstrumentStatus, sizeof(CInstrumentStatus));
}
	
int CInstrumentStatusFactory::addActionTrigger(CInstrumentStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CInstrumentStatusFactory::removeActionTrigger(CInstrumentStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CInstrumentStatusFactory::addCommitTrigger(CInstrumentStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CInstrumentStatusFactory::removeCommitTrigger(CInstrumentStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CInstrumentStatus *CInstrumentStatusFactory::getFirst(void)
{
	CInstrumentStatus *pResult=(CInstrumentStatus *)(pMem->getFirst());
	return pResult;
}
	
CInstrumentStatus *CInstrumentStatusFactory::getNext(void)
{
	CInstrumentStatus *pResult=(CInstrumentStatus *)(pMem->getNext());
	return pResult;
}
	
void CInstrumentStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CInstrumentStatusFactory::beforeAdd(CWriteableInstrumentStatus *pInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pInstrumentStatus);
	}
}
	
void CInstrumentStatusFactory::afterAdd(CInstrumentStatus *pInstrumentStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pInstrumentStatus);
	}
}

void CInstrumentStatusFactory::beforeUpdate(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pNewInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pInstrumentStatus,pNewInstrumentStatus);
	}
}
	
void CInstrumentStatusFactory::afterUpdate(CInstrumentStatus *pInstrumentStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pInstrumentStatus);
	}
}
	
void CInstrumentStatusFactory::beforeRemove(CInstrumentStatus *pInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pInstrumentStatus);
	}
}

void CInstrumentStatusFactory::commitAdd(CInstrumentStatus *pInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pInstrumentStatus);
	}
}

void CInstrumentStatusFactory::commitUpdate(CInstrumentStatus *pInstrumentStatus, CWriteableInstrumentStatus *pOldInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pInstrumentStatus,pOldInstrumentStatus);
	}
}
	
void CInstrumentStatusFactory::commitRemove(CWriteableInstrumentStatus *pInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pInstrumentStatus);
	}
}

void CInstrumentStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CInstrumentStatusFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CInstrumentStatus *pInstrumentStatus;
	pInstrumentStatus=getFirst();
	while (pInstrumentStatus != NULL) {
		pInstrumentStatus->linkInstrument(pFactory);
		pInstrumentStatus=getNext();
	}
	endGet();
}

void CInstrumentStatusFactory::linkAllCurrPriceBanding(CCurrPriceBandingFactory *pFactory)
{
	CInstrumentStatus *pInstrumentStatus;
	pInstrumentStatus=getFirst();
	while (pInstrumentStatus != NULL) {
		pInstrumentStatus->linkCurrPriceBanding(pFactory);
		pInstrumentStatus=getNext();
	}
	endGet();
}

void CInstrumentStatusFactory::linkAllMdPubStatus(CMdPubStatusFactory *pFactory)
{
	CInstrumentStatus *pInstrumentStatus;
	pInstrumentStatus=getFirst();
	while (pInstrumentStatus != NULL) {
		pInstrumentStatus->linkMdPubStatus(pFactory);
		pInstrumentStatus=getNext();
	}
	endGet();
}

extern int compareForParticipantIDIndexinOrder(const void *pV1, const void *pV2);
extern int compareForOrderLocalIDIndexinOrder(const void *pV1, const void *pV2);
extern int compareForInstrumentIDIndexinOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForOrder=0;
int updateWithIndexActionForOrder=0;
int updateWithoutIndexActionForOrder=0;
int removeActionForOrder=0;
int addCommitForOrder=0;
int updateCommitForOrder=0;
int removeCommitForOrder=0;
#endif
void COrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Order_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Order_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pOrderLocalIDIndex=new CAVLTree(maxUnit,compareForOrderLocalIDIndexinOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Order_OrderLocalIDIndex",pOrderLocalIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Order_OrderLocalIDIndex");
			if(it != pIndexMap->end()) {
				pOrderLocalIDIndex=new CAVLTree(maxUnit,compareForOrderLocalIDIndexinOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pOrderLocalIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Order_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Order_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=1572869;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("Order.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pOrderSysIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Order_OrderSysIDHashIndex",pOrderSysIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Order_OrderSysIDHashIndex");
			if(it != pIndexMap->end()) {
				pOrderSysIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pOrderSysIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByParticipantID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByUserID=NULL;
	pLastFoundInSearchByInstrumentID=NULL;
	pLastFoundInSearchStartByInstrumentID=NULL;
	pActionTriggers=new vector<COrderActionTrigger *>;
	pCommitTriggers=new vector<COrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

COrderFactory::COrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

COrderFactory::COrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

COrderFactory::~COrderFactory(void)
{
	if (runLevel>=1) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (runLevel>=0) {
		if (pOrderLocalIDIndex!=NULL)
			delete pOrderLocalIDIndex;
	}
	if (runLevel>=1) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (runLevel>=0) {
		if (pOrderSysIDHashIndex!=NULL)
			delete pOrderSysIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void COrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"COrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pOrderLocalIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int COrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableOrder thisOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisOrder.readCSV(input,pNames))
		add(&thisOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int COrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Order.csv");
	return readCSV(szFileName);
}

int COrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableOrder *pOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableOrder::writeCSVHead(output);
	pOrder=(CWriteableOrder *)(pMem->getFirst());
	while (pOrder!=NULL) {
		if (!pOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pOrder=(CWriteableOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int COrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Order.csv");
	return writeCSV(szFileName);
}

void COrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void COrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableOrder *pOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"COrderFactory={       Total Count=%d\n", pMem->getCount());
	pOrder=(CWriteableOrder *)(pMem->getFirst());
	while (pOrder!=NULL) {
		pOrder->dump(fp,index++);
		pOrder=(CWriteableOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void COrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pParticipantIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pOrderLocalIDIndex->removeAll();
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pOrderSysIDHashIndex->removeAll();
	}
}

COrder *COrderFactory::internalAdd(CWriteableOrder *pOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForOrder++;
#endif
	COrder *pTarget;	
	beforeAdd(pOrder);
	pTarget=(COrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Order in memory database");
		return NULL;
	}
	forceCopy(pTarget, pOrder, sizeof(COrder));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pParticipantIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pOrderLocalIDIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pOrderSysIDHashIndex->addObject(pTarget,pTarget->HashOrderSysID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

COrder *COrderFactory::add(CWriteableOrder *pOrder, CTransaction *pTransaction)
{
	pOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pOrder,true);
	}
	else {
		COrder *pNewOrder;
		pNewOrder = internalAdd(pOrder,false);
		pTransaction->addResource(COrderResource::alloc(CREATE_ACTION,this,pNewOrder,NULL));
		return pNewOrder;
	}
}

void COrderFactory::internalUpdate(COrder *pOrder, CWriteableOrder *pNewOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForOrder++;
	}
	else {
		updateWithoutIndexActionForOrder++;
	}
#endif
	CWriteableOrder theOldOrder;
	beforeUpdate(pOrder,pNewOrder);
	if (bNoTransaction) {
		forceCopy(&theOldOrder,pOrder,sizeof(COrder));
	}
	if (updateIndex) {
	}

	forceCopy(pOrder,pNewOrder,sizeof(COrder));
	pMem->updateObject(pOrder);
	if (updateIndex) {
	}
	afterUpdate(pOrder);
	if (bNoTransaction) {
		commitUpdate(pOrder,&theOldOrder);
	}
}

void COrderFactory::update(COrder *pOrder, CWriteableOrder *pNewOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pOrder,pNewOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(COrderResource::alloc(UPDATE_ACTION,this,pOrder,pNewOrder,updateIndex));
		internalUpdate(pOrder,pNewOrder,updateIndex,false);
	}
}

void COrderFactory::internalRemove(COrder *pOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForOrder++;
#endif
	CWriteableOrder theOldOrder;
	beforeRemove(pOrder);
	if (bNoTransaction) {
		forceCopy(&theOldOrder,pOrder,sizeof(COrder));
	}
	if (runLevel>=1) {
		pParticipantIDIndex->removeObject(pOrder);
	}
	if (runLevel>=0) {
		pOrderLocalIDIndex->removeObject(pOrder);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->removeObject(pOrder);
	}
	if (runLevel>=0) {
		pOrderSysIDHashIndex->removeObject(pOrder,pOrder->HashOrderSysID);
	}	
	pMem->free(pOrder);
	if(bNoTransaction) {
		commitRemove(&theOldOrder);
	}
}

void COrderFactory::remove(COrder *pOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pOrder,true);
	}
	else {
		pTransaction->addResource(COrderResource::alloc(DELETE_ACTION,this,pOrder,NULL));
		internalRemove(pOrder,false);		
	}
}

COrder* COrderFactory::addOrUpdate(COrder *pOrder, CWriteableOrder *pNewOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pOrder == NULL) {
		return add(pNewOrder,pTransaction);
	}
	else {
		update(pOrder,pNewOrder,pTransaction,updateIndex);
		return pOrder;
	}
}

void COrderFactory::retrieve(COrder *pOrder, CWriteableOrder *pTargetOrder)
{
	forceCopy(pTargetOrder, pOrder, sizeof(COrder));
}
	
int COrderFactory::addActionTrigger(COrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int COrderFactory::removeActionTrigger(COrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int COrderFactory::addCommitTrigger(COrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int COrderFactory::removeCommitTrigger(COrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

COrder *COrderFactory::getFirst(void)
{
	COrder *pResult=(COrder *)(pMem->getFirst());
	return pResult;
}
	
COrder *COrderFactory::getNext(void)
{
	COrder *pResult=(COrder *)(pMem->getNext());
	return pResult;
}
	
void COrderFactory::endGet(void)
{
	pMem->endGet();
}

void COrderFactory::beforeAdd(CWriteableOrder *pOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pOrder);
	}
}
	
void COrderFactory::afterAdd(COrder *pOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pOrder);
	}
}

void COrderFactory::beforeUpdate(COrder *pOrder, CWriteableOrder *pNewOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pOrder,pNewOrder);
	}
}
	
void COrderFactory::afterUpdate(COrder *pOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pOrder);
	}
}
	
void COrderFactory::beforeRemove(COrder *pOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pOrder);
	}
}

void COrderFactory::commitAdd(COrder *pOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pOrder);
	}
}

void COrderFactory::commitUpdate(COrder *pOrder, CWriteableOrder *pOldOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pOrder,pOldOrder);
	}
}
	
void COrderFactory::commitRemove(CWriteableOrder *pOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pOrder);
	}
}

void COrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void COrderFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	COrder *pOrder;
	pOrder=getFirst();
	while (pOrder != NULL) {
		pOrder->linkInstrument(pFactory);
		pOrder=getNext();
	}
	endGet();
}

void COrderFactory::linkAllPartClient(CPartClientFactory *pFactory)
{
	COrder *pOrder;
	pOrder=getFirst();
	while (pOrder != NULL) {
		pOrder->linkPartClient(pFactory);
		pOrder=getNext();
	}
	endGet();
}

void COrderFactory::linkAllClientPosition(CClientPositionFactory *pFactory)
{
	COrder *pOrder;
	pOrder=getFirst();
	while (pOrder != NULL) {
		pOrder->linkClientPosition(pFactory);
		pOrder=getNext();
	}
	endGet();
}

extern int compareForParticipantIDIndexinCombOrder(const void *pV1, const void *pV2);
extern int compareForCombOrderLocalIDIndexinCombOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCombOrder=0;
int updateWithIndexActionForCombOrder=0;
int updateWithoutIndexActionForCombOrder=0;
int removeActionForCombOrder=0;
int addCommitForCombOrder=0;
int updateCommitForCombOrder=0;
int removeCommitForCombOrder=0;
#endif
void CCombOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinCombOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CombOrder_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CombOrder_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinCombOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pCombOrderLocalIDIndex=new CAVLTree(maxUnit,compareForCombOrderLocalIDIndexinCombOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CombOrder_CombOrderLocalIDIndex",pCombOrderLocalIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CombOrder_CombOrderLocalIDIndex");
			if(it != pIndexMap->end()) {
				pCombOrderLocalIDIndex=new CAVLTree(maxUnit,compareForCombOrderLocalIDIndexinCombOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pCombOrderLocalIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=1572869;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("CombOrder.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pCombOrderSysIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CombOrder_CombOrderSysIDHashIndex",pCombOrderSysIDHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CombOrder_CombOrderSysIDHashIndex");
			if(it != pIndexMap->end()) {
				pCombOrderSysIDHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pCombOrderSysIDHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchStartByParticipantID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByUserID=NULL;
	pActionTriggers=new vector<CCombOrderActionTrigger *>;
	pCommitTriggers=new vector<CCombOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCombOrderFactory::CCombOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCombOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCombOrderFactory::CCombOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCombOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCombOrderFactory::~CCombOrderFactory(void)
{
	if (runLevel>=1) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (runLevel>=0) {
		if (pCombOrderLocalIDIndex!=NULL)
			delete pCombOrderLocalIDIndex;
	}
	if (runLevel>=0) {
		if (pCombOrderSysIDHashIndex!=NULL)
			delete pCombOrderSysIDHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCombOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCombOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pCombOrderLocalIDIndex->output(pLogger,indent+1);
	}
}

int CCombOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCombOrder thisCombOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCombOrder.readCSV(input,pNames))
		add(&thisCombOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CCombOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CombOrder.csv");
	return readCSV(szFileName);
}

int CCombOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCombOrder *pCombOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCombOrder::writeCSVHead(output);
	pCombOrder=(CWriteableCombOrder *)(pMem->getFirst());
	while (pCombOrder!=NULL) {
		if (!pCombOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCombOrder=(CWriteableCombOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCombOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CombOrder.csv");
	return writeCSV(szFileName);
}

void CCombOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCombOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCombOrder *pCombOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCombOrderFactory={       Total Count=%d\n", pMem->getCount());
	pCombOrder=(CWriteableCombOrder *)(pMem->getFirst());
	while (pCombOrder!=NULL) {
		pCombOrder->dump(fp,index++);
		pCombOrder=(CWriteableCombOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCombOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pParticipantIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pCombOrderLocalIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pCombOrderSysIDHashIndex->removeAll();
	}
}

CCombOrder *CCombOrderFactory::internalAdd(CWriteableCombOrder *pCombOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCombOrder++;
#endif
	CCombOrder *pTarget;	
	beforeAdd(pCombOrder);
	pTarget=(CCombOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CombOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCombOrder, sizeof(CCombOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pParticipantIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pCombOrderLocalIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pCombOrderSysIDHashIndex->addObject(pTarget,pTarget->HashCombOrderSysID);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCombOrder *CCombOrderFactory::add(CWriteableCombOrder *pCombOrder, CTransaction *pTransaction)
{
	pCombOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCombOrder,true);
	}
	else {
		CCombOrder *pNewCombOrder;
		pNewCombOrder = internalAdd(pCombOrder,false);
		pTransaction->addResource(CCombOrderResource::alloc(CREATE_ACTION,this,pNewCombOrder,NULL));
		return pNewCombOrder;
	}
}

void CCombOrderFactory::internalUpdate(CCombOrder *pCombOrder, CWriteableCombOrder *pNewCombOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCombOrder++;
	}
	else {
		updateWithoutIndexActionForCombOrder++;
	}
#endif
	CWriteableCombOrder theOldCombOrder;
	beforeUpdate(pCombOrder,pNewCombOrder);
	if (bNoTransaction) {
		forceCopy(&theOldCombOrder,pCombOrder,sizeof(CCombOrder));
	}
	if (updateIndex) {
	}

	forceCopy(pCombOrder,pNewCombOrder,sizeof(CCombOrder));
	pMem->updateObject(pCombOrder);
	if (updateIndex) {
	}
	afterUpdate(pCombOrder);
	if (bNoTransaction) {
		commitUpdate(pCombOrder,&theOldCombOrder);
	}
}

void CCombOrderFactory::update(CCombOrder *pCombOrder, CWriteableCombOrder *pNewCombOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewCombOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCombOrder,pNewCombOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCombOrderResource::alloc(UPDATE_ACTION,this,pCombOrder,pNewCombOrder,updateIndex));
		internalUpdate(pCombOrder,pNewCombOrder,updateIndex,false);
	}
}

void CCombOrderFactory::internalRemove(CCombOrder *pCombOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCombOrder++;
#endif
	CWriteableCombOrder theOldCombOrder;
	beforeRemove(pCombOrder);
	if (bNoTransaction) {
		forceCopy(&theOldCombOrder,pCombOrder,sizeof(CCombOrder));
	}
	if (runLevel>=1) {
		pParticipantIDIndex->removeObject(pCombOrder);
	}
	if (runLevel>=0) {
		pCombOrderLocalIDIndex->removeObject(pCombOrder);
	}
	if (runLevel>=0) {
		pCombOrderSysIDHashIndex->removeObject(pCombOrder,pCombOrder->HashCombOrderSysID);
	}	
	pMem->free(pCombOrder);
	if(bNoTransaction) {
		commitRemove(&theOldCombOrder);
	}
}

void CCombOrderFactory::remove(CCombOrder *pCombOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCombOrder,true);
	}
	else {
		pTransaction->addResource(CCombOrderResource::alloc(DELETE_ACTION,this,pCombOrder,NULL));
		internalRemove(pCombOrder,false);		
	}
}

CCombOrder* CCombOrderFactory::addOrUpdate(CCombOrder *pCombOrder, CWriteableCombOrder *pNewCombOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pCombOrder == NULL) {
		return add(pNewCombOrder,pTransaction);
	}
	else {
		update(pCombOrder,pNewCombOrder,pTransaction,updateIndex);
		return pCombOrder;
	}
}

void CCombOrderFactory::retrieve(CCombOrder *pCombOrder, CWriteableCombOrder *pTargetCombOrder)
{
	forceCopy(pTargetCombOrder, pCombOrder, sizeof(CCombOrder));
}
	
int CCombOrderFactory::addActionTrigger(CCombOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCombOrderFactory::removeActionTrigger(CCombOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCombOrderFactory::addCommitTrigger(CCombOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCombOrderFactory::removeCommitTrigger(CCombOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCombOrder *CCombOrderFactory::getFirst(void)
{
	CCombOrder *pResult=(CCombOrder *)(pMem->getFirst());
	return pResult;
}
	
CCombOrder *CCombOrderFactory::getNext(void)
{
	CCombOrder *pResult=(CCombOrder *)(pMem->getNext());
	return pResult;
}
	
void CCombOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CCombOrderFactory::beforeAdd(CWriteableCombOrder *pCombOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCombOrder);
	}
}
	
void CCombOrderFactory::afterAdd(CCombOrder *pCombOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCombOrder);
	}
}

void CCombOrderFactory::beforeUpdate(CCombOrder *pCombOrder, CWriteableCombOrder *pNewCombOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCombOrder,pNewCombOrder);
	}
}
	
void CCombOrderFactory::afterUpdate(CCombOrder *pCombOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCombOrder);
	}
}
	
void CCombOrderFactory::beforeRemove(CCombOrder *pCombOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCombOrder);
	}
}

void CCombOrderFactory::commitAdd(CCombOrder *pCombOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCombOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCombOrder);
	}
}

void CCombOrderFactory::commitUpdate(CCombOrder *pCombOrder, CWriteableCombOrder *pOldCombOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCombOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCombOrder,pOldCombOrder);
	}
}
	
void CCombOrderFactory::commitRemove(CWriteableCombOrder *pCombOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCombOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCombOrder);
	}
}

void CCombOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CCombOrderFactory::linkAllPartClient(CPartClientFactory *pFactory)
{
	CCombOrder *pCombOrder;
	pCombOrder=getFirst();
	while (pCombOrder != NULL) {
		pCombOrder->linkPartClient(pFactory);
		pCombOrder=getNext();
	}
	endGet();
}

void CCombOrderFactory::linkAllInstrument1(CInstrumentFactory *pFactory)
{
	CCombOrder *pCombOrder;
	pCombOrder=getFirst();
	while (pCombOrder != NULL) {
		pCombOrder->linkInstrument1(pFactory);
		pCombOrder=getNext();
	}
	endGet();
}

void CCombOrderFactory::linkAllInstrument2(CInstrumentFactory *pFactory)
{
	CCombOrder *pCombOrder;
	pCombOrder=getFirst();
	while (pCombOrder != NULL) {
		pCombOrder->linkInstrument2(pFactory);
		pCombOrder=getNext();
	}
	endGet();
}

void CCombOrderFactory::linkAllInstrument3(CInstrumentFactory *pFactory)
{
	CCombOrder *pCombOrder;
	pCombOrder=getFirst();
	while (pCombOrder != NULL) {
		pCombOrder->linkInstrument3(pFactory);
		pCombOrder=getNext();
	}
	endGet();
}

void CCombOrderFactory::linkAllInstrument4(CInstrumentFactory *pFactory)
{
	CCombOrder *pCombOrder;
	pCombOrder=getFirst();
	while (pCombOrder != NULL) {
		pCombOrder->linkInstrument4(pFactory);
		pCombOrder=getNext();
	}
	endGet();
}

extern int compareForOTCOrderIDIndexinOTCOrder(const void *pV1, const void *pV2);
extern int compareForOTCOrderLocalIDIndexinOTCOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForOTCOrder=0;
int updateWithIndexActionForOTCOrder=0;
int updateWithoutIndexActionForOTCOrder=0;
int removeActionForOTCOrder=0;
int addCommitForOTCOrder=0;
int updateCommitForOTCOrder=0;
int removeCommitForOTCOrder=0;
#endif
void COTCOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pOTCOrderIDIndex=new CAVLTree(maxUnit,compareForOTCOrderIDIndexinOTCOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("OTCOrder_OTCOrderIDIndex",pOTCOrderIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("OTCOrder_OTCOrderIDIndex");
			if(it != pIndexMap->end()) {
				pOTCOrderIDIndex=new CAVLTree(maxUnit,compareForOTCOrderIDIndexinOTCOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pOTCOrderIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pOTCOrderLocalIDIndex=new CAVLTree(maxUnit,compareForOTCOrderLocalIDIndexinOTCOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("OTCOrder_OTCOrderLocalIDIndex",pOTCOrderLocalIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("OTCOrder_OTCOrderLocalIDIndex");
			if(it != pIndexMap->end()) {
				pOTCOrderLocalIDIndex=new CAVLTree(maxUnit,compareForOTCOrderLocalIDIndexinOTCOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pOTCOrderLocalIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<COTCOrderActionTrigger *>;
	pCommitTriggers=new vector<COTCOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

COTCOrderFactory::COTCOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COTCOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

COTCOrderFactory::COTCOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(COTCOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

COTCOrderFactory::~COTCOrderFactory(void)
{
	if (runLevel>=0) {
		if (pOTCOrderIDIndex!=NULL)
			delete pOTCOrderIDIndex;
	}
	if (runLevel>=0) {
		if (pOTCOrderLocalIDIndex!=NULL)
			delete pOTCOrderLocalIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void COTCOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"COTCOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pOTCOrderIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pOTCOrderLocalIDIndex->output(pLogger,indent+1);
	}
}

int COTCOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableOTCOrder thisOTCOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisOTCOrder.readCSV(input,pNames))
		add(&thisOTCOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int COTCOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "OTCOrder.csv");
	return readCSV(szFileName);
}

int COTCOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableOTCOrder *pOTCOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableOTCOrder::writeCSVHead(output);
	pOTCOrder=(CWriteableOTCOrder *)(pMem->getFirst());
	while (pOTCOrder!=NULL) {
		if (!pOTCOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pOTCOrder=(CWriteableOTCOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int COTCOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "OTCOrder.csv");
	return writeCSV(szFileName);
}

void COTCOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void COTCOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableOTCOrder *pOTCOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"COTCOrderFactory={       Total Count=%d\n", pMem->getCount());
	pOTCOrder=(CWriteableOTCOrder *)(pMem->getFirst());
	while (pOTCOrder!=NULL) {
		pOTCOrder->dump(fp,index++);
		pOTCOrder=(CWriteableOTCOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void COTCOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pOTCOrderIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pOTCOrderLocalIDIndex->removeAll();
	}
}

COTCOrder *COTCOrderFactory::internalAdd(CWriteableOTCOrder *pOTCOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForOTCOrder++;
#endif
	COTCOrder *pTarget;	
	beforeAdd(pOTCOrder);
	pTarget=(COTCOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough OTCOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pOTCOrder, sizeof(COTCOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pOTCOrderIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pOTCOrderLocalIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

COTCOrder *COTCOrderFactory::add(CWriteableOTCOrder *pOTCOrder, CTransaction *pTransaction)
{
	pOTCOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pOTCOrder,true);
	}
	else {
		COTCOrder *pNewOTCOrder;
		pNewOTCOrder = internalAdd(pOTCOrder,false);
		pTransaction->addResource(COTCOrderResource::alloc(CREATE_ACTION,this,pNewOTCOrder,NULL));
		return pNewOTCOrder;
	}
}

void COTCOrderFactory::internalUpdate(COTCOrder *pOTCOrder, CWriteableOTCOrder *pNewOTCOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForOTCOrder++;
	}
	else {
		updateWithoutIndexActionForOTCOrder++;
	}
#endif
	CWriteableOTCOrder theOldOTCOrder;
	beforeUpdate(pOTCOrder,pNewOTCOrder);
	if (bNoTransaction) {
		forceCopy(&theOldOTCOrder,pOTCOrder,sizeof(COTCOrder));
	}
	if (updateIndex) {
	}

	forceCopy(pOTCOrder,pNewOTCOrder,sizeof(COTCOrder));
	pMem->updateObject(pOTCOrder);
	if (updateIndex) {
	}
	afterUpdate(pOTCOrder);
	if (bNoTransaction) {
		commitUpdate(pOTCOrder,&theOldOTCOrder);
	}
}

void COTCOrderFactory::update(COTCOrder *pOTCOrder, CWriteableOTCOrder *pNewOTCOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewOTCOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pOTCOrder,pNewOTCOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(COTCOrderResource::alloc(UPDATE_ACTION,this,pOTCOrder,pNewOTCOrder,updateIndex));
		internalUpdate(pOTCOrder,pNewOTCOrder,updateIndex,false);
	}
}

void COTCOrderFactory::internalRemove(COTCOrder *pOTCOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForOTCOrder++;
#endif
	CWriteableOTCOrder theOldOTCOrder;
	beforeRemove(pOTCOrder);
	if (bNoTransaction) {
		forceCopy(&theOldOTCOrder,pOTCOrder,sizeof(COTCOrder));
	}
	if (runLevel>=0) {
		pOTCOrderIDIndex->removeObject(pOTCOrder);
	}
	if (runLevel>=0) {
		pOTCOrderLocalIDIndex->removeObject(pOTCOrder);
	}
	pMem->free(pOTCOrder);
	if(bNoTransaction) {
		commitRemove(&theOldOTCOrder);
	}
}

void COTCOrderFactory::remove(COTCOrder *pOTCOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pOTCOrder,true);
	}
	else {
		pTransaction->addResource(COTCOrderResource::alloc(DELETE_ACTION,this,pOTCOrder,NULL));
		internalRemove(pOTCOrder,false);		
	}
}

COTCOrder* COTCOrderFactory::addOrUpdate(COTCOrder *pOTCOrder, CWriteableOTCOrder *pNewOTCOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pOTCOrder == NULL) {
		return add(pNewOTCOrder,pTransaction);
	}
	else {
		update(pOTCOrder,pNewOTCOrder,pTransaction,updateIndex);
		return pOTCOrder;
	}
}

void COTCOrderFactory::retrieve(COTCOrder *pOTCOrder, CWriteableOTCOrder *pTargetOTCOrder)
{
	forceCopy(pTargetOTCOrder, pOTCOrder, sizeof(COTCOrder));
}
	
int COTCOrderFactory::addActionTrigger(COTCOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int COTCOrderFactory::removeActionTrigger(COTCOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int COTCOrderFactory::addCommitTrigger(COTCOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int COTCOrderFactory::removeCommitTrigger(COTCOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

COTCOrder *COTCOrderFactory::getFirst(void)
{
	COTCOrder *pResult=(COTCOrder *)(pMem->getFirst());
	return pResult;
}
	
COTCOrder *COTCOrderFactory::getNext(void)
{
	COTCOrder *pResult=(COTCOrder *)(pMem->getNext());
	return pResult;
}
	
void COTCOrderFactory::endGet(void)
{
	pMem->endGet();
}

void COTCOrderFactory::beforeAdd(CWriteableOTCOrder *pOTCOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pOTCOrder);
	}
}
	
void COTCOrderFactory::afterAdd(COTCOrder *pOTCOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pOTCOrder);
	}
}

void COTCOrderFactory::beforeUpdate(COTCOrder *pOTCOrder, CWriteableOTCOrder *pNewOTCOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pOTCOrder,pNewOTCOrder);
	}
}
	
void COTCOrderFactory::afterUpdate(COTCOrder *pOTCOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pOTCOrder);
	}
}
	
void COTCOrderFactory::beforeRemove(COTCOrder *pOTCOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pOTCOrder);
	}
}

void COTCOrderFactory::commitAdd(COTCOrder *pOTCOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForOTCOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pOTCOrder);
	}
}

void COTCOrderFactory::commitUpdate(COTCOrder *pOTCOrder, CWriteableOTCOrder *pOldOTCOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForOTCOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pOTCOrder,pOldOTCOrder);
	}
}
	
void COTCOrderFactory::commitRemove(CWriteableOTCOrder *pOTCOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForOTCOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pOTCOrder);
	}
}

void COTCOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void COTCOrderFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	COTCOrder *pOTCOrder;
	pOTCOrder=getFirst();
	while (pOTCOrder != NULL) {
		pOTCOrder->linkInstrument(pFactory);
		pOTCOrder=getNext();
	}
	endGet();
}

extern int compareForImplyLegInstrumentIndexinImplyOrder(const void *pV1, const void *pV2);
extern int compareForImplyOrderAndAnchorLegIndexinImplyOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForImplyOrder=0;
int updateWithIndexActionForImplyOrder=0;
int updateWithoutIndexActionForImplyOrder=0;
int removeActionForImplyOrder=0;
int addCommitForImplyOrder=0;
int updateCommitForImplyOrder=0;
int removeCommitForImplyOrder=0;
#endif
void CImplyOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pImplyLegInstrumentIndex=new CAVLTree(maxUnit,compareForImplyLegInstrumentIndexinImplyOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ImplyOrder_ImplyLegInstrumentIndex",pImplyLegInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ImplyOrder_ImplyLegInstrumentIndex");
			if(it != pIndexMap->end()) {
				pImplyLegInstrumentIndex=new CAVLTree(maxUnit,compareForImplyLegInstrumentIndexinImplyOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pImplyLegInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pImplyOrderAndAnchorLegIndex=new CAVLTree(maxUnit,compareForImplyOrderAndAnchorLegIndexinImplyOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ImplyOrder_ImplyOrderAndAnchorLegIndex",pImplyOrderAndAnchorLegIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ImplyOrder_ImplyOrderAndAnchorLegIndex");
			if(it != pIndexMap->end()) {
				pImplyOrderAndAnchorLegIndex=new CAVLTree(maxUnit,compareForImplyOrderAndAnchorLegIndexinImplyOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pImplyOrderAndAnchorLegIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByImplyLeg=NULL;
	pLastFoundInSearchByImplyOrderAndAnchorLeg=NULL;
	pLastFoundInSearchByImplyOrder=NULL;
	pActionTriggers=new vector<CImplyOrderActionTrigger *>;
	pCommitTriggers=new vector<CImplyOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CImplyOrderFactory::CImplyOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CImplyOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CImplyOrderFactory::CImplyOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CImplyOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CImplyOrderFactory::~CImplyOrderFactory(void)
{
	if (runLevel>=0) {
		if (pImplyLegInstrumentIndex!=NULL)
			delete pImplyLegInstrumentIndex;
	}
	if (runLevel>=0) {
		if (pImplyOrderAndAnchorLegIndex!=NULL)
			delete pImplyOrderAndAnchorLegIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CImplyOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CImplyOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pImplyLegInstrumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pImplyOrderAndAnchorLegIndex->output(pLogger,indent+1);
	}
}

int CImplyOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableImplyOrder thisImplyOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisImplyOrder.readCSV(input,pNames))
		add(&thisImplyOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CImplyOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ImplyOrder.csv");
	return readCSV(szFileName);
}

int CImplyOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableImplyOrder *pImplyOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableImplyOrder::writeCSVHead(output);
	pImplyOrder=(CWriteableImplyOrder *)(pMem->getFirst());
	while (pImplyOrder!=NULL) {
		if (!pImplyOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pImplyOrder=(CWriteableImplyOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CImplyOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ImplyOrder.csv");
	return writeCSV(szFileName);
}

void CImplyOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CImplyOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableImplyOrder *pImplyOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CImplyOrderFactory={       Total Count=%d\n", pMem->getCount());
	pImplyOrder=(CWriteableImplyOrder *)(pMem->getFirst());
	while (pImplyOrder!=NULL) {
		pImplyOrder->dump(fp,index++);
		pImplyOrder=(CWriteableImplyOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CImplyOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pImplyLegInstrumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pImplyOrderAndAnchorLegIndex->removeAll();
	}
}

CImplyOrder *CImplyOrderFactory::internalAdd(CWriteableImplyOrder *pImplyOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForImplyOrder++;
#endif
	CImplyOrder *pTarget;	
	beforeAdd(pImplyOrder);
	pTarget=(CImplyOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ImplyOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pImplyOrder, sizeof(CImplyOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pImplyLegInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pImplyOrderAndAnchorLegIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CImplyOrder *CImplyOrderFactory::add(CWriteableImplyOrder *pImplyOrder, CTransaction *pTransaction)
{
	pImplyOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pImplyOrder,true);
	}
	else {
		CImplyOrder *pNewImplyOrder;
		pNewImplyOrder = internalAdd(pImplyOrder,false);
		pTransaction->addResource(CImplyOrderResource::alloc(CREATE_ACTION,this,pNewImplyOrder,NULL));
		return pNewImplyOrder;
	}
}

void CImplyOrderFactory::internalUpdate(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pNewImplyOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForImplyOrder++;
	}
	else {
		updateWithoutIndexActionForImplyOrder++;
	}
#endif
	CWriteableImplyOrder theOldImplyOrder;
	beforeUpdate(pImplyOrder,pNewImplyOrder);
	if (bNoTransaction) {
		forceCopy(&theOldImplyOrder,pImplyOrder,sizeof(CImplyOrder));
	}
	CAVLNode *pImplyOrderAndAnchorLegIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pImplyOrderAndAnchorLegIndexNode=pImplyOrderAndAnchorLegIndex->findObject(pImplyOrder);
		}
	}

	forceCopy(pImplyOrder,pNewImplyOrder,sizeof(CImplyOrder));
	pMem->updateObject(pImplyOrder);
	if (updateIndex) {
		if (runLevel>=0) {
			pImplyOrderAndAnchorLegIndex->updateNode(pImplyOrderAndAnchorLegIndexNode);
		}
	}
	afterUpdate(pImplyOrder);
	if (bNoTransaction) {
		commitUpdate(pImplyOrder,&theOldImplyOrder);
	}
}

void CImplyOrderFactory::update(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pNewImplyOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewImplyOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pImplyOrder,pNewImplyOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CImplyOrderResource::alloc(UPDATE_ACTION,this,pImplyOrder,pNewImplyOrder,updateIndex));
		internalUpdate(pImplyOrder,pNewImplyOrder,updateIndex,false);
	}
}

void CImplyOrderFactory::internalRemove(CImplyOrder *pImplyOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForImplyOrder++;
#endif
	CWriteableImplyOrder theOldImplyOrder;
	beforeRemove(pImplyOrder);
	if (bNoTransaction) {
		forceCopy(&theOldImplyOrder,pImplyOrder,sizeof(CImplyOrder));
	}
	if (runLevel>=0) {
		pImplyLegInstrumentIndex->removeObject(pImplyOrder);
	}
	if (runLevel>=0) {
		pImplyOrderAndAnchorLegIndex->removeObject(pImplyOrder);
	}
	pMem->free(pImplyOrder);
	if(bNoTransaction) {
		commitRemove(&theOldImplyOrder);
	}
}

void CImplyOrderFactory::remove(CImplyOrder *pImplyOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pImplyOrder,true);
	}
	else {
		pTransaction->addResource(CImplyOrderResource::alloc(DELETE_ACTION,this,pImplyOrder,NULL));
		internalRemove(pImplyOrder,false);		
	}
}

CImplyOrder* CImplyOrderFactory::addOrUpdate(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pNewImplyOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pImplyOrder == NULL) {
		return add(pNewImplyOrder,pTransaction);
	}
	else {
		update(pImplyOrder,pNewImplyOrder,pTransaction,updateIndex);
		return pImplyOrder;
	}
}

void CImplyOrderFactory::retrieve(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pTargetImplyOrder)
{
	forceCopy(pTargetImplyOrder, pImplyOrder, sizeof(CImplyOrder));
}
	
int CImplyOrderFactory::addActionTrigger(CImplyOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CImplyOrderFactory::removeActionTrigger(CImplyOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CImplyOrderFactory::addCommitTrigger(CImplyOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CImplyOrderFactory::removeCommitTrigger(CImplyOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CImplyOrder *CImplyOrderFactory::getFirst(void)
{
	CImplyOrder *pResult=(CImplyOrder *)(pMem->getFirst());
	return pResult;
}
	
CImplyOrder *CImplyOrderFactory::getNext(void)
{
	CImplyOrder *pResult=(CImplyOrder *)(pMem->getNext());
	return pResult;
}
	
void CImplyOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CImplyOrderFactory::beforeAdd(CWriteableImplyOrder *pImplyOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pImplyOrder);
	}
}
	
void CImplyOrderFactory::afterAdd(CImplyOrder *pImplyOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pImplyOrder);
	}
}

void CImplyOrderFactory::beforeUpdate(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pNewImplyOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pImplyOrder,pNewImplyOrder);
	}
}
	
void CImplyOrderFactory::afterUpdate(CImplyOrder *pImplyOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pImplyOrder);
	}
}
	
void CImplyOrderFactory::beforeRemove(CImplyOrder *pImplyOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pImplyOrder);
	}
}

void CImplyOrderFactory::commitAdd(CImplyOrder *pImplyOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForImplyOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pImplyOrder);
	}
}

void CImplyOrderFactory::commitUpdate(CImplyOrder *pImplyOrder, CWriteableImplyOrder *pOldImplyOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForImplyOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pImplyOrder,pOldImplyOrder);
	}
}
	
void CImplyOrderFactory::commitRemove(CWriteableImplyOrder *pImplyOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForImplyOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pImplyOrder);
	}
}

void CImplyOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForQuoteIDIndexinQuote(const void *pV1, const void *pV2);
extern int compareForPartClientAndInstrumentIndexinQuote(const void *pV1, const void *pV2);
extern int compareForQuoteLocalIDIndexinQuote(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForQuote=0;
int updateWithIndexActionForQuote=0;
int updateWithoutIndexActionForQuote=0;
int removeActionForQuote=0;
int addCommitForQuote=0;
int updateCommitForQuote=0;
int removeCommitForQuote=0;
#endif
void CQuoteFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pQuoteIDIndex=new CAVLTree(maxUnit,compareForQuoteIDIndexinQuote,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Quote_QuoteIDIndex",pQuoteIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Quote_QuoteIDIndex");
			if(it != pIndexMap->end()) {
				pQuoteIDIndex=new CAVLTree(maxUnit,compareForQuoteIDIndexinQuote,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pQuoteIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pPartClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstrumentIndexinQuote,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Quote_PartClientAndInstrumentIndex",pPartClientAndInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Quote_PartClientAndInstrumentIndex");
			if(it != pIndexMap->end()) {
				pPartClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForPartClientAndInstrumentIndexinQuote,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartClientAndInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pQuoteLocalIDIndex=new CAVLTree(maxUnit,compareForQuoteLocalIDIndexinQuote,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Quote_QuoteLocalIDIndex",pQuoteLocalIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Quote_QuoteLocalIDIndex");
			if(it != pIndexMap->end()) {
				pQuoteLocalIDIndex=new CAVLTree(maxUnit,compareForQuoteLocalIDIndexinQuote,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pQuoteLocalIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=10000;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("Quote.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pAskOrderHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Quote_AskOrderHashIndex",pAskOrderHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Quote_AskOrderHashIndex");
			if(it != pIndexMap->end()) {
				pAskOrderHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pAskOrderHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		int hashKeySize=10000;
		if (m_pConfig!=NULL) {
			int newSize=atoi(m_pConfig->getConfig("Quote.size"));
			if (newSize>0) {
				hashKeySize=newSize;
			}
		}
		if(!reuse) {
			pBidOrderHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Quote_BidOrderHashIndex",pBidOrderHashIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Quote_BidOrderHashIndex");
			if(it != pIndexMap->end()) {
				pBidOrderHashIndex=new CHashIndex(hashKeySize,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pBidOrderHashIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByUserID=NULL;
	pLastFoundInSearchStartByParticipantID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CQuoteActionTrigger *>;
	pCommitTriggers=new vector<CQuoteCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CQuoteFactory::CQuoteFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CQuote),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CQuoteFactory::CQuoteFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CQuote),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CQuoteFactory::~CQuoteFactory(void)
{
	if (runLevel>=0) {
		if (pQuoteIDIndex!=NULL)
			delete pQuoteIDIndex;
	}
	if (runLevel>=0) {
		if (pPartClientAndInstrumentIndex!=NULL)
			delete pPartClientAndInstrumentIndex;
	}
	if (runLevel>=0) {
		if (pQuoteLocalIDIndex!=NULL)
			delete pQuoteLocalIDIndex;
	}
	if (runLevel>=0) {
		if (pAskOrderHashIndex!=NULL)
			delete pAskOrderHashIndex;
	}
	if (runLevel>=0) {
		if (pBidOrderHashIndex!=NULL)
			delete pBidOrderHashIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CQuoteFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CQuoteFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pQuoteIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pQuoteLocalIDIndex->output(pLogger,indent+1);
	}
}

int CQuoteFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableQuote thisQuote;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisQuote.readCSV(input,pNames))
		add(&thisQuote);
	fclose(input);
	delete pNames;
	return 1;
}

int CQuoteFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Quote.csv");
	return readCSV(szFileName);
}

int CQuoteFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableQuote *pQuote;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableQuote::writeCSVHead(output);
	pQuote=(CWriteableQuote *)(pMem->getFirst());
	while (pQuote!=NULL) {
		if (!pQuote->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pQuote=(CWriteableQuote *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CQuoteFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Quote.csv");
	return writeCSV(szFileName);
}

void CQuoteFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CQuoteFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableQuote *pQuote;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CQuoteFactory={       Total Count=%d\n", pMem->getCount());
	pQuote=(CWriteableQuote *)(pMem->getFirst());
	while (pQuote!=NULL) {
		pQuote->dump(fp,index++);
		pQuote=(CWriteableQuote *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CQuoteFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pQuoteIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pQuoteLocalIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pAskOrderHashIndex->removeAll();
	}
	if (runLevel>=0) {
		pBidOrderHashIndex->removeAll();
	}
}

CQuote *CQuoteFactory::internalAdd(CWriteableQuote *pQuote, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForQuote++;
#endif
	CQuote *pTarget;	
	beforeAdd(pQuote);
	pTarget=(CQuote *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Quote in memory database");
		return NULL;
	}
	forceCopy(pTarget, pQuote, sizeof(CQuote));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pQuoteIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pQuoteLocalIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pAskOrderHashIndex->addObject(pTarget,pTarget->HashAskOrderSysIDHashKey);
	}
	if (runLevel>=0) {
		pBidOrderHashIndex->addObject(pTarget,pTarget->HashBidOrderSysIDHashKey);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CQuote *CQuoteFactory::add(CWriteableQuote *pQuote, CTransaction *pTransaction)
{
	pQuote->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pQuote,true);
	}
	else {
		CQuote *pNewQuote;
		pNewQuote = internalAdd(pQuote,false);
		pTransaction->addResource(CQuoteResource::alloc(CREATE_ACTION,this,pNewQuote,NULL));
		return pNewQuote;
	}
}

void CQuoteFactory::internalUpdate(CQuote *pQuote, CWriteableQuote *pNewQuote, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForQuote++;
	}
	else {
		updateWithoutIndexActionForQuote++;
	}
#endif
	CWriteableQuote theOldQuote;
	beforeUpdate(pQuote,pNewQuote);
	if (bNoTransaction) {
		forceCopy(&theOldQuote,pQuote,sizeof(CQuote));
	}
	if (updateIndex) {
		if (runLevel>=0) {
			pAskOrderHashIndex->removeObject(pQuote,pQuote->HashAskOrderSysIDHashKey);
		}
		if (runLevel>=0) {
			pBidOrderHashIndex->removeObject(pQuote,pQuote->HashBidOrderSysIDHashKey);
		}
	}

	forceCopy(pQuote,pNewQuote,sizeof(CQuote));
	pMem->updateObject(pQuote);
	if (updateIndex) {
		if (runLevel>=0) {
			pAskOrderHashIndex->addObject(pQuote,pQuote->HashAskOrderSysIDHashKey);
		}
		if (runLevel>=0) {
			pBidOrderHashIndex->addObject(pQuote,pQuote->HashBidOrderSysIDHashKey);
		}
	}
	afterUpdate(pQuote);
	if (bNoTransaction) {
		commitUpdate(pQuote,&theOldQuote);
	}
}

void CQuoteFactory::update(CQuote *pQuote, CWriteableQuote *pNewQuote, CTransaction *pTransaction, bool updateIndex)
{
	pNewQuote->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pQuote,pNewQuote,updateIndex,true);
	}
	else {
		pTransaction->addResource(CQuoteResource::alloc(UPDATE_ACTION,this,pQuote,pNewQuote,updateIndex));
		internalUpdate(pQuote,pNewQuote,updateIndex,false);
	}
}

void CQuoteFactory::internalRemove(CQuote *pQuote, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForQuote++;
#endif
	CWriteableQuote theOldQuote;
	beforeRemove(pQuote);
	if (bNoTransaction) {
		forceCopy(&theOldQuote,pQuote,sizeof(CQuote));
	}
	if (runLevel>=0) {
		pQuoteIDIndex->removeObject(pQuote);
	}
	if (runLevel>=0) {
		pPartClientAndInstrumentIndex->removeObject(pQuote);
	}
	if (runLevel>=0) {
		pQuoteLocalIDIndex->removeObject(pQuote);
	}
	if (runLevel>=0) {
		pAskOrderHashIndex->removeObject(pQuote,pQuote->HashAskOrderSysIDHashKey);
	}	
	if (runLevel>=0) {
		pBidOrderHashIndex->removeObject(pQuote,pQuote->HashBidOrderSysIDHashKey);
	}	
	pMem->free(pQuote);
	if(bNoTransaction) {
		commitRemove(&theOldQuote);
	}
}

void CQuoteFactory::remove(CQuote *pQuote, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pQuote,true);
	}
	else {
		pTransaction->addResource(CQuoteResource::alloc(DELETE_ACTION,this,pQuote,NULL));
		internalRemove(pQuote,false);		
	}
}

CQuote* CQuoteFactory::addOrUpdate(CQuote *pQuote, CWriteableQuote *pNewQuote, CTransaction *pTransaction, bool updateIndex)
{
	if(pQuote == NULL) {
		return add(pNewQuote,pTransaction);
	}
	else {
		update(pQuote,pNewQuote,pTransaction,updateIndex);
		return pQuote;
	}
}

void CQuoteFactory::retrieve(CQuote *pQuote, CWriteableQuote *pTargetQuote)
{
	forceCopy(pTargetQuote, pQuote, sizeof(CQuote));
}
	
int CQuoteFactory::addActionTrigger(CQuoteActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CQuoteFactory::removeActionTrigger(CQuoteActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CQuoteFactory::addCommitTrigger(CQuoteCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CQuoteFactory::removeCommitTrigger(CQuoteCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CQuote *CQuoteFactory::getFirst(void)
{
	CQuote *pResult=(CQuote *)(pMem->getFirst());
	return pResult;
}
	
CQuote *CQuoteFactory::getNext(void)
{
	CQuote *pResult=(CQuote *)(pMem->getNext());
	return pResult;
}
	
void CQuoteFactory::endGet(void)
{
	pMem->endGet();
}

void CQuoteFactory::beforeAdd(CWriteableQuote *pQuote)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pQuote);
	}
}
	
void CQuoteFactory::afterAdd(CQuote *pQuote)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pQuote);
	}
}

void CQuoteFactory::beforeUpdate(CQuote *pQuote, CWriteableQuote *pNewQuote)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pQuote,pNewQuote);
	}
}
	
void CQuoteFactory::afterUpdate(CQuote *pQuote)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pQuote);
	}
}
	
void CQuoteFactory::beforeRemove(CQuote *pQuote)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pQuote);
	}
}

void CQuoteFactory::commitAdd(CQuote *pQuote)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForQuote++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pQuote);
	}
}

void CQuoteFactory::commitUpdate(CQuote *pQuote, CWriteableQuote *pOldQuote)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForQuote++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pQuote,pOldQuote);
	}
}
	
void CQuoteFactory::commitRemove(CWriteableQuote *pQuote)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForQuote++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pQuote);
	}
}

void CQuoteFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CQuoteFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CQuote *pQuote;
	pQuote=getFirst();
	while (pQuote != NULL) {
		pQuote->linkInstrument(pFactory);
		pQuote=getNext();
	}
	endGet();
}

void CQuoteFactory::linkAllPartClient(CPartClientFactory *pFactory)
{
	CQuote *pQuote;
	pQuote=getFirst();
	while (pQuote != NULL) {
		pQuote->linkPartClient(pFactory);
		pQuote=getNext();
	}
	endGet();
}

extern int compareForBuyMBLIndexinMBLMarketData(const void *pV1, const void *pV2);
extern int compareForSellMBLIndexinMBLMarketData(const void *pV1, const void *pV2);
extern int compareForQBuyMBLIndexinMBLMarketData(const void *pV1, const void *pV2);
extern int compareForQSellMBLIndexinMBLMarketData(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForMBLMarketData=0;
int updateWithIndexActionForMBLMarketData=0;
int updateWithoutIndexActionForMBLMarketData=0;
int removeActionForMBLMarketData=0;
int addCommitForMBLMarketData=0;
int updateCommitForMBLMarketData=0;
int removeCommitForMBLMarketData=0;
#endif
void CMBLMarketDataFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pBuyMBLIndex=new CAVLTree(maxUnit,compareForBuyMBLIndexinMBLMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MBLMarketData_BuyMBLIndex",pBuyMBLIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MBLMarketData_BuyMBLIndex");
			if(it != pIndexMap->end()) {
				pBuyMBLIndex=new CAVLTree(maxUnit,compareForBuyMBLIndexinMBLMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pBuyMBLIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSellMBLIndex=new CAVLTree(maxUnit,compareForSellMBLIndexinMBLMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MBLMarketData_SellMBLIndex",pSellMBLIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MBLMarketData_SellMBLIndex");
			if(it != pIndexMap->end()) {
				pSellMBLIndex=new CAVLTree(maxUnit,compareForSellMBLIndexinMBLMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSellMBLIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pQBuyMBLIndex=new CAVLTree(maxUnit,compareForQBuyMBLIndexinMBLMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MBLMarketData_QBuyMBLIndex",pQBuyMBLIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MBLMarketData_QBuyMBLIndex");
			if(it != pIndexMap->end()) {
				pQBuyMBLIndex=new CAVLTree(maxUnit,compareForQBuyMBLIndexinMBLMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pQBuyMBLIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pQSellMBLIndex=new CAVLTree(maxUnit,compareForQSellMBLIndexinMBLMarketData,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("MBLMarketData_QSellMBLIndex",pQSellMBLIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("MBLMarketData_QSellMBLIndex");
			if(it != pIndexMap->end()) {
				pQSellMBLIndex=new CAVLTree(maxUnit,compareForQSellMBLIndexinMBLMarketData,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pQSellMBLIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByBuyMBLData=NULL;
	pLastFoundInSearchBySellMBLData=NULL;
	pLastFoundInSearchStartByBuyMBLData=NULL;
	pLastFoundInSearchStartBySellMBLData=NULL;
	pActionTriggers=new vector<CMBLMarketDataActionTrigger *>;
	pCommitTriggers=new vector<CMBLMarketDataCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CMBLMarketDataFactory::CMBLMarketDataFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMBLMarketData),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CMBLMarketDataFactory::CMBLMarketDataFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CMBLMarketData),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CMBLMarketDataFactory::~CMBLMarketDataFactory(void)
{
	if (runLevel>=0) {
		if (pBuyMBLIndex!=NULL)
			delete pBuyMBLIndex;
	}
	if (runLevel>=0) {
		if (pSellMBLIndex!=NULL)
			delete pSellMBLIndex;
	}
	if (runLevel>=1) {
		if (pQBuyMBLIndex!=NULL)
			delete pQBuyMBLIndex;
	}
	if (runLevel>=1) {
		if (pQSellMBLIndex!=NULL)
			delete pQSellMBLIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CMBLMarketDataFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CMBLMarketDataFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pBuyMBLIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSellMBLIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pQBuyMBLIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pQSellMBLIndex->output(pLogger,indent+1);
	}
}

int CMBLMarketDataFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableMBLMarketData thisMBLMarketData;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisMBLMarketData.readCSV(input,pNames))
		add(&thisMBLMarketData);
	fclose(input);
	delete pNames;
	return 1;
}

int CMBLMarketDataFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "MBLMarketData.csv");
	return readCSV(szFileName);
}

int CMBLMarketDataFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableMBLMarketData *pMBLMarketData;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableMBLMarketData::writeCSVHead(output);
	pMBLMarketData=(CWriteableMBLMarketData *)(pMem->getFirst());
	while (pMBLMarketData!=NULL) {
		if (!pMBLMarketData->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pMBLMarketData=(CWriteableMBLMarketData *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CMBLMarketDataFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "MBLMarketData.csv");
	return writeCSV(szFileName);
}

void CMBLMarketDataFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CMBLMarketDataFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableMBLMarketData *pMBLMarketData;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CMBLMarketDataFactory={       Total Count=%d\n", pMem->getCount());
	pMBLMarketData=(CWriteableMBLMarketData *)(pMem->getFirst());
	while (pMBLMarketData!=NULL) {
		pMBLMarketData->dump(fp,index++);
		pMBLMarketData=(CWriteableMBLMarketData *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CMBLMarketDataFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pBuyMBLIndex->removeAll();
	}
	if (runLevel>=0) {
		pSellMBLIndex->removeAll();
	}
	if (runLevel>=1) {
		pQBuyMBLIndex->removeAll();
	}
	if (runLevel>=1) {
		pQSellMBLIndex->removeAll();
	}
}

CMBLMarketData *CMBLMarketDataFactory::internalAdd(CWriteableMBLMarketData *pMBLMarketData, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForMBLMarketData++;
#endif
	CMBLMarketData *pTarget;	
	beforeAdd(pMBLMarketData);
	pTarget=(CMBLMarketData *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough MBLMarketData in memory database");
		return NULL;
	}
	forceCopy(pTarget, pMBLMarketData, sizeof(CMBLMarketData));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pBuyMBLIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSellMBLIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pQBuyMBLIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pQSellMBLIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CMBLMarketData *CMBLMarketDataFactory::add(CWriteableMBLMarketData *pMBLMarketData, CTransaction *pTransaction)
{
	pMBLMarketData->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pMBLMarketData,true);
	}
	else {
		CMBLMarketData *pNewMBLMarketData;
		pNewMBLMarketData = internalAdd(pMBLMarketData,false);
		pTransaction->addResource(CMBLMarketDataResource::alloc(CREATE_ACTION,this,pNewMBLMarketData,NULL));
		return pNewMBLMarketData;
	}
}

void CMBLMarketDataFactory::internalUpdate(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pNewMBLMarketData, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForMBLMarketData++;
	}
	else {
		updateWithoutIndexActionForMBLMarketData++;
	}
#endif
	CWriteableMBLMarketData theOldMBLMarketData;
	beforeUpdate(pMBLMarketData,pNewMBLMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldMBLMarketData,pMBLMarketData,sizeof(CMBLMarketData));
	}
	if (updateIndex) {
	}

	forceCopy(pMBLMarketData,pNewMBLMarketData,sizeof(CMBLMarketData));
	pMem->updateObject(pMBLMarketData);
	if (updateIndex) {
	}
	afterUpdate(pMBLMarketData);
	if (bNoTransaction) {
		commitUpdate(pMBLMarketData,&theOldMBLMarketData);
	}
}

void CMBLMarketDataFactory::update(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pNewMBLMarketData, CTransaction *pTransaction, bool updateIndex)
{
	pNewMBLMarketData->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pMBLMarketData,pNewMBLMarketData,updateIndex,true);
	}
	else {
		pTransaction->addResource(CMBLMarketDataResource::alloc(UPDATE_ACTION,this,pMBLMarketData,pNewMBLMarketData,updateIndex));
		internalUpdate(pMBLMarketData,pNewMBLMarketData,updateIndex,false);
	}
}

void CMBLMarketDataFactory::internalRemove(CMBLMarketData *pMBLMarketData, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForMBLMarketData++;
#endif
	CWriteableMBLMarketData theOldMBLMarketData;
	beforeRemove(pMBLMarketData);
	if (bNoTransaction) {
		forceCopy(&theOldMBLMarketData,pMBLMarketData,sizeof(CMBLMarketData));
	}
	if (runLevel>=0) {
		pBuyMBLIndex->removeObject(pMBLMarketData);
	}
	if (runLevel>=0) {
		pSellMBLIndex->removeObject(pMBLMarketData);
	}
	if (runLevel>=1) {
		pQBuyMBLIndex->removeObject(pMBLMarketData);
	}
	if (runLevel>=1) {
		pQSellMBLIndex->removeObject(pMBLMarketData);
	}
	pMem->free(pMBLMarketData);
	if(bNoTransaction) {
		commitRemove(&theOldMBLMarketData);
	}
}

void CMBLMarketDataFactory::remove(CMBLMarketData *pMBLMarketData, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pMBLMarketData,true);
	}
	else {
		pTransaction->addResource(CMBLMarketDataResource::alloc(DELETE_ACTION,this,pMBLMarketData,NULL));
		internalRemove(pMBLMarketData,false);		
	}
}

CMBLMarketData* CMBLMarketDataFactory::addOrUpdate(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pNewMBLMarketData, CTransaction *pTransaction, bool updateIndex)
{
	if(pMBLMarketData == NULL) {
		return add(pNewMBLMarketData,pTransaction);
	}
	else {
		update(pMBLMarketData,pNewMBLMarketData,pTransaction,updateIndex);
		return pMBLMarketData;
	}
}

void CMBLMarketDataFactory::retrieve(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pTargetMBLMarketData)
{
	forceCopy(pTargetMBLMarketData, pMBLMarketData, sizeof(CMBLMarketData));
}
	
int CMBLMarketDataFactory::addActionTrigger(CMBLMarketDataActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CMBLMarketDataFactory::removeActionTrigger(CMBLMarketDataActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CMBLMarketDataFactory::addCommitTrigger(CMBLMarketDataCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CMBLMarketDataFactory::removeCommitTrigger(CMBLMarketDataCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CMBLMarketData *CMBLMarketDataFactory::getFirst(void)
{
	CMBLMarketData *pResult=(CMBLMarketData *)(pMem->getFirst());
	return pResult;
}
	
CMBLMarketData *CMBLMarketDataFactory::getNext(void)
{
	CMBLMarketData *pResult=(CMBLMarketData *)(pMem->getNext());
	return pResult;
}
	
void CMBLMarketDataFactory::endGet(void)
{
	pMem->endGet();
}

void CMBLMarketDataFactory::beforeAdd(CWriteableMBLMarketData *pMBLMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pMBLMarketData);
	}
}
	
void CMBLMarketDataFactory::afterAdd(CMBLMarketData *pMBLMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pMBLMarketData);
	}
}

void CMBLMarketDataFactory::beforeUpdate(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pNewMBLMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pMBLMarketData,pNewMBLMarketData);
	}
}
	
void CMBLMarketDataFactory::afterUpdate(CMBLMarketData *pMBLMarketData)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pMBLMarketData);
	}
}
	
void CMBLMarketDataFactory::beforeRemove(CMBLMarketData *pMBLMarketData)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pMBLMarketData);
	}
}

void CMBLMarketDataFactory::commitAdd(CMBLMarketData *pMBLMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForMBLMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pMBLMarketData);
	}
}

void CMBLMarketDataFactory::commitUpdate(CMBLMarketData *pMBLMarketData, CWriteableMBLMarketData *pOldMBLMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForMBLMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pMBLMarketData,pOldMBLMarketData);
	}
}
	
void CMBLMarketDataFactory::commitRemove(CWriteableMBLMarketData *pMBLMarketData)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForMBLMarketData++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pMBLMarketData);
	}
}

void CMBLMarketDataFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForTradeIDIndexinTrade(const void *pV1, const void *pV2);
extern int compareForPartIDIndexinTrade(const void *pV1, const void *pV2);
extern int compareForClientIDIndexinTrade(const void *pV1, const void *pV2);
extern int compareForInstrumentIDIndexinTrade(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForTrade=0;
int updateWithIndexActionForTrade=0;
int updateWithoutIndexActionForTrade=0;
int removeActionForTrade=0;
int addCommitForTrade=0;
int updateCommitForTrade=0;
int removeCommitForTrade=0;
#endif
void CTradeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=1) {
		if(!reuse) {
			pTradeIDIndex=new CAVLTree(maxUnit,compareForTradeIDIndexinTrade,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Trade_TradeIDIndex",pTradeIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Trade_TradeIDIndex");
			if(it != pIndexMap->end()) {
				pTradeIDIndex=new CAVLTree(maxUnit,compareForTradeIDIndexinTrade,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pTradeIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pPartIDIndex=new CAVLTree(maxUnit,compareForPartIDIndexinTrade,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Trade_PartIDIndex",pPartIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Trade_PartIDIndex");
			if(it != pIndexMap->end()) {
				pPartIDIndex=new CAVLTree(maxUnit,compareForPartIDIndexinTrade,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pPartIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pClientIDIndex=new CAVLTree(maxUnit,compareForClientIDIndexinTrade,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Trade_ClientIDIndex",pClientIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Trade_ClientIDIndex");
			if(it != pIndexMap->end()) {
				pClientIDIndex=new CAVLTree(maxUnit,compareForClientIDIndexinTrade,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=1) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinTrade,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("Trade_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("Trade_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinTrade,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchAll=NULL;
	pLastFoundInSearchByTradeID=NULL;
	pLastFoundInSearchStartByPartID=NULL;
	pLastFoundInSearchByClientID=NULL;
	pLastFoundInSearchStartByInstrumentID=NULL;
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CTradeActionTrigger *>;
	pCommitTriggers=new vector<CTradeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CTradeFactory::CTradeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTrade),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CTradeFactory::CTradeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CTrade),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CTradeFactory::~CTradeFactory(void)
{
	if (runLevel>=1) {
		if (pTradeIDIndex!=NULL)
			delete pTradeIDIndex;
	}
	if (runLevel>=1) {
		if (pPartIDIndex!=NULL)
			delete pPartIDIndex;
	}
	if (runLevel>=1) {
		if (pClientIDIndex!=NULL)
			delete pClientIDIndex;
	}
	if (runLevel>=1) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CTradeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CTradeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=1) {
		pTradeIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pPartIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pClientIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CTradeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableTrade thisTrade;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisTrade.readCSV(input,pNames))
		add(&thisTrade);
	fclose(input);
	delete pNames;
	return 1;
}

int CTradeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "Trade.csv");
	return readCSV(szFileName);
}

int CTradeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableTrade *pTrade;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableTrade::writeCSVHead(output);
	pTrade=(CWriteableTrade *)(pMem->getFirst());
	while (pTrade!=NULL) {
		if (!pTrade->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pTrade=(CWriteableTrade *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CTradeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "Trade.csv");
	return writeCSV(szFileName);
}

void CTradeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CTradeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableTrade *pTrade;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CTradeFactory={       Total Count=%d\n", pMem->getCount());
	pTrade=(CWriteableTrade *)(pMem->getFirst());
	while (pTrade!=NULL) {
		pTrade->dump(fp,index++);
		pTrade=(CWriteableTrade *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CTradeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=1) {
		pTradeIDIndex->removeAll();
	}
	if (runLevel>=1) {
		pPartIDIndex->removeAll();
	}
	if (runLevel>=1) {
		pClientIDIndex->removeAll();
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->removeAll();
	}
}

CTrade *CTradeFactory::internalAdd(CWriteableTrade *pTrade, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForTrade++;
#endif
	CTrade *pTarget;	
	beforeAdd(pTrade);
	pTarget=(CTrade *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough Trade in memory database");
		return NULL;
	}
	forceCopy(pTarget, pTrade, sizeof(CTrade));
	pMem->updateObject(pTarget);
	if (runLevel>=1) {
		pTradeIDIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pPartIDIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pClientIDIndex->addObject(pTarget);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CTrade *CTradeFactory::add(CWriteableTrade *pTrade, CTransaction *pTransaction)
{
	pTrade->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pTrade,true);
	}
	else {
		CTrade *pNewTrade;
		pNewTrade = internalAdd(pTrade,false);
		pTransaction->addResource(CTradeResource::alloc(CREATE_ACTION,this,pNewTrade,NULL));
		return pNewTrade;
	}
}

void CTradeFactory::internalUpdate(CTrade *pTrade, CWriteableTrade *pNewTrade, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForTrade++;
	}
	else {
		updateWithoutIndexActionForTrade++;
	}
#endif
	CWriteableTrade theOldTrade;
	beforeUpdate(pTrade,pNewTrade);
	if (bNoTransaction) {
		forceCopy(&theOldTrade,pTrade,sizeof(CTrade));
	}
	if (updateIndex) {
	}

	forceCopy(pTrade,pNewTrade,sizeof(CTrade));
	pMem->updateObject(pTrade);
	if (updateIndex) {
	}
	afterUpdate(pTrade);
	if (bNoTransaction) {
		commitUpdate(pTrade,&theOldTrade);
	}
}

void CTradeFactory::update(CTrade *pTrade, CWriteableTrade *pNewTrade, CTransaction *pTransaction, bool updateIndex)
{
	pNewTrade->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pTrade,pNewTrade,updateIndex,true);
	}
	else {
		pTransaction->addResource(CTradeResource::alloc(UPDATE_ACTION,this,pTrade,pNewTrade,updateIndex));
		internalUpdate(pTrade,pNewTrade,updateIndex,false);
	}
}

void CTradeFactory::internalRemove(CTrade *pTrade, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForTrade++;
#endif
	CWriteableTrade theOldTrade;
	beforeRemove(pTrade);
	if (bNoTransaction) {
		forceCopy(&theOldTrade,pTrade,sizeof(CTrade));
	}
	if (runLevel>=1) {
		pTradeIDIndex->removeObject(pTrade);
	}
	if (runLevel>=1) {
		pPartIDIndex->removeObject(pTrade);
	}
	if (runLevel>=1) {
		pClientIDIndex->removeObject(pTrade);
	}
	if (runLevel>=1) {
		pInstrumentIDIndex->removeObject(pTrade);
	}
	pMem->free(pTrade);
	if(bNoTransaction) {
		commitRemove(&theOldTrade);
	}
}

void CTradeFactory::remove(CTrade *pTrade, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pTrade,true);
	}
	else {
		pTransaction->addResource(CTradeResource::alloc(DELETE_ACTION,this,pTrade,NULL));
		internalRemove(pTrade,false);		
	}
}

CTrade* CTradeFactory::addOrUpdate(CTrade *pTrade, CWriteableTrade *pNewTrade, CTransaction *pTransaction, bool updateIndex)
{
	if(pTrade == NULL) {
		return add(pNewTrade,pTransaction);
	}
	else {
		update(pTrade,pNewTrade,pTransaction,updateIndex);
		return pTrade;
	}
}

void CTradeFactory::retrieve(CTrade *pTrade, CWriteableTrade *pTargetTrade)
{
	forceCopy(pTargetTrade, pTrade, sizeof(CTrade));
}
	
int CTradeFactory::addActionTrigger(CTradeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CTradeFactory::removeActionTrigger(CTradeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CTradeFactory::addCommitTrigger(CTradeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CTradeFactory::removeCommitTrigger(CTradeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CTrade *CTradeFactory::getFirst(void)
{
	CTrade *pResult=(CTrade *)(pMem->getFirst());
	return pResult;
}
	
CTrade *CTradeFactory::getNext(void)
{
	CTrade *pResult=(CTrade *)(pMem->getNext());
	return pResult;
}
	
void CTradeFactory::endGet(void)
{
	pMem->endGet();
}

void CTradeFactory::beforeAdd(CWriteableTrade *pTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pTrade);
	}
}
	
void CTradeFactory::afterAdd(CTrade *pTrade)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pTrade);
	}
}

void CTradeFactory::beforeUpdate(CTrade *pTrade, CWriteableTrade *pNewTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pTrade,pNewTrade);
	}
}
	
void CTradeFactory::afterUpdate(CTrade *pTrade)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pTrade);
	}
}
	
void CTradeFactory::beforeRemove(CTrade *pTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pTrade);
	}
}

void CTradeFactory::commitAdd(CTrade *pTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pTrade);
	}
}

void CTradeFactory::commitUpdate(CTrade *pTrade, CWriteableTrade *pOldTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pTrade,pOldTrade);
	}
}
	
void CTradeFactory::commitRemove(CWriteableTrade *pTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pTrade);
	}
}

void CTradeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CTradeFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CTrade *pTrade;
	pTrade=getFirst();
	while (pTrade != NULL) {
		pTrade->linkInstrument(pFactory);
		pTrade=getNext();
	}
	endGet();
}

void CTradeFactory::linkAllPartClient(CPartClientFactory *pFactory)
{
	CTrade *pTrade;
	pTrade=getFirst();
	while (pTrade != NULL) {
		pTrade->linkPartClient(pFactory);
		pTrade=getNext();
	}
	endGet();
}

extern int compareForInstrumentIDIndexinFusePhase(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForFusePhase=0;
int updateWithIndexActionForFusePhase=0;
int updateWithoutIndexActionForFusePhase=0;
int removeActionForFusePhase=0;
int addCommitForFusePhase=0;
int updateCommitForFusePhase=0;
int removeCommitForFusePhase=0;
#endif
void CFusePhaseFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinFusePhase,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("FusePhase_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("FusePhase_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinFusePhase,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CFusePhaseActionTrigger *>;
	pCommitTriggers=new vector<CFusePhaseCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CFusePhaseFactory::CFusePhaseFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CFusePhase),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CFusePhaseFactory::CFusePhaseFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CFusePhase),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CFusePhaseFactory::~CFusePhaseFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CFusePhaseFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CFusePhaseFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CFusePhaseFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableFusePhase thisFusePhase;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisFusePhase.readCSV(input,pNames))
		add(&thisFusePhase);
	fclose(input);
	delete pNames;
	return 1;
}

int CFusePhaseFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "FusePhase.csv");
	return readCSV(szFileName);
}

int CFusePhaseFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableFusePhase *pFusePhase;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableFusePhase::writeCSVHead(output);
	pFusePhase=(CWriteableFusePhase *)(pMem->getFirst());
	while (pFusePhase!=NULL) {
		if (!pFusePhase->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pFusePhase=(CWriteableFusePhase *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CFusePhaseFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "FusePhase.csv");
	return writeCSV(szFileName);
}

void CFusePhaseFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CFusePhaseFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableFusePhase *pFusePhase;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CFusePhaseFactory={       Total Count=%d\n", pMem->getCount());
	pFusePhase=(CWriteableFusePhase *)(pMem->getFirst());
	while (pFusePhase!=NULL) {
		pFusePhase->dump(fp,index++);
		pFusePhase=(CWriteableFusePhase *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CFusePhaseFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CFusePhase *CFusePhaseFactory::internalAdd(CWriteableFusePhase *pFusePhase, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForFusePhase++;
#endif
	CFusePhase *pTarget;	
	beforeAdd(pFusePhase);
	pTarget=(CFusePhase *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough FusePhase in memory database");
		return NULL;
	}
	forceCopy(pTarget, pFusePhase, sizeof(CFusePhase));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CFusePhase *CFusePhaseFactory::add(CWriteableFusePhase *pFusePhase, CTransaction *pTransaction)
{
	pFusePhase->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pFusePhase,true);
	}
	else {
		CFusePhase *pNewFusePhase;
		pNewFusePhase = internalAdd(pFusePhase,false);
		pTransaction->addResource(CFusePhaseResource::alloc(CREATE_ACTION,this,pNewFusePhase,NULL));
		return pNewFusePhase;
	}
}

void CFusePhaseFactory::internalUpdate(CFusePhase *pFusePhase, CWriteableFusePhase *pNewFusePhase, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForFusePhase++;
	}
	else {
		updateWithoutIndexActionForFusePhase++;
	}
#endif
	CWriteableFusePhase theOldFusePhase;
	beforeUpdate(pFusePhase,pNewFusePhase);
	if (bNoTransaction) {
		forceCopy(&theOldFusePhase,pFusePhase,sizeof(CFusePhase));
	}
	if (updateIndex) {
	}

	forceCopy(pFusePhase,pNewFusePhase,sizeof(CFusePhase));
	pMem->updateObject(pFusePhase);
	if (updateIndex) {
	}
	afterUpdate(pFusePhase);
	if (bNoTransaction) {
		commitUpdate(pFusePhase,&theOldFusePhase);
	}
}

void CFusePhaseFactory::update(CFusePhase *pFusePhase, CWriteableFusePhase *pNewFusePhase, CTransaction *pTransaction, bool updateIndex)
{
	pNewFusePhase->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pFusePhase,pNewFusePhase,updateIndex,true);
	}
	else {
		pTransaction->addResource(CFusePhaseResource::alloc(UPDATE_ACTION,this,pFusePhase,pNewFusePhase,updateIndex));
		internalUpdate(pFusePhase,pNewFusePhase,updateIndex,false);
	}
}

void CFusePhaseFactory::internalRemove(CFusePhase *pFusePhase, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForFusePhase++;
#endif
	CWriteableFusePhase theOldFusePhase;
	beforeRemove(pFusePhase);
	if (bNoTransaction) {
		forceCopy(&theOldFusePhase,pFusePhase,sizeof(CFusePhase));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pFusePhase);
	}
	pMem->free(pFusePhase);
	if(bNoTransaction) {
		commitRemove(&theOldFusePhase);
	}
}

void CFusePhaseFactory::remove(CFusePhase *pFusePhase, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pFusePhase,true);
	}
	else {
		pTransaction->addResource(CFusePhaseResource::alloc(DELETE_ACTION,this,pFusePhase,NULL));
		internalRemove(pFusePhase,false);		
	}
}

CFusePhase* CFusePhaseFactory::addOrUpdate(CFusePhase *pFusePhase, CWriteableFusePhase *pNewFusePhase, CTransaction *pTransaction, bool updateIndex)
{
	if(pFusePhase == NULL) {
		return add(pNewFusePhase,pTransaction);
	}
	else {
		update(pFusePhase,pNewFusePhase,pTransaction,updateIndex);
		return pFusePhase;
	}
}

void CFusePhaseFactory::retrieve(CFusePhase *pFusePhase, CWriteableFusePhase *pTargetFusePhase)
{
	forceCopy(pTargetFusePhase, pFusePhase, sizeof(CFusePhase));
}
	
int CFusePhaseFactory::addActionTrigger(CFusePhaseActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CFusePhaseFactory::removeActionTrigger(CFusePhaseActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CFusePhaseFactory::addCommitTrigger(CFusePhaseCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CFusePhaseFactory::removeCommitTrigger(CFusePhaseCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CFusePhase *CFusePhaseFactory::getFirst(void)
{
	CFusePhase *pResult=(CFusePhase *)(pMem->getFirst());
	return pResult;
}
	
CFusePhase *CFusePhaseFactory::getNext(void)
{
	CFusePhase *pResult=(CFusePhase *)(pMem->getNext());
	return pResult;
}
	
void CFusePhaseFactory::endGet(void)
{
	pMem->endGet();
}

void CFusePhaseFactory::beforeAdd(CWriteableFusePhase *pFusePhase)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pFusePhase);
	}
}
	
void CFusePhaseFactory::afterAdd(CFusePhase *pFusePhase)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pFusePhase);
	}
}

void CFusePhaseFactory::beforeUpdate(CFusePhase *pFusePhase, CWriteableFusePhase *pNewFusePhase)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pFusePhase,pNewFusePhase);
	}
}
	
void CFusePhaseFactory::afterUpdate(CFusePhase *pFusePhase)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pFusePhase);
	}
}
	
void CFusePhaseFactory::beforeRemove(CFusePhase *pFusePhase)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pFusePhase);
	}
}

void CFusePhaseFactory::commitAdd(CFusePhase *pFusePhase)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForFusePhase++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pFusePhase);
	}
}

void CFusePhaseFactory::commitUpdate(CFusePhase *pFusePhase, CWriteableFusePhase *pOldFusePhase)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForFusePhase++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pFusePhase,pOldFusePhase);
	}
}
	
void CFusePhaseFactory::commitRemove(CWriteableFusePhase *pFusePhase)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForFusePhase++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pFusePhase);
	}
}

void CFusePhaseFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CFusePhaseFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CFusePhase *pFusePhase;
	pFusePhase=getFirst();
	while (pFusePhase != NULL) {
		pFusePhase->linkInstrument(pFactory);
		pFusePhase=getNext();
	}
	endGet();
}

extern int compareForExecOrderIDIndexinExecOrder(const void *pV1, const void *pV2);
extern int compareForParticipantIDIndexinExecOrder(const void *pV1, const void *pV2);
extern int compareForClientAndInstrumentIndexinExecOrder(const void *pV1, const void *pV2);
extern int compareForExecOrderLocalIDIndexinExecOrder(const void *pV1, const void *pV2);
extern int compareForInstrumentIDIndexinExecOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForExecOrder=0;
int updateWithIndexActionForExecOrder=0;
int updateWithoutIndexActionForExecOrder=0;
int removeActionForExecOrder=0;
int addCommitForExecOrder=0;
int updateCommitForExecOrder=0;
int removeCommitForExecOrder=0;
#endif
void CExecOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pExecOrderIDIndex=new CAVLTree(maxUnit,compareForExecOrderIDIndexinExecOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExecOrder_ExecOrderIDIndex",pExecOrderIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExecOrder_ExecOrderIDIndex");
			if(it != pIndexMap->end()) {
				pExecOrderIDIndex=new CAVLTree(maxUnit,compareForExecOrderIDIndexinExecOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pExecOrderIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinExecOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExecOrder_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExecOrder_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinExecOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForClientAndInstrumentIndexinExecOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExecOrder_ClientAndInstrumentIndex",pClientAndInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExecOrder_ClientAndInstrumentIndex");
			if(it != pIndexMap->end()) {
				pClientAndInstrumentIndex=new CAVLTree(maxUnit,compareForClientAndInstrumentIndexinExecOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pClientAndInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pExecOrderLocalIDIndex=new CAVLTree(maxUnit,compareForExecOrderLocalIDIndexinExecOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExecOrder_ExecOrderLocalIDIndex",pExecOrderLocalIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExecOrder_ExecOrderLocalIDIndex");
			if(it != pIndexMap->end()) {
				pExecOrderLocalIDIndex=new CAVLTree(maxUnit,compareForExecOrderLocalIDIndexinExecOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pExecOrderLocalIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinExecOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("ExecOrder_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("ExecOrder_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinExecOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchByParticipantID=NULL;
	pLastFoundInSearchByClientID=NULL;
	pLastFoundInSearchByClientIDAndInstrumentID=NULL;
	pLastFoundInSearchByUserID=NULL;
	pActionTriggers=new vector<CExecOrderActionTrigger *>;
	pCommitTriggers=new vector<CExecOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CExecOrderFactory::CExecOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExecOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CExecOrderFactory::CExecOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CExecOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CExecOrderFactory::~CExecOrderFactory(void)
{
	if (runLevel>=0) {
		if (pExecOrderIDIndex!=NULL)
			delete pExecOrderIDIndex;
	}
	if (runLevel>=0) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (runLevel>=0) {
		if (pClientAndInstrumentIndex!=NULL)
			delete pClientAndInstrumentIndex;
	}
	if (runLevel>=0) {
		if (pExecOrderLocalIDIndex!=NULL)
			delete pExecOrderLocalIDIndex;
	}
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CExecOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CExecOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pExecOrderIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pClientAndInstrumentIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pExecOrderLocalIDIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CExecOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableExecOrder thisExecOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisExecOrder.readCSV(input,pNames))
		add(&thisExecOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CExecOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "ExecOrder.csv");
	return readCSV(szFileName);
}

int CExecOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableExecOrder *pExecOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableExecOrder::writeCSVHead(output);
	pExecOrder=(CWriteableExecOrder *)(pMem->getFirst());
	while (pExecOrder!=NULL) {
		if (!pExecOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pExecOrder=(CWriteableExecOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CExecOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "ExecOrder.csv");
	return writeCSV(szFileName);
}

void CExecOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CExecOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableExecOrder *pExecOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CExecOrderFactory={       Total Count=%d\n", pMem->getCount());
	pExecOrder=(CWriteableExecOrder *)(pMem->getFirst());
	while (pExecOrder!=NULL) {
		pExecOrder->dump(fp,index++);
		pExecOrder=(CWriteableExecOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CExecOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pExecOrderIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pParticipantIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pClientAndInstrumentIndex->removeAll();
	}
	if (runLevel>=0) {
		pExecOrderLocalIDIndex->removeAll();
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CExecOrder *CExecOrderFactory::internalAdd(CWriteableExecOrder *pExecOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForExecOrder++;
#endif
	CExecOrder *pTarget;	
	beforeAdd(pExecOrder);
	pTarget=(CExecOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough ExecOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pExecOrder, sizeof(CExecOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pExecOrderIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pParticipantIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pClientAndInstrumentIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pExecOrderLocalIDIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CExecOrder *CExecOrderFactory::add(CWriteableExecOrder *pExecOrder, CTransaction *pTransaction)
{
	pExecOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pExecOrder,true);
	}
	else {
		CExecOrder *pNewExecOrder;
		pNewExecOrder = internalAdd(pExecOrder,false);
		pTransaction->addResource(CExecOrderResource::alloc(CREATE_ACTION,this,pNewExecOrder,NULL));
		return pNewExecOrder;
	}
}

void CExecOrderFactory::internalUpdate(CExecOrder *pExecOrder, CWriteableExecOrder *pNewExecOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForExecOrder++;
	}
	else {
		updateWithoutIndexActionForExecOrder++;
	}
#endif
	CWriteableExecOrder theOldExecOrder;
	beforeUpdate(pExecOrder,pNewExecOrder);
	if (bNoTransaction) {
		forceCopy(&theOldExecOrder,pExecOrder,sizeof(CExecOrder));
	}
	CAVLNode *pInstrumentIDIndexNode=NULL;
	if (updateIndex) {
		if (runLevel>=0) {
			pInstrumentIDIndexNode=pInstrumentIDIndex->findObject(pExecOrder);
		}
	}

	forceCopy(pExecOrder,pNewExecOrder,sizeof(CExecOrder));
	pMem->updateObject(pExecOrder);
	if (updateIndex) {
		if (runLevel>=0) {
			pInstrumentIDIndex->updateNode(pInstrumentIDIndexNode);
		}
	}
	afterUpdate(pExecOrder);
	if (bNoTransaction) {
		commitUpdate(pExecOrder,&theOldExecOrder);
	}
}

void CExecOrderFactory::update(CExecOrder *pExecOrder, CWriteableExecOrder *pNewExecOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewExecOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pExecOrder,pNewExecOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CExecOrderResource::alloc(UPDATE_ACTION,this,pExecOrder,pNewExecOrder,updateIndex));
		internalUpdate(pExecOrder,pNewExecOrder,updateIndex,false);
	}
}

void CExecOrderFactory::internalRemove(CExecOrder *pExecOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForExecOrder++;
#endif
	CWriteableExecOrder theOldExecOrder;
	beforeRemove(pExecOrder);
	if (bNoTransaction) {
		forceCopy(&theOldExecOrder,pExecOrder,sizeof(CExecOrder));
	}
	if (runLevel>=0) {
		pExecOrderIDIndex->removeObject(pExecOrder);
	}
	if (runLevel>=0) {
		pParticipantIDIndex->removeObject(pExecOrder);
	}
	if (runLevel>=0) {
		pClientAndInstrumentIndex->removeObject(pExecOrder);
	}
	if (runLevel>=0) {
		pExecOrderLocalIDIndex->removeObject(pExecOrder);
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pExecOrder);
	}
	pMem->free(pExecOrder);
	if(bNoTransaction) {
		commitRemove(&theOldExecOrder);
	}
}

void CExecOrderFactory::remove(CExecOrder *pExecOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pExecOrder,true);
	}
	else {
		pTransaction->addResource(CExecOrderResource::alloc(DELETE_ACTION,this,pExecOrder,NULL));
		internalRemove(pExecOrder,false);		
	}
}

CExecOrder* CExecOrderFactory::addOrUpdate(CExecOrder *pExecOrder, CWriteableExecOrder *pNewExecOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pExecOrder == NULL) {
		return add(pNewExecOrder,pTransaction);
	}
	else {
		update(pExecOrder,pNewExecOrder,pTransaction,updateIndex);
		return pExecOrder;
	}
}

void CExecOrderFactory::retrieve(CExecOrder *pExecOrder, CWriteableExecOrder *pTargetExecOrder)
{
	forceCopy(pTargetExecOrder, pExecOrder, sizeof(CExecOrder));
}
	
int CExecOrderFactory::addActionTrigger(CExecOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CExecOrderFactory::removeActionTrigger(CExecOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CExecOrderFactory::addCommitTrigger(CExecOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CExecOrderFactory::removeCommitTrigger(CExecOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CExecOrder *CExecOrderFactory::getFirst(void)
{
	CExecOrder *pResult=(CExecOrder *)(pMem->getFirst());
	return pResult;
}
	
CExecOrder *CExecOrderFactory::getNext(void)
{
	CExecOrder *pResult=(CExecOrder *)(pMem->getNext());
	return pResult;
}
	
void CExecOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CExecOrderFactory::beforeAdd(CWriteableExecOrder *pExecOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pExecOrder);
	}
}
	
void CExecOrderFactory::afterAdd(CExecOrder *pExecOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pExecOrder);
	}
}

void CExecOrderFactory::beforeUpdate(CExecOrder *pExecOrder, CWriteableExecOrder *pNewExecOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pExecOrder,pNewExecOrder);
	}
}
	
void CExecOrderFactory::afterUpdate(CExecOrder *pExecOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pExecOrder);
	}
}
	
void CExecOrderFactory::beforeRemove(CExecOrder *pExecOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pExecOrder);
	}
}

void CExecOrderFactory::commitAdd(CExecOrder *pExecOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForExecOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pExecOrder);
	}
}

void CExecOrderFactory::commitUpdate(CExecOrder *pExecOrder, CWriteableExecOrder *pOldExecOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForExecOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pExecOrder,pOldExecOrder);
	}
}
	
void CExecOrderFactory::commitRemove(CWriteableExecOrder *pExecOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForExecOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pExecOrder);
	}
}

void CExecOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

void CExecOrderFactory::linkAllPartClient(CPartClientFactory *pFactory)
{
	CExecOrder *pExecOrder;
	pExecOrder=getFirst();
	while (pExecOrder != NULL) {
		pExecOrder->linkPartClient(pFactory);
		pExecOrder=getNext();
	}
	endGet();
}

void CExecOrderFactory::linkAllInstrument(CInstrumentFactory *pFactory)
{
	CExecOrder *pExecOrder;
	pExecOrder=getFirst();
	while (pExecOrder != NULL) {
		pExecOrder->linkInstrument(pFactory);
		pExecOrder=getNext();
	}
	endGet();
}

extern int compareForInstrumentIDIndexinUniPressure(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForUniPressure=0;
int updateWithIndexActionForUniPressure=0;
int updateWithoutIndexActionForUniPressure=0;
int removeActionForUniPressure=0;
int addCommitForUniPressure=0;
int updateCommitForUniPressure=0;
int removeCommitForUniPressure=0;
#endif
void CUniPressureFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinUniPressure,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("UniPressure_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("UniPressure_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinUniPressure,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CUniPressureActionTrigger *>;
	pCommitTriggers=new vector<CUniPressureCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CUniPressureFactory::CUniPressureFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUniPressure),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CUniPressureFactory::CUniPressureFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CUniPressure),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CUniPressureFactory::~CUniPressureFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CUniPressureFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CUniPressureFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CUniPressureFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableUniPressure thisUniPressure;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisUniPressure.readCSV(input,pNames))
		add(&thisUniPressure);
	fclose(input);
	delete pNames;
	return 1;
}

int CUniPressureFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "UniPressure.csv");
	return readCSV(szFileName);
}

int CUniPressureFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableUniPressure *pUniPressure;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableUniPressure::writeCSVHead(output);
	pUniPressure=(CWriteableUniPressure *)(pMem->getFirst());
	while (pUniPressure!=NULL) {
		if (!pUniPressure->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pUniPressure=(CWriteableUniPressure *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CUniPressureFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "UniPressure.csv");
	return writeCSV(szFileName);
}

void CUniPressureFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CUniPressureFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableUniPressure *pUniPressure;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CUniPressureFactory={       Total Count=%d\n", pMem->getCount());
	pUniPressure=(CWriteableUniPressure *)(pMem->getFirst());
	while (pUniPressure!=NULL) {
		pUniPressure->dump(fp,index++);
		pUniPressure=(CWriteableUniPressure *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CUniPressureFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CUniPressure *CUniPressureFactory::internalAdd(CWriteableUniPressure *pUniPressure, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForUniPressure++;
#endif
	CUniPressure *pTarget;	
	beforeAdd(pUniPressure);
	pTarget=(CUniPressure *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough UniPressure in memory database");
		return NULL;
	}
	forceCopy(pTarget, pUniPressure, sizeof(CUniPressure));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CUniPressure *CUniPressureFactory::add(CWriteableUniPressure *pUniPressure, CTransaction *pTransaction)
{
	pUniPressure->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pUniPressure,true);
	}
	else {
		CUniPressure *pNewUniPressure;
		pNewUniPressure = internalAdd(pUniPressure,false);
		pTransaction->addResource(CUniPressureResource::alloc(CREATE_ACTION,this,pNewUniPressure,NULL));
		return pNewUniPressure;
	}
}

void CUniPressureFactory::internalUpdate(CUniPressure *pUniPressure, CWriteableUniPressure *pNewUniPressure, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForUniPressure++;
	}
	else {
		updateWithoutIndexActionForUniPressure++;
	}
#endif
	CWriteableUniPressure theOldUniPressure;
	beforeUpdate(pUniPressure,pNewUniPressure);
	if (bNoTransaction) {
		forceCopy(&theOldUniPressure,pUniPressure,sizeof(CUniPressure));
	}
	if (updateIndex) {
	}

	forceCopy(pUniPressure,pNewUniPressure,sizeof(CUniPressure));
	pMem->updateObject(pUniPressure);
	if (updateIndex) {
	}
	afterUpdate(pUniPressure);
	if (bNoTransaction) {
		commitUpdate(pUniPressure,&theOldUniPressure);
	}
}

void CUniPressureFactory::update(CUniPressure *pUniPressure, CWriteableUniPressure *pNewUniPressure, CTransaction *pTransaction, bool updateIndex)
{
	pNewUniPressure->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pUniPressure,pNewUniPressure,updateIndex,true);
	}
	else {
		pTransaction->addResource(CUniPressureResource::alloc(UPDATE_ACTION,this,pUniPressure,pNewUniPressure,updateIndex));
		internalUpdate(pUniPressure,pNewUniPressure,updateIndex,false);
	}
}

void CUniPressureFactory::internalRemove(CUniPressure *pUniPressure, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForUniPressure++;
#endif
	CWriteableUniPressure theOldUniPressure;
	beforeRemove(pUniPressure);
	if (bNoTransaction) {
		forceCopy(&theOldUniPressure,pUniPressure,sizeof(CUniPressure));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pUniPressure);
	}
	pMem->free(pUniPressure);
	if(bNoTransaction) {
		commitRemove(&theOldUniPressure);
	}
}

void CUniPressureFactory::remove(CUniPressure *pUniPressure, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pUniPressure,true);
	}
	else {
		pTransaction->addResource(CUniPressureResource::alloc(DELETE_ACTION,this,pUniPressure,NULL));
		internalRemove(pUniPressure,false);		
	}
}

CUniPressure* CUniPressureFactory::addOrUpdate(CUniPressure *pUniPressure, CWriteableUniPressure *pNewUniPressure, CTransaction *pTransaction, bool updateIndex)
{
	if(pUniPressure == NULL) {
		return add(pNewUniPressure,pTransaction);
	}
	else {
		update(pUniPressure,pNewUniPressure,pTransaction,updateIndex);
		return pUniPressure;
	}
}

void CUniPressureFactory::retrieve(CUniPressure *pUniPressure, CWriteableUniPressure *pTargetUniPressure)
{
	forceCopy(pTargetUniPressure, pUniPressure, sizeof(CUniPressure));
}
	
int CUniPressureFactory::addActionTrigger(CUniPressureActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CUniPressureFactory::removeActionTrigger(CUniPressureActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CUniPressureFactory::addCommitTrigger(CUniPressureCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CUniPressureFactory::removeCommitTrigger(CUniPressureCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CUniPressure *CUniPressureFactory::getFirst(void)
{
	CUniPressure *pResult=(CUniPressure *)(pMem->getFirst());
	return pResult;
}
	
CUniPressure *CUniPressureFactory::getNext(void)
{
	CUniPressure *pResult=(CUniPressure *)(pMem->getNext());
	return pResult;
}
	
void CUniPressureFactory::endGet(void)
{
	pMem->endGet();
}

void CUniPressureFactory::beforeAdd(CWriteableUniPressure *pUniPressure)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pUniPressure);
	}
}
	
void CUniPressureFactory::afterAdd(CUniPressure *pUniPressure)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pUniPressure);
	}
}

void CUniPressureFactory::beforeUpdate(CUniPressure *pUniPressure, CWriteableUniPressure *pNewUniPressure)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pUniPressure,pNewUniPressure);
	}
}
	
void CUniPressureFactory::afterUpdate(CUniPressure *pUniPressure)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pUniPressure);
	}
}
	
void CUniPressureFactory::beforeRemove(CUniPressure *pUniPressure)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pUniPressure);
	}
}

void CUniPressureFactory::commitAdd(CUniPressure *pUniPressure)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForUniPressure++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pUniPressure);
	}
}

void CUniPressureFactory::commitUpdate(CUniPressure *pUniPressure, CWriteableUniPressure *pOldUniPressure)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForUniPressure++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pUniPressure,pOldUniPressure);
	}
}
	
void CUniPressureFactory::commitRemove(CWriteableUniPressure *pUniPressure)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForUniPressure++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pUniPressure);
	}
}

void CUniPressureFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinBasePriceLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForBasePriceLimit=0;
int updateWithIndexActionForBasePriceLimit=0;
int updateWithoutIndexActionForBasePriceLimit=0;
int removeActionForBasePriceLimit=0;
int addCommitForBasePriceLimit=0;
int updateCommitForBasePriceLimit=0;
int removeCommitForBasePriceLimit=0;
#endif
void CBasePriceLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinBasePriceLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("BasePriceLimit_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("BasePriceLimit_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinBasePriceLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CBasePriceLimitActionTrigger *>;
	pCommitTriggers=new vector<CBasePriceLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CBasePriceLimitFactory::CBasePriceLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBasePriceLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CBasePriceLimitFactory::CBasePriceLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CBasePriceLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CBasePriceLimitFactory::~CBasePriceLimitFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CBasePriceLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CBasePriceLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CBasePriceLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableBasePriceLimit thisBasePriceLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisBasePriceLimit.readCSV(input,pNames))
		add(&thisBasePriceLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CBasePriceLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "BasePriceLimit.csv");
	return readCSV(szFileName);
}

int CBasePriceLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableBasePriceLimit *pBasePriceLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableBasePriceLimit::writeCSVHead(output);
	pBasePriceLimit=(CWriteableBasePriceLimit *)(pMem->getFirst());
	while (pBasePriceLimit!=NULL) {
		if (!pBasePriceLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pBasePriceLimit=(CWriteableBasePriceLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CBasePriceLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "BasePriceLimit.csv");
	return writeCSV(szFileName);
}

void CBasePriceLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CBasePriceLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableBasePriceLimit *pBasePriceLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CBasePriceLimitFactory={       Total Count=%d\n", pMem->getCount());
	pBasePriceLimit=(CWriteableBasePriceLimit *)(pMem->getFirst());
	while (pBasePriceLimit!=NULL) {
		pBasePriceLimit->dump(fp,index++);
		pBasePriceLimit=(CWriteableBasePriceLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CBasePriceLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CBasePriceLimit *CBasePriceLimitFactory::internalAdd(CWriteableBasePriceLimit *pBasePriceLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForBasePriceLimit++;
#endif
	CBasePriceLimit *pTarget;	
	beforeAdd(pBasePriceLimit);
	pTarget=(CBasePriceLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough BasePriceLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pBasePriceLimit, sizeof(CBasePriceLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CBasePriceLimit *CBasePriceLimitFactory::add(CWriteableBasePriceLimit *pBasePriceLimit, CTransaction *pTransaction)
{
	pBasePriceLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pBasePriceLimit,true);
	}
	else {
		CBasePriceLimit *pNewBasePriceLimit;
		pNewBasePriceLimit = internalAdd(pBasePriceLimit,false);
		pTransaction->addResource(CBasePriceLimitResource::alloc(CREATE_ACTION,this,pNewBasePriceLimit,NULL));
		return pNewBasePriceLimit;
	}
}

void CBasePriceLimitFactory::internalUpdate(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pNewBasePriceLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForBasePriceLimit++;
	}
	else {
		updateWithoutIndexActionForBasePriceLimit++;
	}
#endif
	CWriteableBasePriceLimit theOldBasePriceLimit;
	beforeUpdate(pBasePriceLimit,pNewBasePriceLimit);
	if (bNoTransaction) {
		forceCopy(&theOldBasePriceLimit,pBasePriceLimit,sizeof(CBasePriceLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pBasePriceLimit,pNewBasePriceLimit,sizeof(CBasePriceLimit));
	pMem->updateObject(pBasePriceLimit);
	if (updateIndex) {
	}
	afterUpdate(pBasePriceLimit);
	if (bNoTransaction) {
		commitUpdate(pBasePriceLimit,&theOldBasePriceLimit);
	}
}

void CBasePriceLimitFactory::update(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pNewBasePriceLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewBasePriceLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pBasePriceLimit,pNewBasePriceLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CBasePriceLimitResource::alloc(UPDATE_ACTION,this,pBasePriceLimit,pNewBasePriceLimit,updateIndex));
		internalUpdate(pBasePriceLimit,pNewBasePriceLimit,updateIndex,false);
	}
}

void CBasePriceLimitFactory::internalRemove(CBasePriceLimit *pBasePriceLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForBasePriceLimit++;
#endif
	CWriteableBasePriceLimit theOldBasePriceLimit;
	beforeRemove(pBasePriceLimit);
	if (bNoTransaction) {
		forceCopy(&theOldBasePriceLimit,pBasePriceLimit,sizeof(CBasePriceLimit));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pBasePriceLimit);
	}
	pMem->free(pBasePriceLimit);
	if(bNoTransaction) {
		commitRemove(&theOldBasePriceLimit);
	}
}

void CBasePriceLimitFactory::remove(CBasePriceLimit *pBasePriceLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pBasePriceLimit,true);
	}
	else {
		pTransaction->addResource(CBasePriceLimitResource::alloc(DELETE_ACTION,this,pBasePriceLimit,NULL));
		internalRemove(pBasePriceLimit,false);		
	}
}

CBasePriceLimit* CBasePriceLimitFactory::addOrUpdate(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pNewBasePriceLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pBasePriceLimit == NULL) {
		return add(pNewBasePriceLimit,pTransaction);
	}
	else {
		update(pBasePriceLimit,pNewBasePriceLimit,pTransaction,updateIndex);
		return pBasePriceLimit;
	}
}

void CBasePriceLimitFactory::retrieve(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pTargetBasePriceLimit)
{
	forceCopy(pTargetBasePriceLimit, pBasePriceLimit, sizeof(CBasePriceLimit));
}
	
int CBasePriceLimitFactory::addActionTrigger(CBasePriceLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CBasePriceLimitFactory::removeActionTrigger(CBasePriceLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CBasePriceLimitFactory::addCommitTrigger(CBasePriceLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CBasePriceLimitFactory::removeCommitTrigger(CBasePriceLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CBasePriceLimit *CBasePriceLimitFactory::getFirst(void)
{
	CBasePriceLimit *pResult=(CBasePriceLimit *)(pMem->getFirst());
	return pResult;
}
	
CBasePriceLimit *CBasePriceLimitFactory::getNext(void)
{
	CBasePriceLimit *pResult=(CBasePriceLimit *)(pMem->getNext());
	return pResult;
}
	
void CBasePriceLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CBasePriceLimitFactory::beforeAdd(CWriteableBasePriceLimit *pBasePriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pBasePriceLimit);
	}
}
	
void CBasePriceLimitFactory::afterAdd(CBasePriceLimit *pBasePriceLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pBasePriceLimit);
	}
}

void CBasePriceLimitFactory::beforeUpdate(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pNewBasePriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pBasePriceLimit,pNewBasePriceLimit);
	}
}
	
void CBasePriceLimitFactory::afterUpdate(CBasePriceLimit *pBasePriceLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pBasePriceLimit);
	}
}
	
void CBasePriceLimitFactory::beforeRemove(CBasePriceLimit *pBasePriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pBasePriceLimit);
	}
}

void CBasePriceLimitFactory::commitAdd(CBasePriceLimit *pBasePriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForBasePriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pBasePriceLimit);
	}
}

void CBasePriceLimitFactory::commitUpdate(CBasePriceLimit *pBasePriceLimit, CWriteableBasePriceLimit *pOldBasePriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForBasePriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pBasePriceLimit,pOldBasePriceLimit);
	}
}
	
void CBasePriceLimitFactory::commitRemove(CWriteableBasePriceLimit *pBasePriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForBasePriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pBasePriceLimit);
	}
}

void CBasePriceLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForParticipantIDIndexinCreditLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCreditLimit=0;
int updateWithIndexActionForCreditLimit=0;
int updateWithoutIndexActionForCreditLimit=0;
int removeActionForCreditLimit=0;
int addCommitForCreditLimit=0;
int updateCommitForCreditLimit=0;
int removeCommitForCreditLimit=0;
#endif
void CCreditLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinCreditLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CreditLimit_ParticipantIDIndex",pParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CreditLimit_ParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pParticipantIDIndex=new CAVLTree(maxUnit,compareForParticipantIDIndexinCreditLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pLastFoundInSearchAllByParticipantID=NULL;
	pLastFoundInSearchAllByClearingPartID=NULL;
	pLastFoundInSearchAll=NULL;
	pActionTriggers=new vector<CCreditLimitActionTrigger *>;
	pCommitTriggers=new vector<CCreditLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCreditLimitFactory::CCreditLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCreditLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCreditLimitFactory::CCreditLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCreditLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCreditLimitFactory::~CCreditLimitFactory(void)
{
	if (runLevel>=0) {
		if (pParticipantIDIndex!=NULL)
			delete pParticipantIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCreditLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCreditLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pParticipantIDIndex->output(pLogger,indent+1);
	}
}

int CCreditLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCreditLimit thisCreditLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCreditLimit.readCSV(input,pNames))
		add(&thisCreditLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CCreditLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CreditLimit.csv");
	return readCSV(szFileName);
}

int CCreditLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCreditLimit *pCreditLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCreditLimit::writeCSVHead(output);
	pCreditLimit=(CWriteableCreditLimit *)(pMem->getFirst());
	while (pCreditLimit!=NULL) {
		if (!pCreditLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCreditLimit=(CWriteableCreditLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCreditLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CreditLimit.csv");
	return writeCSV(szFileName);
}

void CCreditLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCreditLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCreditLimit *pCreditLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCreditLimitFactory={       Total Count=%d\n", pMem->getCount());
	pCreditLimit=(CWriteableCreditLimit *)(pMem->getFirst());
	while (pCreditLimit!=NULL) {
		pCreditLimit->dump(fp,index++);
		pCreditLimit=(CWriteableCreditLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCreditLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pParticipantIDIndex->removeAll();
	}
}

CCreditLimit *CCreditLimitFactory::internalAdd(CWriteableCreditLimit *pCreditLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCreditLimit++;
#endif
	CCreditLimit *pTarget;	
	beforeAdd(pCreditLimit);
	pTarget=(CCreditLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CreditLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCreditLimit, sizeof(CCreditLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pParticipantIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCreditLimit *CCreditLimitFactory::add(CWriteableCreditLimit *pCreditLimit, CTransaction *pTransaction)
{
	pCreditLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCreditLimit,true);
	}
	else {
		CCreditLimit *pNewCreditLimit;
		pNewCreditLimit = internalAdd(pCreditLimit,false);
		pTransaction->addResource(CCreditLimitResource::alloc(CREATE_ACTION,this,pNewCreditLimit,NULL));
		return pNewCreditLimit;
	}
}

void CCreditLimitFactory::internalUpdate(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pNewCreditLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCreditLimit++;
	}
	else {
		updateWithoutIndexActionForCreditLimit++;
	}
#endif
	CWriteableCreditLimit theOldCreditLimit;
	beforeUpdate(pCreditLimit,pNewCreditLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCreditLimit,pCreditLimit,sizeof(CCreditLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pCreditLimit,pNewCreditLimit,sizeof(CCreditLimit));
	pMem->updateObject(pCreditLimit);
	if (updateIndex) {
	}
	afterUpdate(pCreditLimit);
	if (bNoTransaction) {
		commitUpdate(pCreditLimit,&theOldCreditLimit);
	}
}

void CCreditLimitFactory::update(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pNewCreditLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewCreditLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCreditLimit,pNewCreditLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCreditLimitResource::alloc(UPDATE_ACTION,this,pCreditLimit,pNewCreditLimit,updateIndex));
		internalUpdate(pCreditLimit,pNewCreditLimit,updateIndex,false);
	}
}

void CCreditLimitFactory::internalRemove(CCreditLimit *pCreditLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCreditLimit++;
#endif
	CWriteableCreditLimit theOldCreditLimit;
	beforeRemove(pCreditLimit);
	if (bNoTransaction) {
		forceCopy(&theOldCreditLimit,pCreditLimit,sizeof(CCreditLimit));
	}
	if (runLevel>=0) {
		pParticipantIDIndex->removeObject(pCreditLimit);
	}
	pMem->free(pCreditLimit);
	if(bNoTransaction) {
		commitRemove(&theOldCreditLimit);
	}
}

void CCreditLimitFactory::remove(CCreditLimit *pCreditLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCreditLimit,true);
	}
	else {
		pTransaction->addResource(CCreditLimitResource::alloc(DELETE_ACTION,this,pCreditLimit,NULL));
		internalRemove(pCreditLimit,false);		
	}
}

CCreditLimit* CCreditLimitFactory::addOrUpdate(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pNewCreditLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pCreditLimit == NULL) {
		return add(pNewCreditLimit,pTransaction);
	}
	else {
		update(pCreditLimit,pNewCreditLimit,pTransaction,updateIndex);
		return pCreditLimit;
	}
}

void CCreditLimitFactory::retrieve(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pTargetCreditLimit)
{
	forceCopy(pTargetCreditLimit, pCreditLimit, sizeof(CCreditLimit));
}
	
int CCreditLimitFactory::addActionTrigger(CCreditLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCreditLimitFactory::removeActionTrigger(CCreditLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCreditLimitFactory::addCommitTrigger(CCreditLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCreditLimitFactory::removeCommitTrigger(CCreditLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCreditLimit *CCreditLimitFactory::getFirst(void)
{
	CCreditLimit *pResult=(CCreditLimit *)(pMem->getFirst());
	return pResult;
}
	
CCreditLimit *CCreditLimitFactory::getNext(void)
{
	CCreditLimit *pResult=(CCreditLimit *)(pMem->getNext());
	return pResult;
}
	
void CCreditLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CCreditLimitFactory::beforeAdd(CWriteableCreditLimit *pCreditLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCreditLimit);
	}
}
	
void CCreditLimitFactory::afterAdd(CCreditLimit *pCreditLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCreditLimit);
	}
}

void CCreditLimitFactory::beforeUpdate(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pNewCreditLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCreditLimit,pNewCreditLimit);
	}
}
	
void CCreditLimitFactory::afterUpdate(CCreditLimit *pCreditLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCreditLimit);
	}
}
	
void CCreditLimitFactory::beforeRemove(CCreditLimit *pCreditLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCreditLimit);
	}
}

void CCreditLimitFactory::commitAdd(CCreditLimit *pCreditLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCreditLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCreditLimit);
	}
}

void CCreditLimitFactory::commitUpdate(CCreditLimit *pCreditLimit, CWriteableCreditLimit *pOldCreditLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCreditLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCreditLimit,pOldCreditLimit);
	}
}
	
void CCreditLimitFactory::commitRemove(CWriteableCreditLimit *pCreditLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCreditLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCreditLimit);
	}
}

void CCreditLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForInstrumentIDIndexinCurrInstrumentOption(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForCurrInstrumentOption=0;
int updateWithIndexActionForCurrInstrumentOption=0;
int updateWithoutIndexActionForCurrInstrumentOption=0;
int removeActionForCurrInstrumentOption=0;
int addCommitForCurrInstrumentOption=0;
int updateCommitForCurrInstrumentOption=0;
int removeCommitForCurrInstrumentOption=0;
#endif
void CCurrInstrumentOptionFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrInstrumentOption,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("CurrInstrumentOption_InstrumentIDIndex",pInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("CurrInstrumentOption_InstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pInstrumentIDIndex=new CAVLTree(maxUnit,compareForInstrumentIDIndexinCurrInstrumentOption,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchBySettlementGroupID=NULL;
	pActionTriggers=new vector<CCurrInstrumentOptionActionTrigger *>;
	pCommitTriggers=new vector<CCurrInstrumentOptionCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CCurrInstrumentOptionFactory::CCurrInstrumentOptionFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrInstrumentOption),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CCurrInstrumentOptionFactory::CCurrInstrumentOptionFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CCurrInstrumentOption),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CCurrInstrumentOptionFactory::~CCurrInstrumentOptionFactory(void)
{
	if (runLevel>=0) {
		if (pInstrumentIDIndex!=NULL)
			delete pInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CCurrInstrumentOptionFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CCurrInstrumentOptionFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CCurrInstrumentOptionFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableCurrInstrumentOption thisCurrInstrumentOption;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisCurrInstrumentOption.readCSV(input,pNames))
		add(&thisCurrInstrumentOption);
	fclose(input);
	delete pNames;
	return 1;
}

int CCurrInstrumentOptionFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "CurrInstrumentOption.csv");
	return readCSV(szFileName);
}

int CCurrInstrumentOptionFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableCurrInstrumentOption *pCurrInstrumentOption;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableCurrInstrumentOption::writeCSVHead(output);
	pCurrInstrumentOption=(CWriteableCurrInstrumentOption *)(pMem->getFirst());
	while (pCurrInstrumentOption!=NULL) {
		if (!pCurrInstrumentOption->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pCurrInstrumentOption=(CWriteableCurrInstrumentOption *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CCurrInstrumentOptionFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "CurrInstrumentOption.csv");
	return writeCSV(szFileName);
}

void CCurrInstrumentOptionFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CCurrInstrumentOptionFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableCurrInstrumentOption *pCurrInstrumentOption;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CCurrInstrumentOptionFactory={       Total Count=%d\n", pMem->getCount());
	pCurrInstrumentOption=(CWriteableCurrInstrumentOption *)(pMem->getFirst());
	while (pCurrInstrumentOption!=NULL) {
		pCurrInstrumentOption->dump(fp,index++);
		pCurrInstrumentOption=(CWriteableCurrInstrumentOption *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CCurrInstrumentOptionFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pInstrumentIDIndex->removeAll();
	}
}

CCurrInstrumentOption *CCurrInstrumentOptionFactory::internalAdd(CWriteableCurrInstrumentOption *pCurrInstrumentOption, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForCurrInstrumentOption++;
#endif
	CCurrInstrumentOption *pTarget;	
	beforeAdd(pCurrInstrumentOption);
	pTarget=(CCurrInstrumentOption *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough CurrInstrumentOption in memory database");
		return NULL;
	}
	forceCopy(pTarget, pCurrInstrumentOption, sizeof(CCurrInstrumentOption));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CCurrInstrumentOption *CCurrInstrumentOptionFactory::add(CWriteableCurrInstrumentOption *pCurrInstrumentOption, CTransaction *pTransaction)
{
	pCurrInstrumentOption->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pCurrInstrumentOption,true);
	}
	else {
		CCurrInstrumentOption *pNewCurrInstrumentOption;
		pNewCurrInstrumentOption = internalAdd(pCurrInstrumentOption,false);
		pTransaction->addResource(CCurrInstrumentOptionResource::alloc(CREATE_ACTION,this,pNewCurrInstrumentOption,NULL));
		return pNewCurrInstrumentOption;
	}
}

void CCurrInstrumentOptionFactory::internalUpdate(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pNewCurrInstrumentOption, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForCurrInstrumentOption++;
	}
	else {
		updateWithoutIndexActionForCurrInstrumentOption++;
	}
#endif
	CWriteableCurrInstrumentOption theOldCurrInstrumentOption;
	beforeUpdate(pCurrInstrumentOption,pNewCurrInstrumentOption);
	if (bNoTransaction) {
		forceCopy(&theOldCurrInstrumentOption,pCurrInstrumentOption,sizeof(CCurrInstrumentOption));
	}
	if (updateIndex) {
	}

	forceCopy(pCurrInstrumentOption,pNewCurrInstrumentOption,sizeof(CCurrInstrumentOption));
	pMem->updateObject(pCurrInstrumentOption);
	if (updateIndex) {
	}
	afterUpdate(pCurrInstrumentOption);
	if (bNoTransaction) {
		commitUpdate(pCurrInstrumentOption,&theOldCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::update(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pNewCurrInstrumentOption, CTransaction *pTransaction, bool updateIndex)
{
	pNewCurrInstrumentOption->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pCurrInstrumentOption,pNewCurrInstrumentOption,updateIndex,true);
	}
	else {
		pTransaction->addResource(CCurrInstrumentOptionResource::alloc(UPDATE_ACTION,this,pCurrInstrumentOption,pNewCurrInstrumentOption,updateIndex));
		internalUpdate(pCurrInstrumentOption,pNewCurrInstrumentOption,updateIndex,false);
	}
}

void CCurrInstrumentOptionFactory::internalRemove(CCurrInstrumentOption *pCurrInstrumentOption, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForCurrInstrumentOption++;
#endif
	CWriteableCurrInstrumentOption theOldCurrInstrumentOption;
	beforeRemove(pCurrInstrumentOption);
	if (bNoTransaction) {
		forceCopy(&theOldCurrInstrumentOption,pCurrInstrumentOption,sizeof(CCurrInstrumentOption));
	}
	if (runLevel>=0) {
		pInstrumentIDIndex->removeObject(pCurrInstrumentOption);
	}
	pMem->free(pCurrInstrumentOption);
	if(bNoTransaction) {
		commitRemove(&theOldCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::remove(CCurrInstrumentOption *pCurrInstrumentOption, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pCurrInstrumentOption,true);
	}
	else {
		pTransaction->addResource(CCurrInstrumentOptionResource::alloc(DELETE_ACTION,this,pCurrInstrumentOption,NULL));
		internalRemove(pCurrInstrumentOption,false);		
	}
}

CCurrInstrumentOption* CCurrInstrumentOptionFactory::addOrUpdate(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pNewCurrInstrumentOption, CTransaction *pTransaction, bool updateIndex)
{
	if(pCurrInstrumentOption == NULL) {
		return add(pNewCurrInstrumentOption,pTransaction);
	}
	else {
		update(pCurrInstrumentOption,pNewCurrInstrumentOption,pTransaction,updateIndex);
		return pCurrInstrumentOption;
	}
}

void CCurrInstrumentOptionFactory::retrieve(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pTargetCurrInstrumentOption)
{
	forceCopy(pTargetCurrInstrumentOption, pCurrInstrumentOption, sizeof(CCurrInstrumentOption));
}
	
int CCurrInstrumentOptionFactory::addActionTrigger(CCurrInstrumentOptionActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CCurrInstrumentOptionFactory::removeActionTrigger(CCurrInstrumentOptionActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CCurrInstrumentOptionFactory::addCommitTrigger(CCurrInstrumentOptionCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CCurrInstrumentOptionFactory::removeCommitTrigger(CCurrInstrumentOptionCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CCurrInstrumentOption *CCurrInstrumentOptionFactory::getFirst(void)
{
	CCurrInstrumentOption *pResult=(CCurrInstrumentOption *)(pMem->getFirst());
	return pResult;
}
	
CCurrInstrumentOption *CCurrInstrumentOptionFactory::getNext(void)
{
	CCurrInstrumentOption *pResult=(CCurrInstrumentOption *)(pMem->getNext());
	return pResult;
}
	
void CCurrInstrumentOptionFactory::endGet(void)
{
	pMem->endGet();
}

void CCurrInstrumentOptionFactory::beforeAdd(CWriteableCurrInstrumentOption *pCurrInstrumentOption)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pCurrInstrumentOption);
	}
}
	
void CCurrInstrumentOptionFactory::afterAdd(CCurrInstrumentOption *pCurrInstrumentOption)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::beforeUpdate(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pNewCurrInstrumentOption)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pCurrInstrumentOption,pNewCurrInstrumentOption);
	}
}
	
void CCurrInstrumentOptionFactory::afterUpdate(CCurrInstrumentOption *pCurrInstrumentOption)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pCurrInstrumentOption);
	}
}
	
void CCurrInstrumentOptionFactory::beforeRemove(CCurrInstrumentOption *pCurrInstrumentOption)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::commitAdd(CCurrInstrumentOption *pCurrInstrumentOption)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForCurrInstrumentOption++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::commitUpdate(CCurrInstrumentOption *pCurrInstrumentOption, CWriteableCurrInstrumentOption *pOldCurrInstrumentOption)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForCurrInstrumentOption++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pCurrInstrumentOption,pOldCurrInstrumentOption);
	}
}
	
void CCurrInstrumentOptionFactory::commitRemove(CWriteableCurrInstrumentOption *pCurrInstrumentOption)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForCurrInstrumentOption++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pCurrInstrumentOption);
	}
}

void CCurrInstrumentOptionFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}


#ifdef COUNT_OPERATION

#define clearCount(name)						\
	addActionFor ## name =0;					\
	updateWithIndexActionFor ## name =0;		\
	updateWithoutIndexActionFor ## name =0;		\
	removeActionFor ## name =0;					\
	addCommitFor ## name=0;						\
	updateCommitFor ## name =0;					\
	removeCommitFor ## name =0;

void initAllOperationCount(void)
{
	clearCount(ExchangeDataSyncStatus);
	clearCount(SGDataSyncStatus);
	clearCount(CurrentTime);
	clearCount(DataCenterDesc);
	clearCount(Exchange);
	clearCount(SettlementGroup);
	clearCount(Market);
	clearCount(MarketProduct);
	clearCount(MarketProductGroup);
	clearCount(MdPubStatus);
	clearCount(MarketDataTopic);
	clearCount(PartTopicSubscribe);
	clearCount(Participant);
	clearCount(User);
	clearCount(Client);
	clearCount(UserIP);
	clearCount(PartClient);
	clearCount(ClearingTradingPart);
	clearCount(AliasDefine);
	clearCount(UserFunctionRight);
	clearCount(Account);
	clearCount(UserCommFlux);
	clearCount(MarketDataLog);
	clearCount(UserSession);
	clearCount(MDSession);
	clearCount(LoginInfo);
	clearCount(DepthMarketDataDetail);
	clearCount(InstrumentStatusDetail);
	clearCount(FrontStatus);
	clearCount(MaxLocalID);
	clearCount(Bulletin);
	clearCount(MarketDataModify);
	clearCount(DepthMarketData);
	clearCount(TopicMarketData);
	clearCount(TopicMarketDataVersion);
	clearCount(Information);
	clearCount(OrderCount);
	clearCount(Instrument);
	clearCount(CombinationLeg);
	clearCount(PartRoleAccount);
	clearCount(PartProductRole);
	clearCount(PartProductRight);
	clearCount(PartInstrumentRight);
	clearCount(ClientProductRight);
	clearCount(ClientInstrumentRight);
	clearCount(PartClientProductRight);
	clearCount(PartClientInstrumentRight);
	clearCount(CurrProductProperty);
	clearCount(CurrInstrumentProperty);
	clearCount(CurrPriceBanding);
	clearCount(CurrMarginRate);
	clearCount(CurrMarginRateDetail);
	clearCount(CurrPartPosiLimit);
	clearCount(CurrPartPosiLimitDetail);
	clearCount(CurrClientPosiLimit);
	clearCount(CurrClientPosiLimitDetail);
	clearCount(CurrSpecialPosiLimit);
	clearCount(CurrSpecialPosiLimitDetail);
	clearCount(CurrHedgeRule);
	clearCount(CurrTradingSegmentAttr);
	clearCount(CurrFuse);
	clearCount(TradingAccount);
	clearCount(BaseReserveAccount);
	clearCount(PartPosition);
	clearCount(ClientPosition);
	clearCount(HedgeVolume);
	clearCount(RemainOrder);
	clearCount(MarketData);
	clearCount(ClearingPartPosition);
	clearCount(InstrumentStatus);
	clearCount(Order);
	clearCount(CombOrder);
	clearCount(OTCOrder);
	clearCount(ImplyOrder);
	clearCount(Quote);
	clearCount(MBLMarketData);
	clearCount(Trade);
	clearCount(FusePhase);
	clearCount(ExecOrder);
	clearCount(UniPressure);
	clearCount(BasePriceLimit);
	clearCount(CreditLimit);
	clearCount(CurrInstrumentOption);
}

#define display(id)						\
	if (id!=0)							\
	{									\
		printf("\t" #id ":%d\n", id);	\
	}

#define displayAll(name)							\
	display(addActionFor ## name);					\
	display(updateWithIndexActionFor ## name);		\
	display(updateWithoutIndexActionFor ## name);	\
	display(removeActionFor ## name);				\
	display(addCommitFor ## name);					\
	display(updateCommitFor ## name);				\
	display(removeCommitFor ## name);

void showAllOperationCount(void)
{
	displayAll(ExchangeDataSyncStatus);
	displayAll(SGDataSyncStatus);
	displayAll(CurrentTime);
	displayAll(DataCenterDesc);
	displayAll(Exchange);
	displayAll(SettlementGroup);
	displayAll(Market);
	displayAll(MarketProduct);
	displayAll(MarketProductGroup);
	displayAll(MdPubStatus);
	displayAll(MarketDataTopic);
	displayAll(PartTopicSubscribe);
	displayAll(Participant);
	displayAll(User);
	displayAll(Client);
	displayAll(UserIP);
	displayAll(PartClient);
	displayAll(ClearingTradingPart);
	displayAll(AliasDefine);
	displayAll(UserFunctionRight);
	displayAll(Account);
	displayAll(UserCommFlux);
	displayAll(MarketDataLog);
	displayAll(UserSession);
	displayAll(MDSession);
	displayAll(LoginInfo);
	displayAll(DepthMarketDataDetail);
	displayAll(InstrumentStatusDetail);
	displayAll(FrontStatus);
	displayAll(MaxLocalID);
	displayAll(Bulletin);
	displayAll(MarketDataModify);
	displayAll(DepthMarketData);
	displayAll(TopicMarketData);
	displayAll(TopicMarketDataVersion);
	displayAll(Information);
	displayAll(OrderCount);
	displayAll(Instrument);
	displayAll(CombinationLeg);
	displayAll(PartRoleAccount);
	displayAll(PartProductRole);
	displayAll(PartProductRight);
	displayAll(PartInstrumentRight);
	displayAll(ClientProductRight);
	displayAll(ClientInstrumentRight);
	displayAll(PartClientProductRight);
	displayAll(PartClientInstrumentRight);
	displayAll(CurrProductProperty);
	displayAll(CurrInstrumentProperty);
	displayAll(CurrPriceBanding);
	displayAll(CurrMarginRate);
	displayAll(CurrMarginRateDetail);
	displayAll(CurrPartPosiLimit);
	displayAll(CurrPartPosiLimitDetail);
	displayAll(CurrClientPosiLimit);
	displayAll(CurrClientPosiLimitDetail);
	displayAll(CurrSpecialPosiLimit);
	displayAll(CurrSpecialPosiLimitDetail);
	displayAll(CurrHedgeRule);
	displayAll(CurrTradingSegmentAttr);
	displayAll(CurrFuse);
	displayAll(TradingAccount);
	displayAll(BaseReserveAccount);
	displayAll(PartPosition);
	displayAll(ClientPosition);
	displayAll(HedgeVolume);
	displayAll(RemainOrder);
	displayAll(MarketData);
	displayAll(ClearingPartPosition);
	displayAll(InstrumentStatus);
	displayAll(Order);
	displayAll(CombOrder);
	displayAll(OTCOrder);
	displayAll(ImplyOrder);
	displayAll(Quote);
	displayAll(MBLMarketData);
	displayAll(Trade);
	displayAll(FusePhase);
	displayAll(ExecOrder);
	displayAll(UniPressure);
	displayAll(BasePriceLimit);
	displayAll(CreditLimit);
	displayAll(CurrInstrumentOption);
}
#endif

