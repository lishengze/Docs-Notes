/////////////////////////////////////////////////////////////////////////
///@system 执行引擎系统
///@company 上海期货信息技术有限公司
///@file databaseFactories.pp
///@brief实现了若干个内存数据库的对象工厂
///@history 
///20060127	王肇东		创建该文件
/////////////////////////////////////////////////////////////////////////

#include "BaseDataStruct.h"
#include "databaseFactories.h"
#include "databaseResources.h"
#include "monitorIndex.h"

//#define COUNT_OPERATION

///强制进行复制，不理会const标记
///@param	target	复制的目标地址
///@param	source	复制的源地址
///@param	size	复制的空间大小
static void forceCopy(const void *target, const void *source, int size)
{
	if ((source==NULL)||(target==NULL))
	{
		REPORT_EVENT(LOG_CRITICAL,"InternalError","copy from or to null");
		return;
	}
	memcpy((void *)target,source,size);
}

extern int compareForSysInsertTimeIndexinSysInvalidateOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysInvalidateOrder=0;
int updateWithIndexActionForSysInvalidateOrder=0;
int updateWithoutIndexActionForSysInvalidateOrder=0;
int removeActionForSysInvalidateOrder=0;
int addCommitForSysInvalidateOrder=0;
int updateCommitForSysInvalidateOrder=0;
int removeCommitForSysInvalidateOrder=0;
#endif
void CSysInvalidateOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInsertTimeIndex=new CAVLTree(maxUnit,compareForSysInsertTimeIndexinSysInvalidateOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysInvalidateOrder_SysInsertTimeIndex",pSysInsertTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysInvalidateOrder_SysInsertTimeIndex");
			if(it != pIndexMap->end()) {
				pSysInsertTimeIndex=new CAVLTree(maxUnit,compareForSysInsertTimeIndexinSysInvalidateOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInsertTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysInvalidateOrderActionTrigger *>;
	pCommitTriggers=new vector<CSysInvalidateOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysInvalidateOrderFactory::CSysInvalidateOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInvalidateOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysInvalidateOrderFactory::CSysInvalidateOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInvalidateOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysInvalidateOrderFactory::~CSysInvalidateOrderFactory(void)
{
	if (runLevel>=0) {
		if (pSysInsertTimeIndex!=NULL)
			delete pSysInsertTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysInvalidateOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysInvalidateOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInsertTimeIndex->output(pLogger,indent+1);
	}
}

int CSysInvalidateOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysInvalidateOrder thisSysInvalidateOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysInvalidateOrder.readCSV(input,pNames))
		add(&thisSysInvalidateOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysInvalidateOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysInvalidateOrder.csv");
	return readCSV(szFileName);
}

int CSysInvalidateOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysInvalidateOrder *pSysInvalidateOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysInvalidateOrder::writeCSVHead(output);
	pSysInvalidateOrder=(CWriteableSysInvalidateOrder *)(pMem->getFirst());
	while (pSysInvalidateOrder!=NULL) {
		if (!pSysInvalidateOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysInvalidateOrder=(CWriteableSysInvalidateOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysInvalidateOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysInvalidateOrder.csv");
	return writeCSV(szFileName);
}

void CSysInvalidateOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysInvalidateOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysInvalidateOrder *pSysInvalidateOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysInvalidateOrderFactory={       Total Count=%d\n", pMem->getCount());
	pSysInvalidateOrder=(CWriteableSysInvalidateOrder *)(pMem->getFirst());
	while (pSysInvalidateOrder!=NULL) {
		pSysInvalidateOrder->dump(fp,index++);
		pSysInvalidateOrder=(CWriteableSysInvalidateOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysInvalidateOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInsertTimeIndex->removeAll();
	}
}

CSysInvalidateOrder *CSysInvalidateOrderFactory::internalAdd(CWriteableSysInvalidateOrder *pSysInvalidateOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysInvalidateOrder++;
#endif
	CSysInvalidateOrder *pTarget;	
	beforeAdd(pSysInvalidateOrder);
	pTarget=(CSysInvalidateOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysInvalidateOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysInvalidateOrder, sizeof(CSysInvalidateOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInsertTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysInvalidateOrder *CSysInvalidateOrderFactory::add(CWriteableSysInvalidateOrder *pSysInvalidateOrder, CTransaction *pTransaction)
{
	pSysInvalidateOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysInvalidateOrder,true);
	}
	else {
		CSysInvalidateOrder *pNewSysInvalidateOrder;
		pNewSysInvalidateOrder = internalAdd(pSysInvalidateOrder,false);
		pTransaction->addResource(CSysInvalidateOrderResource::alloc(CREATE_ACTION,this,pNewSysInvalidateOrder,NULL));
		return pNewSysInvalidateOrder;
	}
}

void CSysInvalidateOrderFactory::internalUpdate(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pNewSysInvalidateOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysInvalidateOrder++;
	}
	else {
		updateWithoutIndexActionForSysInvalidateOrder++;
	}
#endif
	CWriteableSysInvalidateOrder theOldSysInvalidateOrder;
	beforeUpdate(pSysInvalidateOrder,pNewSysInvalidateOrder);
	if (bNoTransaction) {
		forceCopy(&theOldSysInvalidateOrder,pSysInvalidateOrder,sizeof(CSysInvalidateOrder));
	}
	if (updateIndex) {
	}

	forceCopy(pSysInvalidateOrder,pNewSysInvalidateOrder,sizeof(CSysInvalidateOrder));
	pMem->updateObject(pSysInvalidateOrder);
	if (updateIndex) {
	}
	afterUpdate(pSysInvalidateOrder);
	if (bNoTransaction) {
		commitUpdate(pSysInvalidateOrder,&theOldSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::update(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pNewSysInvalidateOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysInvalidateOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysInvalidateOrder,pNewSysInvalidateOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysInvalidateOrderResource::alloc(UPDATE_ACTION,this,pSysInvalidateOrder,pNewSysInvalidateOrder,updateIndex));
		internalUpdate(pSysInvalidateOrder,pNewSysInvalidateOrder,updateIndex,false);
	}
}

void CSysInvalidateOrderFactory::internalRemove(CSysInvalidateOrder *pSysInvalidateOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysInvalidateOrder++;
#endif
	CWriteableSysInvalidateOrder theOldSysInvalidateOrder;
	beforeRemove(pSysInvalidateOrder);
	if (bNoTransaction) {
		forceCopy(&theOldSysInvalidateOrder,pSysInvalidateOrder,sizeof(CSysInvalidateOrder));
	}
	if (runLevel>=0) {
		pSysInsertTimeIndex->removeObject(pSysInvalidateOrder);
	}
	pMem->free(pSysInvalidateOrder);
	if(bNoTransaction) {
		commitRemove(&theOldSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::remove(CSysInvalidateOrder *pSysInvalidateOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysInvalidateOrder,true);
	}
	else {
		pTransaction->addResource(CSysInvalidateOrderResource::alloc(DELETE_ACTION,this,pSysInvalidateOrder,NULL));
		internalRemove(pSysInvalidateOrder,false);		
	}
}

CSysInvalidateOrder* CSysInvalidateOrderFactory::addOrUpdate(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pNewSysInvalidateOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysInvalidateOrder == NULL) {
		return add(pNewSysInvalidateOrder,pTransaction);
	}
	else {
		update(pSysInvalidateOrder,pNewSysInvalidateOrder,pTransaction,updateIndex);
		return pSysInvalidateOrder;
	}
}

void CSysInvalidateOrderFactory::retrieve(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pTargetSysInvalidateOrder)
{
	forceCopy(pTargetSysInvalidateOrder, pSysInvalidateOrder, sizeof(CSysInvalidateOrder));
}
	
int CSysInvalidateOrderFactory::addActionTrigger(CSysInvalidateOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysInvalidateOrderFactory::removeActionTrigger(CSysInvalidateOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysInvalidateOrderFactory::addCommitTrigger(CSysInvalidateOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysInvalidateOrderFactory::removeCommitTrigger(CSysInvalidateOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysInvalidateOrder *CSysInvalidateOrderFactory::getFirst(void)
{
	CSysInvalidateOrder *pResult=(CSysInvalidateOrder *)(pMem->getFirst());
	return pResult;
}
	
CSysInvalidateOrder *CSysInvalidateOrderFactory::getNext(void)
{
	CSysInvalidateOrder *pResult=(CSysInvalidateOrder *)(pMem->getNext());
	return pResult;
}
	
void CSysInvalidateOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CSysInvalidateOrderFactory::beforeAdd(CWriteableSysInvalidateOrder *pSysInvalidateOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysInvalidateOrder);
	}
}
	
void CSysInvalidateOrderFactory::afterAdd(CSysInvalidateOrder *pSysInvalidateOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::beforeUpdate(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pNewSysInvalidateOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysInvalidateOrder,pNewSysInvalidateOrder);
	}
}
	
void CSysInvalidateOrderFactory::afterUpdate(CSysInvalidateOrder *pSysInvalidateOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysInvalidateOrder);
	}
}
	
void CSysInvalidateOrderFactory::beforeRemove(CSysInvalidateOrder *pSysInvalidateOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::commitAdd(CSysInvalidateOrder *pSysInvalidateOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysInvalidateOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::commitUpdate(CSysInvalidateOrder *pSysInvalidateOrder, CWriteableSysInvalidateOrder *pOldSysInvalidateOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysInvalidateOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysInvalidateOrder,pOldSysInvalidateOrder);
	}
}
	
void CSysInvalidateOrderFactory::commitRemove(CWriteableSysInvalidateOrder *pSysInvalidateOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysInvalidateOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysInvalidateOrder);
	}
}

void CSysInvalidateOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysOrderStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysOrderStatus=0;
int updateWithIndexActionForSysOrderStatus=0;
int updateWithoutIndexActionForSysOrderStatus=0;
int removeActionForSysOrderStatus=0;
int addCommitForSysOrderStatus=0;
int updateCommitForSysOrderStatus=0;
int removeCommitForSysOrderStatus=0;
#endif
void CSysOrderStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysOrderStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysOrderStatus_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysOrderStatus_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysOrderStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysOrderStatusActionTrigger *>;
	pCommitTriggers=new vector<CSysOrderStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysOrderStatusFactory::CSysOrderStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysOrderStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysOrderStatusFactory::CSysOrderStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysOrderStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysOrderStatusFactory::~CSysOrderStatusFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysOrderStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysOrderStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysOrderStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysOrderStatus thisSysOrderStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysOrderStatus.readCSV(input,pNames))
		add(&thisSysOrderStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysOrderStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysOrderStatus.csv");
	return readCSV(szFileName);
}

int CSysOrderStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysOrderStatus *pSysOrderStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysOrderStatus::writeCSVHead(output);
	pSysOrderStatus=(CWriteableSysOrderStatus *)(pMem->getFirst());
	while (pSysOrderStatus!=NULL) {
		if (!pSysOrderStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysOrderStatus=(CWriteableSysOrderStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysOrderStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysOrderStatus.csv");
	return writeCSV(szFileName);
}

void CSysOrderStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysOrderStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysOrderStatus *pSysOrderStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysOrderStatusFactory={       Total Count=%d\n", pMem->getCount());
	pSysOrderStatus=(CWriteableSysOrderStatus *)(pMem->getFirst());
	while (pSysOrderStatus!=NULL) {
		pSysOrderStatus->dump(fp,index++);
		pSysOrderStatus=(CWriteableSysOrderStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysOrderStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysOrderStatus *CSysOrderStatusFactory::internalAdd(CWriteableSysOrderStatus *pSysOrderStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysOrderStatus++;
#endif
	CSysOrderStatus *pTarget;	
	beforeAdd(pSysOrderStatus);
	pTarget=(CSysOrderStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysOrderStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysOrderStatus, sizeof(CSysOrderStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysOrderStatus *CSysOrderStatusFactory::add(CWriteableSysOrderStatus *pSysOrderStatus, CTransaction *pTransaction)
{
	pSysOrderStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysOrderStatus,true);
	}
	else {
		CSysOrderStatus *pNewSysOrderStatus;
		pNewSysOrderStatus = internalAdd(pSysOrderStatus,false);
		pTransaction->addResource(CSysOrderStatusResource::alloc(CREATE_ACTION,this,pNewSysOrderStatus,NULL));
		return pNewSysOrderStatus;
	}
}

void CSysOrderStatusFactory::internalUpdate(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pNewSysOrderStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysOrderStatus++;
	}
	else {
		updateWithoutIndexActionForSysOrderStatus++;
	}
#endif
	CWriteableSysOrderStatus theOldSysOrderStatus;
	beforeUpdate(pSysOrderStatus,pNewSysOrderStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSysOrderStatus,pSysOrderStatus,sizeof(CSysOrderStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pSysOrderStatus,pNewSysOrderStatus,sizeof(CSysOrderStatus));
	pMem->updateObject(pSysOrderStatus);
	if (updateIndex) {
	}
	afterUpdate(pSysOrderStatus);
	if (bNoTransaction) {
		commitUpdate(pSysOrderStatus,&theOldSysOrderStatus);
	}
}

void CSysOrderStatusFactory::update(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pNewSysOrderStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysOrderStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysOrderStatus,pNewSysOrderStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysOrderStatusResource::alloc(UPDATE_ACTION,this,pSysOrderStatus,pNewSysOrderStatus,updateIndex));
		internalUpdate(pSysOrderStatus,pNewSysOrderStatus,updateIndex,false);
	}
}

void CSysOrderStatusFactory::internalRemove(CSysOrderStatus *pSysOrderStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysOrderStatus++;
#endif
	CWriteableSysOrderStatus theOldSysOrderStatus;
	beforeRemove(pSysOrderStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSysOrderStatus,pSysOrderStatus,sizeof(CSysOrderStatus));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysOrderStatus);
	}
	pMem->free(pSysOrderStatus);
	if(bNoTransaction) {
		commitRemove(&theOldSysOrderStatus);
	}
}

void CSysOrderStatusFactory::remove(CSysOrderStatus *pSysOrderStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysOrderStatus,true);
	}
	else {
		pTransaction->addResource(CSysOrderStatusResource::alloc(DELETE_ACTION,this,pSysOrderStatus,NULL));
		internalRemove(pSysOrderStatus,false);		
	}
}

CSysOrderStatus* CSysOrderStatusFactory::addOrUpdate(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pNewSysOrderStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysOrderStatus == NULL) {
		return add(pNewSysOrderStatus,pTransaction);
	}
	else {
		update(pSysOrderStatus,pNewSysOrderStatus,pTransaction,updateIndex);
		return pSysOrderStatus;
	}
}

void CSysOrderStatusFactory::retrieve(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pTargetSysOrderStatus)
{
	forceCopy(pTargetSysOrderStatus, pSysOrderStatus, sizeof(CSysOrderStatus));
}
	
int CSysOrderStatusFactory::addActionTrigger(CSysOrderStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysOrderStatusFactory::removeActionTrigger(CSysOrderStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysOrderStatusFactory::addCommitTrigger(CSysOrderStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysOrderStatusFactory::removeCommitTrigger(CSysOrderStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysOrderStatus *CSysOrderStatusFactory::getFirst(void)
{
	CSysOrderStatus *pResult=(CSysOrderStatus *)(pMem->getFirst());
	return pResult;
}
	
CSysOrderStatus *CSysOrderStatusFactory::getNext(void)
{
	CSysOrderStatus *pResult=(CSysOrderStatus *)(pMem->getNext());
	return pResult;
}
	
void CSysOrderStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CSysOrderStatusFactory::beforeAdd(CWriteableSysOrderStatus *pSysOrderStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysOrderStatus);
	}
}
	
void CSysOrderStatusFactory::afterAdd(CSysOrderStatus *pSysOrderStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysOrderStatus);
	}
}

void CSysOrderStatusFactory::beforeUpdate(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pNewSysOrderStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysOrderStatus,pNewSysOrderStatus);
	}
}
	
void CSysOrderStatusFactory::afterUpdate(CSysOrderStatus *pSysOrderStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysOrderStatus);
	}
}
	
void CSysOrderStatusFactory::beforeRemove(CSysOrderStatus *pSysOrderStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysOrderStatus);
	}
}

void CSysOrderStatusFactory::commitAdd(CSysOrderStatus *pSysOrderStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysOrderStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysOrderStatus);
	}
}

void CSysOrderStatusFactory::commitUpdate(CSysOrderStatus *pSysOrderStatus, CWriteableSysOrderStatus *pOldSysOrderStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysOrderStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysOrderStatus,pOldSysOrderStatus);
	}
}
	
void CSysOrderStatusFactory::commitRemove(CWriteableSysOrderStatus *pSysOrderStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysOrderStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysOrderStatus);
	}
}

void CSysOrderStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTradeTimeIndexinSysBargainOrder(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysBargainOrder=0;
int updateWithIndexActionForSysBargainOrder=0;
int updateWithoutIndexActionForSysBargainOrder=0;
int removeActionForSysBargainOrder=0;
int addCommitForSysBargainOrder=0;
int updateCommitForSysBargainOrder=0;
int removeCommitForSysBargainOrder=0;
#endif
void CSysBargainOrderFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysBargainOrder,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysBargainOrder_SysTradeTimeIndex",pSysTradeTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysBargainOrder_SysTradeTimeIndex");
			if(it != pIndexMap->end()) {
				pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysBargainOrder,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTradeTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysBargainOrderActionTrigger *>;
	pCommitTriggers=new vector<CSysBargainOrderCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysBargainOrderFactory::CSysBargainOrderFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysBargainOrder),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysBargainOrderFactory::CSysBargainOrderFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysBargainOrder),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysBargainOrderFactory::~CSysBargainOrderFactory(void)
{
	if (runLevel>=0) {
		if (pSysTradeTimeIndex!=NULL)
			delete pSysTradeTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysBargainOrderFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysBargainOrderFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTradeTimeIndex->output(pLogger,indent+1);
	}
}

int CSysBargainOrderFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysBargainOrder thisSysBargainOrder;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysBargainOrder.readCSV(input,pNames))
		add(&thisSysBargainOrder);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysBargainOrderFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysBargainOrder.csv");
	return readCSV(szFileName);
}

int CSysBargainOrderFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysBargainOrder *pSysBargainOrder;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysBargainOrder::writeCSVHead(output);
	pSysBargainOrder=(CWriteableSysBargainOrder *)(pMem->getFirst());
	while (pSysBargainOrder!=NULL) {
		if (!pSysBargainOrder->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysBargainOrder=(CWriteableSysBargainOrder *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysBargainOrderFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysBargainOrder.csv");
	return writeCSV(szFileName);
}

void CSysBargainOrderFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysBargainOrderFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysBargainOrder *pSysBargainOrder;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysBargainOrderFactory={       Total Count=%d\n", pMem->getCount());
	pSysBargainOrder=(CWriteableSysBargainOrder *)(pMem->getFirst());
	while (pSysBargainOrder!=NULL) {
		pSysBargainOrder->dump(fp,index++);
		pSysBargainOrder=(CWriteableSysBargainOrder *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysBargainOrderFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeAll();
	}
}

CSysBargainOrder *CSysBargainOrderFactory::internalAdd(CWriteableSysBargainOrder *pSysBargainOrder, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysBargainOrder++;
#endif
	CSysBargainOrder *pTarget;	
	beforeAdd(pSysBargainOrder);
	pTarget=(CSysBargainOrder *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysBargainOrder in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysBargainOrder, sizeof(CSysBargainOrder));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTradeTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysBargainOrder *CSysBargainOrderFactory::add(CWriteableSysBargainOrder *pSysBargainOrder, CTransaction *pTransaction)
{
	pSysBargainOrder->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysBargainOrder,true);
	}
	else {
		CSysBargainOrder *pNewSysBargainOrder;
		pNewSysBargainOrder = internalAdd(pSysBargainOrder,false);
		pTransaction->addResource(CSysBargainOrderResource::alloc(CREATE_ACTION,this,pNewSysBargainOrder,NULL));
		return pNewSysBargainOrder;
	}
}

void CSysBargainOrderFactory::internalUpdate(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pNewSysBargainOrder, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysBargainOrder++;
	}
	else {
		updateWithoutIndexActionForSysBargainOrder++;
	}
#endif
	CWriteableSysBargainOrder theOldSysBargainOrder;
	beforeUpdate(pSysBargainOrder,pNewSysBargainOrder);
	if (bNoTransaction) {
		forceCopy(&theOldSysBargainOrder,pSysBargainOrder,sizeof(CSysBargainOrder));
	}
	if (updateIndex) {
	}

	forceCopy(pSysBargainOrder,pNewSysBargainOrder,sizeof(CSysBargainOrder));
	pMem->updateObject(pSysBargainOrder);
	if (updateIndex) {
	}
	afterUpdate(pSysBargainOrder);
	if (bNoTransaction) {
		commitUpdate(pSysBargainOrder,&theOldSysBargainOrder);
	}
}

void CSysBargainOrderFactory::update(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pNewSysBargainOrder, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysBargainOrder->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysBargainOrder,pNewSysBargainOrder,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysBargainOrderResource::alloc(UPDATE_ACTION,this,pSysBargainOrder,pNewSysBargainOrder,updateIndex));
		internalUpdate(pSysBargainOrder,pNewSysBargainOrder,updateIndex,false);
	}
}

void CSysBargainOrderFactory::internalRemove(CSysBargainOrder *pSysBargainOrder, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysBargainOrder++;
#endif
	CWriteableSysBargainOrder theOldSysBargainOrder;
	beforeRemove(pSysBargainOrder);
	if (bNoTransaction) {
		forceCopy(&theOldSysBargainOrder,pSysBargainOrder,sizeof(CSysBargainOrder));
	}
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeObject(pSysBargainOrder);
	}
	pMem->free(pSysBargainOrder);
	if(bNoTransaction) {
		commitRemove(&theOldSysBargainOrder);
	}
}

void CSysBargainOrderFactory::remove(CSysBargainOrder *pSysBargainOrder, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysBargainOrder,true);
	}
	else {
		pTransaction->addResource(CSysBargainOrderResource::alloc(DELETE_ACTION,this,pSysBargainOrder,NULL));
		internalRemove(pSysBargainOrder,false);		
	}
}

CSysBargainOrder* CSysBargainOrderFactory::addOrUpdate(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pNewSysBargainOrder, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysBargainOrder == NULL) {
		return add(pNewSysBargainOrder,pTransaction);
	}
	else {
		update(pSysBargainOrder,pNewSysBargainOrder,pTransaction,updateIndex);
		return pSysBargainOrder;
	}
}

void CSysBargainOrderFactory::retrieve(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pTargetSysBargainOrder)
{
	forceCopy(pTargetSysBargainOrder, pSysBargainOrder, sizeof(CSysBargainOrder));
}
	
int CSysBargainOrderFactory::addActionTrigger(CSysBargainOrderActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysBargainOrderFactory::removeActionTrigger(CSysBargainOrderActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysBargainOrderFactory::addCommitTrigger(CSysBargainOrderCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysBargainOrderFactory::removeCommitTrigger(CSysBargainOrderCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysBargainOrder *CSysBargainOrderFactory::getFirst(void)
{
	CSysBargainOrder *pResult=(CSysBargainOrder *)(pMem->getFirst());
	return pResult;
}
	
CSysBargainOrder *CSysBargainOrderFactory::getNext(void)
{
	CSysBargainOrder *pResult=(CSysBargainOrder *)(pMem->getNext());
	return pResult;
}
	
void CSysBargainOrderFactory::endGet(void)
{
	pMem->endGet();
}

void CSysBargainOrderFactory::beforeAdd(CWriteableSysBargainOrder *pSysBargainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysBargainOrder);
	}
}
	
void CSysBargainOrderFactory::afterAdd(CSysBargainOrder *pSysBargainOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysBargainOrder);
	}
}

void CSysBargainOrderFactory::beforeUpdate(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pNewSysBargainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysBargainOrder,pNewSysBargainOrder);
	}
}
	
void CSysBargainOrderFactory::afterUpdate(CSysBargainOrder *pSysBargainOrder)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysBargainOrder);
	}
}
	
void CSysBargainOrderFactory::beforeRemove(CSysBargainOrder *pSysBargainOrder)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysBargainOrder);
	}
}

void CSysBargainOrderFactory::commitAdd(CSysBargainOrder *pSysBargainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysBargainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysBargainOrder);
	}
}

void CSysBargainOrderFactory::commitUpdate(CSysBargainOrder *pSysBargainOrder, CWriteableSysBargainOrder *pOldSysBargainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysBargainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysBargainOrder,pOldSysBargainOrder);
	}
}
	
void CSysBargainOrderFactory::commitRemove(CWriteableSysBargainOrder *pSysBargainOrder)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysBargainOrder++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysBargainOrder);
	}
}

void CSysBargainOrderFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysInstProperty(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysInstProperty=0;
int updateWithIndexActionForSysInstProperty=0;
int updateWithoutIndexActionForSysInstProperty=0;
int removeActionForSysInstProperty=0;
int addCommitForSysInstProperty=0;
int updateCommitForSysInstProperty=0;
int removeCommitForSysInstProperty=0;
#endif
void CSysInstPropertyFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysInstProperty,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysInstProperty_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysInstProperty_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysInstProperty,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysInstPropertyActionTrigger *>;
	pCommitTriggers=new vector<CSysInstPropertyCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysInstPropertyFactory::CSysInstPropertyFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInstProperty),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysInstPropertyFactory::CSysInstPropertyFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInstProperty),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysInstPropertyFactory::~CSysInstPropertyFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysInstPropertyFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysInstPropertyFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysInstPropertyFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysInstProperty thisSysInstProperty;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysInstProperty.readCSV(input,pNames))
		add(&thisSysInstProperty);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysInstPropertyFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysInstProperty.csv");
	return readCSV(szFileName);
}

int CSysInstPropertyFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysInstProperty *pSysInstProperty;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysInstProperty::writeCSVHead(output);
	pSysInstProperty=(CWriteableSysInstProperty *)(pMem->getFirst());
	while (pSysInstProperty!=NULL) {
		if (!pSysInstProperty->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysInstProperty=(CWriteableSysInstProperty *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysInstPropertyFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysInstProperty.csv");
	return writeCSV(szFileName);
}

void CSysInstPropertyFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysInstPropertyFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysInstProperty *pSysInstProperty;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysInstPropertyFactory={       Total Count=%d\n", pMem->getCount());
	pSysInstProperty=(CWriteableSysInstProperty *)(pMem->getFirst());
	while (pSysInstProperty!=NULL) {
		pSysInstProperty->dump(fp,index++);
		pSysInstProperty=(CWriteableSysInstProperty *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysInstPropertyFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysInstProperty *CSysInstPropertyFactory::internalAdd(CWriteableSysInstProperty *pSysInstProperty, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysInstProperty++;
#endif
	CSysInstProperty *pTarget;	
	beforeAdd(pSysInstProperty);
	pTarget=(CSysInstProperty *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysInstProperty in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysInstProperty, sizeof(CSysInstProperty));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysInstProperty *CSysInstPropertyFactory::add(CWriteableSysInstProperty *pSysInstProperty, CTransaction *pTransaction)
{
	pSysInstProperty->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysInstProperty,true);
	}
	else {
		CSysInstProperty *pNewSysInstProperty;
		pNewSysInstProperty = internalAdd(pSysInstProperty,false);
		pTransaction->addResource(CSysInstPropertyResource::alloc(CREATE_ACTION,this,pNewSysInstProperty,NULL));
		return pNewSysInstProperty;
	}
}

void CSysInstPropertyFactory::internalUpdate(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pNewSysInstProperty, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysInstProperty++;
	}
	else {
		updateWithoutIndexActionForSysInstProperty++;
	}
#endif
	CWriteableSysInstProperty theOldSysInstProperty;
	beforeUpdate(pSysInstProperty,pNewSysInstProperty);
	if (bNoTransaction) {
		forceCopy(&theOldSysInstProperty,pSysInstProperty,sizeof(CSysInstProperty));
	}
	if (updateIndex) {
	}

	forceCopy(pSysInstProperty,pNewSysInstProperty,sizeof(CSysInstProperty));
	pMem->updateObject(pSysInstProperty);
	if (updateIndex) {
	}
	afterUpdate(pSysInstProperty);
	if (bNoTransaction) {
		commitUpdate(pSysInstProperty,&theOldSysInstProperty);
	}
}

void CSysInstPropertyFactory::update(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pNewSysInstProperty, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysInstProperty->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysInstProperty,pNewSysInstProperty,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysInstPropertyResource::alloc(UPDATE_ACTION,this,pSysInstProperty,pNewSysInstProperty,updateIndex));
		internalUpdate(pSysInstProperty,pNewSysInstProperty,updateIndex,false);
	}
}

void CSysInstPropertyFactory::internalRemove(CSysInstProperty *pSysInstProperty, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysInstProperty++;
#endif
	CWriteableSysInstProperty theOldSysInstProperty;
	beforeRemove(pSysInstProperty);
	if (bNoTransaction) {
		forceCopy(&theOldSysInstProperty,pSysInstProperty,sizeof(CSysInstProperty));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysInstProperty);
	}
	pMem->free(pSysInstProperty);
	if(bNoTransaction) {
		commitRemove(&theOldSysInstProperty);
	}
}

void CSysInstPropertyFactory::remove(CSysInstProperty *pSysInstProperty, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysInstProperty,true);
	}
	else {
		pTransaction->addResource(CSysInstPropertyResource::alloc(DELETE_ACTION,this,pSysInstProperty,NULL));
		internalRemove(pSysInstProperty,false);		
	}
}

CSysInstProperty* CSysInstPropertyFactory::addOrUpdate(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pNewSysInstProperty, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysInstProperty == NULL) {
		return add(pNewSysInstProperty,pTransaction);
	}
	else {
		update(pSysInstProperty,pNewSysInstProperty,pTransaction,updateIndex);
		return pSysInstProperty;
	}
}

void CSysInstPropertyFactory::retrieve(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pTargetSysInstProperty)
{
	forceCopy(pTargetSysInstProperty, pSysInstProperty, sizeof(CSysInstProperty));
}
	
int CSysInstPropertyFactory::addActionTrigger(CSysInstPropertyActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysInstPropertyFactory::removeActionTrigger(CSysInstPropertyActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysInstPropertyFactory::addCommitTrigger(CSysInstPropertyCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysInstPropertyFactory::removeCommitTrigger(CSysInstPropertyCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysInstProperty *CSysInstPropertyFactory::getFirst(void)
{
	CSysInstProperty *pResult=(CSysInstProperty *)(pMem->getFirst());
	return pResult;
}
	
CSysInstProperty *CSysInstPropertyFactory::getNext(void)
{
	CSysInstProperty *pResult=(CSysInstProperty *)(pMem->getNext());
	return pResult;
}
	
void CSysInstPropertyFactory::endGet(void)
{
	pMem->endGet();
}

void CSysInstPropertyFactory::beforeAdd(CWriteableSysInstProperty *pSysInstProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysInstProperty);
	}
}
	
void CSysInstPropertyFactory::afterAdd(CSysInstProperty *pSysInstProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysInstProperty);
	}
}

void CSysInstPropertyFactory::beforeUpdate(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pNewSysInstProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysInstProperty,pNewSysInstProperty);
	}
}
	
void CSysInstPropertyFactory::afterUpdate(CSysInstProperty *pSysInstProperty)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysInstProperty);
	}
}
	
void CSysInstPropertyFactory::beforeRemove(CSysInstProperty *pSysInstProperty)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysInstProperty);
	}
}

void CSysInstPropertyFactory::commitAdd(CSysInstProperty *pSysInstProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysInstProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysInstProperty);
	}
}

void CSysInstPropertyFactory::commitUpdate(CSysInstProperty *pSysInstProperty, CWriteableSysInstProperty *pOldSysInstProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysInstProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysInstProperty,pOldSysInstProperty);
	}
}
	
void CSysInstPropertyFactory::commitRemove(CWriteableSysInstProperty *pSysInstProperty)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysInstProperty++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysInstProperty);
	}
}

void CSysInstPropertyFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysMarginRate(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMarginRate=0;
int updateWithIndexActionForSysMarginRate=0;
int updateWithoutIndexActionForSysMarginRate=0;
int removeActionForSysMarginRate=0;
int addCommitForSysMarginRate=0;
int updateCommitForSysMarginRate=0;
int removeCommitForSysMarginRate=0;
#endif
void CSysMarginRateFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysMarginRate,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMarginRate_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMarginRate_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysMarginRate,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysMarginRateActionTrigger *>;
	pCommitTriggers=new vector<CSysMarginRateCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMarginRateFactory::CSysMarginRateFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMarginRate),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMarginRateFactory::CSysMarginRateFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMarginRate),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMarginRateFactory::~CSysMarginRateFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMarginRateFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMarginRateFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysMarginRateFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMarginRate thisSysMarginRate;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMarginRate.readCSV(input,pNames))
		add(&thisSysMarginRate);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMarginRateFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMarginRate.csv");
	return readCSV(szFileName);
}

int CSysMarginRateFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMarginRate *pSysMarginRate;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMarginRate::writeCSVHead(output);
	pSysMarginRate=(CWriteableSysMarginRate *)(pMem->getFirst());
	while (pSysMarginRate!=NULL) {
		if (!pSysMarginRate->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMarginRate=(CWriteableSysMarginRate *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMarginRateFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMarginRate.csv");
	return writeCSV(szFileName);
}

void CSysMarginRateFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMarginRateFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMarginRate *pSysMarginRate;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMarginRateFactory={       Total Count=%d\n", pMem->getCount());
	pSysMarginRate=(CWriteableSysMarginRate *)(pMem->getFirst());
	while (pSysMarginRate!=NULL) {
		pSysMarginRate->dump(fp,index++);
		pSysMarginRate=(CWriteableSysMarginRate *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMarginRateFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysMarginRate *CSysMarginRateFactory::internalAdd(CWriteableSysMarginRate *pSysMarginRate, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMarginRate++;
#endif
	CSysMarginRate *pTarget;	
	beforeAdd(pSysMarginRate);
	pTarget=(CSysMarginRate *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMarginRate in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMarginRate, sizeof(CSysMarginRate));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMarginRate *CSysMarginRateFactory::add(CWriteableSysMarginRate *pSysMarginRate, CTransaction *pTransaction)
{
	pSysMarginRate->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMarginRate,true);
	}
	else {
		CSysMarginRate *pNewSysMarginRate;
		pNewSysMarginRate = internalAdd(pSysMarginRate,false);
		pTransaction->addResource(CSysMarginRateResource::alloc(CREATE_ACTION,this,pNewSysMarginRate,NULL));
		return pNewSysMarginRate;
	}
}

void CSysMarginRateFactory::internalUpdate(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pNewSysMarginRate, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMarginRate++;
	}
	else {
		updateWithoutIndexActionForSysMarginRate++;
	}
#endif
	CWriteableSysMarginRate theOldSysMarginRate;
	beforeUpdate(pSysMarginRate,pNewSysMarginRate);
	if (bNoTransaction) {
		forceCopy(&theOldSysMarginRate,pSysMarginRate,sizeof(CSysMarginRate));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMarginRate,pNewSysMarginRate,sizeof(CSysMarginRate));
	pMem->updateObject(pSysMarginRate);
	if (updateIndex) {
	}
	afterUpdate(pSysMarginRate);
	if (bNoTransaction) {
		commitUpdate(pSysMarginRate,&theOldSysMarginRate);
	}
}

void CSysMarginRateFactory::update(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pNewSysMarginRate, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMarginRate->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMarginRate,pNewSysMarginRate,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMarginRateResource::alloc(UPDATE_ACTION,this,pSysMarginRate,pNewSysMarginRate,updateIndex));
		internalUpdate(pSysMarginRate,pNewSysMarginRate,updateIndex,false);
	}
}

void CSysMarginRateFactory::internalRemove(CSysMarginRate *pSysMarginRate, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMarginRate++;
#endif
	CWriteableSysMarginRate theOldSysMarginRate;
	beforeRemove(pSysMarginRate);
	if (bNoTransaction) {
		forceCopy(&theOldSysMarginRate,pSysMarginRate,sizeof(CSysMarginRate));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysMarginRate);
	}
	pMem->free(pSysMarginRate);
	if(bNoTransaction) {
		commitRemove(&theOldSysMarginRate);
	}
}

void CSysMarginRateFactory::remove(CSysMarginRate *pSysMarginRate, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMarginRate,true);
	}
	else {
		pTransaction->addResource(CSysMarginRateResource::alloc(DELETE_ACTION,this,pSysMarginRate,NULL));
		internalRemove(pSysMarginRate,false);		
	}
}

CSysMarginRate* CSysMarginRateFactory::addOrUpdate(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pNewSysMarginRate, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMarginRate == NULL) {
		return add(pNewSysMarginRate,pTransaction);
	}
	else {
		update(pSysMarginRate,pNewSysMarginRate,pTransaction,updateIndex);
		return pSysMarginRate;
	}
}

void CSysMarginRateFactory::retrieve(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pTargetSysMarginRate)
{
	forceCopy(pTargetSysMarginRate, pSysMarginRate, sizeof(CSysMarginRate));
}
	
int CSysMarginRateFactory::addActionTrigger(CSysMarginRateActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMarginRateFactory::removeActionTrigger(CSysMarginRateActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMarginRateFactory::addCommitTrigger(CSysMarginRateCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMarginRateFactory::removeCommitTrigger(CSysMarginRateCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMarginRate *CSysMarginRateFactory::getFirst(void)
{
	CSysMarginRate *pResult=(CSysMarginRate *)(pMem->getFirst());
	return pResult;
}
	
CSysMarginRate *CSysMarginRateFactory::getNext(void)
{
	CSysMarginRate *pResult=(CSysMarginRate *)(pMem->getNext());
	return pResult;
}
	
void CSysMarginRateFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMarginRateFactory::beforeAdd(CWriteableSysMarginRate *pSysMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMarginRate);
	}
}
	
void CSysMarginRateFactory::afterAdd(CSysMarginRate *pSysMarginRate)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMarginRate);
	}
}

void CSysMarginRateFactory::beforeUpdate(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pNewSysMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMarginRate,pNewSysMarginRate);
	}
}
	
void CSysMarginRateFactory::afterUpdate(CSysMarginRate *pSysMarginRate)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMarginRate);
	}
}
	
void CSysMarginRateFactory::beforeRemove(CSysMarginRate *pSysMarginRate)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMarginRate);
	}
}

void CSysMarginRateFactory::commitAdd(CSysMarginRate *pSysMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMarginRate);
	}
}

void CSysMarginRateFactory::commitUpdate(CSysMarginRate *pSysMarginRate, CWriteableSysMarginRate *pOldSysMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMarginRate,pOldSysMarginRate);
	}
}
	
void CSysMarginRateFactory::commitRemove(CWriteableSysMarginRate *pSysMarginRate)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMarginRate++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMarginRate);
	}
}

void CSysMarginRateFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysPriceLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysPriceLimit=0;
int updateWithIndexActionForSysPriceLimit=0;
int updateWithoutIndexActionForSysPriceLimit=0;
int removeActionForSysPriceLimit=0;
int addCommitForSysPriceLimit=0;
int updateCommitForSysPriceLimit=0;
int removeCommitForSysPriceLimit=0;
#endif
void CSysPriceLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysPriceLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysPriceLimit_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysPriceLimit_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysPriceLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysPriceLimitActionTrigger *>;
	pCommitTriggers=new vector<CSysPriceLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysPriceLimitFactory::CSysPriceLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPriceLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysPriceLimitFactory::CSysPriceLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPriceLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysPriceLimitFactory::~CSysPriceLimitFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysPriceLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysPriceLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysPriceLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysPriceLimit thisSysPriceLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysPriceLimit.readCSV(input,pNames))
		add(&thisSysPriceLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysPriceLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysPriceLimit.csv");
	return readCSV(szFileName);
}

int CSysPriceLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysPriceLimit *pSysPriceLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysPriceLimit::writeCSVHead(output);
	pSysPriceLimit=(CWriteableSysPriceLimit *)(pMem->getFirst());
	while (pSysPriceLimit!=NULL) {
		if (!pSysPriceLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysPriceLimit=(CWriteableSysPriceLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysPriceLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysPriceLimit.csv");
	return writeCSV(szFileName);
}

void CSysPriceLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysPriceLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysPriceLimit *pSysPriceLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysPriceLimitFactory={       Total Count=%d\n", pMem->getCount());
	pSysPriceLimit=(CWriteableSysPriceLimit *)(pMem->getFirst());
	while (pSysPriceLimit!=NULL) {
		pSysPriceLimit->dump(fp,index++);
		pSysPriceLimit=(CWriteableSysPriceLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysPriceLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysPriceLimit *CSysPriceLimitFactory::internalAdd(CWriteableSysPriceLimit *pSysPriceLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysPriceLimit++;
#endif
	CSysPriceLimit *pTarget;	
	beforeAdd(pSysPriceLimit);
	pTarget=(CSysPriceLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysPriceLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysPriceLimit, sizeof(CSysPriceLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysPriceLimit *CSysPriceLimitFactory::add(CWriteableSysPriceLimit *pSysPriceLimit, CTransaction *pTransaction)
{
	pSysPriceLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysPriceLimit,true);
	}
	else {
		CSysPriceLimit *pNewSysPriceLimit;
		pNewSysPriceLimit = internalAdd(pSysPriceLimit,false);
		pTransaction->addResource(CSysPriceLimitResource::alloc(CREATE_ACTION,this,pNewSysPriceLimit,NULL));
		return pNewSysPriceLimit;
	}
}

void CSysPriceLimitFactory::internalUpdate(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pNewSysPriceLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysPriceLimit++;
	}
	else {
		updateWithoutIndexActionForSysPriceLimit++;
	}
#endif
	CWriteableSysPriceLimit theOldSysPriceLimit;
	beforeUpdate(pSysPriceLimit,pNewSysPriceLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysPriceLimit,pSysPriceLimit,sizeof(CSysPriceLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysPriceLimit,pNewSysPriceLimit,sizeof(CSysPriceLimit));
	pMem->updateObject(pSysPriceLimit);
	if (updateIndex) {
	}
	afterUpdate(pSysPriceLimit);
	if (bNoTransaction) {
		commitUpdate(pSysPriceLimit,&theOldSysPriceLimit);
	}
}

void CSysPriceLimitFactory::update(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pNewSysPriceLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysPriceLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysPriceLimit,pNewSysPriceLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysPriceLimitResource::alloc(UPDATE_ACTION,this,pSysPriceLimit,pNewSysPriceLimit,updateIndex));
		internalUpdate(pSysPriceLimit,pNewSysPriceLimit,updateIndex,false);
	}
}

void CSysPriceLimitFactory::internalRemove(CSysPriceLimit *pSysPriceLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysPriceLimit++;
#endif
	CWriteableSysPriceLimit theOldSysPriceLimit;
	beforeRemove(pSysPriceLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysPriceLimit,pSysPriceLimit,sizeof(CSysPriceLimit));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysPriceLimit);
	}
	pMem->free(pSysPriceLimit);
	if(bNoTransaction) {
		commitRemove(&theOldSysPriceLimit);
	}
}

void CSysPriceLimitFactory::remove(CSysPriceLimit *pSysPriceLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysPriceLimit,true);
	}
	else {
		pTransaction->addResource(CSysPriceLimitResource::alloc(DELETE_ACTION,this,pSysPriceLimit,NULL));
		internalRemove(pSysPriceLimit,false);		
	}
}

CSysPriceLimit* CSysPriceLimitFactory::addOrUpdate(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pNewSysPriceLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysPriceLimit == NULL) {
		return add(pNewSysPriceLimit,pTransaction);
	}
	else {
		update(pSysPriceLimit,pNewSysPriceLimit,pTransaction,updateIndex);
		return pSysPriceLimit;
	}
}

void CSysPriceLimitFactory::retrieve(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pTargetSysPriceLimit)
{
	forceCopy(pTargetSysPriceLimit, pSysPriceLimit, sizeof(CSysPriceLimit));
}
	
int CSysPriceLimitFactory::addActionTrigger(CSysPriceLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysPriceLimitFactory::removeActionTrigger(CSysPriceLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysPriceLimitFactory::addCommitTrigger(CSysPriceLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysPriceLimitFactory::removeCommitTrigger(CSysPriceLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysPriceLimit *CSysPriceLimitFactory::getFirst(void)
{
	CSysPriceLimit *pResult=(CSysPriceLimit *)(pMem->getFirst());
	return pResult;
}
	
CSysPriceLimit *CSysPriceLimitFactory::getNext(void)
{
	CSysPriceLimit *pResult=(CSysPriceLimit *)(pMem->getNext());
	return pResult;
}
	
void CSysPriceLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysPriceLimitFactory::beforeAdd(CWriteableSysPriceLimit *pSysPriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysPriceLimit);
	}
}
	
void CSysPriceLimitFactory::afterAdd(CSysPriceLimit *pSysPriceLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysPriceLimit);
	}
}

void CSysPriceLimitFactory::beforeUpdate(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pNewSysPriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysPriceLimit,pNewSysPriceLimit);
	}
}
	
void CSysPriceLimitFactory::afterUpdate(CSysPriceLimit *pSysPriceLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysPriceLimit);
	}
}
	
void CSysPriceLimitFactory::beforeRemove(CSysPriceLimit *pSysPriceLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysPriceLimit);
	}
}

void CSysPriceLimitFactory::commitAdd(CSysPriceLimit *pSysPriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysPriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysPriceLimit);
	}
}

void CSysPriceLimitFactory::commitUpdate(CSysPriceLimit *pSysPriceLimit, CWriteableSysPriceLimit *pOldSysPriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysPriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysPriceLimit,pOldSysPriceLimit);
	}
}
	
void CSysPriceLimitFactory::commitRemove(CWriteableSysPriceLimit *pSysPriceLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysPriceLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysPriceLimit);
	}
}

void CSysPriceLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysPartPosiLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysPartPosiLimit=0;
int updateWithIndexActionForSysPartPosiLimit=0;
int updateWithoutIndexActionForSysPartPosiLimit=0;
int removeActionForSysPartPosiLimit=0;
int addCommitForSysPartPosiLimit=0;
int updateCommitForSysPartPosiLimit=0;
int removeCommitForSysPartPosiLimit=0;
#endif
void CSysPartPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysPartPosiLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysPartPosiLimit_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysPartPosiLimit_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysPartPosiLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysPartPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CSysPartPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysPartPosiLimitFactory::CSysPartPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysPartPosiLimitFactory::CSysPartPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysPartPosiLimitFactory::~CSysPartPosiLimitFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysPartPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysPartPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysPartPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysPartPosiLimit thisSysPartPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysPartPosiLimit.readCSV(input,pNames))
		add(&thisSysPartPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysPartPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysPartPosiLimit.csv");
	return readCSV(szFileName);
}

int CSysPartPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysPartPosiLimit *pSysPartPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysPartPosiLimit::writeCSVHead(output);
	pSysPartPosiLimit=(CWriteableSysPartPosiLimit *)(pMem->getFirst());
	while (pSysPartPosiLimit!=NULL) {
		if (!pSysPartPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysPartPosiLimit=(CWriteableSysPartPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysPartPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysPartPosiLimit.csv");
	return writeCSV(szFileName);
}

void CSysPartPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysPartPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysPartPosiLimit *pSysPartPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysPartPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pSysPartPosiLimit=(CWriteableSysPartPosiLimit *)(pMem->getFirst());
	while (pSysPartPosiLimit!=NULL) {
		pSysPartPosiLimit->dump(fp,index++);
		pSysPartPosiLimit=(CWriteableSysPartPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysPartPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysPartPosiLimit *CSysPartPosiLimitFactory::internalAdd(CWriteableSysPartPosiLimit *pSysPartPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysPartPosiLimit++;
#endif
	CSysPartPosiLimit *pTarget;	
	beforeAdd(pSysPartPosiLimit);
	pTarget=(CSysPartPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysPartPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysPartPosiLimit, sizeof(CSysPartPosiLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysPartPosiLimit *CSysPartPosiLimitFactory::add(CWriteableSysPartPosiLimit *pSysPartPosiLimit, CTransaction *pTransaction)
{
	pSysPartPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysPartPosiLimit,true);
	}
	else {
		CSysPartPosiLimit *pNewSysPartPosiLimit;
		pNewSysPartPosiLimit = internalAdd(pSysPartPosiLimit,false);
		pTransaction->addResource(CSysPartPosiLimitResource::alloc(CREATE_ACTION,this,pNewSysPartPosiLimit,NULL));
		return pNewSysPartPosiLimit;
	}
}

void CSysPartPosiLimitFactory::internalUpdate(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pNewSysPartPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysPartPosiLimit++;
	}
	else {
		updateWithoutIndexActionForSysPartPosiLimit++;
	}
#endif
	CWriteableSysPartPosiLimit theOldSysPartPosiLimit;
	beforeUpdate(pSysPartPosiLimit,pNewSysPartPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartPosiLimit,pSysPartPosiLimit,sizeof(CSysPartPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysPartPosiLimit,pNewSysPartPosiLimit,sizeof(CSysPartPosiLimit));
	pMem->updateObject(pSysPartPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pSysPartPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pSysPartPosiLimit,&theOldSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::update(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pNewSysPartPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysPartPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysPartPosiLimit,pNewSysPartPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysPartPosiLimitResource::alloc(UPDATE_ACTION,this,pSysPartPosiLimit,pNewSysPartPosiLimit,updateIndex));
		internalUpdate(pSysPartPosiLimit,pNewSysPartPosiLimit,updateIndex,false);
	}
}

void CSysPartPosiLimitFactory::internalRemove(CSysPartPosiLimit *pSysPartPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysPartPosiLimit++;
#endif
	CWriteableSysPartPosiLimit theOldSysPartPosiLimit;
	beforeRemove(pSysPartPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartPosiLimit,pSysPartPosiLimit,sizeof(CSysPartPosiLimit));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysPartPosiLimit);
	}
	pMem->free(pSysPartPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::remove(CSysPartPosiLimit *pSysPartPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysPartPosiLimit,true);
	}
	else {
		pTransaction->addResource(CSysPartPosiLimitResource::alloc(DELETE_ACTION,this,pSysPartPosiLimit,NULL));
		internalRemove(pSysPartPosiLimit,false);		
	}
}

CSysPartPosiLimit* CSysPartPosiLimitFactory::addOrUpdate(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pNewSysPartPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysPartPosiLimit == NULL) {
		return add(pNewSysPartPosiLimit,pTransaction);
	}
	else {
		update(pSysPartPosiLimit,pNewSysPartPosiLimit,pTransaction,updateIndex);
		return pSysPartPosiLimit;
	}
}

void CSysPartPosiLimitFactory::retrieve(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pTargetSysPartPosiLimit)
{
	forceCopy(pTargetSysPartPosiLimit, pSysPartPosiLimit, sizeof(CSysPartPosiLimit));
}
	
int CSysPartPosiLimitFactory::addActionTrigger(CSysPartPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysPartPosiLimitFactory::removeActionTrigger(CSysPartPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysPartPosiLimitFactory::addCommitTrigger(CSysPartPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysPartPosiLimitFactory::removeCommitTrigger(CSysPartPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysPartPosiLimit *CSysPartPosiLimitFactory::getFirst(void)
{
	CSysPartPosiLimit *pResult=(CSysPartPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CSysPartPosiLimit *CSysPartPosiLimitFactory::getNext(void)
{
	CSysPartPosiLimit *pResult=(CSysPartPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CSysPartPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysPartPosiLimitFactory::beforeAdd(CWriteableSysPartPosiLimit *pSysPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysPartPosiLimit);
	}
}
	
void CSysPartPosiLimitFactory::afterAdd(CSysPartPosiLimit *pSysPartPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::beforeUpdate(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pNewSysPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysPartPosiLimit,pNewSysPartPosiLimit);
	}
}
	
void CSysPartPosiLimitFactory::afterUpdate(CSysPartPosiLimit *pSysPartPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysPartPosiLimit);
	}
}
	
void CSysPartPosiLimitFactory::beforeRemove(CSysPartPosiLimit *pSysPartPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::commitAdd(CSysPartPosiLimit *pSysPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::commitUpdate(CSysPartPosiLimit *pSysPartPosiLimit, CWriteableSysPartPosiLimit *pOldSysPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysPartPosiLimit,pOldSysPartPosiLimit);
	}
}
	
void CSysPartPosiLimitFactory::commitRemove(CWriteableSysPartPosiLimit *pSysPartPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysPartPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysPartPosiLimit);
	}
}

void CSysPartPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysClientPosiLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysClientPosiLimit=0;
int updateWithIndexActionForSysClientPosiLimit=0;
int updateWithoutIndexActionForSysClientPosiLimit=0;
int removeActionForSysClientPosiLimit=0;
int addCommitForSysClientPosiLimit=0;
int updateCommitForSysClientPosiLimit=0;
int removeCommitForSysClientPosiLimit=0;
#endif
void CSysClientPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysClientPosiLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysClientPosiLimit_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysClientPosiLimit_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysClientPosiLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysClientPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CSysClientPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysClientPosiLimitFactory::CSysClientPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysClientPosiLimitFactory::CSysClientPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysClientPosiLimitFactory::~CSysClientPosiLimitFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysClientPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysClientPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysClientPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysClientPosiLimit thisSysClientPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysClientPosiLimit.readCSV(input,pNames))
		add(&thisSysClientPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysClientPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysClientPosiLimit.csv");
	return readCSV(szFileName);
}

int CSysClientPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysClientPosiLimit *pSysClientPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysClientPosiLimit::writeCSVHead(output);
	pSysClientPosiLimit=(CWriteableSysClientPosiLimit *)(pMem->getFirst());
	while (pSysClientPosiLimit!=NULL) {
		if (!pSysClientPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysClientPosiLimit=(CWriteableSysClientPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysClientPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysClientPosiLimit.csv");
	return writeCSV(szFileName);
}

void CSysClientPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysClientPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysClientPosiLimit *pSysClientPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysClientPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pSysClientPosiLimit=(CWriteableSysClientPosiLimit *)(pMem->getFirst());
	while (pSysClientPosiLimit!=NULL) {
		pSysClientPosiLimit->dump(fp,index++);
		pSysClientPosiLimit=(CWriteableSysClientPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysClientPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysClientPosiLimit *CSysClientPosiLimitFactory::internalAdd(CWriteableSysClientPosiLimit *pSysClientPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysClientPosiLimit++;
#endif
	CSysClientPosiLimit *pTarget;	
	beforeAdd(pSysClientPosiLimit);
	pTarget=(CSysClientPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysClientPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysClientPosiLimit, sizeof(CSysClientPosiLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysClientPosiLimit *CSysClientPosiLimitFactory::add(CWriteableSysClientPosiLimit *pSysClientPosiLimit, CTransaction *pTransaction)
{
	pSysClientPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysClientPosiLimit,true);
	}
	else {
		CSysClientPosiLimit *pNewSysClientPosiLimit;
		pNewSysClientPosiLimit = internalAdd(pSysClientPosiLimit,false);
		pTransaction->addResource(CSysClientPosiLimitResource::alloc(CREATE_ACTION,this,pNewSysClientPosiLimit,NULL));
		return pNewSysClientPosiLimit;
	}
}

void CSysClientPosiLimitFactory::internalUpdate(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pNewSysClientPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysClientPosiLimit++;
	}
	else {
		updateWithoutIndexActionForSysClientPosiLimit++;
	}
#endif
	CWriteableSysClientPosiLimit theOldSysClientPosiLimit;
	beforeUpdate(pSysClientPosiLimit,pNewSysClientPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientPosiLimit,pSysClientPosiLimit,sizeof(CSysClientPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysClientPosiLimit,pNewSysClientPosiLimit,sizeof(CSysClientPosiLimit));
	pMem->updateObject(pSysClientPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pSysClientPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pSysClientPosiLimit,&theOldSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::update(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pNewSysClientPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysClientPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysClientPosiLimit,pNewSysClientPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysClientPosiLimitResource::alloc(UPDATE_ACTION,this,pSysClientPosiLimit,pNewSysClientPosiLimit,updateIndex));
		internalUpdate(pSysClientPosiLimit,pNewSysClientPosiLimit,updateIndex,false);
	}
}

void CSysClientPosiLimitFactory::internalRemove(CSysClientPosiLimit *pSysClientPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysClientPosiLimit++;
#endif
	CWriteableSysClientPosiLimit theOldSysClientPosiLimit;
	beforeRemove(pSysClientPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientPosiLimit,pSysClientPosiLimit,sizeof(CSysClientPosiLimit));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysClientPosiLimit);
	}
	pMem->free(pSysClientPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::remove(CSysClientPosiLimit *pSysClientPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysClientPosiLimit,true);
	}
	else {
		pTransaction->addResource(CSysClientPosiLimitResource::alloc(DELETE_ACTION,this,pSysClientPosiLimit,NULL));
		internalRemove(pSysClientPosiLimit,false);		
	}
}

CSysClientPosiLimit* CSysClientPosiLimitFactory::addOrUpdate(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pNewSysClientPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysClientPosiLimit == NULL) {
		return add(pNewSysClientPosiLimit,pTransaction);
	}
	else {
		update(pSysClientPosiLimit,pNewSysClientPosiLimit,pTransaction,updateIndex);
		return pSysClientPosiLimit;
	}
}

void CSysClientPosiLimitFactory::retrieve(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pTargetSysClientPosiLimit)
{
	forceCopy(pTargetSysClientPosiLimit, pSysClientPosiLimit, sizeof(CSysClientPosiLimit));
}
	
int CSysClientPosiLimitFactory::addActionTrigger(CSysClientPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysClientPosiLimitFactory::removeActionTrigger(CSysClientPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysClientPosiLimitFactory::addCommitTrigger(CSysClientPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysClientPosiLimitFactory::removeCommitTrigger(CSysClientPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysClientPosiLimit *CSysClientPosiLimitFactory::getFirst(void)
{
	CSysClientPosiLimit *pResult=(CSysClientPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CSysClientPosiLimit *CSysClientPosiLimitFactory::getNext(void)
{
	CSysClientPosiLimit *pResult=(CSysClientPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CSysClientPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysClientPosiLimitFactory::beforeAdd(CWriteableSysClientPosiLimit *pSysClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysClientPosiLimit);
	}
}
	
void CSysClientPosiLimitFactory::afterAdd(CSysClientPosiLimit *pSysClientPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::beforeUpdate(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pNewSysClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysClientPosiLimit,pNewSysClientPosiLimit);
	}
}
	
void CSysClientPosiLimitFactory::afterUpdate(CSysClientPosiLimit *pSysClientPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysClientPosiLimit);
	}
}
	
void CSysClientPosiLimitFactory::beforeRemove(CSysClientPosiLimit *pSysClientPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::commitAdd(CSysClientPosiLimit *pSysClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::commitUpdate(CSysClientPosiLimit *pSysClientPosiLimit, CWriteableSysClientPosiLimit *pOldSysClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysClientPosiLimit,pOldSysClientPosiLimit);
	}
}
	
void CSysClientPosiLimitFactory::commitRemove(CWriteableSysClientPosiLimit *pSysClientPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysClientPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysClientPosiLimit);
	}
}

void CSysClientPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysInstrumentIDIndexinSysSpecialPosiLimit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysSpecialPosiLimit=0;
int updateWithIndexActionForSysSpecialPosiLimit=0;
int updateWithoutIndexActionForSysSpecialPosiLimit=0;
int removeActionForSysSpecialPosiLimit=0;
int addCommitForSysSpecialPosiLimit=0;
int updateCommitForSysSpecialPosiLimit=0;
int removeCommitForSysSpecialPosiLimit=0;
#endif
void CSysSpecialPosiLimitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysSpecialPosiLimit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysSpecialPosiLimit_SysInstrumentIDIndex",pSysInstrumentIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysSpecialPosiLimit_SysInstrumentIDIndex");
			if(it != pIndexMap->end()) {
				pSysInstrumentIDIndex=new CAVLTree(maxUnit,compareForSysInstrumentIDIndexinSysSpecialPosiLimit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysInstrumentIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysSpecialPosiLimitActionTrigger *>;
	pCommitTriggers=new vector<CSysSpecialPosiLimitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysSpecialPosiLimitFactory::CSysSpecialPosiLimitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysSpecialPosiLimit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysSpecialPosiLimitFactory::CSysSpecialPosiLimitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysSpecialPosiLimit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysSpecialPosiLimitFactory::~CSysSpecialPosiLimitFactory(void)
{
	if (runLevel>=0) {
		if (pSysInstrumentIDIndex!=NULL)
			delete pSysInstrumentIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysSpecialPosiLimitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysSpecialPosiLimitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->output(pLogger,indent+1);
	}
}

int CSysSpecialPosiLimitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysSpecialPosiLimit thisSysSpecialPosiLimit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysSpecialPosiLimit.readCSV(input,pNames))
		add(&thisSysSpecialPosiLimit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysSpecialPosiLimitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysSpecialPosiLimit.csv");
	return readCSV(szFileName);
}

int CSysSpecialPosiLimitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysSpecialPosiLimit::writeCSVHead(output);
	pSysSpecialPosiLimit=(CWriteableSysSpecialPosiLimit *)(pMem->getFirst());
	while (pSysSpecialPosiLimit!=NULL) {
		if (!pSysSpecialPosiLimit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysSpecialPosiLimit=(CWriteableSysSpecialPosiLimit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysSpecialPosiLimitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysSpecialPosiLimit.csv");
	return writeCSV(szFileName);
}

void CSysSpecialPosiLimitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysSpecialPosiLimitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysSpecialPosiLimitFactory={       Total Count=%d\n", pMem->getCount());
	pSysSpecialPosiLimit=(CWriteableSysSpecialPosiLimit *)(pMem->getFirst());
	while (pSysSpecialPosiLimit!=NULL) {
		pSysSpecialPosiLimit->dump(fp,index++);
		pSysSpecialPosiLimit=(CWriteableSysSpecialPosiLimit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysSpecialPosiLimitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeAll();
	}
}

CSysSpecialPosiLimit *CSysSpecialPosiLimitFactory::internalAdd(CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysSpecialPosiLimit++;
#endif
	CSysSpecialPosiLimit *pTarget;	
	beforeAdd(pSysSpecialPosiLimit);
	pTarget=(CSysSpecialPosiLimit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysSpecialPosiLimit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysSpecialPosiLimit, sizeof(CSysSpecialPosiLimit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysInstrumentIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysSpecialPosiLimit *CSysSpecialPosiLimitFactory::add(CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit, CTransaction *pTransaction)
{
	pSysSpecialPosiLimit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysSpecialPosiLimit,true);
	}
	else {
		CSysSpecialPosiLimit *pNewSysSpecialPosiLimit;
		pNewSysSpecialPosiLimit = internalAdd(pSysSpecialPosiLimit,false);
		pTransaction->addResource(CSysSpecialPosiLimitResource::alloc(CREATE_ACTION,this,pNewSysSpecialPosiLimit,NULL));
		return pNewSysSpecialPosiLimit;
	}
}

void CSysSpecialPosiLimitFactory::internalUpdate(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pNewSysSpecialPosiLimit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysSpecialPosiLimit++;
	}
	else {
		updateWithoutIndexActionForSysSpecialPosiLimit++;
	}
#endif
	CWriteableSysSpecialPosiLimit theOldSysSpecialPosiLimit;
	beforeUpdate(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysSpecialPosiLimit,pSysSpecialPosiLimit,sizeof(CSysSpecialPosiLimit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit,sizeof(CSysSpecialPosiLimit));
	pMem->updateObject(pSysSpecialPosiLimit);
	if (updateIndex) {
	}
	afterUpdate(pSysSpecialPosiLimit);
	if (bNoTransaction) {
		commitUpdate(pSysSpecialPosiLimit,&theOldSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::update(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pNewSysSpecialPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysSpecialPosiLimit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysSpecialPosiLimitResource::alloc(UPDATE_ACTION,this,pSysSpecialPosiLimit,pNewSysSpecialPosiLimit,updateIndex));
		internalUpdate(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit,updateIndex,false);
	}
}

void CSysSpecialPosiLimitFactory::internalRemove(CSysSpecialPosiLimit *pSysSpecialPosiLimit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysSpecialPosiLimit++;
#endif
	CWriteableSysSpecialPosiLimit theOldSysSpecialPosiLimit;
	beforeRemove(pSysSpecialPosiLimit);
	if (bNoTransaction) {
		forceCopy(&theOldSysSpecialPosiLimit,pSysSpecialPosiLimit,sizeof(CSysSpecialPosiLimit));
	}
	if (runLevel>=0) {
		pSysInstrumentIDIndex->removeObject(pSysSpecialPosiLimit);
	}
	pMem->free(pSysSpecialPosiLimit);
	if(bNoTransaction) {
		commitRemove(&theOldSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::remove(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysSpecialPosiLimit,true);
	}
	else {
		pTransaction->addResource(CSysSpecialPosiLimitResource::alloc(DELETE_ACTION,this,pSysSpecialPosiLimit,NULL));
		internalRemove(pSysSpecialPosiLimit,false);		
	}
}

CSysSpecialPosiLimit* CSysSpecialPosiLimitFactory::addOrUpdate(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pNewSysSpecialPosiLimit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysSpecialPosiLimit == NULL) {
		return add(pNewSysSpecialPosiLimit,pTransaction);
	}
	else {
		update(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit,pTransaction,updateIndex);
		return pSysSpecialPosiLimit;
	}
}

void CSysSpecialPosiLimitFactory::retrieve(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pTargetSysSpecialPosiLimit)
{
	forceCopy(pTargetSysSpecialPosiLimit, pSysSpecialPosiLimit, sizeof(CSysSpecialPosiLimit));
}
	
int CSysSpecialPosiLimitFactory::addActionTrigger(CSysSpecialPosiLimitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysSpecialPosiLimitFactory::removeActionTrigger(CSysSpecialPosiLimitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysSpecialPosiLimitFactory::addCommitTrigger(CSysSpecialPosiLimitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysSpecialPosiLimitFactory::removeCommitTrigger(CSysSpecialPosiLimitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysSpecialPosiLimit *CSysSpecialPosiLimitFactory::getFirst(void)
{
	CSysSpecialPosiLimit *pResult=(CSysSpecialPosiLimit *)(pMem->getFirst());
	return pResult;
}
	
CSysSpecialPosiLimit *CSysSpecialPosiLimitFactory::getNext(void)
{
	CSysSpecialPosiLimit *pResult=(CSysSpecialPosiLimit *)(pMem->getNext());
	return pResult;
}
	
void CSysSpecialPosiLimitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysSpecialPosiLimitFactory::beforeAdd(CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysSpecialPosiLimit);
	}
}
	
void CSysSpecialPosiLimitFactory::afterAdd(CSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::beforeUpdate(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pNewSysSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysSpecialPosiLimit,pNewSysSpecialPosiLimit);
	}
}
	
void CSysSpecialPosiLimitFactory::afterUpdate(CSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysSpecialPosiLimit);
	}
}
	
void CSysSpecialPosiLimitFactory::beforeRemove(CSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::commitAdd(CSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::commitUpdate(CSysSpecialPosiLimit *pSysSpecialPosiLimit, CWriteableSysSpecialPosiLimit *pOldSysSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysSpecialPosiLimit,pOldSysSpecialPosiLimit);
	}
}
	
void CSysSpecialPosiLimitFactory::commitRemove(CWriteableSysSpecialPosiLimit *pSysSpecialPosiLimit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysSpecialPosiLimit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysSpecialPosiLimit);
	}
}

void CSysSpecialPosiLimitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysTransactionChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysTransactionChg=0;
int updateWithIndexActionForSysTransactionChg=0;
int updateWithoutIndexActionForSysTransactionChg=0;
int removeActionForSysTransactionChg=0;
int addCommitForSysTransactionChg=0;
int updateCommitForSysTransactionChg=0;
int removeCommitForSysTransactionChg=0;
#endif
void CSysTransactionChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysTransactionChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysTransactionChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysTransactionChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysTransactionChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysTransactionChgActionTrigger *>;
	pCommitTriggers=new vector<CSysTransactionChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysTransactionChgFactory::CSysTransactionChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysTransactionChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysTransactionChgFactory::CSysTransactionChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysTransactionChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysTransactionChgFactory::~CSysTransactionChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysTransactionChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysTransactionChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysTransactionChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysTransactionChg thisSysTransactionChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysTransactionChg.readCSV(input,pNames))
		add(&thisSysTransactionChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysTransactionChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysTransactionChg.csv");
	return readCSV(szFileName);
}

int CSysTransactionChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysTransactionChg *pSysTransactionChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysTransactionChg::writeCSVHead(output);
	pSysTransactionChg=(CWriteableSysTransactionChg *)(pMem->getFirst());
	while (pSysTransactionChg!=NULL) {
		if (!pSysTransactionChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysTransactionChg=(CWriteableSysTransactionChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysTransactionChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysTransactionChg.csv");
	return writeCSV(szFileName);
}

void CSysTransactionChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysTransactionChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysTransactionChg *pSysTransactionChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysTransactionChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysTransactionChg=(CWriteableSysTransactionChg *)(pMem->getFirst());
	while (pSysTransactionChg!=NULL) {
		pSysTransactionChg->dump(fp,index++);
		pSysTransactionChg=(CWriteableSysTransactionChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysTransactionChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysTransactionChg *CSysTransactionChgFactory::internalAdd(CWriteableSysTransactionChg *pSysTransactionChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysTransactionChg++;
#endif
	CSysTransactionChg *pTarget;	
	beforeAdd(pSysTransactionChg);
	pTarget=(CSysTransactionChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysTransactionChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysTransactionChg, sizeof(CSysTransactionChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysTransactionChg *CSysTransactionChgFactory::add(CWriteableSysTransactionChg *pSysTransactionChg, CTransaction *pTransaction)
{
	pSysTransactionChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysTransactionChg,true);
	}
	else {
		CSysTransactionChg *pNewSysTransactionChg;
		pNewSysTransactionChg = internalAdd(pSysTransactionChg,false);
		pTransaction->addResource(CSysTransactionChgResource::alloc(CREATE_ACTION,this,pNewSysTransactionChg,NULL));
		return pNewSysTransactionChg;
	}
}

void CSysTransactionChgFactory::internalUpdate(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pNewSysTransactionChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysTransactionChg++;
	}
	else {
		updateWithoutIndexActionForSysTransactionChg++;
	}
#endif
	CWriteableSysTransactionChg theOldSysTransactionChg;
	beforeUpdate(pSysTransactionChg,pNewSysTransactionChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysTransactionChg,pSysTransactionChg,sizeof(CSysTransactionChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysTransactionChg,pNewSysTransactionChg,sizeof(CSysTransactionChg));
	pMem->updateObject(pSysTransactionChg);
	if (updateIndex) {
	}
	afterUpdate(pSysTransactionChg);
	if (bNoTransaction) {
		commitUpdate(pSysTransactionChg,&theOldSysTransactionChg);
	}
}

void CSysTransactionChgFactory::update(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pNewSysTransactionChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysTransactionChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysTransactionChg,pNewSysTransactionChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysTransactionChgResource::alloc(UPDATE_ACTION,this,pSysTransactionChg,pNewSysTransactionChg,updateIndex));
		internalUpdate(pSysTransactionChg,pNewSysTransactionChg,updateIndex,false);
	}
}

void CSysTransactionChgFactory::internalRemove(CSysTransactionChg *pSysTransactionChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysTransactionChg++;
#endif
	CWriteableSysTransactionChg theOldSysTransactionChg;
	beforeRemove(pSysTransactionChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysTransactionChg,pSysTransactionChg,sizeof(CSysTransactionChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysTransactionChg);
	}
	pMem->free(pSysTransactionChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysTransactionChg);
	}
}

void CSysTransactionChgFactory::remove(CSysTransactionChg *pSysTransactionChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysTransactionChg,true);
	}
	else {
		pTransaction->addResource(CSysTransactionChgResource::alloc(DELETE_ACTION,this,pSysTransactionChg,NULL));
		internalRemove(pSysTransactionChg,false);		
	}
}

CSysTransactionChg* CSysTransactionChgFactory::addOrUpdate(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pNewSysTransactionChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysTransactionChg == NULL) {
		return add(pNewSysTransactionChg,pTransaction);
	}
	else {
		update(pSysTransactionChg,pNewSysTransactionChg,pTransaction,updateIndex);
		return pSysTransactionChg;
	}
}

void CSysTransactionChgFactory::retrieve(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pTargetSysTransactionChg)
{
	forceCopy(pTargetSysTransactionChg, pSysTransactionChg, sizeof(CSysTransactionChg));
}
	
int CSysTransactionChgFactory::addActionTrigger(CSysTransactionChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysTransactionChgFactory::removeActionTrigger(CSysTransactionChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysTransactionChgFactory::addCommitTrigger(CSysTransactionChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysTransactionChgFactory::removeCommitTrigger(CSysTransactionChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysTransactionChg *CSysTransactionChgFactory::getFirst(void)
{
	CSysTransactionChg *pResult=(CSysTransactionChg *)(pMem->getFirst());
	return pResult;
}
	
CSysTransactionChg *CSysTransactionChgFactory::getNext(void)
{
	CSysTransactionChg *pResult=(CSysTransactionChg *)(pMem->getNext());
	return pResult;
}
	
void CSysTransactionChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysTransactionChgFactory::beforeAdd(CWriteableSysTransactionChg *pSysTransactionChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysTransactionChg);
	}
}
	
void CSysTransactionChgFactory::afterAdd(CSysTransactionChg *pSysTransactionChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysTransactionChg);
	}
}

void CSysTransactionChgFactory::beforeUpdate(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pNewSysTransactionChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysTransactionChg,pNewSysTransactionChg);
	}
}
	
void CSysTransactionChgFactory::afterUpdate(CSysTransactionChg *pSysTransactionChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysTransactionChg);
	}
}
	
void CSysTransactionChgFactory::beforeRemove(CSysTransactionChg *pSysTransactionChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysTransactionChg);
	}
}

void CSysTransactionChgFactory::commitAdd(CSysTransactionChg *pSysTransactionChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysTransactionChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysTransactionChg);
	}
}

void CSysTransactionChgFactory::commitUpdate(CSysTransactionChg *pSysTransactionChg, CWriteableSysTransactionChg *pOldSysTransactionChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysTransactionChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysTransactionChg,pOldSysTransactionChg);
	}
}
	
void CSysTransactionChgFactory::commitRemove(CWriteableSysTransactionChg *pSysTransactionChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysTransactionChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysTransactionChg);
	}
}

void CSysTransactionChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysClientChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysClientChg=0;
int updateWithIndexActionForSysClientChg=0;
int updateWithoutIndexActionForSysClientChg=0;
int removeActionForSysClientChg=0;
int addCommitForSysClientChg=0;
int updateCommitForSysClientChg=0;
int removeCommitForSysClientChg=0;
#endif
void CSysClientChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysClientChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysClientChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysClientChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysClientChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysClientChgActionTrigger *>;
	pCommitTriggers=new vector<CSysClientChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysClientChgFactory::CSysClientChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysClientChgFactory::CSysClientChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysClientChgFactory::~CSysClientChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysClientChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysClientChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysClientChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysClientChg thisSysClientChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysClientChg.readCSV(input,pNames))
		add(&thisSysClientChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysClientChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysClientChg.csv");
	return readCSV(szFileName);
}

int CSysClientChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysClientChg *pSysClientChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysClientChg::writeCSVHead(output);
	pSysClientChg=(CWriteableSysClientChg *)(pMem->getFirst());
	while (pSysClientChg!=NULL) {
		if (!pSysClientChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysClientChg=(CWriteableSysClientChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysClientChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysClientChg.csv");
	return writeCSV(szFileName);
}

void CSysClientChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysClientChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysClientChg *pSysClientChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysClientChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysClientChg=(CWriteableSysClientChg *)(pMem->getFirst());
	while (pSysClientChg!=NULL) {
		pSysClientChg->dump(fp,index++);
		pSysClientChg=(CWriteableSysClientChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysClientChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysClientChg *CSysClientChgFactory::internalAdd(CWriteableSysClientChg *pSysClientChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysClientChg++;
#endif
	CSysClientChg *pTarget;	
	beforeAdd(pSysClientChg);
	pTarget=(CSysClientChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysClientChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysClientChg, sizeof(CSysClientChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysClientChg *CSysClientChgFactory::add(CWriteableSysClientChg *pSysClientChg, CTransaction *pTransaction)
{
	pSysClientChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysClientChg,true);
	}
	else {
		CSysClientChg *pNewSysClientChg;
		pNewSysClientChg = internalAdd(pSysClientChg,false);
		pTransaction->addResource(CSysClientChgResource::alloc(CREATE_ACTION,this,pNewSysClientChg,NULL));
		return pNewSysClientChg;
	}
}

void CSysClientChgFactory::internalUpdate(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pNewSysClientChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysClientChg++;
	}
	else {
		updateWithoutIndexActionForSysClientChg++;
	}
#endif
	CWriteableSysClientChg theOldSysClientChg;
	beforeUpdate(pSysClientChg,pNewSysClientChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientChg,pSysClientChg,sizeof(CSysClientChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysClientChg,pNewSysClientChg,sizeof(CSysClientChg));
	pMem->updateObject(pSysClientChg);
	if (updateIndex) {
	}
	afterUpdate(pSysClientChg);
	if (bNoTransaction) {
		commitUpdate(pSysClientChg,&theOldSysClientChg);
	}
}

void CSysClientChgFactory::update(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pNewSysClientChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysClientChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysClientChg,pNewSysClientChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysClientChgResource::alloc(UPDATE_ACTION,this,pSysClientChg,pNewSysClientChg,updateIndex));
		internalUpdate(pSysClientChg,pNewSysClientChg,updateIndex,false);
	}
}

void CSysClientChgFactory::internalRemove(CSysClientChg *pSysClientChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysClientChg++;
#endif
	CWriteableSysClientChg theOldSysClientChg;
	beforeRemove(pSysClientChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientChg,pSysClientChg,sizeof(CSysClientChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysClientChg);
	}
	pMem->free(pSysClientChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysClientChg);
	}
}

void CSysClientChgFactory::remove(CSysClientChg *pSysClientChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysClientChg,true);
	}
	else {
		pTransaction->addResource(CSysClientChgResource::alloc(DELETE_ACTION,this,pSysClientChg,NULL));
		internalRemove(pSysClientChg,false);		
	}
}

CSysClientChg* CSysClientChgFactory::addOrUpdate(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pNewSysClientChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysClientChg == NULL) {
		return add(pNewSysClientChg,pTransaction);
	}
	else {
		update(pSysClientChg,pNewSysClientChg,pTransaction,updateIndex);
		return pSysClientChg;
	}
}

void CSysClientChgFactory::retrieve(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pTargetSysClientChg)
{
	forceCopy(pTargetSysClientChg, pSysClientChg, sizeof(CSysClientChg));
}
	
int CSysClientChgFactory::addActionTrigger(CSysClientChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysClientChgFactory::removeActionTrigger(CSysClientChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysClientChgFactory::addCommitTrigger(CSysClientChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysClientChgFactory::removeCommitTrigger(CSysClientChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysClientChg *CSysClientChgFactory::getFirst(void)
{
	CSysClientChg *pResult=(CSysClientChg *)(pMem->getFirst());
	return pResult;
}
	
CSysClientChg *CSysClientChgFactory::getNext(void)
{
	CSysClientChg *pResult=(CSysClientChg *)(pMem->getNext());
	return pResult;
}
	
void CSysClientChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysClientChgFactory::beforeAdd(CWriteableSysClientChg *pSysClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysClientChg);
	}
}
	
void CSysClientChgFactory::afterAdd(CSysClientChg *pSysClientChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysClientChg);
	}
}

void CSysClientChgFactory::beforeUpdate(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pNewSysClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysClientChg,pNewSysClientChg);
	}
}
	
void CSysClientChgFactory::afterUpdate(CSysClientChg *pSysClientChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysClientChg);
	}
}
	
void CSysClientChgFactory::beforeRemove(CSysClientChg *pSysClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysClientChg);
	}
}

void CSysClientChgFactory::commitAdd(CSysClientChg *pSysClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysClientChg);
	}
}

void CSysClientChgFactory::commitUpdate(CSysClientChg *pSysClientChg, CWriteableSysClientChg *pOldSysClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysClientChg,pOldSysClientChg);
	}
}
	
void CSysClientChgFactory::commitRemove(CWriteableSysClientChg *pSysClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysClientChg);
	}
}

void CSysClientChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysPartClientChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysPartClientChg=0;
int updateWithIndexActionForSysPartClientChg=0;
int updateWithoutIndexActionForSysPartClientChg=0;
int removeActionForSysPartClientChg=0;
int addCommitForSysPartClientChg=0;
int updateCommitForSysPartClientChg=0;
int removeCommitForSysPartClientChg=0;
#endif
void CSysPartClientChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysPartClientChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysPartClientChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysPartClientChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysPartClientChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysPartClientChgActionTrigger *>;
	pCommitTriggers=new vector<CSysPartClientChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysPartClientChgFactory::CSysPartClientChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartClientChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysPartClientChgFactory::CSysPartClientChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartClientChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysPartClientChgFactory::~CSysPartClientChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysPartClientChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysPartClientChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysPartClientChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysPartClientChg thisSysPartClientChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysPartClientChg.readCSV(input,pNames))
		add(&thisSysPartClientChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysPartClientChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysPartClientChg.csv");
	return readCSV(szFileName);
}

int CSysPartClientChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysPartClientChg *pSysPartClientChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysPartClientChg::writeCSVHead(output);
	pSysPartClientChg=(CWriteableSysPartClientChg *)(pMem->getFirst());
	while (pSysPartClientChg!=NULL) {
		if (!pSysPartClientChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysPartClientChg=(CWriteableSysPartClientChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysPartClientChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysPartClientChg.csv");
	return writeCSV(szFileName);
}

void CSysPartClientChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysPartClientChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysPartClientChg *pSysPartClientChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysPartClientChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysPartClientChg=(CWriteableSysPartClientChg *)(pMem->getFirst());
	while (pSysPartClientChg!=NULL) {
		pSysPartClientChg->dump(fp,index++);
		pSysPartClientChg=(CWriteableSysPartClientChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysPartClientChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysPartClientChg *CSysPartClientChgFactory::internalAdd(CWriteableSysPartClientChg *pSysPartClientChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysPartClientChg++;
#endif
	CSysPartClientChg *pTarget;	
	beforeAdd(pSysPartClientChg);
	pTarget=(CSysPartClientChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysPartClientChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysPartClientChg, sizeof(CSysPartClientChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysPartClientChg *CSysPartClientChgFactory::add(CWriteableSysPartClientChg *pSysPartClientChg, CTransaction *pTransaction)
{
	pSysPartClientChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysPartClientChg,true);
	}
	else {
		CSysPartClientChg *pNewSysPartClientChg;
		pNewSysPartClientChg = internalAdd(pSysPartClientChg,false);
		pTransaction->addResource(CSysPartClientChgResource::alloc(CREATE_ACTION,this,pNewSysPartClientChg,NULL));
		return pNewSysPartClientChg;
	}
}

void CSysPartClientChgFactory::internalUpdate(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pNewSysPartClientChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysPartClientChg++;
	}
	else {
		updateWithoutIndexActionForSysPartClientChg++;
	}
#endif
	CWriteableSysPartClientChg theOldSysPartClientChg;
	beforeUpdate(pSysPartClientChg,pNewSysPartClientChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartClientChg,pSysPartClientChg,sizeof(CSysPartClientChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysPartClientChg,pNewSysPartClientChg,sizeof(CSysPartClientChg));
	pMem->updateObject(pSysPartClientChg);
	if (updateIndex) {
	}
	afterUpdate(pSysPartClientChg);
	if (bNoTransaction) {
		commitUpdate(pSysPartClientChg,&theOldSysPartClientChg);
	}
}

void CSysPartClientChgFactory::update(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pNewSysPartClientChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysPartClientChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysPartClientChg,pNewSysPartClientChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysPartClientChgResource::alloc(UPDATE_ACTION,this,pSysPartClientChg,pNewSysPartClientChg,updateIndex));
		internalUpdate(pSysPartClientChg,pNewSysPartClientChg,updateIndex,false);
	}
}

void CSysPartClientChgFactory::internalRemove(CSysPartClientChg *pSysPartClientChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysPartClientChg++;
#endif
	CWriteableSysPartClientChg theOldSysPartClientChg;
	beforeRemove(pSysPartClientChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartClientChg,pSysPartClientChg,sizeof(CSysPartClientChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysPartClientChg);
	}
	pMem->free(pSysPartClientChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysPartClientChg);
	}
}

void CSysPartClientChgFactory::remove(CSysPartClientChg *pSysPartClientChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysPartClientChg,true);
	}
	else {
		pTransaction->addResource(CSysPartClientChgResource::alloc(DELETE_ACTION,this,pSysPartClientChg,NULL));
		internalRemove(pSysPartClientChg,false);		
	}
}

CSysPartClientChg* CSysPartClientChgFactory::addOrUpdate(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pNewSysPartClientChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysPartClientChg == NULL) {
		return add(pNewSysPartClientChg,pTransaction);
	}
	else {
		update(pSysPartClientChg,pNewSysPartClientChg,pTransaction,updateIndex);
		return pSysPartClientChg;
	}
}

void CSysPartClientChgFactory::retrieve(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pTargetSysPartClientChg)
{
	forceCopy(pTargetSysPartClientChg, pSysPartClientChg, sizeof(CSysPartClientChg));
}
	
int CSysPartClientChgFactory::addActionTrigger(CSysPartClientChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysPartClientChgFactory::removeActionTrigger(CSysPartClientChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysPartClientChgFactory::addCommitTrigger(CSysPartClientChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysPartClientChgFactory::removeCommitTrigger(CSysPartClientChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysPartClientChg *CSysPartClientChgFactory::getFirst(void)
{
	CSysPartClientChg *pResult=(CSysPartClientChg *)(pMem->getFirst());
	return pResult;
}
	
CSysPartClientChg *CSysPartClientChgFactory::getNext(void)
{
	CSysPartClientChg *pResult=(CSysPartClientChg *)(pMem->getNext());
	return pResult;
}
	
void CSysPartClientChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysPartClientChgFactory::beforeAdd(CWriteableSysPartClientChg *pSysPartClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysPartClientChg);
	}
}
	
void CSysPartClientChgFactory::afterAdd(CSysPartClientChg *pSysPartClientChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysPartClientChg);
	}
}

void CSysPartClientChgFactory::beforeUpdate(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pNewSysPartClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysPartClientChg,pNewSysPartClientChg);
	}
}
	
void CSysPartClientChgFactory::afterUpdate(CSysPartClientChg *pSysPartClientChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysPartClientChg);
	}
}
	
void CSysPartClientChgFactory::beforeRemove(CSysPartClientChg *pSysPartClientChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysPartClientChg);
	}
}

void CSysPartClientChgFactory::commitAdd(CSysPartClientChg *pSysPartClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysPartClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysPartClientChg);
	}
}

void CSysPartClientChgFactory::commitUpdate(CSysPartClientChg *pSysPartClientChg, CWriteableSysPartClientChg *pOldSysPartClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysPartClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysPartClientChg,pOldSysPartClientChg);
	}
}
	
void CSysPartClientChgFactory::commitRemove(CWriteableSysPartClientChg *pSysPartClientChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysPartClientChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysPartClientChg);
	}
}

void CSysPartClientChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysPosiLimitChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysPosiLimitChg=0;
int updateWithIndexActionForSysPosiLimitChg=0;
int updateWithoutIndexActionForSysPosiLimitChg=0;
int removeActionForSysPosiLimitChg=0;
int addCommitForSysPosiLimitChg=0;
int updateCommitForSysPosiLimitChg=0;
int removeCommitForSysPosiLimitChg=0;
#endif
void CSysPosiLimitChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysPosiLimitChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysPosiLimitChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysPosiLimitChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysPosiLimitChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysPosiLimitChgActionTrigger *>;
	pCommitTriggers=new vector<CSysPosiLimitChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysPosiLimitChgFactory::CSysPosiLimitChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPosiLimitChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysPosiLimitChgFactory::CSysPosiLimitChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPosiLimitChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysPosiLimitChgFactory::~CSysPosiLimitChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysPosiLimitChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysPosiLimitChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysPosiLimitChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysPosiLimitChg thisSysPosiLimitChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysPosiLimitChg.readCSV(input,pNames))
		add(&thisSysPosiLimitChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysPosiLimitChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysPosiLimitChg.csv");
	return readCSV(szFileName);
}

int CSysPosiLimitChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysPosiLimitChg *pSysPosiLimitChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysPosiLimitChg::writeCSVHead(output);
	pSysPosiLimitChg=(CWriteableSysPosiLimitChg *)(pMem->getFirst());
	while (pSysPosiLimitChg!=NULL) {
		if (!pSysPosiLimitChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysPosiLimitChg=(CWriteableSysPosiLimitChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysPosiLimitChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysPosiLimitChg.csv");
	return writeCSV(szFileName);
}

void CSysPosiLimitChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysPosiLimitChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysPosiLimitChg *pSysPosiLimitChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysPosiLimitChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysPosiLimitChg=(CWriteableSysPosiLimitChg *)(pMem->getFirst());
	while (pSysPosiLimitChg!=NULL) {
		pSysPosiLimitChg->dump(fp,index++);
		pSysPosiLimitChg=(CWriteableSysPosiLimitChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysPosiLimitChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysPosiLimitChg *CSysPosiLimitChgFactory::internalAdd(CWriteableSysPosiLimitChg *pSysPosiLimitChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysPosiLimitChg++;
#endif
	CSysPosiLimitChg *pTarget;	
	beforeAdd(pSysPosiLimitChg);
	pTarget=(CSysPosiLimitChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysPosiLimitChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysPosiLimitChg, sizeof(CSysPosiLimitChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysPosiLimitChg *CSysPosiLimitChgFactory::add(CWriteableSysPosiLimitChg *pSysPosiLimitChg, CTransaction *pTransaction)
{
	pSysPosiLimitChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysPosiLimitChg,true);
	}
	else {
		CSysPosiLimitChg *pNewSysPosiLimitChg;
		pNewSysPosiLimitChg = internalAdd(pSysPosiLimitChg,false);
		pTransaction->addResource(CSysPosiLimitChgResource::alloc(CREATE_ACTION,this,pNewSysPosiLimitChg,NULL));
		return pNewSysPosiLimitChg;
	}
}

void CSysPosiLimitChgFactory::internalUpdate(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pNewSysPosiLimitChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysPosiLimitChg++;
	}
	else {
		updateWithoutIndexActionForSysPosiLimitChg++;
	}
#endif
	CWriteableSysPosiLimitChg theOldSysPosiLimitChg;
	beforeUpdate(pSysPosiLimitChg,pNewSysPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysPosiLimitChg,pSysPosiLimitChg,sizeof(CSysPosiLimitChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysPosiLimitChg,pNewSysPosiLimitChg,sizeof(CSysPosiLimitChg));
	pMem->updateObject(pSysPosiLimitChg);
	if (updateIndex) {
	}
	afterUpdate(pSysPosiLimitChg);
	if (bNoTransaction) {
		commitUpdate(pSysPosiLimitChg,&theOldSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::update(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pNewSysPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysPosiLimitChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysPosiLimitChg,pNewSysPosiLimitChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysPosiLimitChgResource::alloc(UPDATE_ACTION,this,pSysPosiLimitChg,pNewSysPosiLimitChg,updateIndex));
		internalUpdate(pSysPosiLimitChg,pNewSysPosiLimitChg,updateIndex,false);
	}
}

void CSysPosiLimitChgFactory::internalRemove(CSysPosiLimitChg *pSysPosiLimitChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysPosiLimitChg++;
#endif
	CWriteableSysPosiLimitChg theOldSysPosiLimitChg;
	beforeRemove(pSysPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysPosiLimitChg,pSysPosiLimitChg,sizeof(CSysPosiLimitChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysPosiLimitChg);
	}
	pMem->free(pSysPosiLimitChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::remove(CSysPosiLimitChg *pSysPosiLimitChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysPosiLimitChg,true);
	}
	else {
		pTransaction->addResource(CSysPosiLimitChgResource::alloc(DELETE_ACTION,this,pSysPosiLimitChg,NULL));
		internalRemove(pSysPosiLimitChg,false);		
	}
}

CSysPosiLimitChg* CSysPosiLimitChgFactory::addOrUpdate(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pNewSysPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysPosiLimitChg == NULL) {
		return add(pNewSysPosiLimitChg,pTransaction);
	}
	else {
		update(pSysPosiLimitChg,pNewSysPosiLimitChg,pTransaction,updateIndex);
		return pSysPosiLimitChg;
	}
}

void CSysPosiLimitChgFactory::retrieve(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pTargetSysPosiLimitChg)
{
	forceCopy(pTargetSysPosiLimitChg, pSysPosiLimitChg, sizeof(CSysPosiLimitChg));
}
	
int CSysPosiLimitChgFactory::addActionTrigger(CSysPosiLimitChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysPosiLimitChgFactory::removeActionTrigger(CSysPosiLimitChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysPosiLimitChgFactory::addCommitTrigger(CSysPosiLimitChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysPosiLimitChgFactory::removeCommitTrigger(CSysPosiLimitChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysPosiLimitChg *CSysPosiLimitChgFactory::getFirst(void)
{
	CSysPosiLimitChg *pResult=(CSysPosiLimitChg *)(pMem->getFirst());
	return pResult;
}
	
CSysPosiLimitChg *CSysPosiLimitChgFactory::getNext(void)
{
	CSysPosiLimitChg *pResult=(CSysPosiLimitChg *)(pMem->getNext());
	return pResult;
}
	
void CSysPosiLimitChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysPosiLimitChgFactory::beforeAdd(CWriteableSysPosiLimitChg *pSysPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysPosiLimitChg);
	}
}
	
void CSysPosiLimitChgFactory::afterAdd(CSysPosiLimitChg *pSysPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::beforeUpdate(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pNewSysPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysPosiLimitChg,pNewSysPosiLimitChg);
	}
}
	
void CSysPosiLimitChgFactory::afterUpdate(CSysPosiLimitChg *pSysPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysPosiLimitChg);
	}
}
	
void CSysPosiLimitChgFactory::beforeRemove(CSysPosiLimitChg *pSysPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::commitAdd(CSysPosiLimitChg *pSysPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::commitUpdate(CSysPosiLimitChg *pSysPosiLimitChg, CWriteableSysPosiLimitChg *pOldSysPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysPosiLimitChg,pOldSysPosiLimitChg);
	}
}
	
void CSysPosiLimitChgFactory::commitRemove(CWriteableSysPosiLimitChg *pSysPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysPosiLimitChg);
	}
}

void CSysPosiLimitChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysClientPosiLimitChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysClientPosiLimitChg=0;
int updateWithIndexActionForSysClientPosiLimitChg=0;
int updateWithoutIndexActionForSysClientPosiLimitChg=0;
int removeActionForSysClientPosiLimitChg=0;
int addCommitForSysClientPosiLimitChg=0;
int updateCommitForSysClientPosiLimitChg=0;
int removeCommitForSysClientPosiLimitChg=0;
#endif
void CSysClientPosiLimitChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysClientPosiLimitChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysClientPosiLimitChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysClientPosiLimitChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysClientPosiLimitChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysClientPosiLimitChgActionTrigger *>;
	pCommitTriggers=new vector<CSysClientPosiLimitChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysClientPosiLimitChgFactory::CSysClientPosiLimitChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientPosiLimitChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysClientPosiLimitChgFactory::CSysClientPosiLimitChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientPosiLimitChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysClientPosiLimitChgFactory::~CSysClientPosiLimitChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysClientPosiLimitChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysClientPosiLimitChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysClientPosiLimitChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysClientPosiLimitChg thisSysClientPosiLimitChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysClientPosiLimitChg.readCSV(input,pNames))
		add(&thisSysClientPosiLimitChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysClientPosiLimitChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysClientPosiLimitChg.csv");
	return readCSV(szFileName);
}

int CSysClientPosiLimitChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysClientPosiLimitChg::writeCSVHead(output);
	pSysClientPosiLimitChg=(CWriteableSysClientPosiLimitChg *)(pMem->getFirst());
	while (pSysClientPosiLimitChg!=NULL) {
		if (!pSysClientPosiLimitChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysClientPosiLimitChg=(CWriteableSysClientPosiLimitChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysClientPosiLimitChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysClientPosiLimitChg.csv");
	return writeCSV(szFileName);
}

void CSysClientPosiLimitChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysClientPosiLimitChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysClientPosiLimitChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysClientPosiLimitChg=(CWriteableSysClientPosiLimitChg *)(pMem->getFirst());
	while (pSysClientPosiLimitChg!=NULL) {
		pSysClientPosiLimitChg->dump(fp,index++);
		pSysClientPosiLimitChg=(CWriteableSysClientPosiLimitChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysClientPosiLimitChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysClientPosiLimitChg *CSysClientPosiLimitChgFactory::internalAdd(CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysClientPosiLimitChg++;
#endif
	CSysClientPosiLimitChg *pTarget;	
	beforeAdd(pSysClientPosiLimitChg);
	pTarget=(CSysClientPosiLimitChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysClientPosiLimitChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysClientPosiLimitChg, sizeof(CSysClientPosiLimitChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysClientPosiLimitChg *CSysClientPosiLimitChgFactory::add(CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg, CTransaction *pTransaction)
{
	pSysClientPosiLimitChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysClientPosiLimitChg,true);
	}
	else {
		CSysClientPosiLimitChg *pNewSysClientPosiLimitChg;
		pNewSysClientPosiLimitChg = internalAdd(pSysClientPosiLimitChg,false);
		pTransaction->addResource(CSysClientPosiLimitChgResource::alloc(CREATE_ACTION,this,pNewSysClientPosiLimitChg,NULL));
		return pNewSysClientPosiLimitChg;
	}
}

void CSysClientPosiLimitChgFactory::internalUpdate(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pNewSysClientPosiLimitChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysClientPosiLimitChg++;
	}
	else {
		updateWithoutIndexActionForSysClientPosiLimitChg++;
	}
#endif
	CWriteableSysClientPosiLimitChg theOldSysClientPosiLimitChg;
	beforeUpdate(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientPosiLimitChg,pSysClientPosiLimitChg,sizeof(CSysClientPosiLimitChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg,sizeof(CSysClientPosiLimitChg));
	pMem->updateObject(pSysClientPosiLimitChg);
	if (updateIndex) {
	}
	afterUpdate(pSysClientPosiLimitChg);
	if (bNoTransaction) {
		commitUpdate(pSysClientPosiLimitChg,&theOldSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::update(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pNewSysClientPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysClientPosiLimitChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysClientPosiLimitChgResource::alloc(UPDATE_ACTION,this,pSysClientPosiLimitChg,pNewSysClientPosiLimitChg,updateIndex));
		internalUpdate(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg,updateIndex,false);
	}
}

void CSysClientPosiLimitChgFactory::internalRemove(CSysClientPosiLimitChg *pSysClientPosiLimitChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysClientPosiLimitChg++;
#endif
	CWriteableSysClientPosiLimitChg theOldSysClientPosiLimitChg;
	beforeRemove(pSysClientPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientPosiLimitChg,pSysClientPosiLimitChg,sizeof(CSysClientPosiLimitChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysClientPosiLimitChg);
	}
	pMem->free(pSysClientPosiLimitChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::remove(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysClientPosiLimitChg,true);
	}
	else {
		pTransaction->addResource(CSysClientPosiLimitChgResource::alloc(DELETE_ACTION,this,pSysClientPosiLimitChg,NULL));
		internalRemove(pSysClientPosiLimitChg,false);		
	}
}

CSysClientPosiLimitChg* CSysClientPosiLimitChgFactory::addOrUpdate(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pNewSysClientPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysClientPosiLimitChg == NULL) {
		return add(pNewSysClientPosiLimitChg,pTransaction);
	}
	else {
		update(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg,pTransaction,updateIndex);
		return pSysClientPosiLimitChg;
	}
}

void CSysClientPosiLimitChgFactory::retrieve(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pTargetSysClientPosiLimitChg)
{
	forceCopy(pTargetSysClientPosiLimitChg, pSysClientPosiLimitChg, sizeof(CSysClientPosiLimitChg));
}
	
int CSysClientPosiLimitChgFactory::addActionTrigger(CSysClientPosiLimitChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysClientPosiLimitChgFactory::removeActionTrigger(CSysClientPosiLimitChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysClientPosiLimitChgFactory::addCommitTrigger(CSysClientPosiLimitChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysClientPosiLimitChgFactory::removeCommitTrigger(CSysClientPosiLimitChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysClientPosiLimitChg *CSysClientPosiLimitChgFactory::getFirst(void)
{
	CSysClientPosiLimitChg *pResult=(CSysClientPosiLimitChg *)(pMem->getFirst());
	return pResult;
}
	
CSysClientPosiLimitChg *CSysClientPosiLimitChgFactory::getNext(void)
{
	CSysClientPosiLimitChg *pResult=(CSysClientPosiLimitChg *)(pMem->getNext());
	return pResult;
}
	
void CSysClientPosiLimitChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysClientPosiLimitChgFactory::beforeAdd(CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysClientPosiLimitChg);
	}
}
	
void CSysClientPosiLimitChgFactory::afterAdd(CSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::beforeUpdate(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pNewSysClientPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysClientPosiLimitChg,pNewSysClientPosiLimitChg);
	}
}
	
void CSysClientPosiLimitChgFactory::afterUpdate(CSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysClientPosiLimitChg);
	}
}
	
void CSysClientPosiLimitChgFactory::beforeRemove(CSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::commitAdd(CSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysClientPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::commitUpdate(CSysClientPosiLimitChg *pSysClientPosiLimitChg, CWriteableSysClientPosiLimitChg *pOldSysClientPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysClientPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysClientPosiLimitChg,pOldSysClientPosiLimitChg);
	}
}
	
void CSysClientPosiLimitChgFactory::commitRemove(CWriteableSysClientPosiLimitChg *pSysClientPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysClientPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysClientPosiLimitChg);
	}
}

void CSysClientPosiLimitChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysSpecPosiLimitChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysSpecPosiLimitChg=0;
int updateWithIndexActionForSysSpecPosiLimitChg=0;
int updateWithoutIndexActionForSysSpecPosiLimitChg=0;
int removeActionForSysSpecPosiLimitChg=0;
int addCommitForSysSpecPosiLimitChg=0;
int updateCommitForSysSpecPosiLimitChg=0;
int removeCommitForSysSpecPosiLimitChg=0;
#endif
void CSysSpecPosiLimitChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysSpecPosiLimitChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysSpecPosiLimitChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysSpecPosiLimitChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysSpecPosiLimitChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysSpecPosiLimitChgActionTrigger *>;
	pCommitTriggers=new vector<CSysSpecPosiLimitChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysSpecPosiLimitChgFactory::CSysSpecPosiLimitChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysSpecPosiLimitChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysSpecPosiLimitChgFactory::CSysSpecPosiLimitChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysSpecPosiLimitChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysSpecPosiLimitChgFactory::~CSysSpecPosiLimitChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysSpecPosiLimitChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysSpecPosiLimitChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysSpecPosiLimitChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysSpecPosiLimitChg thisSysSpecPosiLimitChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysSpecPosiLimitChg.readCSV(input,pNames))
		add(&thisSysSpecPosiLimitChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysSpecPosiLimitChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysSpecPosiLimitChg.csv");
	return readCSV(szFileName);
}

int CSysSpecPosiLimitChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysSpecPosiLimitChg::writeCSVHead(output);
	pSysSpecPosiLimitChg=(CWriteableSysSpecPosiLimitChg *)(pMem->getFirst());
	while (pSysSpecPosiLimitChg!=NULL) {
		if (!pSysSpecPosiLimitChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysSpecPosiLimitChg=(CWriteableSysSpecPosiLimitChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysSpecPosiLimitChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysSpecPosiLimitChg.csv");
	return writeCSV(szFileName);
}

void CSysSpecPosiLimitChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysSpecPosiLimitChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysSpecPosiLimitChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysSpecPosiLimitChg=(CWriteableSysSpecPosiLimitChg *)(pMem->getFirst());
	while (pSysSpecPosiLimitChg!=NULL) {
		pSysSpecPosiLimitChg->dump(fp,index++);
		pSysSpecPosiLimitChg=(CWriteableSysSpecPosiLimitChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysSpecPosiLimitChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysSpecPosiLimitChg *CSysSpecPosiLimitChgFactory::internalAdd(CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysSpecPosiLimitChg++;
#endif
	CSysSpecPosiLimitChg *pTarget;	
	beforeAdd(pSysSpecPosiLimitChg);
	pTarget=(CSysSpecPosiLimitChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysSpecPosiLimitChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysSpecPosiLimitChg, sizeof(CSysSpecPosiLimitChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysSpecPosiLimitChg *CSysSpecPosiLimitChgFactory::add(CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CTransaction *pTransaction)
{
	pSysSpecPosiLimitChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysSpecPosiLimitChg,true);
	}
	else {
		CSysSpecPosiLimitChg *pNewSysSpecPosiLimitChg;
		pNewSysSpecPosiLimitChg = internalAdd(pSysSpecPosiLimitChg,false);
		pTransaction->addResource(CSysSpecPosiLimitChgResource::alloc(CREATE_ACTION,this,pNewSysSpecPosiLimitChg,NULL));
		return pNewSysSpecPosiLimitChg;
	}
}

void CSysSpecPosiLimitChgFactory::internalUpdate(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pNewSysSpecPosiLimitChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysSpecPosiLimitChg++;
	}
	else {
		updateWithoutIndexActionForSysSpecPosiLimitChg++;
	}
#endif
	CWriteableSysSpecPosiLimitChg theOldSysSpecPosiLimitChg;
	beforeUpdate(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysSpecPosiLimitChg,pSysSpecPosiLimitChg,sizeof(CSysSpecPosiLimitChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg,sizeof(CSysSpecPosiLimitChg));
	pMem->updateObject(pSysSpecPosiLimitChg);
	if (updateIndex) {
	}
	afterUpdate(pSysSpecPosiLimitChg);
	if (bNoTransaction) {
		commitUpdate(pSysSpecPosiLimitChg,&theOldSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::update(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pNewSysSpecPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysSpecPosiLimitChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysSpecPosiLimitChgResource::alloc(UPDATE_ACTION,this,pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg,updateIndex));
		internalUpdate(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg,updateIndex,false);
	}
}

void CSysSpecPosiLimitChgFactory::internalRemove(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysSpecPosiLimitChg++;
#endif
	CWriteableSysSpecPosiLimitChg theOldSysSpecPosiLimitChg;
	beforeRemove(pSysSpecPosiLimitChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysSpecPosiLimitChg,pSysSpecPosiLimitChg,sizeof(CSysSpecPosiLimitChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysSpecPosiLimitChg);
	}
	pMem->free(pSysSpecPosiLimitChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::remove(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysSpecPosiLimitChg,true);
	}
	else {
		pTransaction->addResource(CSysSpecPosiLimitChgResource::alloc(DELETE_ACTION,this,pSysSpecPosiLimitChg,NULL));
		internalRemove(pSysSpecPosiLimitChg,false);		
	}
}

CSysSpecPosiLimitChg* CSysSpecPosiLimitChgFactory::addOrUpdate(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pNewSysSpecPosiLimitChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysSpecPosiLimitChg == NULL) {
		return add(pNewSysSpecPosiLimitChg,pTransaction);
	}
	else {
		update(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg,pTransaction,updateIndex);
		return pSysSpecPosiLimitChg;
	}
}

void CSysSpecPosiLimitChgFactory::retrieve(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pTargetSysSpecPosiLimitChg)
{
	forceCopy(pTargetSysSpecPosiLimitChg, pSysSpecPosiLimitChg, sizeof(CSysSpecPosiLimitChg));
}
	
int CSysSpecPosiLimitChgFactory::addActionTrigger(CSysSpecPosiLimitChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysSpecPosiLimitChgFactory::removeActionTrigger(CSysSpecPosiLimitChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysSpecPosiLimitChgFactory::addCommitTrigger(CSysSpecPosiLimitChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysSpecPosiLimitChgFactory::removeCommitTrigger(CSysSpecPosiLimitChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysSpecPosiLimitChg *CSysSpecPosiLimitChgFactory::getFirst(void)
{
	CSysSpecPosiLimitChg *pResult=(CSysSpecPosiLimitChg *)(pMem->getFirst());
	return pResult;
}
	
CSysSpecPosiLimitChg *CSysSpecPosiLimitChgFactory::getNext(void)
{
	CSysSpecPosiLimitChg *pResult=(CSysSpecPosiLimitChg *)(pMem->getNext());
	return pResult;
}
	
void CSysSpecPosiLimitChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysSpecPosiLimitChgFactory::beforeAdd(CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysSpecPosiLimitChg);
	}
}
	
void CSysSpecPosiLimitChgFactory::afterAdd(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::beforeUpdate(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pNewSysSpecPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysSpecPosiLimitChg,pNewSysSpecPosiLimitChg);
	}
}
	
void CSysSpecPosiLimitChgFactory::afterUpdate(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysSpecPosiLimitChg);
	}
}
	
void CSysSpecPosiLimitChgFactory::beforeRemove(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::commitAdd(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysSpecPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::commitUpdate(CSysSpecPosiLimitChg *pSysSpecPosiLimitChg, CWriteableSysSpecPosiLimitChg *pOldSysSpecPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysSpecPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysSpecPosiLimitChg,pOldSysSpecPosiLimitChg);
	}
}
	
void CSysSpecPosiLimitChgFactory::commitRemove(CWriteableSysSpecPosiLimitChg *pSysSpecPosiLimitChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysSpecPosiLimitChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysSpecPosiLimitChg);
	}
}

void CSysSpecPosiLimitChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysHedgeDetailChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysHedgeDetailChg=0;
int updateWithIndexActionForSysHedgeDetailChg=0;
int updateWithoutIndexActionForSysHedgeDetailChg=0;
int removeActionForSysHedgeDetailChg=0;
int addCommitForSysHedgeDetailChg=0;
int updateCommitForSysHedgeDetailChg=0;
int removeCommitForSysHedgeDetailChg=0;
#endif
void CSysHedgeDetailChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysHedgeDetailChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysHedgeDetailChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysHedgeDetailChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysHedgeDetailChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysHedgeDetailChgActionTrigger *>;
	pCommitTriggers=new vector<CSysHedgeDetailChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysHedgeDetailChgFactory::CSysHedgeDetailChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysHedgeDetailChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysHedgeDetailChgFactory::CSysHedgeDetailChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysHedgeDetailChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysHedgeDetailChgFactory::~CSysHedgeDetailChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysHedgeDetailChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysHedgeDetailChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysHedgeDetailChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysHedgeDetailChg thisSysHedgeDetailChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysHedgeDetailChg.readCSV(input,pNames))
		add(&thisSysHedgeDetailChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysHedgeDetailChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysHedgeDetailChg.csv");
	return readCSV(szFileName);
}

int CSysHedgeDetailChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysHedgeDetailChg *pSysHedgeDetailChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysHedgeDetailChg::writeCSVHead(output);
	pSysHedgeDetailChg=(CWriteableSysHedgeDetailChg *)(pMem->getFirst());
	while (pSysHedgeDetailChg!=NULL) {
		if (!pSysHedgeDetailChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysHedgeDetailChg=(CWriteableSysHedgeDetailChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysHedgeDetailChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysHedgeDetailChg.csv");
	return writeCSV(szFileName);
}

void CSysHedgeDetailChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysHedgeDetailChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysHedgeDetailChg *pSysHedgeDetailChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysHedgeDetailChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysHedgeDetailChg=(CWriteableSysHedgeDetailChg *)(pMem->getFirst());
	while (pSysHedgeDetailChg!=NULL) {
		pSysHedgeDetailChg->dump(fp,index++);
		pSysHedgeDetailChg=(CWriteableSysHedgeDetailChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysHedgeDetailChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysHedgeDetailChg *CSysHedgeDetailChgFactory::internalAdd(CWriteableSysHedgeDetailChg *pSysHedgeDetailChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysHedgeDetailChg++;
#endif
	CSysHedgeDetailChg *pTarget;	
	beforeAdd(pSysHedgeDetailChg);
	pTarget=(CSysHedgeDetailChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysHedgeDetailChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysHedgeDetailChg, sizeof(CSysHedgeDetailChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysHedgeDetailChg *CSysHedgeDetailChgFactory::add(CWriteableSysHedgeDetailChg *pSysHedgeDetailChg, CTransaction *pTransaction)
{
	pSysHedgeDetailChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysHedgeDetailChg,true);
	}
	else {
		CSysHedgeDetailChg *pNewSysHedgeDetailChg;
		pNewSysHedgeDetailChg = internalAdd(pSysHedgeDetailChg,false);
		pTransaction->addResource(CSysHedgeDetailChgResource::alloc(CREATE_ACTION,this,pNewSysHedgeDetailChg,NULL));
		return pNewSysHedgeDetailChg;
	}
}

void CSysHedgeDetailChgFactory::internalUpdate(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pNewSysHedgeDetailChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysHedgeDetailChg++;
	}
	else {
		updateWithoutIndexActionForSysHedgeDetailChg++;
	}
#endif
	CWriteableSysHedgeDetailChg theOldSysHedgeDetailChg;
	beforeUpdate(pSysHedgeDetailChg,pNewSysHedgeDetailChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysHedgeDetailChg,pSysHedgeDetailChg,sizeof(CSysHedgeDetailChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysHedgeDetailChg,pNewSysHedgeDetailChg,sizeof(CSysHedgeDetailChg));
	pMem->updateObject(pSysHedgeDetailChg);
	if (updateIndex) {
	}
	afterUpdate(pSysHedgeDetailChg);
	if (bNoTransaction) {
		commitUpdate(pSysHedgeDetailChg,&theOldSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::update(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pNewSysHedgeDetailChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysHedgeDetailChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysHedgeDetailChg,pNewSysHedgeDetailChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysHedgeDetailChgResource::alloc(UPDATE_ACTION,this,pSysHedgeDetailChg,pNewSysHedgeDetailChg,updateIndex));
		internalUpdate(pSysHedgeDetailChg,pNewSysHedgeDetailChg,updateIndex,false);
	}
}

void CSysHedgeDetailChgFactory::internalRemove(CSysHedgeDetailChg *pSysHedgeDetailChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysHedgeDetailChg++;
#endif
	CWriteableSysHedgeDetailChg theOldSysHedgeDetailChg;
	beforeRemove(pSysHedgeDetailChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysHedgeDetailChg,pSysHedgeDetailChg,sizeof(CSysHedgeDetailChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysHedgeDetailChg);
	}
	pMem->free(pSysHedgeDetailChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::remove(CSysHedgeDetailChg *pSysHedgeDetailChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysHedgeDetailChg,true);
	}
	else {
		pTransaction->addResource(CSysHedgeDetailChgResource::alloc(DELETE_ACTION,this,pSysHedgeDetailChg,NULL));
		internalRemove(pSysHedgeDetailChg,false);		
	}
}

CSysHedgeDetailChg* CSysHedgeDetailChgFactory::addOrUpdate(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pNewSysHedgeDetailChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysHedgeDetailChg == NULL) {
		return add(pNewSysHedgeDetailChg,pTransaction);
	}
	else {
		update(pSysHedgeDetailChg,pNewSysHedgeDetailChg,pTransaction,updateIndex);
		return pSysHedgeDetailChg;
	}
}

void CSysHedgeDetailChgFactory::retrieve(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pTargetSysHedgeDetailChg)
{
	forceCopy(pTargetSysHedgeDetailChg, pSysHedgeDetailChg, sizeof(CSysHedgeDetailChg));
}
	
int CSysHedgeDetailChgFactory::addActionTrigger(CSysHedgeDetailChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysHedgeDetailChgFactory::removeActionTrigger(CSysHedgeDetailChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysHedgeDetailChgFactory::addCommitTrigger(CSysHedgeDetailChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysHedgeDetailChgFactory::removeCommitTrigger(CSysHedgeDetailChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysHedgeDetailChg *CSysHedgeDetailChgFactory::getFirst(void)
{
	CSysHedgeDetailChg *pResult=(CSysHedgeDetailChg *)(pMem->getFirst());
	return pResult;
}
	
CSysHedgeDetailChg *CSysHedgeDetailChgFactory::getNext(void)
{
	CSysHedgeDetailChg *pResult=(CSysHedgeDetailChg *)(pMem->getNext());
	return pResult;
}
	
void CSysHedgeDetailChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysHedgeDetailChgFactory::beforeAdd(CWriteableSysHedgeDetailChg *pSysHedgeDetailChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysHedgeDetailChg);
	}
}
	
void CSysHedgeDetailChgFactory::afterAdd(CSysHedgeDetailChg *pSysHedgeDetailChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::beforeUpdate(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pNewSysHedgeDetailChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysHedgeDetailChg,pNewSysHedgeDetailChg);
	}
}
	
void CSysHedgeDetailChgFactory::afterUpdate(CSysHedgeDetailChg *pSysHedgeDetailChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysHedgeDetailChg);
	}
}
	
void CSysHedgeDetailChgFactory::beforeRemove(CSysHedgeDetailChg *pSysHedgeDetailChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::commitAdd(CSysHedgeDetailChg *pSysHedgeDetailChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysHedgeDetailChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::commitUpdate(CSysHedgeDetailChg *pSysHedgeDetailChg, CWriteableSysHedgeDetailChg *pOldSysHedgeDetailChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysHedgeDetailChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysHedgeDetailChg,pOldSysHedgeDetailChg);
	}
}
	
void CSysHedgeDetailChgFactory::commitRemove(CWriteableSysHedgeDetailChg *pSysHedgeDetailChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysHedgeDetailChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysHedgeDetailChg);
	}
}

void CSysHedgeDetailChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysParticipantChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysParticipantChg=0;
int updateWithIndexActionForSysParticipantChg=0;
int updateWithoutIndexActionForSysParticipantChg=0;
int removeActionForSysParticipantChg=0;
int addCommitForSysParticipantChg=0;
int updateCommitForSysParticipantChg=0;
int removeCommitForSysParticipantChg=0;
#endif
void CSysParticipantChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysParticipantChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysParticipantChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysParticipantChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysParticipantChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysParticipantChgActionTrigger *>;
	pCommitTriggers=new vector<CSysParticipantChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysParticipantChgFactory::CSysParticipantChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticipantChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysParticipantChgFactory::CSysParticipantChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticipantChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysParticipantChgFactory::~CSysParticipantChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysParticipantChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysParticipantChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysParticipantChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysParticipantChg thisSysParticipantChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysParticipantChg.readCSV(input,pNames))
		add(&thisSysParticipantChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysParticipantChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysParticipantChg.csv");
	return readCSV(szFileName);
}

int CSysParticipantChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysParticipantChg *pSysParticipantChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysParticipantChg::writeCSVHead(output);
	pSysParticipantChg=(CWriteableSysParticipantChg *)(pMem->getFirst());
	while (pSysParticipantChg!=NULL) {
		if (!pSysParticipantChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysParticipantChg=(CWriteableSysParticipantChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysParticipantChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysParticipantChg.csv");
	return writeCSV(szFileName);
}

void CSysParticipantChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysParticipantChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysParticipantChg *pSysParticipantChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysParticipantChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysParticipantChg=(CWriteableSysParticipantChg *)(pMem->getFirst());
	while (pSysParticipantChg!=NULL) {
		pSysParticipantChg->dump(fp,index++);
		pSysParticipantChg=(CWriteableSysParticipantChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysParticipantChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysParticipantChg *CSysParticipantChgFactory::internalAdd(CWriteableSysParticipantChg *pSysParticipantChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysParticipantChg++;
#endif
	CSysParticipantChg *pTarget;	
	beforeAdd(pSysParticipantChg);
	pTarget=(CSysParticipantChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysParticipantChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysParticipantChg, sizeof(CSysParticipantChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysParticipantChg *CSysParticipantChgFactory::add(CWriteableSysParticipantChg *pSysParticipantChg, CTransaction *pTransaction)
{
	pSysParticipantChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysParticipantChg,true);
	}
	else {
		CSysParticipantChg *pNewSysParticipantChg;
		pNewSysParticipantChg = internalAdd(pSysParticipantChg,false);
		pTransaction->addResource(CSysParticipantChgResource::alloc(CREATE_ACTION,this,pNewSysParticipantChg,NULL));
		return pNewSysParticipantChg;
	}
}

void CSysParticipantChgFactory::internalUpdate(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pNewSysParticipantChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysParticipantChg++;
	}
	else {
		updateWithoutIndexActionForSysParticipantChg++;
	}
#endif
	CWriteableSysParticipantChg theOldSysParticipantChg;
	beforeUpdate(pSysParticipantChg,pNewSysParticipantChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticipantChg,pSysParticipantChg,sizeof(CSysParticipantChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysParticipantChg,pNewSysParticipantChg,sizeof(CSysParticipantChg));
	pMem->updateObject(pSysParticipantChg);
	if (updateIndex) {
	}
	afterUpdate(pSysParticipantChg);
	if (bNoTransaction) {
		commitUpdate(pSysParticipantChg,&theOldSysParticipantChg);
	}
}

void CSysParticipantChgFactory::update(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pNewSysParticipantChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysParticipantChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysParticipantChg,pNewSysParticipantChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysParticipantChgResource::alloc(UPDATE_ACTION,this,pSysParticipantChg,pNewSysParticipantChg,updateIndex));
		internalUpdate(pSysParticipantChg,pNewSysParticipantChg,updateIndex,false);
	}
}

void CSysParticipantChgFactory::internalRemove(CSysParticipantChg *pSysParticipantChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysParticipantChg++;
#endif
	CWriteableSysParticipantChg theOldSysParticipantChg;
	beforeRemove(pSysParticipantChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticipantChg,pSysParticipantChg,sizeof(CSysParticipantChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysParticipantChg);
	}
	pMem->free(pSysParticipantChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysParticipantChg);
	}
}

void CSysParticipantChgFactory::remove(CSysParticipantChg *pSysParticipantChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysParticipantChg,true);
	}
	else {
		pTransaction->addResource(CSysParticipantChgResource::alloc(DELETE_ACTION,this,pSysParticipantChg,NULL));
		internalRemove(pSysParticipantChg,false);		
	}
}

CSysParticipantChg* CSysParticipantChgFactory::addOrUpdate(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pNewSysParticipantChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysParticipantChg == NULL) {
		return add(pNewSysParticipantChg,pTransaction);
	}
	else {
		update(pSysParticipantChg,pNewSysParticipantChg,pTransaction,updateIndex);
		return pSysParticipantChg;
	}
}

void CSysParticipantChgFactory::retrieve(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pTargetSysParticipantChg)
{
	forceCopy(pTargetSysParticipantChg, pSysParticipantChg, sizeof(CSysParticipantChg));
}
	
int CSysParticipantChgFactory::addActionTrigger(CSysParticipantChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysParticipantChgFactory::removeActionTrigger(CSysParticipantChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysParticipantChgFactory::addCommitTrigger(CSysParticipantChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysParticipantChgFactory::removeCommitTrigger(CSysParticipantChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysParticipantChg *CSysParticipantChgFactory::getFirst(void)
{
	CSysParticipantChg *pResult=(CSysParticipantChg *)(pMem->getFirst());
	return pResult;
}
	
CSysParticipantChg *CSysParticipantChgFactory::getNext(void)
{
	CSysParticipantChg *pResult=(CSysParticipantChg *)(pMem->getNext());
	return pResult;
}
	
void CSysParticipantChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysParticipantChgFactory::beforeAdd(CWriteableSysParticipantChg *pSysParticipantChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysParticipantChg);
	}
}
	
void CSysParticipantChgFactory::afterAdd(CSysParticipantChg *pSysParticipantChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysParticipantChg);
	}
}

void CSysParticipantChgFactory::beforeUpdate(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pNewSysParticipantChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysParticipantChg,pNewSysParticipantChg);
	}
}
	
void CSysParticipantChgFactory::afterUpdate(CSysParticipantChg *pSysParticipantChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysParticipantChg);
	}
}
	
void CSysParticipantChgFactory::beforeRemove(CSysParticipantChg *pSysParticipantChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysParticipantChg);
	}
}

void CSysParticipantChgFactory::commitAdd(CSysParticipantChg *pSysParticipantChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysParticipantChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysParticipantChg);
	}
}

void CSysParticipantChgFactory::commitUpdate(CSysParticipantChg *pSysParticipantChg, CWriteableSysParticipantChg *pOldSysParticipantChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysParticipantChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysParticipantChg,pOldSysParticipantChg);
	}
}
	
void CSysParticipantChgFactory::commitRemove(CWriteableSysParticipantChg *pSysParticipantChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysParticipantChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysParticipantChg);
	}
}

void CSysParticipantChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysMarginRateChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMarginRateChg=0;
int updateWithIndexActionForSysMarginRateChg=0;
int updateWithoutIndexActionForSysMarginRateChg=0;
int removeActionForSysMarginRateChg=0;
int addCommitForSysMarginRateChg=0;
int updateCommitForSysMarginRateChg=0;
int removeCommitForSysMarginRateChg=0;
#endif
void CSysMarginRateChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysMarginRateChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMarginRateChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMarginRateChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysMarginRateChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysMarginRateChgActionTrigger *>;
	pCommitTriggers=new vector<CSysMarginRateChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMarginRateChgFactory::CSysMarginRateChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMarginRateChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMarginRateChgFactory::CSysMarginRateChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMarginRateChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMarginRateChgFactory::~CSysMarginRateChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMarginRateChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMarginRateChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysMarginRateChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMarginRateChg thisSysMarginRateChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMarginRateChg.readCSV(input,pNames))
		add(&thisSysMarginRateChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMarginRateChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMarginRateChg.csv");
	return readCSV(szFileName);
}

int CSysMarginRateChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMarginRateChg *pSysMarginRateChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMarginRateChg::writeCSVHead(output);
	pSysMarginRateChg=(CWriteableSysMarginRateChg *)(pMem->getFirst());
	while (pSysMarginRateChg!=NULL) {
		if (!pSysMarginRateChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMarginRateChg=(CWriteableSysMarginRateChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMarginRateChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMarginRateChg.csv");
	return writeCSV(szFileName);
}

void CSysMarginRateChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMarginRateChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMarginRateChg *pSysMarginRateChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMarginRateChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysMarginRateChg=(CWriteableSysMarginRateChg *)(pMem->getFirst());
	while (pSysMarginRateChg!=NULL) {
		pSysMarginRateChg->dump(fp,index++);
		pSysMarginRateChg=(CWriteableSysMarginRateChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMarginRateChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysMarginRateChg *CSysMarginRateChgFactory::internalAdd(CWriteableSysMarginRateChg *pSysMarginRateChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMarginRateChg++;
#endif
	CSysMarginRateChg *pTarget;	
	beforeAdd(pSysMarginRateChg);
	pTarget=(CSysMarginRateChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMarginRateChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMarginRateChg, sizeof(CSysMarginRateChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMarginRateChg *CSysMarginRateChgFactory::add(CWriteableSysMarginRateChg *pSysMarginRateChg, CTransaction *pTransaction)
{
	pSysMarginRateChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMarginRateChg,true);
	}
	else {
		CSysMarginRateChg *pNewSysMarginRateChg;
		pNewSysMarginRateChg = internalAdd(pSysMarginRateChg,false);
		pTransaction->addResource(CSysMarginRateChgResource::alloc(CREATE_ACTION,this,pNewSysMarginRateChg,NULL));
		return pNewSysMarginRateChg;
	}
}

void CSysMarginRateChgFactory::internalUpdate(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pNewSysMarginRateChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMarginRateChg++;
	}
	else {
		updateWithoutIndexActionForSysMarginRateChg++;
	}
#endif
	CWriteableSysMarginRateChg theOldSysMarginRateChg;
	beforeUpdate(pSysMarginRateChg,pNewSysMarginRateChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysMarginRateChg,pSysMarginRateChg,sizeof(CSysMarginRateChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMarginRateChg,pNewSysMarginRateChg,sizeof(CSysMarginRateChg));
	pMem->updateObject(pSysMarginRateChg);
	if (updateIndex) {
	}
	afterUpdate(pSysMarginRateChg);
	if (bNoTransaction) {
		commitUpdate(pSysMarginRateChg,&theOldSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::update(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pNewSysMarginRateChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMarginRateChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMarginRateChg,pNewSysMarginRateChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMarginRateChgResource::alloc(UPDATE_ACTION,this,pSysMarginRateChg,pNewSysMarginRateChg,updateIndex));
		internalUpdate(pSysMarginRateChg,pNewSysMarginRateChg,updateIndex,false);
	}
}

void CSysMarginRateChgFactory::internalRemove(CSysMarginRateChg *pSysMarginRateChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMarginRateChg++;
#endif
	CWriteableSysMarginRateChg theOldSysMarginRateChg;
	beforeRemove(pSysMarginRateChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysMarginRateChg,pSysMarginRateChg,sizeof(CSysMarginRateChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysMarginRateChg);
	}
	pMem->free(pSysMarginRateChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::remove(CSysMarginRateChg *pSysMarginRateChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMarginRateChg,true);
	}
	else {
		pTransaction->addResource(CSysMarginRateChgResource::alloc(DELETE_ACTION,this,pSysMarginRateChg,NULL));
		internalRemove(pSysMarginRateChg,false);		
	}
}

CSysMarginRateChg* CSysMarginRateChgFactory::addOrUpdate(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pNewSysMarginRateChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMarginRateChg == NULL) {
		return add(pNewSysMarginRateChg,pTransaction);
	}
	else {
		update(pSysMarginRateChg,pNewSysMarginRateChg,pTransaction,updateIndex);
		return pSysMarginRateChg;
	}
}

void CSysMarginRateChgFactory::retrieve(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pTargetSysMarginRateChg)
{
	forceCopy(pTargetSysMarginRateChg, pSysMarginRateChg, sizeof(CSysMarginRateChg));
}
	
int CSysMarginRateChgFactory::addActionTrigger(CSysMarginRateChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMarginRateChgFactory::removeActionTrigger(CSysMarginRateChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMarginRateChgFactory::addCommitTrigger(CSysMarginRateChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMarginRateChgFactory::removeCommitTrigger(CSysMarginRateChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMarginRateChg *CSysMarginRateChgFactory::getFirst(void)
{
	CSysMarginRateChg *pResult=(CSysMarginRateChg *)(pMem->getFirst());
	return pResult;
}
	
CSysMarginRateChg *CSysMarginRateChgFactory::getNext(void)
{
	CSysMarginRateChg *pResult=(CSysMarginRateChg *)(pMem->getNext());
	return pResult;
}
	
void CSysMarginRateChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMarginRateChgFactory::beforeAdd(CWriteableSysMarginRateChg *pSysMarginRateChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMarginRateChg);
	}
}
	
void CSysMarginRateChgFactory::afterAdd(CSysMarginRateChg *pSysMarginRateChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::beforeUpdate(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pNewSysMarginRateChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMarginRateChg,pNewSysMarginRateChg);
	}
}
	
void CSysMarginRateChgFactory::afterUpdate(CSysMarginRateChg *pSysMarginRateChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMarginRateChg);
	}
}
	
void CSysMarginRateChgFactory::beforeRemove(CSysMarginRateChg *pSysMarginRateChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::commitAdd(CSysMarginRateChg *pSysMarginRateChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMarginRateChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::commitUpdate(CSysMarginRateChg *pSysMarginRateChg, CWriteableSysMarginRateChg *pOldSysMarginRateChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMarginRateChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMarginRateChg,pOldSysMarginRateChg);
	}
}
	
void CSysMarginRateChgFactory::commitRemove(CWriteableSysMarginRateChg *pSysMarginRateChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMarginRateChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMarginRateChg);
	}
}

void CSysMarginRateChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysActionTimeIndexinSysUserIpChg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysUserIpChg=0;
int updateWithIndexActionForSysUserIpChg=0;
int updateWithoutIndexActionForSysUserIpChg=0;
int removeActionForSysUserIpChg=0;
int addCommitForSysUserIpChg=0;
int updateCommitForSysUserIpChg=0;
int removeCommitForSysUserIpChg=0;
#endif
void CSysUserIpChgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysUserIpChg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysUserIpChg_SysActionTimeIndex",pSysActionTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysUserIpChg_SysActionTimeIndex");
			if(it != pIndexMap->end()) {
				pSysActionTimeIndex=new CAVLTree(maxUnit,compareForSysActionTimeIndexinSysUserIpChg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysActionTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pActionTriggers=new vector<CSysUserIpChgActionTrigger *>;
	pCommitTriggers=new vector<CSysUserIpChgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysUserIpChgFactory::CSysUserIpChgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserIpChg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysUserIpChgFactory::CSysUserIpChgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserIpChg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysUserIpChgFactory::~CSysUserIpChgFactory(void)
{
	if (runLevel>=0) {
		if (pSysActionTimeIndex!=NULL)
			delete pSysActionTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysUserIpChgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysUserIpChgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysActionTimeIndex->output(pLogger,indent+1);
	}
}

int CSysUserIpChgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysUserIpChg thisSysUserIpChg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysUserIpChg.readCSV(input,pNames))
		add(&thisSysUserIpChg);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysUserIpChgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysUserIpChg.csv");
	return readCSV(szFileName);
}

int CSysUserIpChgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysUserIpChg *pSysUserIpChg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysUserIpChg::writeCSVHead(output);
	pSysUserIpChg=(CWriteableSysUserIpChg *)(pMem->getFirst());
	while (pSysUserIpChg!=NULL) {
		if (!pSysUserIpChg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysUserIpChg=(CWriteableSysUserIpChg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysUserIpChgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysUserIpChg.csv");
	return writeCSV(szFileName);
}

void CSysUserIpChgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysUserIpChgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysUserIpChg *pSysUserIpChg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysUserIpChgFactory={       Total Count=%d\n", pMem->getCount());
	pSysUserIpChg=(CWriteableSysUserIpChg *)(pMem->getFirst());
	while (pSysUserIpChg!=NULL) {
		pSysUserIpChg->dump(fp,index++);
		pSysUserIpChg=(CWriteableSysUserIpChg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysUserIpChgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysActionTimeIndex->removeAll();
	}
}

CSysUserIpChg *CSysUserIpChgFactory::internalAdd(CWriteableSysUserIpChg *pSysUserIpChg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysUserIpChg++;
#endif
	CSysUserIpChg *pTarget;	
	beforeAdd(pSysUserIpChg);
	pTarget=(CSysUserIpChg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysUserIpChg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysUserIpChg, sizeof(CSysUserIpChg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysActionTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysUserIpChg *CSysUserIpChgFactory::add(CWriteableSysUserIpChg *pSysUserIpChg, CTransaction *pTransaction)
{
	pSysUserIpChg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysUserIpChg,true);
	}
	else {
		CSysUserIpChg *pNewSysUserIpChg;
		pNewSysUserIpChg = internalAdd(pSysUserIpChg,false);
		pTransaction->addResource(CSysUserIpChgResource::alloc(CREATE_ACTION,this,pNewSysUserIpChg,NULL));
		return pNewSysUserIpChg;
	}
}

void CSysUserIpChgFactory::internalUpdate(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pNewSysUserIpChg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysUserIpChg++;
	}
	else {
		updateWithoutIndexActionForSysUserIpChg++;
	}
#endif
	CWriteableSysUserIpChg theOldSysUserIpChg;
	beforeUpdate(pSysUserIpChg,pNewSysUserIpChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserIpChg,pSysUserIpChg,sizeof(CSysUserIpChg));
	}
	if (updateIndex) {
	}

	forceCopy(pSysUserIpChg,pNewSysUserIpChg,sizeof(CSysUserIpChg));
	pMem->updateObject(pSysUserIpChg);
	if (updateIndex) {
	}
	afterUpdate(pSysUserIpChg);
	if (bNoTransaction) {
		commitUpdate(pSysUserIpChg,&theOldSysUserIpChg);
	}
}

void CSysUserIpChgFactory::update(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pNewSysUserIpChg, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysUserIpChg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysUserIpChg,pNewSysUserIpChg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysUserIpChgResource::alloc(UPDATE_ACTION,this,pSysUserIpChg,pNewSysUserIpChg,updateIndex));
		internalUpdate(pSysUserIpChg,pNewSysUserIpChg,updateIndex,false);
	}
}

void CSysUserIpChgFactory::internalRemove(CSysUserIpChg *pSysUserIpChg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysUserIpChg++;
#endif
	CWriteableSysUserIpChg theOldSysUserIpChg;
	beforeRemove(pSysUserIpChg);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserIpChg,pSysUserIpChg,sizeof(CSysUserIpChg));
	}
	if (runLevel>=0) {
		pSysActionTimeIndex->removeObject(pSysUserIpChg);
	}
	pMem->free(pSysUserIpChg);
	if(bNoTransaction) {
		commitRemove(&theOldSysUserIpChg);
	}
}

void CSysUserIpChgFactory::remove(CSysUserIpChg *pSysUserIpChg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysUserIpChg,true);
	}
	else {
		pTransaction->addResource(CSysUserIpChgResource::alloc(DELETE_ACTION,this,pSysUserIpChg,NULL));
		internalRemove(pSysUserIpChg,false);		
	}
}

CSysUserIpChg* CSysUserIpChgFactory::addOrUpdate(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pNewSysUserIpChg, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysUserIpChg == NULL) {
		return add(pNewSysUserIpChg,pTransaction);
	}
	else {
		update(pSysUserIpChg,pNewSysUserIpChg,pTransaction,updateIndex);
		return pSysUserIpChg;
	}
}

void CSysUserIpChgFactory::retrieve(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pTargetSysUserIpChg)
{
	forceCopy(pTargetSysUserIpChg, pSysUserIpChg, sizeof(CSysUserIpChg));
}
	
int CSysUserIpChgFactory::addActionTrigger(CSysUserIpChgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysUserIpChgFactory::removeActionTrigger(CSysUserIpChgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysUserIpChgFactory::addCommitTrigger(CSysUserIpChgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysUserIpChgFactory::removeCommitTrigger(CSysUserIpChgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysUserIpChg *CSysUserIpChgFactory::getFirst(void)
{
	CSysUserIpChg *pResult=(CSysUserIpChg *)(pMem->getFirst());
	return pResult;
}
	
CSysUserIpChg *CSysUserIpChgFactory::getNext(void)
{
	CSysUserIpChg *pResult=(CSysUserIpChg *)(pMem->getNext());
	return pResult;
}
	
void CSysUserIpChgFactory::endGet(void)
{
	pMem->endGet();
}

void CSysUserIpChgFactory::beforeAdd(CWriteableSysUserIpChg *pSysUserIpChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysUserIpChg);
	}
}
	
void CSysUserIpChgFactory::afterAdd(CSysUserIpChg *pSysUserIpChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysUserIpChg);
	}
}

void CSysUserIpChgFactory::beforeUpdate(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pNewSysUserIpChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysUserIpChg,pNewSysUserIpChg);
	}
}
	
void CSysUserIpChgFactory::afterUpdate(CSysUserIpChg *pSysUserIpChg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysUserIpChg);
	}
}
	
void CSysUserIpChgFactory::beforeRemove(CSysUserIpChg *pSysUserIpChg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysUserIpChg);
	}
}

void CSysUserIpChgFactory::commitAdd(CSysUserIpChg *pSysUserIpChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysUserIpChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysUserIpChg);
	}
}

void CSysUserIpChgFactory::commitUpdate(CSysUserIpChg *pSysUserIpChg, CWriteableSysUserIpChg *pOldSysUserIpChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysUserIpChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysUserIpChg,pOldSysUserIpChg);
	}
}
	
void CSysUserIpChgFactory::commitRemove(CWriteableSysUserIpChg *pSysUserIpChg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysUserIpChg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysUserIpChg);
	}
}

void CSysUserIpChgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysPartInstrumentIndexinSysPartTrade(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysPartTrade=0;
int updateWithIndexActionForSysPartTrade=0;
int updateWithoutIndexActionForSysPartTrade=0;
int removeActionForSysPartTrade=0;
int addCommitForSysPartTrade=0;
int updateCommitForSysPartTrade=0;
int removeCommitForSysPartTrade=0;
#endif
void CSysPartTradeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysPartInstrumentIndex=new CAVLTree(maxUnit,compareForSysPartInstrumentIndexinSysPartTrade,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysPartTrade_SysPartInstrumentIndex",pSysPartInstrumentIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysPartTrade_SysPartInstrumentIndex");
			if(it != pIndexMap->end()) {
				pSysPartInstrumentIndex=new CAVLTree(maxUnit,compareForSysPartInstrumentIndexinSysPartTrade,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysPartInstrumentIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysPartTradeActionTrigger *>;
	pCommitTriggers=new vector<CSysPartTradeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysPartTradeFactory::CSysPartTradeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartTrade),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysPartTradeFactory::CSysPartTradeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysPartTrade),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysPartTradeFactory::~CSysPartTradeFactory(void)
{
	if (runLevel>=0) {
		if (pSysPartInstrumentIndex!=NULL)
			delete pSysPartInstrumentIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysPartTradeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysPartTradeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysPartInstrumentIndex->output(pLogger,indent+1);
	}
}

int CSysPartTradeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysPartTrade thisSysPartTrade;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysPartTrade.readCSV(input,pNames))
		add(&thisSysPartTrade);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysPartTradeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysPartTrade.csv");
	return readCSV(szFileName);
}

int CSysPartTradeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysPartTrade *pSysPartTrade;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysPartTrade::writeCSVHead(output);
	pSysPartTrade=(CWriteableSysPartTrade *)(pMem->getFirst());
	while (pSysPartTrade!=NULL) {
		if (!pSysPartTrade->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysPartTrade=(CWriteableSysPartTrade *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysPartTradeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysPartTrade.csv");
	return writeCSV(szFileName);
}

void CSysPartTradeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysPartTradeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysPartTrade *pSysPartTrade;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysPartTradeFactory={       Total Count=%d\n", pMem->getCount());
	pSysPartTrade=(CWriteableSysPartTrade *)(pMem->getFirst());
	while (pSysPartTrade!=NULL) {
		pSysPartTrade->dump(fp,index++);
		pSysPartTrade=(CWriteableSysPartTrade *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysPartTradeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysPartInstrumentIndex->removeAll();
	}
}

CSysPartTrade *CSysPartTradeFactory::internalAdd(CWriteableSysPartTrade *pSysPartTrade, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysPartTrade++;
#endif
	CSysPartTrade *pTarget;	
	beforeAdd(pSysPartTrade);
	pTarget=(CSysPartTrade *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysPartTrade in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysPartTrade, sizeof(CSysPartTrade));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysPartInstrumentIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysPartTrade *CSysPartTradeFactory::add(CWriteableSysPartTrade *pSysPartTrade, CTransaction *pTransaction)
{
	pSysPartTrade->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysPartTrade,true);
	}
	else {
		CSysPartTrade *pNewSysPartTrade;
		pNewSysPartTrade = internalAdd(pSysPartTrade,false);
		pTransaction->addResource(CSysPartTradeResource::alloc(CREATE_ACTION,this,pNewSysPartTrade,NULL));
		return pNewSysPartTrade;
	}
}

void CSysPartTradeFactory::internalUpdate(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pNewSysPartTrade, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysPartTrade++;
	}
	else {
		updateWithoutIndexActionForSysPartTrade++;
	}
#endif
	CWriteableSysPartTrade theOldSysPartTrade;
	beforeUpdate(pSysPartTrade,pNewSysPartTrade);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartTrade,pSysPartTrade,sizeof(CSysPartTrade));
	}
	if (updateIndex) {
	}

	forceCopy(pSysPartTrade,pNewSysPartTrade,sizeof(CSysPartTrade));
	pMem->updateObject(pSysPartTrade);
	if (updateIndex) {
	}
	afterUpdate(pSysPartTrade);
	if (bNoTransaction) {
		commitUpdate(pSysPartTrade,&theOldSysPartTrade);
	}
}

void CSysPartTradeFactory::update(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pNewSysPartTrade, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysPartTrade->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysPartTrade,pNewSysPartTrade,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysPartTradeResource::alloc(UPDATE_ACTION,this,pSysPartTrade,pNewSysPartTrade,updateIndex));
		internalUpdate(pSysPartTrade,pNewSysPartTrade,updateIndex,false);
	}
}

void CSysPartTradeFactory::internalRemove(CSysPartTrade *pSysPartTrade, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysPartTrade++;
#endif
	CWriteableSysPartTrade theOldSysPartTrade;
	beforeRemove(pSysPartTrade);
	if (bNoTransaction) {
		forceCopy(&theOldSysPartTrade,pSysPartTrade,sizeof(CSysPartTrade));
	}
	if (runLevel>=0) {
		pSysPartInstrumentIndex->removeObject(pSysPartTrade);
	}
	pMem->free(pSysPartTrade);
	if(bNoTransaction) {
		commitRemove(&theOldSysPartTrade);
	}
}

void CSysPartTradeFactory::remove(CSysPartTrade *pSysPartTrade, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysPartTrade,true);
	}
	else {
		pTransaction->addResource(CSysPartTradeResource::alloc(DELETE_ACTION,this,pSysPartTrade,NULL));
		internalRemove(pSysPartTrade,false);		
	}
}

CSysPartTrade* CSysPartTradeFactory::addOrUpdate(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pNewSysPartTrade, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysPartTrade == NULL) {
		return add(pNewSysPartTrade,pTransaction);
	}
	else {
		update(pSysPartTrade,pNewSysPartTrade,pTransaction,updateIndex);
		return pSysPartTrade;
	}
}

void CSysPartTradeFactory::retrieve(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pTargetSysPartTrade)
{
	forceCopy(pTargetSysPartTrade, pSysPartTrade, sizeof(CSysPartTrade));
}
	
int CSysPartTradeFactory::addActionTrigger(CSysPartTradeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysPartTradeFactory::removeActionTrigger(CSysPartTradeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysPartTradeFactory::addCommitTrigger(CSysPartTradeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysPartTradeFactory::removeCommitTrigger(CSysPartTradeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysPartTrade *CSysPartTradeFactory::getFirst(void)
{
	CSysPartTrade *pResult=(CSysPartTrade *)(pMem->getFirst());
	return pResult;
}
	
CSysPartTrade *CSysPartTradeFactory::getNext(void)
{
	CSysPartTrade *pResult=(CSysPartTrade *)(pMem->getNext());
	return pResult;
}
	
void CSysPartTradeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysPartTradeFactory::beforeAdd(CWriteableSysPartTrade *pSysPartTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysPartTrade);
	}
}
	
void CSysPartTradeFactory::afterAdd(CSysPartTrade *pSysPartTrade)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysPartTrade);
	}
}

void CSysPartTradeFactory::beforeUpdate(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pNewSysPartTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysPartTrade,pNewSysPartTrade);
	}
}
	
void CSysPartTradeFactory::afterUpdate(CSysPartTrade *pSysPartTrade)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysPartTrade);
	}
}
	
void CSysPartTradeFactory::beforeRemove(CSysPartTrade *pSysPartTrade)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysPartTrade);
	}
}

void CSysPartTradeFactory::commitAdd(CSysPartTrade *pSysPartTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysPartTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysPartTrade);
	}
}

void CSysPartTradeFactory::commitUpdate(CSysPartTrade *pSysPartTrade, CWriteableSysPartTrade *pOldSysPartTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysPartTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysPartTrade,pOldSysPartTrade);
	}
}
	
void CSysPartTradeFactory::commitRemove(CWriteableSysPartTrade *pSysPartTrade)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysPartTrade++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysPartTrade);
	}
}

void CSysPartTradeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbObjectAttr(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbObjectAttr=0;
int updateWithIndexActionForSysMdbObjectAttr=0;
int updateWithoutIndexActionForSysMdbObjectAttr=0;
int removeActionForSysMdbObjectAttr=0;
int addCommitForSysMdbObjectAttr=0;
int updateCommitForSysMdbObjectAttr=0;
int removeCommitForSysMdbObjectAttr=0;
#endif
void CSysMdbObjectAttrFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbObjectAttr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbObjectAttr_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbObjectAttr_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbObjectAttr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByIDType=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbObjectAttrActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbObjectAttrCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbObjectAttrFactory::CSysMdbObjectAttrFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbObjectAttr),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbObjectAttrFactory::CSysMdbObjectAttrFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbObjectAttr),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbObjectAttrFactory::~CSysMdbObjectAttrFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbObjectAttrFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbObjectAttrFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysMdbObjectAttrFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbObjectAttr thisSysMdbObjectAttr;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbObjectAttr.readCSV(input,pNames))
		add(&thisSysMdbObjectAttr);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbObjectAttrFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbObjectAttr.csv");
	return readCSV(szFileName);
}

int CSysMdbObjectAttrFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbObjectAttr *pSysMdbObjectAttr;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbObjectAttr::writeCSVHead(output);
	pSysMdbObjectAttr=(CWriteableSysMdbObjectAttr *)(pMem->getFirst());
	while (pSysMdbObjectAttr!=NULL) {
		if (!pSysMdbObjectAttr->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbObjectAttr=(CWriteableSysMdbObjectAttr *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbObjectAttrFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbObjectAttr.csv");
	return writeCSV(szFileName);
}

void CSysMdbObjectAttrFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbObjectAttrFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbObjectAttr *pSysMdbObjectAttr;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbObjectAttrFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbObjectAttr=(CWriteableSysMdbObjectAttr *)(pMem->getFirst());
	while (pSysMdbObjectAttr!=NULL) {
		pSysMdbObjectAttr->dump(fp,index++);
		pSysMdbObjectAttr=(CWriteableSysMdbObjectAttr *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbObjectAttrFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysMdbObjectAttr *CSysMdbObjectAttrFactory::internalAdd(CWriteableSysMdbObjectAttr *pSysMdbObjectAttr, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbObjectAttr++;
#endif
	CSysMdbObjectAttr *pTarget;	
	beforeAdd(pSysMdbObjectAttr);
	pTarget=(CSysMdbObjectAttr *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbObjectAttr in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbObjectAttr, sizeof(CSysMdbObjectAttr));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbObjectAttr *CSysMdbObjectAttrFactory::add(CWriteableSysMdbObjectAttr *pSysMdbObjectAttr, CTransaction *pTransaction)
{
	pSysMdbObjectAttr->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbObjectAttr,true);
	}
	else {
		CSysMdbObjectAttr *pNewSysMdbObjectAttr;
		pNewSysMdbObjectAttr = internalAdd(pSysMdbObjectAttr,false);
		pTransaction->addResource(CSysMdbObjectAttrResource::alloc(CREATE_ACTION,this,pNewSysMdbObjectAttr,NULL));
		return pNewSysMdbObjectAttr;
	}
}

void CSysMdbObjectAttrFactory::internalUpdate(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pNewSysMdbObjectAttr, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbObjectAttr++;
	}
	else {
		updateWithoutIndexActionForSysMdbObjectAttr++;
	}
#endif
	CWriteableSysMdbObjectAttr theOldSysMdbObjectAttr;
	beforeUpdate(pSysMdbObjectAttr,pNewSysMdbObjectAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbObjectAttr,pSysMdbObjectAttr,sizeof(CSysMdbObjectAttr));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbObjectAttr,pNewSysMdbObjectAttr,sizeof(CSysMdbObjectAttr));
	pMem->updateObject(pSysMdbObjectAttr);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbObjectAttr);
	if (bNoTransaction) {
		commitUpdate(pSysMdbObjectAttr,&theOldSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::update(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pNewSysMdbObjectAttr, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbObjectAttr->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbObjectAttr,pNewSysMdbObjectAttr,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbObjectAttrResource::alloc(UPDATE_ACTION,this,pSysMdbObjectAttr,pNewSysMdbObjectAttr,updateIndex));
		internalUpdate(pSysMdbObjectAttr,pNewSysMdbObjectAttr,updateIndex,false);
	}
}

void CSysMdbObjectAttrFactory::internalRemove(CSysMdbObjectAttr *pSysMdbObjectAttr, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbObjectAttr++;
#endif
	CWriteableSysMdbObjectAttr theOldSysMdbObjectAttr;
	beforeRemove(pSysMdbObjectAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbObjectAttr,pSysMdbObjectAttr,sizeof(CSysMdbObjectAttr));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbObjectAttr);
	}
	pMem->free(pSysMdbObjectAttr);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::remove(CSysMdbObjectAttr *pSysMdbObjectAttr, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbObjectAttr,true);
	}
	else {
		pTransaction->addResource(CSysMdbObjectAttrResource::alloc(DELETE_ACTION,this,pSysMdbObjectAttr,NULL));
		internalRemove(pSysMdbObjectAttr,false);		
	}
}

CSysMdbObjectAttr* CSysMdbObjectAttrFactory::addOrUpdate(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pNewSysMdbObjectAttr, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbObjectAttr == NULL) {
		return add(pNewSysMdbObjectAttr,pTransaction);
	}
	else {
		update(pSysMdbObjectAttr,pNewSysMdbObjectAttr,pTransaction,updateIndex);
		return pSysMdbObjectAttr;
	}
}

void CSysMdbObjectAttrFactory::retrieve(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pTargetSysMdbObjectAttr)
{
	forceCopy(pTargetSysMdbObjectAttr, pSysMdbObjectAttr, sizeof(CSysMdbObjectAttr));
}
	
int CSysMdbObjectAttrFactory::addActionTrigger(CSysMdbObjectAttrActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbObjectAttrFactory::removeActionTrigger(CSysMdbObjectAttrActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbObjectAttrFactory::addCommitTrigger(CSysMdbObjectAttrCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbObjectAttrFactory::removeCommitTrigger(CSysMdbObjectAttrCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbObjectAttr *CSysMdbObjectAttrFactory::getFirst(void)
{
	CSysMdbObjectAttr *pResult=(CSysMdbObjectAttr *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbObjectAttr *CSysMdbObjectAttrFactory::getNext(void)
{
	CSysMdbObjectAttr *pResult=(CSysMdbObjectAttr *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbObjectAttrFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbObjectAttrFactory::beforeAdd(CWriteableSysMdbObjectAttr *pSysMdbObjectAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbObjectAttr);
	}
}
	
void CSysMdbObjectAttrFactory::afterAdd(CSysMdbObjectAttr *pSysMdbObjectAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::beforeUpdate(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pNewSysMdbObjectAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbObjectAttr,pNewSysMdbObjectAttr);
	}
}
	
void CSysMdbObjectAttrFactory::afterUpdate(CSysMdbObjectAttr *pSysMdbObjectAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbObjectAttr);
	}
}
	
void CSysMdbObjectAttrFactory::beforeRemove(CSysMdbObjectAttr *pSysMdbObjectAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::commitAdd(CSysMdbObjectAttr *pSysMdbObjectAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbObjectAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::commitUpdate(CSysMdbObjectAttr *pSysMdbObjectAttr, CWriteableSysMdbObjectAttr *pOldSysMdbObjectAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbObjectAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbObjectAttr,pOldSysMdbObjectAttr);
	}
}
	
void CSysMdbObjectAttrFactory::commitRemove(CWriteableSysMdbObjectAttr *pSysMdbObjectAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbObjectAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbObjectAttr);
	}
}

void CSysMdbObjectAttrFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbSyslogInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbSyslogInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbSyslogInfo=0;
int updateWithIndexActionForSysMdbSyslogInfo=0;
int updateWithoutIndexActionForSysMdbSyslogInfo=0;
int removeActionForSysMdbSyslogInfo=0;
int addCommitForSysMdbSyslogInfo=0;
int updateCommitForSysMdbSyslogInfo=0;
int removeCommitForSysMdbSyslogInfo=0;
#endif
void CSysMdbSyslogInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbSyslogInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbSyslogInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbSyslogInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbSyslogInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbSyslogInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbSyslogInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbSyslogInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbSyslogInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbSyslogInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbSyslogInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbSyslogInfoFactory::CSysMdbSyslogInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbSyslogInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbSyslogInfoFactory::CSysMdbSyslogInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbSyslogInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbSyslogInfoFactory::~CSysMdbSyslogInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbSyslogInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbSyslogInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbSyslogInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbSyslogInfo thisSysMdbSyslogInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbSyslogInfo.readCSV(input,pNames))
		add(&thisSysMdbSyslogInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbSyslogInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbSyslogInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbSyslogInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbSyslogInfo::writeCSVHead(output);
	pSysMdbSyslogInfo=(CWriteableSysMdbSyslogInfo *)(pMem->getFirst());
	while (pSysMdbSyslogInfo!=NULL) {
		if (!pSysMdbSyslogInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbSyslogInfo=(CWriteableSysMdbSyslogInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbSyslogInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbSyslogInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbSyslogInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbSyslogInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbSyslogInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbSyslogInfo=(CWriteableSysMdbSyslogInfo *)(pMem->getFirst());
	while (pSysMdbSyslogInfo!=NULL) {
		pSysMdbSyslogInfo->dump(fp,index++);
		pSysMdbSyslogInfo=(CWriteableSysMdbSyslogInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbSyslogInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbSyslogInfo *CSysMdbSyslogInfoFactory::internalAdd(CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbSyslogInfo++;
#endif
	CSysMdbSyslogInfo *pTarget;	
	beforeAdd(pSysMdbSyslogInfo);
	pTarget=(CSysMdbSyslogInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbSyslogInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbSyslogInfo, sizeof(CSysMdbSyslogInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbSyslogInfo *CSysMdbSyslogInfoFactory::add(CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo, CTransaction *pTransaction)
{
	pSysMdbSyslogInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbSyslogInfo,true);
	}
	else {
		CSysMdbSyslogInfo *pNewSysMdbSyslogInfo;
		pNewSysMdbSyslogInfo = internalAdd(pSysMdbSyslogInfo,false);
		pTransaction->addResource(CSysMdbSyslogInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbSyslogInfo,NULL));
		return pNewSysMdbSyslogInfo;
	}
}

void CSysMdbSyslogInfoFactory::internalUpdate(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pNewSysMdbSyslogInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbSyslogInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbSyslogInfo++;
	}
#endif
	CWriteableSysMdbSyslogInfo theOldSysMdbSyslogInfo;
	beforeUpdate(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbSyslogInfo,pSysMdbSyslogInfo,sizeof(CSysMdbSyslogInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo,sizeof(CSysMdbSyslogInfo));
	pMem->updateObject(pSysMdbSyslogInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbSyslogInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbSyslogInfo,&theOldSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::update(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pNewSysMdbSyslogInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbSyslogInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbSyslogInfoResource::alloc(UPDATE_ACTION,this,pSysMdbSyslogInfo,pNewSysMdbSyslogInfo,updateIndex));
		internalUpdate(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo,updateIndex,false);
	}
}

void CSysMdbSyslogInfoFactory::internalRemove(CSysMdbSyslogInfo *pSysMdbSyslogInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbSyslogInfo++;
#endif
	CWriteableSysMdbSyslogInfo theOldSysMdbSyslogInfo;
	beforeRemove(pSysMdbSyslogInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbSyslogInfo,pSysMdbSyslogInfo,sizeof(CSysMdbSyslogInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbSyslogInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbSyslogInfo);
	}
	pMem->free(pSysMdbSyslogInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::remove(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbSyslogInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbSyslogInfoResource::alloc(DELETE_ACTION,this,pSysMdbSyslogInfo,NULL));
		internalRemove(pSysMdbSyslogInfo,false);		
	}
}

CSysMdbSyslogInfo* CSysMdbSyslogInfoFactory::addOrUpdate(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pNewSysMdbSyslogInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbSyslogInfo == NULL) {
		return add(pNewSysMdbSyslogInfo,pTransaction);
	}
	else {
		update(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo,pTransaction,updateIndex);
		return pSysMdbSyslogInfo;
	}
}

void CSysMdbSyslogInfoFactory::retrieve(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pTargetSysMdbSyslogInfo)
{
	forceCopy(pTargetSysMdbSyslogInfo, pSysMdbSyslogInfo, sizeof(CSysMdbSyslogInfo));
}
	
int CSysMdbSyslogInfoFactory::addActionTrigger(CSysMdbSyslogInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbSyslogInfoFactory::removeActionTrigger(CSysMdbSyslogInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbSyslogInfoFactory::addCommitTrigger(CSysMdbSyslogInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbSyslogInfoFactory::removeCommitTrigger(CSysMdbSyslogInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbSyslogInfo *CSysMdbSyslogInfoFactory::getFirst(void)
{
	CSysMdbSyslogInfo *pResult=(CSysMdbSyslogInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbSyslogInfo *CSysMdbSyslogInfoFactory::getNext(void)
{
	CSysMdbSyslogInfo *pResult=(CSysMdbSyslogInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbSyslogInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbSyslogInfoFactory::beforeAdd(CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbSyslogInfo);
	}
}
	
void CSysMdbSyslogInfoFactory::afterAdd(CSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::beforeUpdate(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pNewSysMdbSyslogInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbSyslogInfo,pNewSysMdbSyslogInfo);
	}
}
	
void CSysMdbSyslogInfoFactory::afterUpdate(CSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbSyslogInfo);
	}
}
	
void CSysMdbSyslogInfoFactory::beforeRemove(CSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::commitAdd(CSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbSyslogInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::commitUpdate(CSysMdbSyslogInfo *pSysMdbSyslogInfo, CWriteableSysMdbSyslogInfo *pOldSysMdbSyslogInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbSyslogInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbSyslogInfo,pOldSysMdbSyslogInfo);
	}
}
	
void CSysMdbSyslogInfoFactory::commitRemove(CWriteableSysMdbSyslogInfo *pSysMdbSyslogInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbSyslogInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbSyslogInfo);
	}
}

void CSysMdbSyslogInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysUserInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysUserInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysUserInfo=0;
int updateWithIndexActionForSysUserInfo=0;
int updateWithoutIndexActionForSysUserInfo=0;
int removeActionForSysUserInfo=0;
int addCommitForSysUserInfo=0;
int updateCommitForSysUserInfo=0;
int removeCommitForSysUserInfo=0;
#endif
void CSysUserInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysUserInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysUserInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysUserInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysUserInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysUserInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysUserInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysUserInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysUserInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDsc=NULL;
	pActionTriggers=new vector<CSysUserInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysUserInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysUserInfoFactory::CSysUserInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysUserInfoFactory::CSysUserInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysUserInfoFactory::~CSysUserInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysUserInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysUserInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysUserInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysUserInfo thisSysUserInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysUserInfo.readCSV(input,pNames))
		add(&thisSysUserInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysUserInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysUserInfo.csv");
	return readCSV(szFileName);
}

int CSysUserInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysUserInfo *pSysUserInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysUserInfo::writeCSVHead(output);
	pSysUserInfo=(CWriteableSysUserInfo *)(pMem->getFirst());
	while (pSysUserInfo!=NULL) {
		if (!pSysUserInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysUserInfo=(CWriteableSysUserInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysUserInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysUserInfo.csv");
	return writeCSV(szFileName);
}

void CSysUserInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysUserInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysUserInfo *pSysUserInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysUserInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysUserInfo=(CWriteableSysUserInfo *)(pMem->getFirst());
	while (pSysUserInfo!=NULL) {
		pSysUserInfo->dump(fp,index++);
		pSysUserInfo=(CWriteableSysUserInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysUserInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysUserInfo *CSysUserInfoFactory::internalAdd(CWriteableSysUserInfo *pSysUserInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysUserInfo++;
#endif
	CSysUserInfo *pTarget;	
	beforeAdd(pSysUserInfo);
	pTarget=(CSysUserInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysUserInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysUserInfo, sizeof(CSysUserInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysUserInfo *CSysUserInfoFactory::add(CWriteableSysUserInfo *pSysUserInfo, CTransaction *pTransaction)
{
	pSysUserInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysUserInfo,true);
	}
	else {
		CSysUserInfo *pNewSysUserInfo;
		pNewSysUserInfo = internalAdd(pSysUserInfo,false);
		pTransaction->addResource(CSysUserInfoResource::alloc(CREATE_ACTION,this,pNewSysUserInfo,NULL));
		return pNewSysUserInfo;
	}
}

void CSysUserInfoFactory::internalUpdate(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pNewSysUserInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysUserInfo++;
	}
	else {
		updateWithoutIndexActionForSysUserInfo++;
	}
#endif
	CWriteableSysUserInfo theOldSysUserInfo;
	beforeUpdate(pSysUserInfo,pNewSysUserInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserInfo,pSysUserInfo,sizeof(CSysUserInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysUserInfo,pNewSysUserInfo,sizeof(CSysUserInfo));
	pMem->updateObject(pSysUserInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysUserInfo);
	if (bNoTransaction) {
		commitUpdate(pSysUserInfo,&theOldSysUserInfo);
	}
}

void CSysUserInfoFactory::update(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pNewSysUserInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysUserInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysUserInfo,pNewSysUserInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysUserInfoResource::alloc(UPDATE_ACTION,this,pSysUserInfo,pNewSysUserInfo,updateIndex));
		internalUpdate(pSysUserInfo,pNewSysUserInfo,updateIndex,false);
	}
}

void CSysUserInfoFactory::internalRemove(CSysUserInfo *pSysUserInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysUserInfo++;
#endif
	CWriteableSysUserInfo theOldSysUserInfo;
	beforeRemove(pSysUserInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserInfo,pSysUserInfo,sizeof(CSysUserInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysUserInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysUserInfo);
	}
	pMem->free(pSysUserInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysUserInfo);
	}
}

void CSysUserInfoFactory::remove(CSysUserInfo *pSysUserInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysUserInfo,true);
	}
	else {
		pTransaction->addResource(CSysUserInfoResource::alloc(DELETE_ACTION,this,pSysUserInfo,NULL));
		internalRemove(pSysUserInfo,false);		
	}
}

CSysUserInfo* CSysUserInfoFactory::addOrUpdate(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pNewSysUserInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysUserInfo == NULL) {
		return add(pNewSysUserInfo,pTransaction);
	}
	else {
		update(pSysUserInfo,pNewSysUserInfo,pTransaction,updateIndex);
		return pSysUserInfo;
	}
}

void CSysUserInfoFactory::retrieve(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pTargetSysUserInfo)
{
	forceCopy(pTargetSysUserInfo, pSysUserInfo, sizeof(CSysUserInfo));
}
	
int CSysUserInfoFactory::addActionTrigger(CSysUserInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysUserInfoFactory::removeActionTrigger(CSysUserInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysUserInfoFactory::addCommitTrigger(CSysUserInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysUserInfoFactory::removeCommitTrigger(CSysUserInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysUserInfo *CSysUserInfoFactory::getFirst(void)
{
	CSysUserInfo *pResult=(CSysUserInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysUserInfo *CSysUserInfoFactory::getNext(void)
{
	CSysUserInfo *pResult=(CSysUserInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysUserInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysUserInfoFactory::beforeAdd(CWriteableSysUserInfo *pSysUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysUserInfo);
	}
}
	
void CSysUserInfoFactory::afterAdd(CSysUserInfo *pSysUserInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysUserInfo);
	}
}

void CSysUserInfoFactory::beforeUpdate(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pNewSysUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysUserInfo,pNewSysUserInfo);
	}
}
	
void CSysUserInfoFactory::afterUpdate(CSysUserInfo *pSysUserInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysUserInfo);
	}
}
	
void CSysUserInfoFactory::beforeRemove(CSysUserInfo *pSysUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysUserInfo);
	}
}

void CSysUserInfoFactory::commitAdd(CSysUserInfo *pSysUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysUserInfo);
	}
}

void CSysUserInfoFactory::commitUpdate(CSysUserInfo *pSysUserInfo, CWriteableSysUserInfo *pOldSysUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysUserInfo,pOldSysUserInfo);
	}
}
	
void CSysUserInfoFactory::commitRemove(CWriteableSysUserInfo *pSysUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysUserInfo);
	}
}

void CSysUserInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysOnlineUserInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysOnlineUserInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysOnlineUserInfo=0;
int updateWithIndexActionForSysOnlineUserInfo=0;
int updateWithoutIndexActionForSysOnlineUserInfo=0;
int removeActionForSysOnlineUserInfo=0;
int addCommitForSysOnlineUserInfo=0;
int updateCommitForSysOnlineUserInfo=0;
int removeCommitForSysOnlineUserInfo=0;
#endif
void CSysOnlineUserInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysOnlineUserInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysOnlineUserInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysOnlineUserInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysOnlineUserInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysOnlineUserInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysOnlineUserInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysOnlineUserInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysOnlineUserInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDsc=NULL;
	pActionTriggers=new vector<CSysOnlineUserInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysOnlineUserInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysOnlineUserInfoFactory::CSysOnlineUserInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysOnlineUserInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysOnlineUserInfoFactory::CSysOnlineUserInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysOnlineUserInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysOnlineUserInfoFactory::~CSysOnlineUserInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysOnlineUserInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysOnlineUserInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysOnlineUserInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysOnlineUserInfo thisSysOnlineUserInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysOnlineUserInfo.readCSV(input,pNames))
		add(&thisSysOnlineUserInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysOnlineUserInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysOnlineUserInfo.csv");
	return readCSV(szFileName);
}

int CSysOnlineUserInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysOnlineUserInfo *pSysOnlineUserInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysOnlineUserInfo::writeCSVHead(output);
	pSysOnlineUserInfo=(CWriteableSysOnlineUserInfo *)(pMem->getFirst());
	while (pSysOnlineUserInfo!=NULL) {
		if (!pSysOnlineUserInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysOnlineUserInfo=(CWriteableSysOnlineUserInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysOnlineUserInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysOnlineUserInfo.csv");
	return writeCSV(szFileName);
}

void CSysOnlineUserInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysOnlineUserInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysOnlineUserInfo *pSysOnlineUserInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysOnlineUserInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysOnlineUserInfo=(CWriteableSysOnlineUserInfo *)(pMem->getFirst());
	while (pSysOnlineUserInfo!=NULL) {
		pSysOnlineUserInfo->dump(fp,index++);
		pSysOnlineUserInfo=(CWriteableSysOnlineUserInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysOnlineUserInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysOnlineUserInfo *CSysOnlineUserInfoFactory::internalAdd(CWriteableSysOnlineUserInfo *pSysOnlineUserInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysOnlineUserInfo++;
#endif
	CSysOnlineUserInfo *pTarget;	
	beforeAdd(pSysOnlineUserInfo);
	pTarget=(CSysOnlineUserInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysOnlineUserInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysOnlineUserInfo, sizeof(CSysOnlineUserInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysOnlineUserInfo *CSysOnlineUserInfoFactory::add(CWriteableSysOnlineUserInfo *pSysOnlineUserInfo, CTransaction *pTransaction)
{
	pSysOnlineUserInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysOnlineUserInfo,true);
	}
	else {
		CSysOnlineUserInfo *pNewSysOnlineUserInfo;
		pNewSysOnlineUserInfo = internalAdd(pSysOnlineUserInfo,false);
		pTransaction->addResource(CSysOnlineUserInfoResource::alloc(CREATE_ACTION,this,pNewSysOnlineUserInfo,NULL));
		return pNewSysOnlineUserInfo;
	}
}

void CSysOnlineUserInfoFactory::internalUpdate(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pNewSysOnlineUserInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysOnlineUserInfo++;
	}
	else {
		updateWithoutIndexActionForSysOnlineUserInfo++;
	}
#endif
	CWriteableSysOnlineUserInfo theOldSysOnlineUserInfo;
	beforeUpdate(pSysOnlineUserInfo,pNewSysOnlineUserInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysOnlineUserInfo,pSysOnlineUserInfo,sizeof(CSysOnlineUserInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysOnlineUserInfo,pNewSysOnlineUserInfo,sizeof(CSysOnlineUserInfo));
	pMem->updateObject(pSysOnlineUserInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysOnlineUserInfo);
	if (bNoTransaction) {
		commitUpdate(pSysOnlineUserInfo,&theOldSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::update(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pNewSysOnlineUserInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysOnlineUserInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysOnlineUserInfo,pNewSysOnlineUserInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysOnlineUserInfoResource::alloc(UPDATE_ACTION,this,pSysOnlineUserInfo,pNewSysOnlineUserInfo,updateIndex));
		internalUpdate(pSysOnlineUserInfo,pNewSysOnlineUserInfo,updateIndex,false);
	}
}

void CSysOnlineUserInfoFactory::internalRemove(CSysOnlineUserInfo *pSysOnlineUserInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysOnlineUserInfo++;
#endif
	CWriteableSysOnlineUserInfo theOldSysOnlineUserInfo;
	beforeRemove(pSysOnlineUserInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysOnlineUserInfo,pSysOnlineUserInfo,sizeof(CSysOnlineUserInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysOnlineUserInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysOnlineUserInfo);
	}
	pMem->free(pSysOnlineUserInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::remove(CSysOnlineUserInfo *pSysOnlineUserInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysOnlineUserInfo,true);
	}
	else {
		pTransaction->addResource(CSysOnlineUserInfoResource::alloc(DELETE_ACTION,this,pSysOnlineUserInfo,NULL));
		internalRemove(pSysOnlineUserInfo,false);		
	}
}

CSysOnlineUserInfo* CSysOnlineUserInfoFactory::addOrUpdate(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pNewSysOnlineUserInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysOnlineUserInfo == NULL) {
		return add(pNewSysOnlineUserInfo,pTransaction);
	}
	else {
		update(pSysOnlineUserInfo,pNewSysOnlineUserInfo,pTransaction,updateIndex);
		return pSysOnlineUserInfo;
	}
}

void CSysOnlineUserInfoFactory::retrieve(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pTargetSysOnlineUserInfo)
{
	forceCopy(pTargetSysOnlineUserInfo, pSysOnlineUserInfo, sizeof(CSysOnlineUserInfo));
}
	
int CSysOnlineUserInfoFactory::addActionTrigger(CSysOnlineUserInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysOnlineUserInfoFactory::removeActionTrigger(CSysOnlineUserInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysOnlineUserInfoFactory::addCommitTrigger(CSysOnlineUserInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysOnlineUserInfoFactory::removeCommitTrigger(CSysOnlineUserInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysOnlineUserInfo *CSysOnlineUserInfoFactory::getFirst(void)
{
	CSysOnlineUserInfo *pResult=(CSysOnlineUserInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysOnlineUserInfo *CSysOnlineUserInfoFactory::getNext(void)
{
	CSysOnlineUserInfo *pResult=(CSysOnlineUserInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysOnlineUserInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysOnlineUserInfoFactory::beforeAdd(CWriteableSysOnlineUserInfo *pSysOnlineUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysOnlineUserInfo);
	}
}
	
void CSysOnlineUserInfoFactory::afterAdd(CSysOnlineUserInfo *pSysOnlineUserInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::beforeUpdate(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pNewSysOnlineUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysOnlineUserInfo,pNewSysOnlineUserInfo);
	}
}
	
void CSysOnlineUserInfoFactory::afterUpdate(CSysOnlineUserInfo *pSysOnlineUserInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysOnlineUserInfo);
	}
}
	
void CSysOnlineUserInfoFactory::beforeRemove(CSysOnlineUserInfo *pSysOnlineUserInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::commitAdd(CSysOnlineUserInfo *pSysOnlineUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysOnlineUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::commitUpdate(CSysOnlineUserInfo *pSysOnlineUserInfo, CWriteableSysOnlineUserInfo *pOldSysOnlineUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysOnlineUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysOnlineUserInfo,pOldSysOnlineUserInfo);
	}
}
	
void CSysOnlineUserInfoFactory::commitRemove(CWriteableSysOnlineUserInfo *pSysOnlineUserInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysOnlineUserInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysOnlineUserInfo);
	}
}

void CSysOnlineUserInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysWarningEvent(const void *pV1, const void *pV2);
extern int compareForSysEventIdIndexinSysWarningEvent(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysWarningEvent=0;
int updateWithIndexActionForSysWarningEvent=0;
int updateWithoutIndexActionForSysWarningEvent=0;
int removeActionForSysWarningEvent=0;
int addCommitForSysWarningEvent=0;
int updateCommitForSysWarningEvent=0;
int removeCommitForSysWarningEvent=0;
#endif
void CSysWarningEventFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysWarningEvent,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysWarningEvent_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysWarningEvent_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysWarningEvent,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysWarningEvent,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysWarningEvent_SysEventIdIndex",pSysEventIdIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysWarningEvent_SysEventIdIndex");
			if(it != pIndexMap->end()) {
				pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysWarningEvent,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysEventIdIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTime=NULL;
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByEvendIDs=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysWarningEventActionTrigger *>;
	pCommitTriggers=new vector<CSysWarningEventCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysWarningEventFactory::CSysWarningEventFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysWarningEvent),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysWarningEventFactory::CSysWarningEventFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysWarningEvent),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysWarningEventFactory::~CSysWarningEventFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pSysEventIdIndex!=NULL)
			delete pSysEventIdIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysWarningEventFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysWarningEventFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->output(pLogger,indent+1);
	}
}

int CSysWarningEventFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysWarningEvent thisSysWarningEvent;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysWarningEvent.readCSV(input,pNames))
		add(&thisSysWarningEvent);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysWarningEventFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysWarningEvent.csv");
	return readCSV(szFileName);
}

int CSysWarningEventFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysWarningEvent *pSysWarningEvent;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysWarningEvent::writeCSVHead(output);
	pSysWarningEvent=(CWriteableSysWarningEvent *)(pMem->getFirst());
	while (pSysWarningEvent!=NULL) {
		if (!pSysWarningEvent->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysWarningEvent=(CWriteableSysWarningEvent *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysWarningEventFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysWarningEvent.csv");
	return writeCSV(szFileName);
}

void CSysWarningEventFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysWarningEventFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysWarningEvent *pSysWarningEvent;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysWarningEventFactory={       Total Count=%d\n", pMem->getCount());
	pSysWarningEvent=(CWriteableSysWarningEvent *)(pMem->getFirst());
	while (pSysWarningEvent!=NULL) {
		pSysWarningEvent->dump(fp,index++);
		pSysWarningEvent=(CWriteableSysWarningEvent *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysWarningEventFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeAll();
	}
}

CSysWarningEvent *CSysWarningEventFactory::internalAdd(CWriteableSysWarningEvent *pSysWarningEvent, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysWarningEvent++;
#endif
	CSysWarningEvent *pTarget;	
	beforeAdd(pSysWarningEvent);
	pTarget=(CSysWarningEvent *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysWarningEvent in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysWarningEvent, sizeof(CSysWarningEvent));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysWarningEvent *CSysWarningEventFactory::add(CWriteableSysWarningEvent *pSysWarningEvent, CTransaction *pTransaction)
{
	pSysWarningEvent->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysWarningEvent,true);
	}
	else {
		CSysWarningEvent *pNewSysWarningEvent;
		pNewSysWarningEvent = internalAdd(pSysWarningEvent,false);
		pTransaction->addResource(CSysWarningEventResource::alloc(CREATE_ACTION,this,pNewSysWarningEvent,NULL));
		return pNewSysWarningEvent;
	}
}

void CSysWarningEventFactory::internalUpdate(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pNewSysWarningEvent, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysWarningEvent++;
	}
	else {
		updateWithoutIndexActionForSysWarningEvent++;
	}
#endif
	CWriteableSysWarningEvent theOldSysWarningEvent;
	beforeUpdate(pSysWarningEvent,pNewSysWarningEvent);
	if (bNoTransaction) {
		forceCopy(&theOldSysWarningEvent,pSysWarningEvent,sizeof(CSysWarningEvent));
	}
	if (updateIndex) {
	}

	forceCopy(pSysWarningEvent,pNewSysWarningEvent,sizeof(CSysWarningEvent));
	pMem->updateObject(pSysWarningEvent);
	if (updateIndex) {
	}
	afterUpdate(pSysWarningEvent);
	if (bNoTransaction) {
		commitUpdate(pSysWarningEvent,&theOldSysWarningEvent);
	}
}

void CSysWarningEventFactory::update(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pNewSysWarningEvent, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysWarningEvent->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysWarningEvent,pNewSysWarningEvent,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysWarningEventResource::alloc(UPDATE_ACTION,this,pSysWarningEvent,pNewSysWarningEvent,updateIndex));
		internalUpdate(pSysWarningEvent,pNewSysWarningEvent,updateIndex,false);
	}
}

void CSysWarningEventFactory::internalRemove(CSysWarningEvent *pSysWarningEvent, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysWarningEvent++;
#endif
	CWriteableSysWarningEvent theOldSysWarningEvent;
	beforeRemove(pSysWarningEvent);
	if (bNoTransaction) {
		forceCopy(&theOldSysWarningEvent,pSysWarningEvent,sizeof(CSysWarningEvent));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysWarningEvent);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeObject(pSysWarningEvent);
	}
	pMem->free(pSysWarningEvent);
	if(bNoTransaction) {
		commitRemove(&theOldSysWarningEvent);
	}
}

void CSysWarningEventFactory::remove(CSysWarningEvent *pSysWarningEvent, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysWarningEvent,true);
	}
	else {
		pTransaction->addResource(CSysWarningEventResource::alloc(DELETE_ACTION,this,pSysWarningEvent,NULL));
		internalRemove(pSysWarningEvent,false);		
	}
}

CSysWarningEvent* CSysWarningEventFactory::addOrUpdate(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pNewSysWarningEvent, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysWarningEvent == NULL) {
		return add(pNewSysWarningEvent,pTransaction);
	}
	else {
		update(pSysWarningEvent,pNewSysWarningEvent,pTransaction,updateIndex);
		return pSysWarningEvent;
	}
}

void CSysWarningEventFactory::retrieve(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pTargetSysWarningEvent)
{
	forceCopy(pTargetSysWarningEvent, pSysWarningEvent, sizeof(CSysWarningEvent));
}
	
int CSysWarningEventFactory::addActionTrigger(CSysWarningEventActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysWarningEventFactory::removeActionTrigger(CSysWarningEventActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysWarningEventFactory::addCommitTrigger(CSysWarningEventCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysWarningEventFactory::removeCommitTrigger(CSysWarningEventCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysWarningEvent *CSysWarningEventFactory::getFirst(void)
{
	CSysWarningEvent *pResult=(CSysWarningEvent *)(pMem->getFirst());
	return pResult;
}
	
CSysWarningEvent *CSysWarningEventFactory::getNext(void)
{
	CSysWarningEvent *pResult=(CSysWarningEvent *)(pMem->getNext());
	return pResult;
}
	
void CSysWarningEventFactory::endGet(void)
{
	pMem->endGet();
}

void CSysWarningEventFactory::beforeAdd(CWriteableSysWarningEvent *pSysWarningEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysWarningEvent);
	}
}
	
void CSysWarningEventFactory::afterAdd(CSysWarningEvent *pSysWarningEvent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysWarningEvent);
	}
}

void CSysWarningEventFactory::beforeUpdate(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pNewSysWarningEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysWarningEvent,pNewSysWarningEvent);
	}
}
	
void CSysWarningEventFactory::afterUpdate(CSysWarningEvent *pSysWarningEvent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysWarningEvent);
	}
}
	
void CSysWarningEventFactory::beforeRemove(CSysWarningEvent *pSysWarningEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysWarningEvent);
	}
}

void CSysWarningEventFactory::commitAdd(CSysWarningEvent *pSysWarningEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysWarningEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysWarningEvent);
	}
}

void CSysWarningEventFactory::commitUpdate(CSysWarningEvent *pSysWarningEvent, CWriteableSysWarningEvent *pOldSysWarningEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysWarningEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysWarningEvent,pOldSysWarningEvent);
	}
}
	
void CSysWarningEventFactory::commitRemove(CWriteableSysWarningEvent *pSysWarningEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysWarningEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysWarningEvent);
	}
}

void CSysWarningEventFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysWarningQuery(const void *pV1, const void *pV2);
extern int compareForSysEventIdIndexinSysWarningQuery(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysWarningQuery=0;
int updateWithIndexActionForSysWarningQuery=0;
int updateWithoutIndexActionForSysWarningQuery=0;
int removeActionForSysWarningQuery=0;
int addCommitForSysWarningQuery=0;
int updateCommitForSysWarningQuery=0;
int removeCommitForSysWarningQuery=0;
#endif
void CSysWarningQueryFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysWarningQuery,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysWarningQuery_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysWarningQuery_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysWarningQuery,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysWarningQuery,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysWarningQuery_SysEventIdIndex",pSysEventIdIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysWarningQuery_SysEventIdIndex");
			if(it != pIndexMap->end()) {
				pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysWarningQuery,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysEventIdIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTime=NULL;
	pActionTriggers=new vector<CSysWarningQueryActionTrigger *>;
	pCommitTriggers=new vector<CSysWarningQueryCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysWarningQueryFactory::CSysWarningQueryFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysWarningQuery),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysWarningQueryFactory::CSysWarningQueryFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysWarningQuery),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysWarningQueryFactory::~CSysWarningQueryFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pSysEventIdIndex!=NULL)
			delete pSysEventIdIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysWarningQueryFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysWarningQueryFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->output(pLogger,indent+1);
	}
}

int CSysWarningQueryFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysWarningQuery thisSysWarningQuery;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysWarningQuery.readCSV(input,pNames))
		add(&thisSysWarningQuery);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysWarningQueryFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysWarningQuery.csv");
	return readCSV(szFileName);
}

int CSysWarningQueryFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysWarningQuery *pSysWarningQuery;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysWarningQuery::writeCSVHead(output);
	pSysWarningQuery=(CWriteableSysWarningQuery *)(pMem->getFirst());
	while (pSysWarningQuery!=NULL) {
		if (!pSysWarningQuery->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysWarningQuery=(CWriteableSysWarningQuery *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysWarningQueryFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysWarningQuery.csv");
	return writeCSV(szFileName);
}

void CSysWarningQueryFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysWarningQueryFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysWarningQuery *pSysWarningQuery;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysWarningQueryFactory={       Total Count=%d\n", pMem->getCount());
	pSysWarningQuery=(CWriteableSysWarningQuery *)(pMem->getFirst());
	while (pSysWarningQuery!=NULL) {
		pSysWarningQuery->dump(fp,index++);
		pSysWarningQuery=(CWriteableSysWarningQuery *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysWarningQueryFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeAll();
	}
}

CSysWarningQuery *CSysWarningQueryFactory::internalAdd(CWriteableSysWarningQuery *pSysWarningQuery, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysWarningQuery++;
#endif
	CSysWarningQuery *pTarget;	
	beforeAdd(pSysWarningQuery);
	pTarget=(CSysWarningQuery *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysWarningQuery in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysWarningQuery, sizeof(CSysWarningQuery));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysWarningQuery *CSysWarningQueryFactory::add(CWriteableSysWarningQuery *pSysWarningQuery, CTransaction *pTransaction)
{
	pSysWarningQuery->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysWarningQuery,true);
	}
	else {
		CSysWarningQuery *pNewSysWarningQuery;
		pNewSysWarningQuery = internalAdd(pSysWarningQuery,false);
		pTransaction->addResource(CSysWarningQueryResource::alloc(CREATE_ACTION,this,pNewSysWarningQuery,NULL));
		return pNewSysWarningQuery;
	}
}

void CSysWarningQueryFactory::internalUpdate(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pNewSysWarningQuery, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysWarningQuery++;
	}
	else {
		updateWithoutIndexActionForSysWarningQuery++;
	}
#endif
	CWriteableSysWarningQuery theOldSysWarningQuery;
	beforeUpdate(pSysWarningQuery,pNewSysWarningQuery);
	if (bNoTransaction) {
		forceCopy(&theOldSysWarningQuery,pSysWarningQuery,sizeof(CSysWarningQuery));
	}
	if (updateIndex) {
	}

	forceCopy(pSysWarningQuery,pNewSysWarningQuery,sizeof(CSysWarningQuery));
	pMem->updateObject(pSysWarningQuery);
	if (updateIndex) {
	}
	afterUpdate(pSysWarningQuery);
	if (bNoTransaction) {
		commitUpdate(pSysWarningQuery,&theOldSysWarningQuery);
	}
}

void CSysWarningQueryFactory::update(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pNewSysWarningQuery, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysWarningQuery->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysWarningQuery,pNewSysWarningQuery,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysWarningQueryResource::alloc(UPDATE_ACTION,this,pSysWarningQuery,pNewSysWarningQuery,updateIndex));
		internalUpdate(pSysWarningQuery,pNewSysWarningQuery,updateIndex,false);
	}
}

void CSysWarningQueryFactory::internalRemove(CSysWarningQuery *pSysWarningQuery, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysWarningQuery++;
#endif
	CWriteableSysWarningQuery theOldSysWarningQuery;
	beforeRemove(pSysWarningQuery);
	if (bNoTransaction) {
		forceCopy(&theOldSysWarningQuery,pSysWarningQuery,sizeof(CSysWarningQuery));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysWarningQuery);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeObject(pSysWarningQuery);
	}
	pMem->free(pSysWarningQuery);
	if(bNoTransaction) {
		commitRemove(&theOldSysWarningQuery);
	}
}

void CSysWarningQueryFactory::remove(CSysWarningQuery *pSysWarningQuery, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysWarningQuery,true);
	}
	else {
		pTransaction->addResource(CSysWarningQueryResource::alloc(DELETE_ACTION,this,pSysWarningQuery,NULL));
		internalRemove(pSysWarningQuery,false);		
	}
}

CSysWarningQuery* CSysWarningQueryFactory::addOrUpdate(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pNewSysWarningQuery, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysWarningQuery == NULL) {
		return add(pNewSysWarningQuery,pTransaction);
	}
	else {
		update(pSysWarningQuery,pNewSysWarningQuery,pTransaction,updateIndex);
		return pSysWarningQuery;
	}
}

void CSysWarningQueryFactory::retrieve(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pTargetSysWarningQuery)
{
	forceCopy(pTargetSysWarningQuery, pSysWarningQuery, sizeof(CSysWarningQuery));
}
	
int CSysWarningQueryFactory::addActionTrigger(CSysWarningQueryActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysWarningQueryFactory::removeActionTrigger(CSysWarningQueryActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysWarningQueryFactory::addCommitTrigger(CSysWarningQueryCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysWarningQueryFactory::removeCommitTrigger(CSysWarningQueryCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysWarningQuery *CSysWarningQueryFactory::getFirst(void)
{
	CSysWarningQuery *pResult=(CSysWarningQuery *)(pMem->getFirst());
	return pResult;
}
	
CSysWarningQuery *CSysWarningQueryFactory::getNext(void)
{
	CSysWarningQuery *pResult=(CSysWarningQuery *)(pMem->getNext());
	return pResult;
}
	
void CSysWarningQueryFactory::endGet(void)
{
	pMem->endGet();
}

void CSysWarningQueryFactory::beforeAdd(CWriteableSysWarningQuery *pSysWarningQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysWarningQuery);
	}
}
	
void CSysWarningQueryFactory::afterAdd(CSysWarningQuery *pSysWarningQuery)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysWarningQuery);
	}
}

void CSysWarningQueryFactory::beforeUpdate(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pNewSysWarningQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysWarningQuery,pNewSysWarningQuery);
	}
}
	
void CSysWarningQueryFactory::afterUpdate(CSysWarningQuery *pSysWarningQuery)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysWarningQuery);
	}
}
	
void CSysWarningQueryFactory::beforeRemove(CSysWarningQuery *pSysWarningQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysWarningQuery);
	}
}

void CSysWarningQueryFactory::commitAdd(CSysWarningQuery *pSysWarningQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysWarningQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysWarningQuery);
	}
}

void CSysWarningQueryFactory::commitUpdate(CSysWarningQuery *pSysWarningQuery, CWriteableSysWarningQuery *pOldSysWarningQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysWarningQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysWarningQuery,pOldSysWarningQuery);
	}
}
	
void CSysWarningQueryFactory::commitRemove(CWriteableSysWarningQuery *pSysWarningQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysWarningQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysWarningQuery);
	}
}

void CSysWarningQueryFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTimeIndexinSyslogEvent(const void *pV1, const void *pV2);
extern int compareForSysEventIdIndexinSyslogEvent(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSyslogEvent=0;
int updateWithIndexActionForSyslogEvent=0;
int updateWithoutIndexActionForSyslogEvent=0;
int removeActionForSyslogEvent=0;
int addCommitForSyslogEvent=0;
int updateCommitForSyslogEvent=0;
int removeCommitForSyslogEvent=0;
#endif
void CSyslogEventFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTimeIndex=new CAVLTree(maxUnit,compareForSysTimeIndexinSyslogEvent,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SyslogEvent_SysTimeIndex",pSysTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SyslogEvent_SysTimeIndex");
			if(it != pIndexMap->end()) {
				pSysTimeIndex=new CAVLTree(maxUnit,compareForSysTimeIndexinSyslogEvent,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSyslogEvent,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SyslogEvent_SysEventIdIndex",pSysEventIdIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SyslogEvent_SysEventIdIndex");
			if(it != pIndexMap->end()) {
				pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSyslogEvent,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysEventIdIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTime=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSyslogEventActionTrigger *>;
	pCommitTriggers=new vector<CSyslogEventCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSyslogEventFactory::CSyslogEventFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSyslogEvent),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSyslogEventFactory::CSyslogEventFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSyslogEvent),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSyslogEventFactory::~CSyslogEventFactory(void)
{
	if (runLevel>=0) {
		if (pSysTimeIndex!=NULL)
			delete pSysTimeIndex;
	}
	if (runLevel>=0) {
		if (pSysEventIdIndex!=NULL)
			delete pSysEventIdIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSyslogEventFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSyslogEventFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTimeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->output(pLogger,indent+1);
	}
}

int CSyslogEventFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSyslogEvent thisSyslogEvent;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSyslogEvent.readCSV(input,pNames))
		add(&thisSyslogEvent);
	fclose(input);
	delete pNames;
	return 1;
}

int CSyslogEventFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SyslogEvent.csv");
	return readCSV(szFileName);
}

int CSyslogEventFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSyslogEvent *pSyslogEvent;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSyslogEvent::writeCSVHead(output);
	pSyslogEvent=(CWriteableSyslogEvent *)(pMem->getFirst());
	while (pSyslogEvent!=NULL) {
		if (!pSyslogEvent->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSyslogEvent=(CWriteableSyslogEvent *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSyslogEventFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SyslogEvent.csv");
	return writeCSV(szFileName);
}

void CSyslogEventFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSyslogEventFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSyslogEvent *pSyslogEvent;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSyslogEventFactory={       Total Count=%d\n", pMem->getCount());
	pSyslogEvent=(CWriteableSyslogEvent *)(pMem->getFirst());
	while (pSyslogEvent!=NULL) {
		pSyslogEvent->dump(fp,index++);
		pSyslogEvent=(CWriteableSyslogEvent *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSyslogEventFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTimeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeAll();
	}
}

CSyslogEvent *CSyslogEventFactory::internalAdd(CWriteableSyslogEvent *pSyslogEvent, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSyslogEvent++;
#endif
	CSyslogEvent *pTarget;	
	beforeAdd(pSyslogEvent);
	pTarget=(CSyslogEvent *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SyslogEvent in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSyslogEvent, sizeof(CSyslogEvent));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTimeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSyslogEvent *CSyslogEventFactory::add(CWriteableSyslogEvent *pSyslogEvent, CTransaction *pTransaction)
{
	pSyslogEvent->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSyslogEvent,true);
	}
	else {
		CSyslogEvent *pNewSyslogEvent;
		pNewSyslogEvent = internalAdd(pSyslogEvent,false);
		pTransaction->addResource(CSyslogEventResource::alloc(CREATE_ACTION,this,pNewSyslogEvent,NULL));
		return pNewSyslogEvent;
	}
}

void CSyslogEventFactory::internalUpdate(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pNewSyslogEvent, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSyslogEvent++;
	}
	else {
		updateWithoutIndexActionForSyslogEvent++;
	}
#endif
	CWriteableSyslogEvent theOldSyslogEvent;
	beforeUpdate(pSyslogEvent,pNewSyslogEvent);
	if (bNoTransaction) {
		forceCopy(&theOldSyslogEvent,pSyslogEvent,sizeof(CSyslogEvent));
	}
	if (updateIndex) {
	}

	forceCopy(pSyslogEvent,pNewSyslogEvent,sizeof(CSyslogEvent));
	pMem->updateObject(pSyslogEvent);
	if (updateIndex) {
	}
	afterUpdate(pSyslogEvent);
	if (bNoTransaction) {
		commitUpdate(pSyslogEvent,&theOldSyslogEvent);
	}
}

void CSyslogEventFactory::update(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pNewSyslogEvent, CTransaction *pTransaction, bool updateIndex)
{
	pNewSyslogEvent->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSyslogEvent,pNewSyslogEvent,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSyslogEventResource::alloc(UPDATE_ACTION,this,pSyslogEvent,pNewSyslogEvent,updateIndex));
		internalUpdate(pSyslogEvent,pNewSyslogEvent,updateIndex,false);
	}
}

void CSyslogEventFactory::internalRemove(CSyslogEvent *pSyslogEvent, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSyslogEvent++;
#endif
	CWriteableSyslogEvent theOldSyslogEvent;
	beforeRemove(pSyslogEvent);
	if (bNoTransaction) {
		forceCopy(&theOldSyslogEvent,pSyslogEvent,sizeof(CSyslogEvent));
	}
	if (runLevel>=0) {
		pSysTimeIndex->removeObject(pSyslogEvent);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeObject(pSyslogEvent);
	}
	pMem->free(pSyslogEvent);
	if(bNoTransaction) {
		commitRemove(&theOldSyslogEvent);
	}
}

void CSyslogEventFactory::remove(CSyslogEvent *pSyslogEvent, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSyslogEvent,true);
	}
	else {
		pTransaction->addResource(CSyslogEventResource::alloc(DELETE_ACTION,this,pSyslogEvent,NULL));
		internalRemove(pSyslogEvent,false);		
	}
}

CSyslogEvent* CSyslogEventFactory::addOrUpdate(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pNewSyslogEvent, CTransaction *pTransaction, bool updateIndex)
{
	if(pSyslogEvent == NULL) {
		return add(pNewSyslogEvent,pTransaction);
	}
	else {
		update(pSyslogEvent,pNewSyslogEvent,pTransaction,updateIndex);
		return pSyslogEvent;
	}
}

void CSyslogEventFactory::retrieve(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pTargetSyslogEvent)
{
	forceCopy(pTargetSyslogEvent, pSyslogEvent, sizeof(CSyslogEvent));
}
	
int CSyslogEventFactory::addActionTrigger(CSyslogEventActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSyslogEventFactory::removeActionTrigger(CSyslogEventActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSyslogEventFactory::addCommitTrigger(CSyslogEventCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSyslogEventFactory::removeCommitTrigger(CSyslogEventCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSyslogEvent *CSyslogEventFactory::getFirst(void)
{
	CSyslogEvent *pResult=(CSyslogEvent *)(pMem->getFirst());
	return pResult;
}
	
CSyslogEvent *CSyslogEventFactory::getNext(void)
{
	CSyslogEvent *pResult=(CSyslogEvent *)(pMem->getNext());
	return pResult;
}
	
void CSyslogEventFactory::endGet(void)
{
	pMem->endGet();
}

void CSyslogEventFactory::beforeAdd(CWriteableSyslogEvent *pSyslogEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSyslogEvent);
	}
}
	
void CSyslogEventFactory::afterAdd(CSyslogEvent *pSyslogEvent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSyslogEvent);
	}
}

void CSyslogEventFactory::beforeUpdate(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pNewSyslogEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSyslogEvent,pNewSyslogEvent);
	}
}
	
void CSyslogEventFactory::afterUpdate(CSyslogEvent *pSyslogEvent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSyslogEvent);
	}
}
	
void CSyslogEventFactory::beforeRemove(CSyslogEvent *pSyslogEvent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSyslogEvent);
	}
}

void CSyslogEventFactory::commitAdd(CSyslogEvent *pSyslogEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSyslogEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSyslogEvent);
	}
}

void CSyslogEventFactory::commitUpdate(CSyslogEvent *pSyslogEvent, CWriteableSyslogEvent *pOldSyslogEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSyslogEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSyslogEvent,pOldSyslogEvent);
	}
}
	
void CSyslogEventFactory::commitRemove(CWriteableSyslogEvent *pSyslogEvent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSyslogEvent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSyslogEvent);
	}
}

void CSyslogEventFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTimeIndexinSysEventDescrip(const void *pV1, const void *pV2);
extern int compareForSysEventIdIndexinSysEventDescrip(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysEventDescrip=0;
int updateWithIndexActionForSysEventDescrip=0;
int updateWithoutIndexActionForSysEventDescrip=0;
int removeActionForSysEventDescrip=0;
int addCommitForSysEventDescrip=0;
int updateCommitForSysEventDescrip=0;
int removeCommitForSysEventDescrip=0;
#endif
void CSysEventDescripFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTimeIndex=new CAVLTree(maxUnit,compareForSysTimeIndexinSysEventDescrip,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysEventDescrip_SysTimeIndex",pSysTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysEventDescrip_SysTimeIndex");
			if(it != pIndexMap->end()) {
				pSysTimeIndex=new CAVLTree(maxUnit,compareForSysTimeIndexinSysEventDescrip,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysEventDescrip,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysEventDescrip_SysEventIdIndex",pSysEventIdIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysEventDescrip_SysEventIdIndex");
			if(it != pIndexMap->end()) {
				pSysEventIdIndex=new CAVLTree(maxUnit,compareForSysEventIdIndexinSysEventDescrip,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysEventIdIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTime=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysEventDescripActionTrigger *>;
	pCommitTriggers=new vector<CSysEventDescripCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysEventDescripFactory::CSysEventDescripFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysEventDescrip),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysEventDescripFactory::CSysEventDescripFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysEventDescrip),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysEventDescripFactory::~CSysEventDescripFactory(void)
{
	if (runLevel>=0) {
		if (pSysTimeIndex!=NULL)
			delete pSysTimeIndex;
	}
	if (runLevel>=0) {
		if (pSysEventIdIndex!=NULL)
			delete pSysEventIdIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysEventDescripFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysEventDescripFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTimeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->output(pLogger,indent+1);
	}
}

int CSysEventDescripFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysEventDescrip thisSysEventDescrip;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysEventDescrip.readCSV(input,pNames))
		add(&thisSysEventDescrip);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysEventDescripFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysEventDescrip.csv");
	return readCSV(szFileName);
}

int CSysEventDescripFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysEventDescrip *pSysEventDescrip;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysEventDescrip::writeCSVHead(output);
	pSysEventDescrip=(CWriteableSysEventDescrip *)(pMem->getFirst());
	while (pSysEventDescrip!=NULL) {
		if (!pSysEventDescrip->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysEventDescrip=(CWriteableSysEventDescrip *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysEventDescripFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysEventDescrip.csv");
	return writeCSV(szFileName);
}

void CSysEventDescripFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysEventDescripFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysEventDescrip *pSysEventDescrip;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysEventDescripFactory={       Total Count=%d\n", pMem->getCount());
	pSysEventDescrip=(CWriteableSysEventDescrip *)(pMem->getFirst());
	while (pSysEventDescrip!=NULL) {
		pSysEventDescrip->dump(fp,index++);
		pSysEventDescrip=(CWriteableSysEventDescrip *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysEventDescripFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTimeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeAll();
	}
}

CSysEventDescrip *CSysEventDescripFactory::internalAdd(CWriteableSysEventDescrip *pSysEventDescrip, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysEventDescrip++;
#endif
	CSysEventDescrip *pTarget;	
	beforeAdd(pSysEventDescrip);
	pTarget=(CSysEventDescrip *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysEventDescrip in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysEventDescrip, sizeof(CSysEventDescrip));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTimeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysEventDescrip *CSysEventDescripFactory::add(CWriteableSysEventDescrip *pSysEventDescrip, CTransaction *pTransaction)
{
	pSysEventDescrip->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysEventDescrip,true);
	}
	else {
		CSysEventDescrip *pNewSysEventDescrip;
		pNewSysEventDescrip = internalAdd(pSysEventDescrip,false);
		pTransaction->addResource(CSysEventDescripResource::alloc(CREATE_ACTION,this,pNewSysEventDescrip,NULL));
		return pNewSysEventDescrip;
	}
}

void CSysEventDescripFactory::internalUpdate(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pNewSysEventDescrip, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysEventDescrip++;
	}
	else {
		updateWithoutIndexActionForSysEventDescrip++;
	}
#endif
	CWriteableSysEventDescrip theOldSysEventDescrip;
	beforeUpdate(pSysEventDescrip,pNewSysEventDescrip);
	if (bNoTransaction) {
		forceCopy(&theOldSysEventDescrip,pSysEventDescrip,sizeof(CSysEventDescrip));
	}
	if (updateIndex) {
	}

	forceCopy(pSysEventDescrip,pNewSysEventDescrip,sizeof(CSysEventDescrip));
	pMem->updateObject(pSysEventDescrip);
	if (updateIndex) {
	}
	afterUpdate(pSysEventDescrip);
	if (bNoTransaction) {
		commitUpdate(pSysEventDescrip,&theOldSysEventDescrip);
	}
}

void CSysEventDescripFactory::update(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pNewSysEventDescrip, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysEventDescrip->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysEventDescrip,pNewSysEventDescrip,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysEventDescripResource::alloc(UPDATE_ACTION,this,pSysEventDescrip,pNewSysEventDescrip,updateIndex));
		internalUpdate(pSysEventDescrip,pNewSysEventDescrip,updateIndex,false);
	}
}

void CSysEventDescripFactory::internalRemove(CSysEventDescrip *pSysEventDescrip, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysEventDescrip++;
#endif
	CWriteableSysEventDescrip theOldSysEventDescrip;
	beforeRemove(pSysEventDescrip);
	if (bNoTransaction) {
		forceCopy(&theOldSysEventDescrip,pSysEventDescrip,sizeof(CSysEventDescrip));
	}
	if (runLevel>=0) {
		pSysTimeIndex->removeObject(pSysEventDescrip);
	}
	if (runLevel>=0) {
		pSysEventIdIndex->removeObject(pSysEventDescrip);
	}
	pMem->free(pSysEventDescrip);
	if(bNoTransaction) {
		commitRemove(&theOldSysEventDescrip);
	}
}

void CSysEventDescripFactory::remove(CSysEventDescrip *pSysEventDescrip, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysEventDescrip,true);
	}
	else {
		pTransaction->addResource(CSysEventDescripResource::alloc(DELETE_ACTION,this,pSysEventDescrip,NULL));
		internalRemove(pSysEventDescrip,false);		
	}
}

CSysEventDescrip* CSysEventDescripFactory::addOrUpdate(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pNewSysEventDescrip, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysEventDescrip == NULL) {
		return add(pNewSysEventDescrip,pTransaction);
	}
	else {
		update(pSysEventDescrip,pNewSysEventDescrip,pTransaction,updateIndex);
		return pSysEventDescrip;
	}
}

void CSysEventDescripFactory::retrieve(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pTargetSysEventDescrip)
{
	forceCopy(pTargetSysEventDescrip, pSysEventDescrip, sizeof(CSysEventDescrip));
}
	
int CSysEventDescripFactory::addActionTrigger(CSysEventDescripActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysEventDescripFactory::removeActionTrigger(CSysEventDescripActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysEventDescripFactory::addCommitTrigger(CSysEventDescripCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysEventDescripFactory::removeCommitTrigger(CSysEventDescripCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysEventDescrip *CSysEventDescripFactory::getFirst(void)
{
	CSysEventDescrip *pResult=(CSysEventDescrip *)(pMem->getFirst());
	return pResult;
}
	
CSysEventDescrip *CSysEventDescripFactory::getNext(void)
{
	CSysEventDescrip *pResult=(CSysEventDescrip *)(pMem->getNext());
	return pResult;
}
	
void CSysEventDescripFactory::endGet(void)
{
	pMem->endGet();
}

void CSysEventDescripFactory::beforeAdd(CWriteableSysEventDescrip *pSysEventDescrip)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysEventDescrip);
	}
}
	
void CSysEventDescripFactory::afterAdd(CSysEventDescrip *pSysEventDescrip)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysEventDescrip);
	}
}

void CSysEventDescripFactory::beforeUpdate(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pNewSysEventDescrip)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysEventDescrip,pNewSysEventDescrip);
	}
}
	
void CSysEventDescripFactory::afterUpdate(CSysEventDescrip *pSysEventDescrip)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysEventDescrip);
	}
}
	
void CSysEventDescripFactory::beforeRemove(CSysEventDescrip *pSysEventDescrip)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysEventDescrip);
	}
}

void CSysEventDescripFactory::commitAdd(CSysEventDescrip *pSysEventDescrip)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysEventDescrip++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysEventDescrip);
	}
}

void CSysEventDescripFactory::commitUpdate(CSysEventDescrip *pSysEventDescrip, CWriteableSysEventDescrip *pOldSysEventDescrip)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysEventDescrip++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysEventDescrip,pOldSysEventDescrip);
	}
}
	
void CSysEventDescripFactory::commitRemove(CWriteableSysEventDescrip *pSysEventDescrip)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysEventDescrip++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysEventDescrip);
	}
}

void CSysEventDescripFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvCommon(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvCommon=0;
int updateWithIndexActionForRspQryHostEnvCommon=0;
int updateWithoutIndexActionForRspQryHostEnvCommon=0;
int removeActionForRspQryHostEnvCommon=0;
int addCommitForRspQryHostEnvCommon=0;
int updateCommitForRspQryHostEnvCommon=0;
int removeCommitForRspQryHostEnvCommon=0;
#endif
void CRspQryHostEnvCommonFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvCommon,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvCommon_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvCommon_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvCommon,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvCommonActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvCommonCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvCommonFactory::CRspQryHostEnvCommonFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvCommon),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvCommonFactory::CRspQryHostEnvCommonFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvCommon),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvCommonFactory::~CRspQryHostEnvCommonFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvCommonFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvCommonFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvCommonFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvCommon thisRspQryHostEnvCommon;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvCommon.readCSV(input,pNames))
		add(&thisRspQryHostEnvCommon);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvCommonFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvCommon.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvCommonFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvCommon::writeCSVHead(output);
	pRspQryHostEnvCommon=(CWriteableRspQryHostEnvCommon *)(pMem->getFirst());
	while (pRspQryHostEnvCommon!=NULL) {
		if (!pRspQryHostEnvCommon->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvCommon=(CWriteableRspQryHostEnvCommon *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvCommonFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvCommon.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvCommonFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvCommonFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvCommonFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvCommon=(CWriteableRspQryHostEnvCommon *)(pMem->getFirst());
	while (pRspQryHostEnvCommon!=NULL) {
		pRspQryHostEnvCommon->dump(fp,index++);
		pRspQryHostEnvCommon=(CWriteableRspQryHostEnvCommon *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvCommonFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvCommon *CRspQryHostEnvCommonFactory::internalAdd(CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvCommon++;
#endif
	CRspQryHostEnvCommon *pTarget;	
	beforeAdd(pRspQryHostEnvCommon);
	pTarget=(CRspQryHostEnvCommon *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvCommon in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvCommon, sizeof(CRspQryHostEnvCommon));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvCommon *CRspQryHostEnvCommonFactory::add(CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon, CTransaction *pTransaction)
{
	pRspQryHostEnvCommon->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvCommon,true);
	}
	else {
		CRspQryHostEnvCommon *pNewRspQryHostEnvCommon;
		pNewRspQryHostEnvCommon = internalAdd(pRspQryHostEnvCommon,false);
		pTransaction->addResource(CRspQryHostEnvCommonResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvCommon,NULL));
		return pNewRspQryHostEnvCommon;
	}
}

void CRspQryHostEnvCommonFactory::internalUpdate(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pNewRspQryHostEnvCommon, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvCommon++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvCommon++;
	}
#endif
	CWriteableRspQryHostEnvCommon theOldRspQryHostEnvCommon;
	beforeUpdate(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvCommon,pRspQryHostEnvCommon,sizeof(CRspQryHostEnvCommon));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon,sizeof(CRspQryHostEnvCommon));
	pMem->updateObject(pRspQryHostEnvCommon);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvCommon);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvCommon,&theOldRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::update(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pNewRspQryHostEnvCommon, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvCommon->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvCommonResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvCommon,pNewRspQryHostEnvCommon,updateIndex));
		internalUpdate(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon,updateIndex,false);
	}
}

void CRspQryHostEnvCommonFactory::internalRemove(CRspQryHostEnvCommon *pRspQryHostEnvCommon, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvCommon++;
#endif
	CWriteableRspQryHostEnvCommon theOldRspQryHostEnvCommon;
	beforeRemove(pRspQryHostEnvCommon);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvCommon,pRspQryHostEnvCommon,sizeof(CRspQryHostEnvCommon));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvCommon);
	}
	pMem->free(pRspQryHostEnvCommon);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::remove(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvCommon,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvCommonResource::alloc(DELETE_ACTION,this,pRspQryHostEnvCommon,NULL));
		internalRemove(pRspQryHostEnvCommon,false);		
	}
}

CRspQryHostEnvCommon* CRspQryHostEnvCommonFactory::addOrUpdate(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pNewRspQryHostEnvCommon, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvCommon == NULL) {
		return add(pNewRspQryHostEnvCommon,pTransaction);
	}
	else {
		update(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon,pTransaction,updateIndex);
		return pRspQryHostEnvCommon;
	}
}

void CRspQryHostEnvCommonFactory::retrieve(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pTargetRspQryHostEnvCommon)
{
	forceCopy(pTargetRspQryHostEnvCommon, pRspQryHostEnvCommon, sizeof(CRspQryHostEnvCommon));
}
	
int CRspQryHostEnvCommonFactory::addActionTrigger(CRspQryHostEnvCommonActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvCommonFactory::removeActionTrigger(CRspQryHostEnvCommonActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvCommonFactory::addCommitTrigger(CRspQryHostEnvCommonCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvCommonFactory::removeCommitTrigger(CRspQryHostEnvCommonCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvCommon *CRspQryHostEnvCommonFactory::getFirst(void)
{
	CRspQryHostEnvCommon *pResult=(CRspQryHostEnvCommon *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvCommon *CRspQryHostEnvCommonFactory::getNext(void)
{
	CRspQryHostEnvCommon *pResult=(CRspQryHostEnvCommon *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvCommonFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvCommonFactory::beforeAdd(CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvCommon);
	}
}
	
void CRspQryHostEnvCommonFactory::afterAdd(CRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::beforeUpdate(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pNewRspQryHostEnvCommon)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvCommon,pNewRspQryHostEnvCommon);
	}
}
	
void CRspQryHostEnvCommonFactory::afterUpdate(CRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvCommon);
	}
}
	
void CRspQryHostEnvCommonFactory::beforeRemove(CRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::commitAdd(CRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvCommon++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::commitUpdate(CRspQryHostEnvCommon *pRspQryHostEnvCommon, CWriteableRspQryHostEnvCommon *pOldRspQryHostEnvCommon)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvCommon++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvCommon,pOldRspQryHostEnvCommon);
	}
}
	
void CRspQryHostEnvCommonFactory::commitRemove(CWriteableRspQryHostEnvCommon *pRspQryHostEnvCommon)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvCommon++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvCommon);
	}
}

void CRspQryHostEnvCommonFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvLan(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvLan=0;
int updateWithIndexActionForRspQryHostEnvLan=0;
int updateWithoutIndexActionForRspQryHostEnvLan=0;
int removeActionForRspQryHostEnvLan=0;
int addCommitForRspQryHostEnvLan=0;
int updateCommitForRspQryHostEnvLan=0;
int removeCommitForRspQryHostEnvLan=0;
#endif
void CRspQryHostEnvLanFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvLan,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvLan_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvLan_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvLan,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvLanActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvLanCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvLanFactory::CRspQryHostEnvLanFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvLan),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvLanFactory::CRspQryHostEnvLanFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvLan),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvLanFactory::~CRspQryHostEnvLanFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvLanFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvLanFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvLanFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvLan thisRspQryHostEnvLan;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvLan.readCSV(input,pNames))
		add(&thisRspQryHostEnvLan);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvLanFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvLan.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvLanFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvLan *pRspQryHostEnvLan;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvLan::writeCSVHead(output);
	pRspQryHostEnvLan=(CWriteableRspQryHostEnvLan *)(pMem->getFirst());
	while (pRspQryHostEnvLan!=NULL) {
		if (!pRspQryHostEnvLan->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvLan=(CWriteableRspQryHostEnvLan *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvLanFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvLan.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvLanFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvLanFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvLan *pRspQryHostEnvLan;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvLanFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvLan=(CWriteableRspQryHostEnvLan *)(pMem->getFirst());
	while (pRspQryHostEnvLan!=NULL) {
		pRspQryHostEnvLan->dump(fp,index++);
		pRspQryHostEnvLan=(CWriteableRspQryHostEnvLan *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvLanFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvLan *CRspQryHostEnvLanFactory::internalAdd(CWriteableRspQryHostEnvLan *pRspQryHostEnvLan, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvLan++;
#endif
	CRspQryHostEnvLan *pTarget;	
	beforeAdd(pRspQryHostEnvLan);
	pTarget=(CRspQryHostEnvLan *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvLan in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvLan, sizeof(CRspQryHostEnvLan));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvLan *CRspQryHostEnvLanFactory::add(CWriteableRspQryHostEnvLan *pRspQryHostEnvLan, CTransaction *pTransaction)
{
	pRspQryHostEnvLan->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvLan,true);
	}
	else {
		CRspQryHostEnvLan *pNewRspQryHostEnvLan;
		pNewRspQryHostEnvLan = internalAdd(pRspQryHostEnvLan,false);
		pTransaction->addResource(CRspQryHostEnvLanResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvLan,NULL));
		return pNewRspQryHostEnvLan;
	}
}

void CRspQryHostEnvLanFactory::internalUpdate(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pNewRspQryHostEnvLan, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvLan++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvLan++;
	}
#endif
	CWriteableRspQryHostEnvLan theOldRspQryHostEnvLan;
	beforeUpdate(pRspQryHostEnvLan,pNewRspQryHostEnvLan);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvLan,pRspQryHostEnvLan,sizeof(CRspQryHostEnvLan));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvLan,pNewRspQryHostEnvLan,sizeof(CRspQryHostEnvLan));
	pMem->updateObject(pRspQryHostEnvLan);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvLan);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvLan,&theOldRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::update(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pNewRspQryHostEnvLan, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvLan->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvLan,pNewRspQryHostEnvLan,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvLanResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvLan,pNewRspQryHostEnvLan,updateIndex));
		internalUpdate(pRspQryHostEnvLan,pNewRspQryHostEnvLan,updateIndex,false);
	}
}

void CRspQryHostEnvLanFactory::internalRemove(CRspQryHostEnvLan *pRspQryHostEnvLan, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvLan++;
#endif
	CWriteableRspQryHostEnvLan theOldRspQryHostEnvLan;
	beforeRemove(pRspQryHostEnvLan);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvLan,pRspQryHostEnvLan,sizeof(CRspQryHostEnvLan));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvLan);
	}
	pMem->free(pRspQryHostEnvLan);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::remove(CRspQryHostEnvLan *pRspQryHostEnvLan, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvLan,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvLanResource::alloc(DELETE_ACTION,this,pRspQryHostEnvLan,NULL));
		internalRemove(pRspQryHostEnvLan,false);		
	}
}

CRspQryHostEnvLan* CRspQryHostEnvLanFactory::addOrUpdate(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pNewRspQryHostEnvLan, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvLan == NULL) {
		return add(pNewRspQryHostEnvLan,pTransaction);
	}
	else {
		update(pRspQryHostEnvLan,pNewRspQryHostEnvLan,pTransaction,updateIndex);
		return pRspQryHostEnvLan;
	}
}

void CRspQryHostEnvLanFactory::retrieve(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pTargetRspQryHostEnvLan)
{
	forceCopy(pTargetRspQryHostEnvLan, pRspQryHostEnvLan, sizeof(CRspQryHostEnvLan));
}
	
int CRspQryHostEnvLanFactory::addActionTrigger(CRspQryHostEnvLanActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvLanFactory::removeActionTrigger(CRspQryHostEnvLanActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvLanFactory::addCommitTrigger(CRspQryHostEnvLanCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvLanFactory::removeCommitTrigger(CRspQryHostEnvLanCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvLan *CRspQryHostEnvLanFactory::getFirst(void)
{
	CRspQryHostEnvLan *pResult=(CRspQryHostEnvLan *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvLan *CRspQryHostEnvLanFactory::getNext(void)
{
	CRspQryHostEnvLan *pResult=(CRspQryHostEnvLan *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvLanFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvLanFactory::beforeAdd(CWriteableRspQryHostEnvLan *pRspQryHostEnvLan)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvLan);
	}
}
	
void CRspQryHostEnvLanFactory::afterAdd(CRspQryHostEnvLan *pRspQryHostEnvLan)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::beforeUpdate(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pNewRspQryHostEnvLan)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvLan,pNewRspQryHostEnvLan);
	}
}
	
void CRspQryHostEnvLanFactory::afterUpdate(CRspQryHostEnvLan *pRspQryHostEnvLan)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvLan);
	}
}
	
void CRspQryHostEnvLanFactory::beforeRemove(CRspQryHostEnvLan *pRspQryHostEnvLan)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::commitAdd(CRspQryHostEnvLan *pRspQryHostEnvLan)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvLan++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::commitUpdate(CRspQryHostEnvLan *pRspQryHostEnvLan, CWriteableRspQryHostEnvLan *pOldRspQryHostEnvLan)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvLan++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvLan,pOldRspQryHostEnvLan);
	}
}
	
void CRspQryHostEnvLanFactory::commitRemove(CWriteableRspQryHostEnvLan *pRspQryHostEnvLan)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvLan++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvLan);
	}
}

void CRspQryHostEnvLanFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvStorage(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvStorage=0;
int updateWithIndexActionForRspQryHostEnvStorage=0;
int updateWithoutIndexActionForRspQryHostEnvStorage=0;
int removeActionForRspQryHostEnvStorage=0;
int addCommitForRspQryHostEnvStorage=0;
int updateCommitForRspQryHostEnvStorage=0;
int removeCommitForRspQryHostEnvStorage=0;
#endif
void CRspQryHostEnvStorageFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvStorage,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvStorage_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvStorage_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvStorage,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvStorageActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvStorageCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvStorageFactory::CRspQryHostEnvStorageFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvStorage),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvStorageFactory::CRspQryHostEnvStorageFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvStorage),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvStorageFactory::~CRspQryHostEnvStorageFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvStorageFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvStorageFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvStorageFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvStorage thisRspQryHostEnvStorage;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvStorage.readCSV(input,pNames))
		add(&thisRspQryHostEnvStorage);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvStorageFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvStorage.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvStorageFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvStorage::writeCSVHead(output);
	pRspQryHostEnvStorage=(CWriteableRspQryHostEnvStorage *)(pMem->getFirst());
	while (pRspQryHostEnvStorage!=NULL) {
		if (!pRspQryHostEnvStorage->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvStorage=(CWriteableRspQryHostEnvStorage *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvStorageFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvStorage.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvStorageFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvStorageFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvStorageFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvStorage=(CWriteableRspQryHostEnvStorage *)(pMem->getFirst());
	while (pRspQryHostEnvStorage!=NULL) {
		pRspQryHostEnvStorage->dump(fp,index++);
		pRspQryHostEnvStorage=(CWriteableRspQryHostEnvStorage *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvStorageFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvStorage *CRspQryHostEnvStorageFactory::internalAdd(CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvStorage++;
#endif
	CRspQryHostEnvStorage *pTarget;	
	beforeAdd(pRspQryHostEnvStorage);
	pTarget=(CRspQryHostEnvStorage *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvStorage in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvStorage, sizeof(CRspQryHostEnvStorage));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvStorage *CRspQryHostEnvStorageFactory::add(CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage, CTransaction *pTransaction)
{
	pRspQryHostEnvStorage->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvStorage,true);
	}
	else {
		CRspQryHostEnvStorage *pNewRspQryHostEnvStorage;
		pNewRspQryHostEnvStorage = internalAdd(pRspQryHostEnvStorage,false);
		pTransaction->addResource(CRspQryHostEnvStorageResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvStorage,NULL));
		return pNewRspQryHostEnvStorage;
	}
}

void CRspQryHostEnvStorageFactory::internalUpdate(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pNewRspQryHostEnvStorage, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvStorage++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvStorage++;
	}
#endif
	CWriteableRspQryHostEnvStorage theOldRspQryHostEnvStorage;
	beforeUpdate(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvStorage,pRspQryHostEnvStorage,sizeof(CRspQryHostEnvStorage));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage,sizeof(CRspQryHostEnvStorage));
	pMem->updateObject(pRspQryHostEnvStorage);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvStorage);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvStorage,&theOldRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::update(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pNewRspQryHostEnvStorage, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvStorage->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvStorageResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvStorage,pNewRspQryHostEnvStorage,updateIndex));
		internalUpdate(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage,updateIndex,false);
	}
}

void CRspQryHostEnvStorageFactory::internalRemove(CRspQryHostEnvStorage *pRspQryHostEnvStorage, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvStorage++;
#endif
	CWriteableRspQryHostEnvStorage theOldRspQryHostEnvStorage;
	beforeRemove(pRspQryHostEnvStorage);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvStorage,pRspQryHostEnvStorage,sizeof(CRspQryHostEnvStorage));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvStorage);
	}
	pMem->free(pRspQryHostEnvStorage);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::remove(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvStorage,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvStorageResource::alloc(DELETE_ACTION,this,pRspQryHostEnvStorage,NULL));
		internalRemove(pRspQryHostEnvStorage,false);		
	}
}

CRspQryHostEnvStorage* CRspQryHostEnvStorageFactory::addOrUpdate(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pNewRspQryHostEnvStorage, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvStorage == NULL) {
		return add(pNewRspQryHostEnvStorage,pTransaction);
	}
	else {
		update(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage,pTransaction,updateIndex);
		return pRspQryHostEnvStorage;
	}
}

void CRspQryHostEnvStorageFactory::retrieve(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pTargetRspQryHostEnvStorage)
{
	forceCopy(pTargetRspQryHostEnvStorage, pRspQryHostEnvStorage, sizeof(CRspQryHostEnvStorage));
}
	
int CRspQryHostEnvStorageFactory::addActionTrigger(CRspQryHostEnvStorageActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvStorageFactory::removeActionTrigger(CRspQryHostEnvStorageActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvStorageFactory::addCommitTrigger(CRspQryHostEnvStorageCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvStorageFactory::removeCommitTrigger(CRspQryHostEnvStorageCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvStorage *CRspQryHostEnvStorageFactory::getFirst(void)
{
	CRspQryHostEnvStorage *pResult=(CRspQryHostEnvStorage *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvStorage *CRspQryHostEnvStorageFactory::getNext(void)
{
	CRspQryHostEnvStorage *pResult=(CRspQryHostEnvStorage *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvStorageFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvStorageFactory::beforeAdd(CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvStorage);
	}
}
	
void CRspQryHostEnvStorageFactory::afterAdd(CRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::beforeUpdate(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pNewRspQryHostEnvStorage)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvStorage,pNewRspQryHostEnvStorage);
	}
}
	
void CRspQryHostEnvStorageFactory::afterUpdate(CRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvStorage);
	}
}
	
void CRspQryHostEnvStorageFactory::beforeRemove(CRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::commitAdd(CRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvStorage++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::commitUpdate(CRspQryHostEnvStorage *pRspQryHostEnvStorage, CWriteableRspQryHostEnvStorage *pOldRspQryHostEnvStorage)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvStorage++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvStorage,pOldRspQryHostEnvStorage);
	}
}
	
void CRspQryHostEnvStorageFactory::commitRemove(CWriteableRspQryHostEnvStorage *pRspQryHostEnvStorage)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvStorage++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvStorage);
	}
}

void CRspQryHostEnvStorageFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvIO(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvIO=0;
int updateWithIndexActionForRspQryHostEnvIO=0;
int updateWithoutIndexActionForRspQryHostEnvIO=0;
int removeActionForRspQryHostEnvIO=0;
int addCommitForRspQryHostEnvIO=0;
int updateCommitForRspQryHostEnvIO=0;
int removeCommitForRspQryHostEnvIO=0;
#endif
void CRspQryHostEnvIOFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvIO,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvIO_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvIO_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvIO,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvIOActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvIOCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvIOFactory::CRspQryHostEnvIOFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvIO),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvIOFactory::CRspQryHostEnvIOFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvIO),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvIOFactory::~CRspQryHostEnvIOFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvIOFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvIOFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvIOFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvIO thisRspQryHostEnvIO;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvIO.readCSV(input,pNames))
		add(&thisRspQryHostEnvIO);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvIOFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvIO.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvIOFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvIO *pRspQryHostEnvIO;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvIO::writeCSVHead(output);
	pRspQryHostEnvIO=(CWriteableRspQryHostEnvIO *)(pMem->getFirst());
	while (pRspQryHostEnvIO!=NULL) {
		if (!pRspQryHostEnvIO->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvIO=(CWriteableRspQryHostEnvIO *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvIOFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvIO.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvIOFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvIOFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvIO *pRspQryHostEnvIO;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvIOFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvIO=(CWriteableRspQryHostEnvIO *)(pMem->getFirst());
	while (pRspQryHostEnvIO!=NULL) {
		pRspQryHostEnvIO->dump(fp,index++);
		pRspQryHostEnvIO=(CWriteableRspQryHostEnvIO *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvIOFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvIO *CRspQryHostEnvIOFactory::internalAdd(CWriteableRspQryHostEnvIO *pRspQryHostEnvIO, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvIO++;
#endif
	CRspQryHostEnvIO *pTarget;	
	beforeAdd(pRspQryHostEnvIO);
	pTarget=(CRspQryHostEnvIO *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvIO in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvIO, sizeof(CRspQryHostEnvIO));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvIO *CRspQryHostEnvIOFactory::add(CWriteableRspQryHostEnvIO *pRspQryHostEnvIO, CTransaction *pTransaction)
{
	pRspQryHostEnvIO->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvIO,true);
	}
	else {
		CRspQryHostEnvIO *pNewRspQryHostEnvIO;
		pNewRspQryHostEnvIO = internalAdd(pRspQryHostEnvIO,false);
		pTransaction->addResource(CRspQryHostEnvIOResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvIO,NULL));
		return pNewRspQryHostEnvIO;
	}
}

void CRspQryHostEnvIOFactory::internalUpdate(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pNewRspQryHostEnvIO, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvIO++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvIO++;
	}
#endif
	CWriteableRspQryHostEnvIO theOldRspQryHostEnvIO;
	beforeUpdate(pRspQryHostEnvIO,pNewRspQryHostEnvIO);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvIO,pRspQryHostEnvIO,sizeof(CRspQryHostEnvIO));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvIO,pNewRspQryHostEnvIO,sizeof(CRspQryHostEnvIO));
	pMem->updateObject(pRspQryHostEnvIO);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvIO);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvIO,&theOldRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::update(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pNewRspQryHostEnvIO, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvIO->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvIO,pNewRspQryHostEnvIO,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvIOResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvIO,pNewRspQryHostEnvIO,updateIndex));
		internalUpdate(pRspQryHostEnvIO,pNewRspQryHostEnvIO,updateIndex,false);
	}
}

void CRspQryHostEnvIOFactory::internalRemove(CRspQryHostEnvIO *pRspQryHostEnvIO, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvIO++;
#endif
	CWriteableRspQryHostEnvIO theOldRspQryHostEnvIO;
	beforeRemove(pRspQryHostEnvIO);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvIO,pRspQryHostEnvIO,sizeof(CRspQryHostEnvIO));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvIO);
	}
	pMem->free(pRspQryHostEnvIO);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::remove(CRspQryHostEnvIO *pRspQryHostEnvIO, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvIO,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvIOResource::alloc(DELETE_ACTION,this,pRspQryHostEnvIO,NULL));
		internalRemove(pRspQryHostEnvIO,false);		
	}
}

CRspQryHostEnvIO* CRspQryHostEnvIOFactory::addOrUpdate(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pNewRspQryHostEnvIO, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvIO == NULL) {
		return add(pNewRspQryHostEnvIO,pTransaction);
	}
	else {
		update(pRspQryHostEnvIO,pNewRspQryHostEnvIO,pTransaction,updateIndex);
		return pRspQryHostEnvIO;
	}
}

void CRspQryHostEnvIOFactory::retrieve(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pTargetRspQryHostEnvIO)
{
	forceCopy(pTargetRspQryHostEnvIO, pRspQryHostEnvIO, sizeof(CRspQryHostEnvIO));
}
	
int CRspQryHostEnvIOFactory::addActionTrigger(CRspQryHostEnvIOActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvIOFactory::removeActionTrigger(CRspQryHostEnvIOActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvIOFactory::addCommitTrigger(CRspQryHostEnvIOCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvIOFactory::removeCommitTrigger(CRspQryHostEnvIOCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvIO *CRspQryHostEnvIOFactory::getFirst(void)
{
	CRspQryHostEnvIO *pResult=(CRspQryHostEnvIO *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvIO *CRspQryHostEnvIOFactory::getNext(void)
{
	CRspQryHostEnvIO *pResult=(CRspQryHostEnvIO *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvIOFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvIOFactory::beforeAdd(CWriteableRspQryHostEnvIO *pRspQryHostEnvIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvIO);
	}
}
	
void CRspQryHostEnvIOFactory::afterAdd(CRspQryHostEnvIO *pRspQryHostEnvIO)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::beforeUpdate(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pNewRspQryHostEnvIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvIO,pNewRspQryHostEnvIO);
	}
}
	
void CRspQryHostEnvIOFactory::afterUpdate(CRspQryHostEnvIO *pRspQryHostEnvIO)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvIO);
	}
}
	
void CRspQryHostEnvIOFactory::beforeRemove(CRspQryHostEnvIO *pRspQryHostEnvIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::commitAdd(CRspQryHostEnvIO *pRspQryHostEnvIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::commitUpdate(CRspQryHostEnvIO *pRspQryHostEnvIO, CWriteableRspQryHostEnvIO *pOldRspQryHostEnvIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvIO,pOldRspQryHostEnvIO);
	}
}
	
void CRspQryHostEnvIOFactory::commitRemove(CWriteableRspQryHostEnvIO *pRspQryHostEnvIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvIO);
	}
}

void CRspQryHostEnvIOFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvFS(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvFS=0;
int updateWithIndexActionForRspQryHostEnvFS=0;
int updateWithoutIndexActionForRspQryHostEnvFS=0;
int removeActionForRspQryHostEnvFS=0;
int addCommitForRspQryHostEnvFS=0;
int updateCommitForRspQryHostEnvFS=0;
int removeCommitForRspQryHostEnvFS=0;
#endif
void CRspQryHostEnvFSFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvFS,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvFS_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvFS_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvFS,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvFSActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvFSCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvFSFactory::CRspQryHostEnvFSFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvFS),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvFSFactory::CRspQryHostEnvFSFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvFS),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvFSFactory::~CRspQryHostEnvFSFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvFSFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvFSFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvFSFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvFS thisRspQryHostEnvFS;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvFS.readCSV(input,pNames))
		add(&thisRspQryHostEnvFS);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvFSFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvFS.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvFSFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvFS *pRspQryHostEnvFS;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvFS::writeCSVHead(output);
	pRspQryHostEnvFS=(CWriteableRspQryHostEnvFS *)(pMem->getFirst());
	while (pRspQryHostEnvFS!=NULL) {
		if (!pRspQryHostEnvFS->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvFS=(CWriteableRspQryHostEnvFS *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvFSFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvFS.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvFSFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvFSFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvFS *pRspQryHostEnvFS;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvFSFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvFS=(CWriteableRspQryHostEnvFS *)(pMem->getFirst());
	while (pRspQryHostEnvFS!=NULL) {
		pRspQryHostEnvFS->dump(fp,index++);
		pRspQryHostEnvFS=(CWriteableRspQryHostEnvFS *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvFSFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvFS *CRspQryHostEnvFSFactory::internalAdd(CWriteableRspQryHostEnvFS *pRspQryHostEnvFS, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvFS++;
#endif
	CRspQryHostEnvFS *pTarget;	
	beforeAdd(pRspQryHostEnvFS);
	pTarget=(CRspQryHostEnvFS *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvFS in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvFS, sizeof(CRspQryHostEnvFS));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvFS *CRspQryHostEnvFSFactory::add(CWriteableRspQryHostEnvFS *pRspQryHostEnvFS, CTransaction *pTransaction)
{
	pRspQryHostEnvFS->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvFS,true);
	}
	else {
		CRspQryHostEnvFS *pNewRspQryHostEnvFS;
		pNewRspQryHostEnvFS = internalAdd(pRspQryHostEnvFS,false);
		pTransaction->addResource(CRspQryHostEnvFSResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvFS,NULL));
		return pNewRspQryHostEnvFS;
	}
}

void CRspQryHostEnvFSFactory::internalUpdate(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pNewRspQryHostEnvFS, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvFS++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvFS++;
	}
#endif
	CWriteableRspQryHostEnvFS theOldRspQryHostEnvFS;
	beforeUpdate(pRspQryHostEnvFS,pNewRspQryHostEnvFS);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvFS,pRspQryHostEnvFS,sizeof(CRspQryHostEnvFS));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvFS,pNewRspQryHostEnvFS,sizeof(CRspQryHostEnvFS));
	pMem->updateObject(pRspQryHostEnvFS);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvFS);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvFS,&theOldRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::update(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pNewRspQryHostEnvFS, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvFS->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvFS,pNewRspQryHostEnvFS,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvFSResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvFS,pNewRspQryHostEnvFS,updateIndex));
		internalUpdate(pRspQryHostEnvFS,pNewRspQryHostEnvFS,updateIndex,false);
	}
}

void CRspQryHostEnvFSFactory::internalRemove(CRspQryHostEnvFS *pRspQryHostEnvFS, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvFS++;
#endif
	CWriteableRspQryHostEnvFS theOldRspQryHostEnvFS;
	beforeRemove(pRspQryHostEnvFS);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvFS,pRspQryHostEnvFS,sizeof(CRspQryHostEnvFS));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvFS);
	}
	pMem->free(pRspQryHostEnvFS);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::remove(CRspQryHostEnvFS *pRspQryHostEnvFS, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvFS,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvFSResource::alloc(DELETE_ACTION,this,pRspQryHostEnvFS,NULL));
		internalRemove(pRspQryHostEnvFS,false);		
	}
}

CRspQryHostEnvFS* CRspQryHostEnvFSFactory::addOrUpdate(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pNewRspQryHostEnvFS, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvFS == NULL) {
		return add(pNewRspQryHostEnvFS,pTransaction);
	}
	else {
		update(pRspQryHostEnvFS,pNewRspQryHostEnvFS,pTransaction,updateIndex);
		return pRspQryHostEnvFS;
	}
}

void CRspQryHostEnvFSFactory::retrieve(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pTargetRspQryHostEnvFS)
{
	forceCopy(pTargetRspQryHostEnvFS, pRspQryHostEnvFS, sizeof(CRspQryHostEnvFS));
}
	
int CRspQryHostEnvFSFactory::addActionTrigger(CRspQryHostEnvFSActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvFSFactory::removeActionTrigger(CRspQryHostEnvFSActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvFSFactory::addCommitTrigger(CRspQryHostEnvFSCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvFSFactory::removeCommitTrigger(CRspQryHostEnvFSCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvFS *CRspQryHostEnvFSFactory::getFirst(void)
{
	CRspQryHostEnvFS *pResult=(CRspQryHostEnvFS *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvFS *CRspQryHostEnvFSFactory::getNext(void)
{
	CRspQryHostEnvFS *pResult=(CRspQryHostEnvFS *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvFSFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvFSFactory::beforeAdd(CWriteableRspQryHostEnvFS *pRspQryHostEnvFS)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvFS);
	}
}
	
void CRspQryHostEnvFSFactory::afterAdd(CRspQryHostEnvFS *pRspQryHostEnvFS)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::beforeUpdate(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pNewRspQryHostEnvFS)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvFS,pNewRspQryHostEnvFS);
	}
}
	
void CRspQryHostEnvFSFactory::afterUpdate(CRspQryHostEnvFS *pRspQryHostEnvFS)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvFS);
	}
}
	
void CRspQryHostEnvFSFactory::beforeRemove(CRspQryHostEnvFS *pRspQryHostEnvFS)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::commitAdd(CRspQryHostEnvFS *pRspQryHostEnvFS)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvFS++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::commitUpdate(CRspQryHostEnvFS *pRspQryHostEnvFS, CWriteableRspQryHostEnvFS *pOldRspQryHostEnvFS)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvFS++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvFS,pOldRspQryHostEnvFS);
	}
}
	
void CRspQryHostEnvFSFactory::commitRemove(CWriteableRspQryHostEnvFS *pRspQryHostEnvFS)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvFS++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvFS);
	}
}

void CRspQryHostEnvFSFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvSwap(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvSwap=0;
int updateWithIndexActionForRspQryHostEnvSwap=0;
int updateWithoutIndexActionForRspQryHostEnvSwap=0;
int removeActionForRspQryHostEnvSwap=0;
int addCommitForRspQryHostEnvSwap=0;
int updateCommitForRspQryHostEnvSwap=0;
int removeCommitForRspQryHostEnvSwap=0;
#endif
void CRspQryHostEnvSwapFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvSwap,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvSwap_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvSwap_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvSwap,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvSwapActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvSwapCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvSwapFactory::CRspQryHostEnvSwapFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvSwap),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvSwapFactory::CRspQryHostEnvSwapFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvSwap),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvSwapFactory::~CRspQryHostEnvSwapFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvSwapFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvSwapFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvSwapFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvSwap thisRspQryHostEnvSwap;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvSwap.readCSV(input,pNames))
		add(&thisRspQryHostEnvSwap);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvSwapFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvSwap.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvSwapFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvSwap::writeCSVHead(output);
	pRspQryHostEnvSwap=(CWriteableRspQryHostEnvSwap *)(pMem->getFirst());
	while (pRspQryHostEnvSwap!=NULL) {
		if (!pRspQryHostEnvSwap->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvSwap=(CWriteableRspQryHostEnvSwap *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvSwapFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvSwap.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvSwapFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvSwapFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvSwapFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvSwap=(CWriteableRspQryHostEnvSwap *)(pMem->getFirst());
	while (pRspQryHostEnvSwap!=NULL) {
		pRspQryHostEnvSwap->dump(fp,index++);
		pRspQryHostEnvSwap=(CWriteableRspQryHostEnvSwap *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvSwapFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvSwap *CRspQryHostEnvSwapFactory::internalAdd(CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvSwap++;
#endif
	CRspQryHostEnvSwap *pTarget;	
	beforeAdd(pRspQryHostEnvSwap);
	pTarget=(CRspQryHostEnvSwap *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvSwap in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvSwap, sizeof(CRspQryHostEnvSwap));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvSwap *CRspQryHostEnvSwapFactory::add(CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap, CTransaction *pTransaction)
{
	pRspQryHostEnvSwap->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvSwap,true);
	}
	else {
		CRspQryHostEnvSwap *pNewRspQryHostEnvSwap;
		pNewRspQryHostEnvSwap = internalAdd(pRspQryHostEnvSwap,false);
		pTransaction->addResource(CRspQryHostEnvSwapResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvSwap,NULL));
		return pNewRspQryHostEnvSwap;
	}
}

void CRspQryHostEnvSwapFactory::internalUpdate(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pNewRspQryHostEnvSwap, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvSwap++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvSwap++;
	}
#endif
	CWriteableRspQryHostEnvSwap theOldRspQryHostEnvSwap;
	beforeUpdate(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvSwap,pRspQryHostEnvSwap,sizeof(CRspQryHostEnvSwap));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap,sizeof(CRspQryHostEnvSwap));
	pMem->updateObject(pRspQryHostEnvSwap);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvSwap);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvSwap,&theOldRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::update(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pNewRspQryHostEnvSwap, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvSwap->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvSwapResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvSwap,pNewRspQryHostEnvSwap,updateIndex));
		internalUpdate(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap,updateIndex,false);
	}
}

void CRspQryHostEnvSwapFactory::internalRemove(CRspQryHostEnvSwap *pRspQryHostEnvSwap, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvSwap++;
#endif
	CWriteableRspQryHostEnvSwap theOldRspQryHostEnvSwap;
	beforeRemove(pRspQryHostEnvSwap);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvSwap,pRspQryHostEnvSwap,sizeof(CRspQryHostEnvSwap));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvSwap);
	}
	pMem->free(pRspQryHostEnvSwap);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::remove(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvSwap,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvSwapResource::alloc(DELETE_ACTION,this,pRspQryHostEnvSwap,NULL));
		internalRemove(pRspQryHostEnvSwap,false);		
	}
}

CRspQryHostEnvSwap* CRspQryHostEnvSwapFactory::addOrUpdate(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pNewRspQryHostEnvSwap, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvSwap == NULL) {
		return add(pNewRspQryHostEnvSwap,pTransaction);
	}
	else {
		update(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap,pTransaction,updateIndex);
		return pRspQryHostEnvSwap;
	}
}

void CRspQryHostEnvSwapFactory::retrieve(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pTargetRspQryHostEnvSwap)
{
	forceCopy(pTargetRspQryHostEnvSwap, pRspQryHostEnvSwap, sizeof(CRspQryHostEnvSwap));
}
	
int CRspQryHostEnvSwapFactory::addActionTrigger(CRspQryHostEnvSwapActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvSwapFactory::removeActionTrigger(CRspQryHostEnvSwapActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvSwapFactory::addCommitTrigger(CRspQryHostEnvSwapCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvSwapFactory::removeCommitTrigger(CRspQryHostEnvSwapCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvSwap *CRspQryHostEnvSwapFactory::getFirst(void)
{
	CRspQryHostEnvSwap *pResult=(CRspQryHostEnvSwap *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvSwap *CRspQryHostEnvSwapFactory::getNext(void)
{
	CRspQryHostEnvSwap *pResult=(CRspQryHostEnvSwap *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvSwapFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvSwapFactory::beforeAdd(CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvSwap);
	}
}
	
void CRspQryHostEnvSwapFactory::afterAdd(CRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::beforeUpdate(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pNewRspQryHostEnvSwap)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvSwap,pNewRspQryHostEnvSwap);
	}
}
	
void CRspQryHostEnvSwapFactory::afterUpdate(CRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvSwap);
	}
}
	
void CRspQryHostEnvSwapFactory::beforeRemove(CRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::commitAdd(CRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvSwap++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::commitUpdate(CRspQryHostEnvSwap *pRspQryHostEnvSwap, CWriteableRspQryHostEnvSwap *pOldRspQryHostEnvSwap)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvSwap++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvSwap,pOldRspQryHostEnvSwap);
	}
}
	
void CRspQryHostEnvSwapFactory::commitRemove(CWriteableRspQryHostEnvSwap *pRspQryHostEnvSwap)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvSwap++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvSwap);
	}
}

void CRspQryHostEnvSwapFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinRspQryHostEnvLanCfg(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForRspQryHostEnvLanCfg=0;
int updateWithIndexActionForRspQryHostEnvLanCfg=0;
int updateWithoutIndexActionForRspQryHostEnvLanCfg=0;
int removeActionForRspQryHostEnvLanCfg=0;
int addCommitForRspQryHostEnvLanCfg=0;
int updateCommitForRspQryHostEnvLanCfg=0;
int removeCommitForRspQryHostEnvLanCfg=0;
#endif
void CRspQryHostEnvLanCfgFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvLanCfg,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("RspQryHostEnvLanCfg_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("RspQryHostEnvLanCfg_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinRspQryHostEnvLanCfg,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CRspQryHostEnvLanCfgActionTrigger *>;
	pCommitTriggers=new vector<CRspQryHostEnvLanCfgCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CRspQryHostEnvLanCfgFactory::CRspQryHostEnvLanCfgFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvLanCfg),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CRspQryHostEnvLanCfgFactory::CRspQryHostEnvLanCfgFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CRspQryHostEnvLanCfg),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CRspQryHostEnvLanCfgFactory::~CRspQryHostEnvLanCfgFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CRspQryHostEnvLanCfgFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CRspQryHostEnvLanCfgFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
}

int CRspQryHostEnvLanCfgFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableRspQryHostEnvLanCfg thisRspQryHostEnvLanCfg;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisRspQryHostEnvLanCfg.readCSV(input,pNames))
		add(&thisRspQryHostEnvLanCfg);
	fclose(input);
	delete pNames;
	return 1;
}

int CRspQryHostEnvLanCfgFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "RspQryHostEnvLanCfg.csv");
	return readCSV(szFileName);
}

int CRspQryHostEnvLanCfgFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableRspQryHostEnvLanCfg::writeCSVHead(output);
	pRspQryHostEnvLanCfg=(CWriteableRspQryHostEnvLanCfg *)(pMem->getFirst());
	while (pRspQryHostEnvLanCfg!=NULL) {
		if (!pRspQryHostEnvLanCfg->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pRspQryHostEnvLanCfg=(CWriteableRspQryHostEnvLanCfg *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CRspQryHostEnvLanCfgFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "RspQryHostEnvLanCfg.csv");
	return writeCSV(szFileName);
}

void CRspQryHostEnvLanCfgFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CRspQryHostEnvLanCfgFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CRspQryHostEnvLanCfgFactory={       Total Count=%d\n", pMem->getCount());
	pRspQryHostEnvLanCfg=(CWriteableRspQryHostEnvLanCfg *)(pMem->getFirst());
	while (pRspQryHostEnvLanCfg!=NULL) {
		pRspQryHostEnvLanCfg->dump(fp,index++);
		pRspQryHostEnvLanCfg=(CWriteableRspQryHostEnvLanCfg *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CRspQryHostEnvLanCfgFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
}

CRspQryHostEnvLanCfg *CRspQryHostEnvLanCfgFactory::internalAdd(CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForRspQryHostEnvLanCfg++;
#endif
	CRspQryHostEnvLanCfg *pTarget;	
	beforeAdd(pRspQryHostEnvLanCfg);
	pTarget=(CRspQryHostEnvLanCfg *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough RspQryHostEnvLanCfg in memory database");
		return NULL;
	}
	forceCopy(pTarget, pRspQryHostEnvLanCfg, sizeof(CRspQryHostEnvLanCfg));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CRspQryHostEnvLanCfg *CRspQryHostEnvLanCfgFactory::add(CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CTransaction *pTransaction)
{
	pRspQryHostEnvLanCfg->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pRspQryHostEnvLanCfg,true);
	}
	else {
		CRspQryHostEnvLanCfg *pNewRspQryHostEnvLanCfg;
		pNewRspQryHostEnvLanCfg = internalAdd(pRspQryHostEnvLanCfg,false);
		pTransaction->addResource(CRspQryHostEnvLanCfgResource::alloc(CREATE_ACTION,this,pNewRspQryHostEnvLanCfg,NULL));
		return pNewRspQryHostEnvLanCfg;
	}
}

void CRspQryHostEnvLanCfgFactory::internalUpdate(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pNewRspQryHostEnvLanCfg, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForRspQryHostEnvLanCfg++;
	}
	else {
		updateWithoutIndexActionForRspQryHostEnvLanCfg++;
	}
#endif
	CWriteableRspQryHostEnvLanCfg theOldRspQryHostEnvLanCfg;
	beforeUpdate(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvLanCfg,pRspQryHostEnvLanCfg,sizeof(CRspQryHostEnvLanCfg));
	}
	if (updateIndex) {
	}

	forceCopy(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg,sizeof(CRspQryHostEnvLanCfg));
	pMem->updateObject(pRspQryHostEnvLanCfg);
	if (updateIndex) {
	}
	afterUpdate(pRspQryHostEnvLanCfg);
	if (bNoTransaction) {
		commitUpdate(pRspQryHostEnvLanCfg,&theOldRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::update(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pNewRspQryHostEnvLanCfg, CTransaction *pTransaction, bool updateIndex)
{
	pNewRspQryHostEnvLanCfg->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg,updateIndex,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvLanCfgResource::alloc(UPDATE_ACTION,this,pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg,updateIndex));
		internalUpdate(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg,updateIndex,false);
	}
}

void CRspQryHostEnvLanCfgFactory::internalRemove(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForRspQryHostEnvLanCfg++;
#endif
	CWriteableRspQryHostEnvLanCfg theOldRspQryHostEnvLanCfg;
	beforeRemove(pRspQryHostEnvLanCfg);
	if (bNoTransaction) {
		forceCopy(&theOldRspQryHostEnvLanCfg,pRspQryHostEnvLanCfg,sizeof(CRspQryHostEnvLanCfg));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pRspQryHostEnvLanCfg);
	}
	pMem->free(pRspQryHostEnvLanCfg);
	if(bNoTransaction) {
		commitRemove(&theOldRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::remove(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pRspQryHostEnvLanCfg,true);
	}
	else {
		pTransaction->addResource(CRspQryHostEnvLanCfgResource::alloc(DELETE_ACTION,this,pRspQryHostEnvLanCfg,NULL));
		internalRemove(pRspQryHostEnvLanCfg,false);		
	}
}

CRspQryHostEnvLanCfg* CRspQryHostEnvLanCfgFactory::addOrUpdate(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pNewRspQryHostEnvLanCfg, CTransaction *pTransaction, bool updateIndex)
{
	if(pRspQryHostEnvLanCfg == NULL) {
		return add(pNewRspQryHostEnvLanCfg,pTransaction);
	}
	else {
		update(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg,pTransaction,updateIndex);
		return pRspQryHostEnvLanCfg;
	}
}

void CRspQryHostEnvLanCfgFactory::retrieve(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pTargetRspQryHostEnvLanCfg)
{
	forceCopy(pTargetRspQryHostEnvLanCfg, pRspQryHostEnvLanCfg, sizeof(CRspQryHostEnvLanCfg));
}
	
int CRspQryHostEnvLanCfgFactory::addActionTrigger(CRspQryHostEnvLanCfgActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CRspQryHostEnvLanCfgFactory::removeActionTrigger(CRspQryHostEnvLanCfgActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CRspQryHostEnvLanCfgFactory::addCommitTrigger(CRspQryHostEnvLanCfgCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CRspQryHostEnvLanCfgFactory::removeCommitTrigger(CRspQryHostEnvLanCfgCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CRspQryHostEnvLanCfg *CRspQryHostEnvLanCfgFactory::getFirst(void)
{
	CRspQryHostEnvLanCfg *pResult=(CRspQryHostEnvLanCfg *)(pMem->getFirst());
	return pResult;
}
	
CRspQryHostEnvLanCfg *CRspQryHostEnvLanCfgFactory::getNext(void)
{
	CRspQryHostEnvLanCfg *pResult=(CRspQryHostEnvLanCfg *)(pMem->getNext());
	return pResult;
}
	
void CRspQryHostEnvLanCfgFactory::endGet(void)
{
	pMem->endGet();
}

void CRspQryHostEnvLanCfgFactory::beforeAdd(CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pRspQryHostEnvLanCfg);
	}
}
	
void CRspQryHostEnvLanCfgFactory::afterAdd(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::beforeUpdate(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pNewRspQryHostEnvLanCfg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pRspQryHostEnvLanCfg,pNewRspQryHostEnvLanCfg);
	}
}
	
void CRspQryHostEnvLanCfgFactory::afterUpdate(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pRspQryHostEnvLanCfg);
	}
}
	
void CRspQryHostEnvLanCfgFactory::beforeRemove(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::commitAdd(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForRspQryHostEnvLanCfg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::commitUpdate(CRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg, CWriteableRspQryHostEnvLanCfg *pOldRspQryHostEnvLanCfg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForRspQryHostEnvLanCfg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pRspQryHostEnvLanCfg,pOldRspQryHostEnvLanCfg);
	}
}
	
void CRspQryHostEnvLanCfgFactory::commitRemove(CWriteableRspQryHostEnvLanCfg *pRspQryHostEnvLanCfg)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForRspQryHostEnvLanCfg++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pRspQryHostEnvLanCfg);
	}
}

void CRspQryHostEnvLanCfgFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbTopCpuInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbTopCpuInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbTopCpuInfo=0;
int updateWithIndexActionForSysMdbTopCpuInfo=0;
int updateWithoutIndexActionForSysMdbTopCpuInfo=0;
int removeActionForSysMdbTopCpuInfo=0;
int addCommitForSysMdbTopCpuInfo=0;
int updateCommitForSysMdbTopCpuInfo=0;
int removeCommitForSysMdbTopCpuInfo=0;
#endif
void CSysMdbTopCpuInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopCpuInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopCpuInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopCpuInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopCpuInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopCpuInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopCpuInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopCpuInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopCpuInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbTopCpuInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbTopCpuInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbTopCpuInfoFactory::CSysMdbTopCpuInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopCpuInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbTopCpuInfoFactory::CSysMdbTopCpuInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopCpuInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbTopCpuInfoFactory::~CSysMdbTopCpuInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbTopCpuInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbTopCpuInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbTopCpuInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbTopCpuInfo thisSysMdbTopCpuInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbTopCpuInfo.readCSV(input,pNames))
		add(&thisSysMdbTopCpuInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbTopCpuInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbTopCpuInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbTopCpuInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbTopCpuInfo::writeCSVHead(output);
	pSysMdbTopCpuInfo=(CWriteableSysMdbTopCpuInfo *)(pMem->getFirst());
	while (pSysMdbTopCpuInfo!=NULL) {
		if (!pSysMdbTopCpuInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbTopCpuInfo=(CWriteableSysMdbTopCpuInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbTopCpuInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbTopCpuInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbTopCpuInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbTopCpuInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbTopCpuInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbTopCpuInfo=(CWriteableSysMdbTopCpuInfo *)(pMem->getFirst());
	while (pSysMdbTopCpuInfo!=NULL) {
		pSysMdbTopCpuInfo->dump(fp,index++);
		pSysMdbTopCpuInfo=(CWriteableSysMdbTopCpuInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbTopCpuInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbTopCpuInfo *CSysMdbTopCpuInfoFactory::internalAdd(CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbTopCpuInfo++;
#endif
	CSysMdbTopCpuInfo *pTarget;	
	beforeAdd(pSysMdbTopCpuInfo);
	pTarget=(CSysMdbTopCpuInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbTopCpuInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbTopCpuInfo, sizeof(CSysMdbTopCpuInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbTopCpuInfo *CSysMdbTopCpuInfoFactory::add(CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CTransaction *pTransaction)
{
	pSysMdbTopCpuInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbTopCpuInfo,true);
	}
	else {
		CSysMdbTopCpuInfo *pNewSysMdbTopCpuInfo;
		pNewSysMdbTopCpuInfo = internalAdd(pSysMdbTopCpuInfo,false);
		pTransaction->addResource(CSysMdbTopCpuInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbTopCpuInfo,NULL));
		return pNewSysMdbTopCpuInfo;
	}
}

void CSysMdbTopCpuInfoFactory::internalUpdate(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pNewSysMdbTopCpuInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbTopCpuInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbTopCpuInfo++;
	}
#endif
	CWriteableSysMdbTopCpuInfo theOldSysMdbTopCpuInfo;
	beforeUpdate(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopCpuInfo,pSysMdbTopCpuInfo,sizeof(CSysMdbTopCpuInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo,sizeof(CSysMdbTopCpuInfo));
	pMem->updateObject(pSysMdbTopCpuInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbTopCpuInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbTopCpuInfo,&theOldSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::update(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pNewSysMdbTopCpuInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbTopCpuInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopCpuInfoResource::alloc(UPDATE_ACTION,this,pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo,updateIndex));
		internalUpdate(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo,updateIndex,false);
	}
}

void CSysMdbTopCpuInfoFactory::internalRemove(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbTopCpuInfo++;
#endif
	CWriteableSysMdbTopCpuInfo theOldSysMdbTopCpuInfo;
	beforeRemove(pSysMdbTopCpuInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopCpuInfo,pSysMdbTopCpuInfo,sizeof(CSysMdbTopCpuInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbTopCpuInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbTopCpuInfo);
	}
	pMem->free(pSysMdbTopCpuInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::remove(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbTopCpuInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopCpuInfoResource::alloc(DELETE_ACTION,this,pSysMdbTopCpuInfo,NULL));
		internalRemove(pSysMdbTopCpuInfo,false);		
	}
}

CSysMdbTopCpuInfo* CSysMdbTopCpuInfoFactory::addOrUpdate(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pNewSysMdbTopCpuInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbTopCpuInfo == NULL) {
		return add(pNewSysMdbTopCpuInfo,pTransaction);
	}
	else {
		update(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo,pTransaction,updateIndex);
		return pSysMdbTopCpuInfo;
	}
}

void CSysMdbTopCpuInfoFactory::retrieve(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pTargetSysMdbTopCpuInfo)
{
	forceCopy(pTargetSysMdbTopCpuInfo, pSysMdbTopCpuInfo, sizeof(CSysMdbTopCpuInfo));
}
	
int CSysMdbTopCpuInfoFactory::addActionTrigger(CSysMdbTopCpuInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbTopCpuInfoFactory::removeActionTrigger(CSysMdbTopCpuInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbTopCpuInfoFactory::addCommitTrigger(CSysMdbTopCpuInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbTopCpuInfoFactory::removeCommitTrigger(CSysMdbTopCpuInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbTopCpuInfo *CSysMdbTopCpuInfoFactory::getFirst(void)
{
	CSysMdbTopCpuInfo *pResult=(CSysMdbTopCpuInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbTopCpuInfo *CSysMdbTopCpuInfoFactory::getNext(void)
{
	CSysMdbTopCpuInfo *pResult=(CSysMdbTopCpuInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbTopCpuInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbTopCpuInfoFactory::beforeAdd(CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbTopCpuInfo);
	}
}
	
void CSysMdbTopCpuInfoFactory::afterAdd(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::beforeUpdate(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pNewSysMdbTopCpuInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbTopCpuInfo,pNewSysMdbTopCpuInfo);
	}
}
	
void CSysMdbTopCpuInfoFactory::afterUpdate(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbTopCpuInfo);
	}
}
	
void CSysMdbTopCpuInfoFactory::beforeRemove(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::commitAdd(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbTopCpuInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::commitUpdate(CSysMdbTopCpuInfo *pSysMdbTopCpuInfo, CWriteableSysMdbTopCpuInfo *pOldSysMdbTopCpuInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbTopCpuInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbTopCpuInfo,pOldSysMdbTopCpuInfo);
	}
}
	
void CSysMdbTopCpuInfoFactory::commitRemove(CWriteableSysMdbTopCpuInfo *pSysMdbTopCpuInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbTopCpuInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbTopCpuInfo);
	}
}

void CSysMdbTopCpuInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbTopMemInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbTopMemInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbTopMemInfo=0;
int updateWithIndexActionForSysMdbTopMemInfo=0;
int updateWithoutIndexActionForSysMdbTopMemInfo=0;
int removeActionForSysMdbTopMemInfo=0;
int addCommitForSysMdbTopMemInfo=0;
int updateCommitForSysMdbTopMemInfo=0;
int removeCommitForSysMdbTopMemInfo=0;
#endif
void CSysMdbTopMemInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopMemInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopMemInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopMemInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopMemInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopMemInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopMemInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopMemInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopMemInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbTopMemInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbTopMemInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbTopMemInfoFactory::CSysMdbTopMemInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopMemInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbTopMemInfoFactory::CSysMdbTopMemInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopMemInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbTopMemInfoFactory::~CSysMdbTopMemInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbTopMemInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbTopMemInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbTopMemInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbTopMemInfo thisSysMdbTopMemInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbTopMemInfo.readCSV(input,pNames))
		add(&thisSysMdbTopMemInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbTopMemInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbTopMemInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbTopMemInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbTopMemInfo::writeCSVHead(output);
	pSysMdbTopMemInfo=(CWriteableSysMdbTopMemInfo *)(pMem->getFirst());
	while (pSysMdbTopMemInfo!=NULL) {
		if (!pSysMdbTopMemInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbTopMemInfo=(CWriteableSysMdbTopMemInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbTopMemInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbTopMemInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbTopMemInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbTopMemInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbTopMemInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbTopMemInfo=(CWriteableSysMdbTopMemInfo *)(pMem->getFirst());
	while (pSysMdbTopMemInfo!=NULL) {
		pSysMdbTopMemInfo->dump(fp,index++);
		pSysMdbTopMemInfo=(CWriteableSysMdbTopMemInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbTopMemInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbTopMemInfo *CSysMdbTopMemInfoFactory::internalAdd(CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbTopMemInfo++;
#endif
	CSysMdbTopMemInfo *pTarget;	
	beforeAdd(pSysMdbTopMemInfo);
	pTarget=(CSysMdbTopMemInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbTopMemInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbTopMemInfo, sizeof(CSysMdbTopMemInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbTopMemInfo *CSysMdbTopMemInfoFactory::add(CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo, CTransaction *pTransaction)
{
	pSysMdbTopMemInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbTopMemInfo,true);
	}
	else {
		CSysMdbTopMemInfo *pNewSysMdbTopMemInfo;
		pNewSysMdbTopMemInfo = internalAdd(pSysMdbTopMemInfo,false);
		pTransaction->addResource(CSysMdbTopMemInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbTopMemInfo,NULL));
		return pNewSysMdbTopMemInfo;
	}
}

void CSysMdbTopMemInfoFactory::internalUpdate(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pNewSysMdbTopMemInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbTopMemInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbTopMemInfo++;
	}
#endif
	CWriteableSysMdbTopMemInfo theOldSysMdbTopMemInfo;
	beforeUpdate(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopMemInfo,pSysMdbTopMemInfo,sizeof(CSysMdbTopMemInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo,sizeof(CSysMdbTopMemInfo));
	pMem->updateObject(pSysMdbTopMemInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbTopMemInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbTopMemInfo,&theOldSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::update(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pNewSysMdbTopMemInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbTopMemInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopMemInfoResource::alloc(UPDATE_ACTION,this,pSysMdbTopMemInfo,pNewSysMdbTopMemInfo,updateIndex));
		internalUpdate(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo,updateIndex,false);
	}
}

void CSysMdbTopMemInfoFactory::internalRemove(CSysMdbTopMemInfo *pSysMdbTopMemInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbTopMemInfo++;
#endif
	CWriteableSysMdbTopMemInfo theOldSysMdbTopMemInfo;
	beforeRemove(pSysMdbTopMemInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopMemInfo,pSysMdbTopMemInfo,sizeof(CSysMdbTopMemInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbTopMemInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbTopMemInfo);
	}
	pMem->free(pSysMdbTopMemInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::remove(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbTopMemInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopMemInfoResource::alloc(DELETE_ACTION,this,pSysMdbTopMemInfo,NULL));
		internalRemove(pSysMdbTopMemInfo,false);		
	}
}

CSysMdbTopMemInfo* CSysMdbTopMemInfoFactory::addOrUpdate(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pNewSysMdbTopMemInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbTopMemInfo == NULL) {
		return add(pNewSysMdbTopMemInfo,pTransaction);
	}
	else {
		update(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo,pTransaction,updateIndex);
		return pSysMdbTopMemInfo;
	}
}

void CSysMdbTopMemInfoFactory::retrieve(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pTargetSysMdbTopMemInfo)
{
	forceCopy(pTargetSysMdbTopMemInfo, pSysMdbTopMemInfo, sizeof(CSysMdbTopMemInfo));
}
	
int CSysMdbTopMemInfoFactory::addActionTrigger(CSysMdbTopMemInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbTopMemInfoFactory::removeActionTrigger(CSysMdbTopMemInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbTopMemInfoFactory::addCommitTrigger(CSysMdbTopMemInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbTopMemInfoFactory::removeCommitTrigger(CSysMdbTopMemInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbTopMemInfo *CSysMdbTopMemInfoFactory::getFirst(void)
{
	CSysMdbTopMemInfo *pResult=(CSysMdbTopMemInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbTopMemInfo *CSysMdbTopMemInfoFactory::getNext(void)
{
	CSysMdbTopMemInfo *pResult=(CSysMdbTopMemInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbTopMemInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbTopMemInfoFactory::beforeAdd(CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbTopMemInfo);
	}
}
	
void CSysMdbTopMemInfoFactory::afterAdd(CSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::beforeUpdate(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pNewSysMdbTopMemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbTopMemInfo,pNewSysMdbTopMemInfo);
	}
}
	
void CSysMdbTopMemInfoFactory::afterUpdate(CSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbTopMemInfo);
	}
}
	
void CSysMdbTopMemInfoFactory::beforeRemove(CSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::commitAdd(CSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbTopMemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::commitUpdate(CSysMdbTopMemInfo *pSysMdbTopMemInfo, CWriteableSysMdbTopMemInfo *pOldSysMdbTopMemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbTopMemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbTopMemInfo,pOldSysMdbTopMemInfo);
	}
}
	
void CSysMdbTopMemInfoFactory::commitRemove(CWriteableSysMdbTopMemInfo *pSysMdbTopMemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbTopMemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbTopMemInfo);
	}
}

void CSysMdbTopMemInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbTopProcessInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbTopProcessInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbTopProcessInfo=0;
int updateWithIndexActionForSysMdbTopProcessInfo=0;
int updateWithoutIndexActionForSysMdbTopProcessInfo=0;
int removeActionForSysMdbTopProcessInfo=0;
int addCommitForSysMdbTopProcessInfo=0;
int updateCommitForSysMdbTopProcessInfo=0;
int removeCommitForSysMdbTopProcessInfo=0;
#endif
void CSysMdbTopProcessInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopProcessInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopProcessInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopProcessInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTopProcessInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopProcessInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTopProcessInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTopProcessInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTopProcessInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysMdbTopProcessInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbTopProcessInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbTopProcessInfoFactory::CSysMdbTopProcessInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopProcessInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbTopProcessInfoFactory::CSysMdbTopProcessInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTopProcessInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbTopProcessInfoFactory::~CSysMdbTopProcessInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbTopProcessInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbTopProcessInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbTopProcessInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbTopProcessInfo thisSysMdbTopProcessInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbTopProcessInfo.readCSV(input,pNames))
		add(&thisSysMdbTopProcessInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbTopProcessInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbTopProcessInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbTopProcessInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbTopProcessInfo::writeCSVHead(output);
	pSysMdbTopProcessInfo=(CWriteableSysMdbTopProcessInfo *)(pMem->getFirst());
	while (pSysMdbTopProcessInfo!=NULL) {
		if (!pSysMdbTopProcessInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbTopProcessInfo=(CWriteableSysMdbTopProcessInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbTopProcessInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbTopProcessInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbTopProcessInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbTopProcessInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbTopProcessInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbTopProcessInfo=(CWriteableSysMdbTopProcessInfo *)(pMem->getFirst());
	while (pSysMdbTopProcessInfo!=NULL) {
		pSysMdbTopProcessInfo->dump(fp,index++);
		pSysMdbTopProcessInfo=(CWriteableSysMdbTopProcessInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbTopProcessInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbTopProcessInfo *CSysMdbTopProcessInfoFactory::internalAdd(CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbTopProcessInfo++;
#endif
	CSysMdbTopProcessInfo *pTarget;	
	beforeAdd(pSysMdbTopProcessInfo);
	pTarget=(CSysMdbTopProcessInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbTopProcessInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbTopProcessInfo, sizeof(CSysMdbTopProcessInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbTopProcessInfo *CSysMdbTopProcessInfoFactory::add(CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CTransaction *pTransaction)
{
	pSysMdbTopProcessInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbTopProcessInfo,true);
	}
	else {
		CSysMdbTopProcessInfo *pNewSysMdbTopProcessInfo;
		pNewSysMdbTopProcessInfo = internalAdd(pSysMdbTopProcessInfo,false);
		pTransaction->addResource(CSysMdbTopProcessInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbTopProcessInfo,NULL));
		return pNewSysMdbTopProcessInfo;
	}
}

void CSysMdbTopProcessInfoFactory::internalUpdate(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pNewSysMdbTopProcessInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbTopProcessInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbTopProcessInfo++;
	}
#endif
	CWriteableSysMdbTopProcessInfo theOldSysMdbTopProcessInfo;
	beforeUpdate(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopProcessInfo,pSysMdbTopProcessInfo,sizeof(CSysMdbTopProcessInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo,sizeof(CSysMdbTopProcessInfo));
	pMem->updateObject(pSysMdbTopProcessInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbTopProcessInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbTopProcessInfo,&theOldSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::update(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pNewSysMdbTopProcessInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbTopProcessInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopProcessInfoResource::alloc(UPDATE_ACTION,this,pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo,updateIndex));
		internalUpdate(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo,updateIndex,false);
	}
}

void CSysMdbTopProcessInfoFactory::internalRemove(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbTopProcessInfo++;
#endif
	CWriteableSysMdbTopProcessInfo theOldSysMdbTopProcessInfo;
	beforeRemove(pSysMdbTopProcessInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTopProcessInfo,pSysMdbTopProcessInfo,sizeof(CSysMdbTopProcessInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbTopProcessInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbTopProcessInfo);
	}
	pMem->free(pSysMdbTopProcessInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::remove(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbTopProcessInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbTopProcessInfoResource::alloc(DELETE_ACTION,this,pSysMdbTopProcessInfo,NULL));
		internalRemove(pSysMdbTopProcessInfo,false);		
	}
}

CSysMdbTopProcessInfo* CSysMdbTopProcessInfoFactory::addOrUpdate(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pNewSysMdbTopProcessInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbTopProcessInfo == NULL) {
		return add(pNewSysMdbTopProcessInfo,pTransaction);
	}
	else {
		update(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo,pTransaction,updateIndex);
		return pSysMdbTopProcessInfo;
	}
}

void CSysMdbTopProcessInfoFactory::retrieve(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pTargetSysMdbTopProcessInfo)
{
	forceCopy(pTargetSysMdbTopProcessInfo, pSysMdbTopProcessInfo, sizeof(CSysMdbTopProcessInfo));
}
	
int CSysMdbTopProcessInfoFactory::addActionTrigger(CSysMdbTopProcessInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbTopProcessInfoFactory::removeActionTrigger(CSysMdbTopProcessInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbTopProcessInfoFactory::addCommitTrigger(CSysMdbTopProcessInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbTopProcessInfoFactory::removeCommitTrigger(CSysMdbTopProcessInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbTopProcessInfo *CSysMdbTopProcessInfoFactory::getFirst(void)
{
	CSysMdbTopProcessInfo *pResult=(CSysMdbTopProcessInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbTopProcessInfo *CSysMdbTopProcessInfoFactory::getNext(void)
{
	CSysMdbTopProcessInfo *pResult=(CSysMdbTopProcessInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbTopProcessInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbTopProcessInfoFactory::beforeAdd(CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbTopProcessInfo);
	}
}
	
void CSysMdbTopProcessInfoFactory::afterAdd(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::beforeUpdate(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pNewSysMdbTopProcessInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbTopProcessInfo,pNewSysMdbTopProcessInfo);
	}
}
	
void CSysMdbTopProcessInfoFactory::afterUpdate(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbTopProcessInfo);
	}
}
	
void CSysMdbTopProcessInfoFactory::beforeRemove(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::commitAdd(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbTopProcessInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::commitUpdate(CSysMdbTopProcessInfo *pSysMdbTopProcessInfo, CWriteableSysMdbTopProcessInfo *pOldSysMdbTopProcessInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbTopProcessInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbTopProcessInfo,pOldSysMdbTopProcessInfo);
	}
}
	
void CSysMdbTopProcessInfoFactory::commitRemove(CWriteableSysMdbTopProcessInfo *pSysMdbTopProcessInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbTopProcessInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbTopProcessInfo);
	}
}

void CSysMdbTopProcessInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbFileSystemInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbFileSystemInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbFileSystemInfo=0;
int updateWithIndexActionForSysMdbFileSystemInfo=0;
int updateWithoutIndexActionForSysMdbFileSystemInfo=0;
int removeActionForSysMdbFileSystemInfo=0;
int addCommitForSysMdbFileSystemInfo=0;
int updateCommitForSysMdbFileSystemInfo=0;
int removeCommitForSysMdbFileSystemInfo=0;
#endif
void CSysMdbFileSystemInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbFileSystemInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbFileSystemInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbFileSystemInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbFileSystemInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbFileSystemInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbFileSystemInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbFileSystemInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbFileSystemInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysMdbFileSystemInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbFileSystemInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbFileSystemInfoFactory::CSysMdbFileSystemInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbFileSystemInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbFileSystemInfoFactory::CSysMdbFileSystemInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbFileSystemInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbFileSystemInfoFactory::~CSysMdbFileSystemInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbFileSystemInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbFileSystemInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbFileSystemInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbFileSystemInfo thisSysMdbFileSystemInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbFileSystemInfo.readCSV(input,pNames))
		add(&thisSysMdbFileSystemInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbFileSystemInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbFileSystemInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbFileSystemInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbFileSystemInfo::writeCSVHead(output);
	pSysMdbFileSystemInfo=(CWriteableSysMdbFileSystemInfo *)(pMem->getFirst());
	while (pSysMdbFileSystemInfo!=NULL) {
		if (!pSysMdbFileSystemInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbFileSystemInfo=(CWriteableSysMdbFileSystemInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbFileSystemInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbFileSystemInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbFileSystemInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbFileSystemInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbFileSystemInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbFileSystemInfo=(CWriteableSysMdbFileSystemInfo *)(pMem->getFirst());
	while (pSysMdbFileSystemInfo!=NULL) {
		pSysMdbFileSystemInfo->dump(fp,index++);
		pSysMdbFileSystemInfo=(CWriteableSysMdbFileSystemInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbFileSystemInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbFileSystemInfo *CSysMdbFileSystemInfoFactory::internalAdd(CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbFileSystemInfo++;
#endif
	CSysMdbFileSystemInfo *pTarget;	
	beforeAdd(pSysMdbFileSystemInfo);
	pTarget=(CSysMdbFileSystemInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbFileSystemInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbFileSystemInfo, sizeof(CSysMdbFileSystemInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbFileSystemInfo *CSysMdbFileSystemInfoFactory::add(CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CTransaction *pTransaction)
{
	pSysMdbFileSystemInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbFileSystemInfo,true);
	}
	else {
		CSysMdbFileSystemInfo *pNewSysMdbFileSystemInfo;
		pNewSysMdbFileSystemInfo = internalAdd(pSysMdbFileSystemInfo,false);
		pTransaction->addResource(CSysMdbFileSystemInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbFileSystemInfo,NULL));
		return pNewSysMdbFileSystemInfo;
	}
}

void CSysMdbFileSystemInfoFactory::internalUpdate(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pNewSysMdbFileSystemInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbFileSystemInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbFileSystemInfo++;
	}
#endif
	CWriteableSysMdbFileSystemInfo theOldSysMdbFileSystemInfo;
	beforeUpdate(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbFileSystemInfo,pSysMdbFileSystemInfo,sizeof(CSysMdbFileSystemInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo,sizeof(CSysMdbFileSystemInfo));
	pMem->updateObject(pSysMdbFileSystemInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbFileSystemInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbFileSystemInfo,&theOldSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::update(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pNewSysMdbFileSystemInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbFileSystemInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbFileSystemInfoResource::alloc(UPDATE_ACTION,this,pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo,updateIndex));
		internalUpdate(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo,updateIndex,false);
	}
}

void CSysMdbFileSystemInfoFactory::internalRemove(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbFileSystemInfo++;
#endif
	CWriteableSysMdbFileSystemInfo theOldSysMdbFileSystemInfo;
	beforeRemove(pSysMdbFileSystemInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbFileSystemInfo,pSysMdbFileSystemInfo,sizeof(CSysMdbFileSystemInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbFileSystemInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbFileSystemInfo);
	}
	pMem->free(pSysMdbFileSystemInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::remove(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbFileSystemInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbFileSystemInfoResource::alloc(DELETE_ACTION,this,pSysMdbFileSystemInfo,NULL));
		internalRemove(pSysMdbFileSystemInfo,false);		
	}
}

CSysMdbFileSystemInfo* CSysMdbFileSystemInfoFactory::addOrUpdate(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pNewSysMdbFileSystemInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbFileSystemInfo == NULL) {
		return add(pNewSysMdbFileSystemInfo,pTransaction);
	}
	else {
		update(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo,pTransaction,updateIndex);
		return pSysMdbFileSystemInfo;
	}
}

void CSysMdbFileSystemInfoFactory::retrieve(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pTargetSysMdbFileSystemInfo)
{
	forceCopy(pTargetSysMdbFileSystemInfo, pSysMdbFileSystemInfo, sizeof(CSysMdbFileSystemInfo));
}
	
int CSysMdbFileSystemInfoFactory::addActionTrigger(CSysMdbFileSystemInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbFileSystemInfoFactory::removeActionTrigger(CSysMdbFileSystemInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbFileSystemInfoFactory::addCommitTrigger(CSysMdbFileSystemInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbFileSystemInfoFactory::removeCommitTrigger(CSysMdbFileSystemInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbFileSystemInfo *CSysMdbFileSystemInfoFactory::getFirst(void)
{
	CSysMdbFileSystemInfo *pResult=(CSysMdbFileSystemInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbFileSystemInfo *CSysMdbFileSystemInfoFactory::getNext(void)
{
	CSysMdbFileSystemInfo *pResult=(CSysMdbFileSystemInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbFileSystemInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbFileSystemInfoFactory::beforeAdd(CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbFileSystemInfo);
	}
}
	
void CSysMdbFileSystemInfoFactory::afterAdd(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::beforeUpdate(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pNewSysMdbFileSystemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbFileSystemInfo,pNewSysMdbFileSystemInfo);
	}
}
	
void CSysMdbFileSystemInfoFactory::afterUpdate(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbFileSystemInfo);
	}
}
	
void CSysMdbFileSystemInfoFactory::beforeRemove(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::commitAdd(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbFileSystemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::commitUpdate(CSysMdbFileSystemInfo *pSysMdbFileSystemInfo, CWriteableSysMdbFileSystemInfo *pOldSysMdbFileSystemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbFileSystemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbFileSystemInfo,pOldSysMdbFileSystemInfo);
	}
}
	
void CSysMdbFileSystemInfoFactory::commitRemove(CWriteableSysMdbFileSystemInfo *pSysMdbFileSystemInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbFileSystemInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbFileSystemInfo);
	}
}

void CSysMdbFileSystemInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbNetworkInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbNetworkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbNetworkInfo=0;
int updateWithIndexActionForSysMdbNetworkInfo=0;
int updateWithoutIndexActionForSysMdbNetworkInfo=0;
int removeActionForSysMdbNetworkInfo=0;
int addCommitForSysMdbNetworkInfo=0;
int updateCommitForSysMdbNetworkInfo=0;
int removeCommitForSysMdbNetworkInfo=0;
#endif
void CSysMdbNetworkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbNetworkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbNetworkInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbNetworkInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbNetworkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbNetworkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbNetworkInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbNetworkInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbNetworkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbNetworkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbNetworkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbNetworkInfoFactory::CSysMdbNetworkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbNetworkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbNetworkInfoFactory::CSysMdbNetworkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbNetworkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbNetworkInfoFactory::~CSysMdbNetworkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbNetworkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbNetworkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbNetworkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbNetworkInfo thisSysMdbNetworkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbNetworkInfo.readCSV(input,pNames))
		add(&thisSysMdbNetworkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbNetworkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbNetworkInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbNetworkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbNetworkInfo::writeCSVHead(output);
	pSysMdbNetworkInfo=(CWriteableSysMdbNetworkInfo *)(pMem->getFirst());
	while (pSysMdbNetworkInfo!=NULL) {
		if (!pSysMdbNetworkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbNetworkInfo=(CWriteableSysMdbNetworkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbNetworkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbNetworkInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbNetworkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbNetworkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbNetworkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbNetworkInfo=(CWriteableSysMdbNetworkInfo *)(pMem->getFirst());
	while (pSysMdbNetworkInfo!=NULL) {
		pSysMdbNetworkInfo->dump(fp,index++);
		pSysMdbNetworkInfo=(CWriteableSysMdbNetworkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbNetworkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbNetworkInfo *CSysMdbNetworkInfoFactory::internalAdd(CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbNetworkInfo++;
#endif
	CSysMdbNetworkInfo *pTarget;	
	beforeAdd(pSysMdbNetworkInfo);
	pTarget=(CSysMdbNetworkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbNetworkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbNetworkInfo, sizeof(CSysMdbNetworkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbNetworkInfo *CSysMdbNetworkInfoFactory::add(CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo, CTransaction *pTransaction)
{
	pSysMdbNetworkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbNetworkInfo,true);
	}
	else {
		CSysMdbNetworkInfo *pNewSysMdbNetworkInfo;
		pNewSysMdbNetworkInfo = internalAdd(pSysMdbNetworkInfo,false);
		pTransaction->addResource(CSysMdbNetworkInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbNetworkInfo,NULL));
		return pNewSysMdbNetworkInfo;
	}
}

void CSysMdbNetworkInfoFactory::internalUpdate(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pNewSysMdbNetworkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbNetworkInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbNetworkInfo++;
	}
#endif
	CWriteableSysMdbNetworkInfo theOldSysMdbNetworkInfo;
	beforeUpdate(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbNetworkInfo,pSysMdbNetworkInfo,sizeof(CSysMdbNetworkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo,sizeof(CSysMdbNetworkInfo));
	pMem->updateObject(pSysMdbNetworkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbNetworkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbNetworkInfo,&theOldSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::update(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pNewSysMdbNetworkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbNetworkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbNetworkInfoResource::alloc(UPDATE_ACTION,this,pSysMdbNetworkInfo,pNewSysMdbNetworkInfo,updateIndex));
		internalUpdate(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo,updateIndex,false);
	}
}

void CSysMdbNetworkInfoFactory::internalRemove(CSysMdbNetworkInfo *pSysMdbNetworkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbNetworkInfo++;
#endif
	CWriteableSysMdbNetworkInfo theOldSysMdbNetworkInfo;
	beforeRemove(pSysMdbNetworkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbNetworkInfo,pSysMdbNetworkInfo,sizeof(CSysMdbNetworkInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbNetworkInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbNetworkInfo);
	}
	pMem->free(pSysMdbNetworkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::remove(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbNetworkInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbNetworkInfoResource::alloc(DELETE_ACTION,this,pSysMdbNetworkInfo,NULL));
		internalRemove(pSysMdbNetworkInfo,false);		
	}
}

CSysMdbNetworkInfo* CSysMdbNetworkInfoFactory::addOrUpdate(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pNewSysMdbNetworkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbNetworkInfo == NULL) {
		return add(pNewSysMdbNetworkInfo,pTransaction);
	}
	else {
		update(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo,pTransaction,updateIndex);
		return pSysMdbNetworkInfo;
	}
}

void CSysMdbNetworkInfoFactory::retrieve(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pTargetSysMdbNetworkInfo)
{
	forceCopy(pTargetSysMdbNetworkInfo, pSysMdbNetworkInfo, sizeof(CSysMdbNetworkInfo));
}
	
int CSysMdbNetworkInfoFactory::addActionTrigger(CSysMdbNetworkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbNetworkInfoFactory::removeActionTrigger(CSysMdbNetworkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbNetworkInfoFactory::addCommitTrigger(CSysMdbNetworkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbNetworkInfoFactory::removeCommitTrigger(CSysMdbNetworkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbNetworkInfo *CSysMdbNetworkInfoFactory::getFirst(void)
{
	CSysMdbNetworkInfo *pResult=(CSysMdbNetworkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbNetworkInfo *CSysMdbNetworkInfoFactory::getNext(void)
{
	CSysMdbNetworkInfo *pResult=(CSysMdbNetworkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbNetworkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbNetworkInfoFactory::beforeAdd(CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbNetworkInfo);
	}
}
	
void CSysMdbNetworkInfoFactory::afterAdd(CSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::beforeUpdate(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pNewSysMdbNetworkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbNetworkInfo,pNewSysMdbNetworkInfo);
	}
}
	
void CSysMdbNetworkInfoFactory::afterUpdate(CSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbNetworkInfo);
	}
}
	
void CSysMdbNetworkInfoFactory::beforeRemove(CSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::commitAdd(CSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbNetworkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::commitUpdate(CSysMdbNetworkInfo *pSysMdbNetworkInfo, CWriteableSysMdbNetworkInfo *pOldSysMdbNetworkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbNetworkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbNetworkInfo,pOldSysMdbNetworkInfo);
	}
}
	
void CSysMdbNetworkInfoFactory::commitRemove(CWriteableSysMdbNetworkInfo *pSysMdbNetworkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbNetworkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbNetworkInfo);
	}
}

void CSysMdbNetworkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysParticipantIDIndexinSysParticipantInit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysParticipantInit=0;
int updateWithIndexActionForSysParticipantInit=0;
int updateWithoutIndexActionForSysParticipantInit=0;
int removeActionForSysParticipantInit=0;
int addCommitForSysParticipantInit=0;
int updateCommitForSysParticipantInit=0;
int removeCommitForSysParticipantInit=0;
#endif
void CSysParticipantInitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysParticipantIDIndex=new CAVLTree(maxUnit,compareForSysParticipantIDIndexinSysParticipantInit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysParticipantInit_SysParticipantIDIndex",pSysParticipantIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysParticipantInit_SysParticipantIDIndex");
			if(it != pIndexMap->end()) {
				pSysParticipantIDIndex=new CAVLTree(maxUnit,compareForSysParticipantIDIndexinSysParticipantInit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysParticipantIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysParticipantInitActionTrigger *>;
	pCommitTriggers=new vector<CSysParticipantInitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysParticipantInitFactory::CSysParticipantInitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticipantInit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysParticipantInitFactory::CSysParticipantInitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticipantInit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysParticipantInitFactory::~CSysParticipantInitFactory(void)
{
	if (runLevel>=0) {
		if (pSysParticipantIDIndex!=NULL)
			delete pSysParticipantIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysParticipantInitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysParticipantInitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysParticipantIDIndex->output(pLogger,indent+1);
	}
}

int CSysParticipantInitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysParticipantInit thisSysParticipantInit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysParticipantInit.readCSV(input,pNames))
		add(&thisSysParticipantInit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysParticipantInitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysParticipantInit.csv");
	return readCSV(szFileName);
}

int CSysParticipantInitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysParticipantInit *pSysParticipantInit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysParticipantInit::writeCSVHead(output);
	pSysParticipantInit=(CWriteableSysParticipantInit *)(pMem->getFirst());
	while (pSysParticipantInit!=NULL) {
		if (!pSysParticipantInit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysParticipantInit=(CWriteableSysParticipantInit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysParticipantInitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysParticipantInit.csv");
	return writeCSV(szFileName);
}

void CSysParticipantInitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysParticipantInitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysParticipantInit *pSysParticipantInit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysParticipantInitFactory={       Total Count=%d\n", pMem->getCount());
	pSysParticipantInit=(CWriteableSysParticipantInit *)(pMem->getFirst());
	while (pSysParticipantInit!=NULL) {
		pSysParticipantInit->dump(fp,index++);
		pSysParticipantInit=(CWriteableSysParticipantInit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysParticipantInitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysParticipantIDIndex->removeAll();
	}
}

CSysParticipantInit *CSysParticipantInitFactory::internalAdd(CWriteableSysParticipantInit *pSysParticipantInit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysParticipantInit++;
#endif
	CSysParticipantInit *pTarget;	
	beforeAdd(pSysParticipantInit);
	pTarget=(CSysParticipantInit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysParticipantInit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysParticipantInit, sizeof(CSysParticipantInit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysParticipantIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysParticipantInit *CSysParticipantInitFactory::add(CWriteableSysParticipantInit *pSysParticipantInit, CTransaction *pTransaction)
{
	pSysParticipantInit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysParticipantInit,true);
	}
	else {
		CSysParticipantInit *pNewSysParticipantInit;
		pNewSysParticipantInit = internalAdd(pSysParticipantInit,false);
		pTransaction->addResource(CSysParticipantInitResource::alloc(CREATE_ACTION,this,pNewSysParticipantInit,NULL));
		return pNewSysParticipantInit;
	}
}

void CSysParticipantInitFactory::internalUpdate(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pNewSysParticipantInit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysParticipantInit++;
	}
	else {
		updateWithoutIndexActionForSysParticipantInit++;
	}
#endif
	CWriteableSysParticipantInit theOldSysParticipantInit;
	beforeUpdate(pSysParticipantInit,pNewSysParticipantInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticipantInit,pSysParticipantInit,sizeof(CSysParticipantInit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysParticipantInit,pNewSysParticipantInit,sizeof(CSysParticipantInit));
	pMem->updateObject(pSysParticipantInit);
	if (updateIndex) {
	}
	afterUpdate(pSysParticipantInit);
	if (bNoTransaction) {
		commitUpdate(pSysParticipantInit,&theOldSysParticipantInit);
	}
}

void CSysParticipantInitFactory::update(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pNewSysParticipantInit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysParticipantInit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysParticipantInit,pNewSysParticipantInit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysParticipantInitResource::alloc(UPDATE_ACTION,this,pSysParticipantInit,pNewSysParticipantInit,updateIndex));
		internalUpdate(pSysParticipantInit,pNewSysParticipantInit,updateIndex,false);
	}
}

void CSysParticipantInitFactory::internalRemove(CSysParticipantInit *pSysParticipantInit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysParticipantInit++;
#endif
	CWriteableSysParticipantInit theOldSysParticipantInit;
	beforeRemove(pSysParticipantInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticipantInit,pSysParticipantInit,sizeof(CSysParticipantInit));
	}
	if (runLevel>=0) {
		pSysParticipantIDIndex->removeObject(pSysParticipantInit);
	}
	pMem->free(pSysParticipantInit);
	if(bNoTransaction) {
		commitRemove(&theOldSysParticipantInit);
	}
}

void CSysParticipantInitFactory::remove(CSysParticipantInit *pSysParticipantInit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysParticipantInit,true);
	}
	else {
		pTransaction->addResource(CSysParticipantInitResource::alloc(DELETE_ACTION,this,pSysParticipantInit,NULL));
		internalRemove(pSysParticipantInit,false);		
	}
}

CSysParticipantInit* CSysParticipantInitFactory::addOrUpdate(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pNewSysParticipantInit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysParticipantInit == NULL) {
		return add(pNewSysParticipantInit,pTransaction);
	}
	else {
		update(pSysParticipantInit,pNewSysParticipantInit,pTransaction,updateIndex);
		return pSysParticipantInit;
	}
}

void CSysParticipantInitFactory::retrieve(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pTargetSysParticipantInit)
{
	forceCopy(pTargetSysParticipantInit, pSysParticipantInit, sizeof(CSysParticipantInit));
}
	
int CSysParticipantInitFactory::addActionTrigger(CSysParticipantInitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysParticipantInitFactory::removeActionTrigger(CSysParticipantInitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysParticipantInitFactory::addCommitTrigger(CSysParticipantInitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysParticipantInitFactory::removeCommitTrigger(CSysParticipantInitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysParticipantInit *CSysParticipantInitFactory::getFirst(void)
{
	CSysParticipantInit *pResult=(CSysParticipantInit *)(pMem->getFirst());
	return pResult;
}
	
CSysParticipantInit *CSysParticipantInitFactory::getNext(void)
{
	CSysParticipantInit *pResult=(CSysParticipantInit *)(pMem->getNext());
	return pResult;
}
	
void CSysParticipantInitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysParticipantInitFactory::beforeAdd(CWriteableSysParticipantInit *pSysParticipantInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysParticipantInit);
	}
}
	
void CSysParticipantInitFactory::afterAdd(CSysParticipantInit *pSysParticipantInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysParticipantInit);
	}
}

void CSysParticipantInitFactory::beforeUpdate(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pNewSysParticipantInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysParticipantInit,pNewSysParticipantInit);
	}
}
	
void CSysParticipantInitFactory::afterUpdate(CSysParticipantInit *pSysParticipantInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysParticipantInit);
	}
}
	
void CSysParticipantInitFactory::beforeRemove(CSysParticipantInit *pSysParticipantInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysParticipantInit);
	}
}

void CSysParticipantInitFactory::commitAdd(CSysParticipantInit *pSysParticipantInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysParticipantInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysParticipantInit);
	}
}

void CSysParticipantInitFactory::commitUpdate(CSysParticipantInit *pSysParticipantInit, CWriteableSysParticipantInit *pOldSysParticipantInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysParticipantInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysParticipantInit,pOldSysParticipantInit);
	}
}
	
void CSysParticipantInitFactory::commitRemove(CWriteableSysParticipantInit *pSysParticipantInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysParticipantInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysParticipantInit);
	}
}

void CSysParticipantInitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysUserIDIndexinSysUserInit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysUserInit=0;
int updateWithIndexActionForSysUserInit=0;
int updateWithoutIndexActionForSysUserInit=0;
int removeActionForSysUserInit=0;
int addCommitForSysUserInit=0;
int updateCommitForSysUserInit=0;
int removeCommitForSysUserInit=0;
#endif
void CSysUserInitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysUserIDIndex=new CAVLTree(maxUnit,compareForSysUserIDIndexinSysUserInit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysUserInit_SysUserIDIndex",pSysUserIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysUserInit_SysUserIDIndex");
			if(it != pIndexMap->end()) {
				pSysUserIDIndex=new CAVLTree(maxUnit,compareForSysUserIDIndexinSysUserInit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysUserIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysUserInitActionTrigger *>;
	pCommitTriggers=new vector<CSysUserInitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysUserInitFactory::CSysUserInitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserInit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysUserInitFactory::CSysUserInitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysUserInit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysUserInitFactory::~CSysUserInitFactory(void)
{
	if (runLevel>=0) {
		if (pSysUserIDIndex!=NULL)
			delete pSysUserIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysUserInitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysUserInitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysUserIDIndex->output(pLogger,indent+1);
	}
}

int CSysUserInitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysUserInit thisSysUserInit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysUserInit.readCSV(input,pNames))
		add(&thisSysUserInit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysUserInitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysUserInit.csv");
	return readCSV(szFileName);
}

int CSysUserInitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysUserInit *pSysUserInit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysUserInit::writeCSVHead(output);
	pSysUserInit=(CWriteableSysUserInit *)(pMem->getFirst());
	while (pSysUserInit!=NULL) {
		if (!pSysUserInit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysUserInit=(CWriteableSysUserInit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysUserInitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysUserInit.csv");
	return writeCSV(szFileName);
}

void CSysUserInitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysUserInitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysUserInit *pSysUserInit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysUserInitFactory={       Total Count=%d\n", pMem->getCount());
	pSysUserInit=(CWriteableSysUserInit *)(pMem->getFirst());
	while (pSysUserInit!=NULL) {
		pSysUserInit->dump(fp,index++);
		pSysUserInit=(CWriteableSysUserInit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysUserInitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysUserIDIndex->removeAll();
	}
}

CSysUserInit *CSysUserInitFactory::internalAdd(CWriteableSysUserInit *pSysUserInit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysUserInit++;
#endif
	CSysUserInit *pTarget;	
	beforeAdd(pSysUserInit);
	pTarget=(CSysUserInit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysUserInit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysUserInit, sizeof(CSysUserInit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysUserIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysUserInit *CSysUserInitFactory::add(CWriteableSysUserInit *pSysUserInit, CTransaction *pTransaction)
{
	pSysUserInit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysUserInit,true);
	}
	else {
		CSysUserInit *pNewSysUserInit;
		pNewSysUserInit = internalAdd(pSysUserInit,false);
		pTransaction->addResource(CSysUserInitResource::alloc(CREATE_ACTION,this,pNewSysUserInit,NULL));
		return pNewSysUserInit;
	}
}

void CSysUserInitFactory::internalUpdate(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pNewSysUserInit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysUserInit++;
	}
	else {
		updateWithoutIndexActionForSysUserInit++;
	}
#endif
	CWriteableSysUserInit theOldSysUserInit;
	beforeUpdate(pSysUserInit,pNewSysUserInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserInit,pSysUserInit,sizeof(CSysUserInit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysUserInit,pNewSysUserInit,sizeof(CSysUserInit));
	pMem->updateObject(pSysUserInit);
	if (updateIndex) {
	}
	afterUpdate(pSysUserInit);
	if (bNoTransaction) {
		commitUpdate(pSysUserInit,&theOldSysUserInit);
	}
}

void CSysUserInitFactory::update(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pNewSysUserInit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysUserInit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysUserInit,pNewSysUserInit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysUserInitResource::alloc(UPDATE_ACTION,this,pSysUserInit,pNewSysUserInit,updateIndex));
		internalUpdate(pSysUserInit,pNewSysUserInit,updateIndex,false);
	}
}

void CSysUserInitFactory::internalRemove(CSysUserInit *pSysUserInit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysUserInit++;
#endif
	CWriteableSysUserInit theOldSysUserInit;
	beforeRemove(pSysUserInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysUserInit,pSysUserInit,sizeof(CSysUserInit));
	}
	if (runLevel>=0) {
		pSysUserIDIndex->removeObject(pSysUserInit);
	}
	pMem->free(pSysUserInit);
	if(bNoTransaction) {
		commitRemove(&theOldSysUserInit);
	}
}

void CSysUserInitFactory::remove(CSysUserInit *pSysUserInit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysUserInit,true);
	}
	else {
		pTransaction->addResource(CSysUserInitResource::alloc(DELETE_ACTION,this,pSysUserInit,NULL));
		internalRemove(pSysUserInit,false);		
	}
}

CSysUserInit* CSysUserInitFactory::addOrUpdate(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pNewSysUserInit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysUserInit == NULL) {
		return add(pNewSysUserInit,pTransaction);
	}
	else {
		update(pSysUserInit,pNewSysUserInit,pTransaction,updateIndex);
		return pSysUserInit;
	}
}

void CSysUserInitFactory::retrieve(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pTargetSysUserInit)
{
	forceCopy(pTargetSysUserInit, pSysUserInit, sizeof(CSysUserInit));
}
	
int CSysUserInitFactory::addActionTrigger(CSysUserInitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysUserInitFactory::removeActionTrigger(CSysUserInitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysUserInitFactory::addCommitTrigger(CSysUserInitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysUserInitFactory::removeCommitTrigger(CSysUserInitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysUserInit *CSysUserInitFactory::getFirst(void)
{
	CSysUserInit *pResult=(CSysUserInit *)(pMem->getFirst());
	return pResult;
}
	
CSysUserInit *CSysUserInitFactory::getNext(void)
{
	CSysUserInit *pResult=(CSysUserInit *)(pMem->getNext());
	return pResult;
}
	
void CSysUserInitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysUserInitFactory::beforeAdd(CWriteableSysUserInit *pSysUserInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysUserInit);
	}
}
	
void CSysUserInitFactory::afterAdd(CSysUserInit *pSysUserInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysUserInit);
	}
}

void CSysUserInitFactory::beforeUpdate(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pNewSysUserInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysUserInit,pNewSysUserInit);
	}
}
	
void CSysUserInitFactory::afterUpdate(CSysUserInit *pSysUserInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysUserInit);
	}
}
	
void CSysUserInitFactory::beforeRemove(CSysUserInit *pSysUserInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysUserInit);
	}
}

void CSysUserInitFactory::commitAdd(CSysUserInit *pSysUserInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysUserInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysUserInit);
	}
}

void CSysUserInitFactory::commitUpdate(CSysUserInit *pSysUserInit, CWriteableSysUserInit *pOldSysUserInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysUserInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysUserInit,pOldSysUserInit);
	}
}
	
void CSysUserInitFactory::commitRemove(CWriteableSysUserInit *pSysUserInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysUserInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysUserInit);
	}
}

void CSysUserInitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysClientIDIndexinSysClientInit(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysClientInit=0;
int updateWithIndexActionForSysClientInit=0;
int updateWithoutIndexActionForSysClientInit=0;
int removeActionForSysClientInit=0;
int addCommitForSysClientInit=0;
int updateCommitForSysClientInit=0;
int removeCommitForSysClientInit=0;
#endif
void CSysClientInitFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysClientIDIndex=new CAVLTree(maxUnit,compareForSysClientIDIndexinSysClientInit,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysClientInit_SysClientIDIndex",pSysClientIDIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysClientInit_SysClientIDIndex");
			if(it != pIndexMap->end()) {
				pSysClientIDIndex=new CAVLTree(maxUnit,compareForSysClientIDIndexinSysClientInit,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysClientIDIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysClientInitActionTrigger *>;
	pCommitTriggers=new vector<CSysClientInitCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysClientInitFactory::CSysClientInitFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientInit),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysClientInitFactory::CSysClientInitFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysClientInit),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysClientInitFactory::~CSysClientInitFactory(void)
{
	if (runLevel>=0) {
		if (pSysClientIDIndex!=NULL)
			delete pSysClientIDIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysClientInitFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysClientInitFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysClientIDIndex->output(pLogger,indent+1);
	}
}

int CSysClientInitFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysClientInit thisSysClientInit;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysClientInit.readCSV(input,pNames))
		add(&thisSysClientInit);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysClientInitFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysClientInit.csv");
	return readCSV(szFileName);
}

int CSysClientInitFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysClientInit *pSysClientInit;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysClientInit::writeCSVHead(output);
	pSysClientInit=(CWriteableSysClientInit *)(pMem->getFirst());
	while (pSysClientInit!=NULL) {
		if (!pSysClientInit->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysClientInit=(CWriteableSysClientInit *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysClientInitFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysClientInit.csv");
	return writeCSV(szFileName);
}

void CSysClientInitFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysClientInitFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysClientInit *pSysClientInit;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysClientInitFactory={       Total Count=%d\n", pMem->getCount());
	pSysClientInit=(CWriteableSysClientInit *)(pMem->getFirst());
	while (pSysClientInit!=NULL) {
		pSysClientInit->dump(fp,index++);
		pSysClientInit=(CWriteableSysClientInit *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysClientInitFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysClientIDIndex->removeAll();
	}
}

CSysClientInit *CSysClientInitFactory::internalAdd(CWriteableSysClientInit *pSysClientInit, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysClientInit++;
#endif
	CSysClientInit *pTarget;	
	beforeAdd(pSysClientInit);
	pTarget=(CSysClientInit *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysClientInit in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysClientInit, sizeof(CSysClientInit));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysClientIDIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysClientInit *CSysClientInitFactory::add(CWriteableSysClientInit *pSysClientInit, CTransaction *pTransaction)
{
	pSysClientInit->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysClientInit,true);
	}
	else {
		CSysClientInit *pNewSysClientInit;
		pNewSysClientInit = internalAdd(pSysClientInit,false);
		pTransaction->addResource(CSysClientInitResource::alloc(CREATE_ACTION,this,pNewSysClientInit,NULL));
		return pNewSysClientInit;
	}
}

void CSysClientInitFactory::internalUpdate(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pNewSysClientInit, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysClientInit++;
	}
	else {
		updateWithoutIndexActionForSysClientInit++;
	}
#endif
	CWriteableSysClientInit theOldSysClientInit;
	beforeUpdate(pSysClientInit,pNewSysClientInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientInit,pSysClientInit,sizeof(CSysClientInit));
	}
	if (updateIndex) {
	}

	forceCopy(pSysClientInit,pNewSysClientInit,sizeof(CSysClientInit));
	pMem->updateObject(pSysClientInit);
	if (updateIndex) {
	}
	afterUpdate(pSysClientInit);
	if (bNoTransaction) {
		commitUpdate(pSysClientInit,&theOldSysClientInit);
	}
}

void CSysClientInitFactory::update(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pNewSysClientInit, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysClientInit->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysClientInit,pNewSysClientInit,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysClientInitResource::alloc(UPDATE_ACTION,this,pSysClientInit,pNewSysClientInit,updateIndex));
		internalUpdate(pSysClientInit,pNewSysClientInit,updateIndex,false);
	}
}

void CSysClientInitFactory::internalRemove(CSysClientInit *pSysClientInit, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysClientInit++;
#endif
	CWriteableSysClientInit theOldSysClientInit;
	beforeRemove(pSysClientInit);
	if (bNoTransaction) {
		forceCopy(&theOldSysClientInit,pSysClientInit,sizeof(CSysClientInit));
	}
	if (runLevel>=0) {
		pSysClientIDIndex->removeObject(pSysClientInit);
	}
	pMem->free(pSysClientInit);
	if(bNoTransaction) {
		commitRemove(&theOldSysClientInit);
	}
}

void CSysClientInitFactory::remove(CSysClientInit *pSysClientInit, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysClientInit,true);
	}
	else {
		pTransaction->addResource(CSysClientInitResource::alloc(DELETE_ACTION,this,pSysClientInit,NULL));
		internalRemove(pSysClientInit,false);		
	}
}

CSysClientInit* CSysClientInitFactory::addOrUpdate(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pNewSysClientInit, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysClientInit == NULL) {
		return add(pNewSysClientInit,pTransaction);
	}
	else {
		update(pSysClientInit,pNewSysClientInit,pTransaction,updateIndex);
		return pSysClientInit;
	}
}

void CSysClientInitFactory::retrieve(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pTargetSysClientInit)
{
	forceCopy(pTargetSysClientInit, pSysClientInit, sizeof(CSysClientInit));
}
	
int CSysClientInitFactory::addActionTrigger(CSysClientInitActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysClientInitFactory::removeActionTrigger(CSysClientInitActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysClientInitFactory::addCommitTrigger(CSysClientInitCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysClientInitFactory::removeCommitTrigger(CSysClientInitCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysClientInit *CSysClientInitFactory::getFirst(void)
{
	CSysClientInit *pResult=(CSysClientInit *)(pMem->getFirst());
	return pResult;
}
	
CSysClientInit *CSysClientInitFactory::getNext(void)
{
	CSysClientInit *pResult=(CSysClientInit *)(pMem->getNext());
	return pResult;
}
	
void CSysClientInitFactory::endGet(void)
{
	pMem->endGet();
}

void CSysClientInitFactory::beforeAdd(CWriteableSysClientInit *pSysClientInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysClientInit);
	}
}
	
void CSysClientInitFactory::afterAdd(CSysClientInit *pSysClientInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysClientInit);
	}
}

void CSysClientInitFactory::beforeUpdate(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pNewSysClientInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysClientInit,pNewSysClientInit);
	}
}
	
void CSysClientInitFactory::afterUpdate(CSysClientInit *pSysClientInit)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysClientInit);
	}
}
	
void CSysClientInitFactory::beforeRemove(CSysClientInit *pSysClientInit)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysClientInit);
	}
}

void CSysClientInitFactory::commitAdd(CSysClientInit *pSysClientInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysClientInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysClientInit);
	}
}

void CSysClientInitFactory::commitUpdate(CSysClientInit *pSysClientInit, CWriteableSysClientInit *pOldSysClientInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysClientInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysClientInit,pOldSysClientInit);
	}
}
	
void CSysClientInitFactory::commitRemove(CWriteableSysClientInit *pSysClientInit)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysClientInit++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysClientInit);
	}
}

void CSysClientInitFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTradeUserLoginInfoIndexinSysTradeUserLoginInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysTradeUserLoginInfo=0;
int updateWithIndexActionForSysTradeUserLoginInfo=0;
int updateWithoutIndexActionForSysTradeUserLoginInfo=0;
int removeActionForSysTradeUserLoginInfo=0;
int addCommitForSysTradeUserLoginInfo=0;
int updateCommitForSysTradeUserLoginInfo=0;
int removeCommitForSysTradeUserLoginInfo=0;
#endif
void CSysTradeUserLoginInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTradeUserLoginInfoIndex=new CAVLTree(maxUnit,compareForSysTradeUserLoginInfoIndexinSysTradeUserLoginInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysTradeUserLoginInfo_SysTradeUserLoginInfoIndex",pSysTradeUserLoginInfoIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysTradeUserLoginInfo_SysTradeUserLoginInfoIndex");
			if(it != pIndexMap->end()) {
				pSysTradeUserLoginInfoIndex=new CAVLTree(maxUnit,compareForSysTradeUserLoginInfoIndexinSysTradeUserLoginInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTradeUserLoginInfoIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysTradeUserLoginInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysTradeUserLoginInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysTradeUserLoginInfoFactory::CSysTradeUserLoginInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysTradeUserLoginInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysTradeUserLoginInfoFactory::CSysTradeUserLoginInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysTradeUserLoginInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysTradeUserLoginInfoFactory::~CSysTradeUserLoginInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysTradeUserLoginInfoIndex!=NULL)
			delete pSysTradeUserLoginInfoIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysTradeUserLoginInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysTradeUserLoginInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTradeUserLoginInfoIndex->output(pLogger,indent+1);
	}
}

int CSysTradeUserLoginInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysTradeUserLoginInfo thisSysTradeUserLoginInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysTradeUserLoginInfo.readCSV(input,pNames))
		add(&thisSysTradeUserLoginInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysTradeUserLoginInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysTradeUserLoginInfo.csv");
	return readCSV(szFileName);
}

int CSysTradeUserLoginInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysTradeUserLoginInfo::writeCSVHead(output);
	pSysTradeUserLoginInfo=(CWriteableSysTradeUserLoginInfo *)(pMem->getFirst());
	while (pSysTradeUserLoginInfo!=NULL) {
		if (!pSysTradeUserLoginInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysTradeUserLoginInfo=(CWriteableSysTradeUserLoginInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysTradeUserLoginInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysTradeUserLoginInfo.csv");
	return writeCSV(szFileName);
}

void CSysTradeUserLoginInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysTradeUserLoginInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysTradeUserLoginInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysTradeUserLoginInfo=(CWriteableSysTradeUserLoginInfo *)(pMem->getFirst());
	while (pSysTradeUserLoginInfo!=NULL) {
		pSysTradeUserLoginInfo->dump(fp,index++);
		pSysTradeUserLoginInfo=(CWriteableSysTradeUserLoginInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysTradeUserLoginInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTradeUserLoginInfoIndex->removeAll();
	}
}

CSysTradeUserLoginInfo *CSysTradeUserLoginInfoFactory::internalAdd(CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysTradeUserLoginInfo++;
#endif
	CSysTradeUserLoginInfo *pTarget;	
	beforeAdd(pSysTradeUserLoginInfo);
	pTarget=(CSysTradeUserLoginInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysTradeUserLoginInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysTradeUserLoginInfo, sizeof(CSysTradeUserLoginInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTradeUserLoginInfoIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysTradeUserLoginInfo *CSysTradeUserLoginInfoFactory::add(CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CTransaction *pTransaction)
{
	pSysTradeUserLoginInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysTradeUserLoginInfo,true);
	}
	else {
		CSysTradeUserLoginInfo *pNewSysTradeUserLoginInfo;
		pNewSysTradeUserLoginInfo = internalAdd(pSysTradeUserLoginInfo,false);
		pTransaction->addResource(CSysTradeUserLoginInfoResource::alloc(CREATE_ACTION,this,pNewSysTradeUserLoginInfo,NULL));
		return pNewSysTradeUserLoginInfo;
	}
}

void CSysTradeUserLoginInfoFactory::internalUpdate(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pNewSysTradeUserLoginInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysTradeUserLoginInfo++;
	}
	else {
		updateWithoutIndexActionForSysTradeUserLoginInfo++;
	}
#endif
	CWriteableSysTradeUserLoginInfo theOldSysTradeUserLoginInfo;
	beforeUpdate(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysTradeUserLoginInfo,pSysTradeUserLoginInfo,sizeof(CSysTradeUserLoginInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo,sizeof(CSysTradeUserLoginInfo));
	pMem->updateObject(pSysTradeUserLoginInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysTradeUserLoginInfo);
	if (bNoTransaction) {
		commitUpdate(pSysTradeUserLoginInfo,&theOldSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::update(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pNewSysTradeUserLoginInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysTradeUserLoginInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysTradeUserLoginInfoResource::alloc(UPDATE_ACTION,this,pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo,updateIndex));
		internalUpdate(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo,updateIndex,false);
	}
}

void CSysTradeUserLoginInfoFactory::internalRemove(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysTradeUserLoginInfo++;
#endif
	CWriteableSysTradeUserLoginInfo theOldSysTradeUserLoginInfo;
	beforeRemove(pSysTradeUserLoginInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysTradeUserLoginInfo,pSysTradeUserLoginInfo,sizeof(CSysTradeUserLoginInfo));
	}
	if (runLevel>=0) {
		pSysTradeUserLoginInfoIndex->removeObject(pSysTradeUserLoginInfo);
	}
	pMem->free(pSysTradeUserLoginInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::remove(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysTradeUserLoginInfo,true);
	}
	else {
		pTransaction->addResource(CSysTradeUserLoginInfoResource::alloc(DELETE_ACTION,this,pSysTradeUserLoginInfo,NULL));
		internalRemove(pSysTradeUserLoginInfo,false);		
	}
}

CSysTradeUserLoginInfo* CSysTradeUserLoginInfoFactory::addOrUpdate(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pNewSysTradeUserLoginInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysTradeUserLoginInfo == NULL) {
		return add(pNewSysTradeUserLoginInfo,pTransaction);
	}
	else {
		update(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo,pTransaction,updateIndex);
		return pSysTradeUserLoginInfo;
	}
}

void CSysTradeUserLoginInfoFactory::retrieve(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pTargetSysTradeUserLoginInfo)
{
	forceCopy(pTargetSysTradeUserLoginInfo, pSysTradeUserLoginInfo, sizeof(CSysTradeUserLoginInfo));
}
	
int CSysTradeUserLoginInfoFactory::addActionTrigger(CSysTradeUserLoginInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysTradeUserLoginInfoFactory::removeActionTrigger(CSysTradeUserLoginInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysTradeUserLoginInfoFactory::addCommitTrigger(CSysTradeUserLoginInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysTradeUserLoginInfoFactory::removeCommitTrigger(CSysTradeUserLoginInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysTradeUserLoginInfo *CSysTradeUserLoginInfoFactory::getFirst(void)
{
	CSysTradeUserLoginInfo *pResult=(CSysTradeUserLoginInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysTradeUserLoginInfo *CSysTradeUserLoginInfoFactory::getNext(void)
{
	CSysTradeUserLoginInfo *pResult=(CSysTradeUserLoginInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysTradeUserLoginInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysTradeUserLoginInfoFactory::beforeAdd(CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysTradeUserLoginInfo);
	}
}
	
void CSysTradeUserLoginInfoFactory::afterAdd(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::beforeUpdate(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pNewSysTradeUserLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysTradeUserLoginInfo,pNewSysTradeUserLoginInfo);
	}
}
	
void CSysTradeUserLoginInfoFactory::afterUpdate(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysTradeUserLoginInfo);
	}
}
	
void CSysTradeUserLoginInfoFactory::beforeRemove(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::commitAdd(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysTradeUserLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::commitUpdate(CSysTradeUserLoginInfo *pSysTradeUserLoginInfo, CWriteableSysTradeUserLoginInfo *pOldSysTradeUserLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysTradeUserLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysTradeUserLoginInfo,pOldSysTradeUserLoginInfo);
	}
}
	
void CSysTradeUserLoginInfoFactory::commitRemove(CWriteableSysTradeUserLoginInfo *pSysTradeUserLoginInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysTradeUserLoginInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysTradeUserLoginInfo);
	}
}

void CSysTradeUserLoginInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbWebAppInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbWebAppInfo=0;
int updateWithIndexActionForSysMdbWebAppInfo=0;
int updateWithoutIndexActionForSysMdbWebAppInfo=0;
int removeActionForSysMdbWebAppInfo=0;
int addCommitForSysMdbWebAppInfo=0;
int updateCommitForSysMdbWebAppInfo=0;
int removeCommitForSysMdbWebAppInfo=0;
#endif
void CSysMdbWebAppInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbWebAppInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbWebAppInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbWebAppInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbWebAppInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByIDType=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbWebAppInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbWebAppInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbWebAppInfoFactory::CSysMdbWebAppInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbWebAppInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbWebAppInfoFactory::CSysMdbWebAppInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbWebAppInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbWebAppInfoFactory::~CSysMdbWebAppInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbWebAppInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbWebAppInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysMdbWebAppInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbWebAppInfo thisSysMdbWebAppInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbWebAppInfo.readCSV(input,pNames))
		add(&thisSysMdbWebAppInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbWebAppInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbWebAppInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbWebAppInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbWebAppInfo::writeCSVHead(output);
	pSysMdbWebAppInfo=(CWriteableSysMdbWebAppInfo *)(pMem->getFirst());
	while (pSysMdbWebAppInfo!=NULL) {
		if (!pSysMdbWebAppInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbWebAppInfo=(CWriteableSysMdbWebAppInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbWebAppInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbWebAppInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbWebAppInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbWebAppInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbWebAppInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbWebAppInfo=(CWriteableSysMdbWebAppInfo *)(pMem->getFirst());
	while (pSysMdbWebAppInfo!=NULL) {
		pSysMdbWebAppInfo->dump(fp,index++);
		pSysMdbWebAppInfo=(CWriteableSysMdbWebAppInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbWebAppInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysMdbWebAppInfo *CSysMdbWebAppInfoFactory::internalAdd(CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbWebAppInfo++;
#endif
	CSysMdbWebAppInfo *pTarget;	
	beforeAdd(pSysMdbWebAppInfo);
	pTarget=(CSysMdbWebAppInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbWebAppInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbWebAppInfo, sizeof(CSysMdbWebAppInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbWebAppInfo *CSysMdbWebAppInfoFactory::add(CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo, CTransaction *pTransaction)
{
	pSysMdbWebAppInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbWebAppInfo,true);
	}
	else {
		CSysMdbWebAppInfo *pNewSysMdbWebAppInfo;
		pNewSysMdbWebAppInfo = internalAdd(pSysMdbWebAppInfo,false);
		pTransaction->addResource(CSysMdbWebAppInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbWebAppInfo,NULL));
		return pNewSysMdbWebAppInfo;
	}
}

void CSysMdbWebAppInfoFactory::internalUpdate(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pNewSysMdbWebAppInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbWebAppInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbWebAppInfo++;
	}
#endif
	CWriteableSysMdbWebAppInfo theOldSysMdbWebAppInfo;
	beforeUpdate(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbWebAppInfo,pSysMdbWebAppInfo,sizeof(CSysMdbWebAppInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo,sizeof(CSysMdbWebAppInfo));
	pMem->updateObject(pSysMdbWebAppInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbWebAppInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbWebAppInfo,&theOldSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::update(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pNewSysMdbWebAppInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbWebAppInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbWebAppInfoResource::alloc(UPDATE_ACTION,this,pSysMdbWebAppInfo,pNewSysMdbWebAppInfo,updateIndex));
		internalUpdate(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo,updateIndex,false);
	}
}

void CSysMdbWebAppInfoFactory::internalRemove(CSysMdbWebAppInfo *pSysMdbWebAppInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbWebAppInfo++;
#endif
	CWriteableSysMdbWebAppInfo theOldSysMdbWebAppInfo;
	beforeRemove(pSysMdbWebAppInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbWebAppInfo,pSysMdbWebAppInfo,sizeof(CSysMdbWebAppInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbWebAppInfo);
	}
	pMem->free(pSysMdbWebAppInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::remove(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbWebAppInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbWebAppInfoResource::alloc(DELETE_ACTION,this,pSysMdbWebAppInfo,NULL));
		internalRemove(pSysMdbWebAppInfo,false);		
	}
}

CSysMdbWebAppInfo* CSysMdbWebAppInfoFactory::addOrUpdate(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pNewSysMdbWebAppInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbWebAppInfo == NULL) {
		return add(pNewSysMdbWebAppInfo,pTransaction);
	}
	else {
		update(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo,pTransaction,updateIndex);
		return pSysMdbWebAppInfo;
	}
}

void CSysMdbWebAppInfoFactory::retrieve(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pTargetSysMdbWebAppInfo)
{
	forceCopy(pTargetSysMdbWebAppInfo, pSysMdbWebAppInfo, sizeof(CSysMdbWebAppInfo));
}
	
int CSysMdbWebAppInfoFactory::addActionTrigger(CSysMdbWebAppInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbWebAppInfoFactory::removeActionTrigger(CSysMdbWebAppInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbWebAppInfoFactory::addCommitTrigger(CSysMdbWebAppInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbWebAppInfoFactory::removeCommitTrigger(CSysMdbWebAppInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbWebAppInfo *CSysMdbWebAppInfoFactory::getFirst(void)
{
	CSysMdbWebAppInfo *pResult=(CSysMdbWebAppInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbWebAppInfo *CSysMdbWebAppInfoFactory::getNext(void)
{
	CSysMdbWebAppInfo *pResult=(CSysMdbWebAppInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbWebAppInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbWebAppInfoFactory::beforeAdd(CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbWebAppInfo);
	}
}
	
void CSysMdbWebAppInfoFactory::afterAdd(CSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::beforeUpdate(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pNewSysMdbWebAppInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbWebAppInfo,pNewSysMdbWebAppInfo);
	}
}
	
void CSysMdbWebAppInfoFactory::afterUpdate(CSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbWebAppInfo);
	}
}
	
void CSysMdbWebAppInfoFactory::beforeRemove(CSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::commitAdd(CSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbWebAppInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::commitUpdate(CSysMdbWebAppInfo *pSysMdbWebAppInfo, CWriteableSysMdbWebAppInfo *pOldSysMdbWebAppInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbWebAppInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbWebAppInfo,pOldSysMdbWebAppInfo);
	}
}
	
void CSysMdbWebAppInfoFactory::commitRemove(CWriteableSysMdbWebAppInfo *pSysMdbWebAppInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbWebAppInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbWebAppInfo);
	}
}

void CSysMdbWebAppInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbMemPoolInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbMemPoolInfo=0;
int updateWithIndexActionForSysMdbMemPoolInfo=0;
int updateWithoutIndexActionForSysMdbMemPoolInfo=0;
int removeActionForSysMdbMemPoolInfo=0;
int addCommitForSysMdbMemPoolInfo=0;
int updateCommitForSysMdbMemPoolInfo=0;
int removeCommitForSysMdbMemPoolInfo=0;
#endif
void CSysMdbMemPoolInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbMemPoolInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbMemPoolInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbMemPoolInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbMemPoolInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByIDType=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbMemPoolInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbMemPoolInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbMemPoolInfoFactory::CSysMdbMemPoolInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbMemPoolInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbMemPoolInfoFactory::CSysMdbMemPoolInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbMemPoolInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbMemPoolInfoFactory::~CSysMdbMemPoolInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbMemPoolInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbMemPoolInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysMdbMemPoolInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbMemPoolInfo thisSysMdbMemPoolInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbMemPoolInfo.readCSV(input,pNames))
		add(&thisSysMdbMemPoolInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbMemPoolInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbMemPoolInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbMemPoolInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbMemPoolInfo::writeCSVHead(output);
	pSysMdbMemPoolInfo=(CWriteableSysMdbMemPoolInfo *)(pMem->getFirst());
	while (pSysMdbMemPoolInfo!=NULL) {
		if (!pSysMdbMemPoolInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbMemPoolInfo=(CWriteableSysMdbMemPoolInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbMemPoolInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbMemPoolInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbMemPoolInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbMemPoolInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbMemPoolInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbMemPoolInfo=(CWriteableSysMdbMemPoolInfo *)(pMem->getFirst());
	while (pSysMdbMemPoolInfo!=NULL) {
		pSysMdbMemPoolInfo->dump(fp,index++);
		pSysMdbMemPoolInfo=(CWriteableSysMdbMemPoolInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbMemPoolInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysMdbMemPoolInfo *CSysMdbMemPoolInfoFactory::internalAdd(CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbMemPoolInfo++;
#endif
	CSysMdbMemPoolInfo *pTarget;	
	beforeAdd(pSysMdbMemPoolInfo);
	pTarget=(CSysMdbMemPoolInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbMemPoolInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbMemPoolInfo, sizeof(CSysMdbMemPoolInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbMemPoolInfo *CSysMdbMemPoolInfoFactory::add(CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CTransaction *pTransaction)
{
	pSysMdbMemPoolInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbMemPoolInfo,true);
	}
	else {
		CSysMdbMemPoolInfo *pNewSysMdbMemPoolInfo;
		pNewSysMdbMemPoolInfo = internalAdd(pSysMdbMemPoolInfo,false);
		pTransaction->addResource(CSysMdbMemPoolInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbMemPoolInfo,NULL));
		return pNewSysMdbMemPoolInfo;
	}
}

void CSysMdbMemPoolInfoFactory::internalUpdate(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pNewSysMdbMemPoolInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbMemPoolInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbMemPoolInfo++;
	}
#endif
	CWriteableSysMdbMemPoolInfo theOldSysMdbMemPoolInfo;
	beforeUpdate(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbMemPoolInfo,pSysMdbMemPoolInfo,sizeof(CSysMdbMemPoolInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo,sizeof(CSysMdbMemPoolInfo));
	pMem->updateObject(pSysMdbMemPoolInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbMemPoolInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbMemPoolInfo,&theOldSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::update(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pNewSysMdbMemPoolInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbMemPoolInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbMemPoolInfoResource::alloc(UPDATE_ACTION,this,pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo,updateIndex));
		internalUpdate(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo,updateIndex,false);
	}
}

void CSysMdbMemPoolInfoFactory::internalRemove(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbMemPoolInfo++;
#endif
	CWriteableSysMdbMemPoolInfo theOldSysMdbMemPoolInfo;
	beforeRemove(pSysMdbMemPoolInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbMemPoolInfo,pSysMdbMemPoolInfo,sizeof(CSysMdbMemPoolInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbMemPoolInfo);
	}
	pMem->free(pSysMdbMemPoolInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::remove(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbMemPoolInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbMemPoolInfoResource::alloc(DELETE_ACTION,this,pSysMdbMemPoolInfo,NULL));
		internalRemove(pSysMdbMemPoolInfo,false);		
	}
}

CSysMdbMemPoolInfo* CSysMdbMemPoolInfoFactory::addOrUpdate(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pNewSysMdbMemPoolInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbMemPoolInfo == NULL) {
		return add(pNewSysMdbMemPoolInfo,pTransaction);
	}
	else {
		update(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo,pTransaction,updateIndex);
		return pSysMdbMemPoolInfo;
	}
}

void CSysMdbMemPoolInfoFactory::retrieve(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pTargetSysMdbMemPoolInfo)
{
	forceCopy(pTargetSysMdbMemPoolInfo, pSysMdbMemPoolInfo, sizeof(CSysMdbMemPoolInfo));
}
	
int CSysMdbMemPoolInfoFactory::addActionTrigger(CSysMdbMemPoolInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbMemPoolInfoFactory::removeActionTrigger(CSysMdbMemPoolInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbMemPoolInfoFactory::addCommitTrigger(CSysMdbMemPoolInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbMemPoolInfoFactory::removeCommitTrigger(CSysMdbMemPoolInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbMemPoolInfo *CSysMdbMemPoolInfoFactory::getFirst(void)
{
	CSysMdbMemPoolInfo *pResult=(CSysMdbMemPoolInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbMemPoolInfo *CSysMdbMemPoolInfoFactory::getNext(void)
{
	CSysMdbMemPoolInfo *pResult=(CSysMdbMemPoolInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbMemPoolInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbMemPoolInfoFactory::beforeAdd(CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbMemPoolInfo);
	}
}
	
void CSysMdbMemPoolInfoFactory::afterAdd(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::beforeUpdate(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pNewSysMdbMemPoolInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbMemPoolInfo,pNewSysMdbMemPoolInfo);
	}
}
	
void CSysMdbMemPoolInfoFactory::afterUpdate(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbMemPoolInfo);
	}
}
	
void CSysMdbMemPoolInfoFactory::beforeRemove(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::commitAdd(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbMemPoolInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::commitUpdate(CSysMdbMemPoolInfo *pSysMdbMemPoolInfo, CWriteableSysMdbMemPoolInfo *pOldSysMdbMemPoolInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbMemPoolInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbMemPoolInfo,pOldSysMdbMemPoolInfo);
	}
}
	
void CSysMdbMemPoolInfoFactory::commitRemove(CWriteableSysMdbMemPoolInfo *pSysMdbMemPoolInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbMemPoolInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbMemPoolInfo);
	}
}

void CSysMdbMemPoolInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbConnectorInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbConnectorInfo=0;
int updateWithIndexActionForSysMdbConnectorInfo=0;
int updateWithoutIndexActionForSysMdbConnectorInfo=0;
int removeActionForSysMdbConnectorInfo=0;
int addCommitForSysMdbConnectorInfo=0;
int updateCommitForSysMdbConnectorInfo=0;
int removeCommitForSysMdbConnectorInfo=0;
#endif
void CSysMdbConnectorInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbConnectorInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbConnectorInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbConnectorInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbConnectorInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByIDType=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbConnectorInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbConnectorInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbConnectorInfoFactory::CSysMdbConnectorInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbConnectorInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbConnectorInfoFactory::CSysMdbConnectorInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbConnectorInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbConnectorInfoFactory::~CSysMdbConnectorInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbConnectorInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbConnectorInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysMdbConnectorInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbConnectorInfo thisSysMdbConnectorInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbConnectorInfo.readCSV(input,pNames))
		add(&thisSysMdbConnectorInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbConnectorInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbConnectorInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbConnectorInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbConnectorInfo::writeCSVHead(output);
	pSysMdbConnectorInfo=(CWriteableSysMdbConnectorInfo *)(pMem->getFirst());
	while (pSysMdbConnectorInfo!=NULL) {
		if (!pSysMdbConnectorInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbConnectorInfo=(CWriteableSysMdbConnectorInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbConnectorInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbConnectorInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbConnectorInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbConnectorInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbConnectorInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbConnectorInfo=(CWriteableSysMdbConnectorInfo *)(pMem->getFirst());
	while (pSysMdbConnectorInfo!=NULL) {
		pSysMdbConnectorInfo->dump(fp,index++);
		pSysMdbConnectorInfo=(CWriteableSysMdbConnectorInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbConnectorInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysMdbConnectorInfo *CSysMdbConnectorInfoFactory::internalAdd(CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbConnectorInfo++;
#endif
	CSysMdbConnectorInfo *pTarget;	
	beforeAdd(pSysMdbConnectorInfo);
	pTarget=(CSysMdbConnectorInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbConnectorInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbConnectorInfo, sizeof(CSysMdbConnectorInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbConnectorInfo *CSysMdbConnectorInfoFactory::add(CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo, CTransaction *pTransaction)
{
	pSysMdbConnectorInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbConnectorInfo,true);
	}
	else {
		CSysMdbConnectorInfo *pNewSysMdbConnectorInfo;
		pNewSysMdbConnectorInfo = internalAdd(pSysMdbConnectorInfo,false);
		pTransaction->addResource(CSysMdbConnectorInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbConnectorInfo,NULL));
		return pNewSysMdbConnectorInfo;
	}
}

void CSysMdbConnectorInfoFactory::internalUpdate(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pNewSysMdbConnectorInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbConnectorInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbConnectorInfo++;
	}
#endif
	CWriteableSysMdbConnectorInfo theOldSysMdbConnectorInfo;
	beforeUpdate(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbConnectorInfo,pSysMdbConnectorInfo,sizeof(CSysMdbConnectorInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo,sizeof(CSysMdbConnectorInfo));
	pMem->updateObject(pSysMdbConnectorInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbConnectorInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbConnectorInfo,&theOldSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::update(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pNewSysMdbConnectorInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbConnectorInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbConnectorInfoResource::alloc(UPDATE_ACTION,this,pSysMdbConnectorInfo,pNewSysMdbConnectorInfo,updateIndex));
		internalUpdate(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo,updateIndex,false);
	}
}

void CSysMdbConnectorInfoFactory::internalRemove(CSysMdbConnectorInfo *pSysMdbConnectorInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbConnectorInfo++;
#endif
	CWriteableSysMdbConnectorInfo theOldSysMdbConnectorInfo;
	beforeRemove(pSysMdbConnectorInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbConnectorInfo,pSysMdbConnectorInfo,sizeof(CSysMdbConnectorInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbConnectorInfo);
	}
	pMem->free(pSysMdbConnectorInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::remove(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbConnectorInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbConnectorInfoResource::alloc(DELETE_ACTION,this,pSysMdbConnectorInfo,NULL));
		internalRemove(pSysMdbConnectorInfo,false);		
	}
}

CSysMdbConnectorInfo* CSysMdbConnectorInfoFactory::addOrUpdate(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pNewSysMdbConnectorInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbConnectorInfo == NULL) {
		return add(pNewSysMdbConnectorInfo,pTransaction);
	}
	else {
		update(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo,pTransaction,updateIndex);
		return pSysMdbConnectorInfo;
	}
}

void CSysMdbConnectorInfoFactory::retrieve(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pTargetSysMdbConnectorInfo)
{
	forceCopy(pTargetSysMdbConnectorInfo, pSysMdbConnectorInfo, sizeof(CSysMdbConnectorInfo));
}
	
int CSysMdbConnectorInfoFactory::addActionTrigger(CSysMdbConnectorInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbConnectorInfoFactory::removeActionTrigger(CSysMdbConnectorInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbConnectorInfoFactory::addCommitTrigger(CSysMdbConnectorInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbConnectorInfoFactory::removeCommitTrigger(CSysMdbConnectorInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbConnectorInfo *CSysMdbConnectorInfoFactory::getFirst(void)
{
	CSysMdbConnectorInfo *pResult=(CSysMdbConnectorInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbConnectorInfo *CSysMdbConnectorInfoFactory::getNext(void)
{
	CSysMdbConnectorInfo *pResult=(CSysMdbConnectorInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbConnectorInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbConnectorInfoFactory::beforeAdd(CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbConnectorInfo);
	}
}
	
void CSysMdbConnectorInfoFactory::afterAdd(CSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::beforeUpdate(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pNewSysMdbConnectorInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbConnectorInfo,pNewSysMdbConnectorInfo);
	}
}
	
void CSysMdbConnectorInfoFactory::afterUpdate(CSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbConnectorInfo);
	}
}
	
void CSysMdbConnectorInfoFactory::beforeRemove(CSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::commitAdd(CSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbConnectorInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::commitUpdate(CSysMdbConnectorInfo *pSysMdbConnectorInfo, CWriteableSysMdbConnectorInfo *pOldSysMdbConnectorInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbConnectorInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbConnectorInfo,pOldSysMdbConnectorInfo);
	}
}
	
void CSysMdbConnectorInfoFactory::commitRemove(CWriteableSysMdbConnectorInfo *pSysMdbConnectorInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbConnectorInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbConnectorInfo);
	}
}

void CSysMdbConnectorInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysMdbDBQuery(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbDBQuery=0;
int updateWithIndexActionForSysMdbDBQuery=0;
int updateWithoutIndexActionForSysMdbDBQuery=0;
int removeActionForSysMdbDBQuery=0;
int addCommitForSysMdbDBQuery=0;
int updateCommitForSysMdbDBQuery=0;
int removeCommitForSysMdbDBQuery=0;
#endif
void CSysMdbDBQueryFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbDBQuery,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbDBQuery_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbDBQuery_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysMdbDBQuery,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByIDType=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbDBQueryActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbDBQueryCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbDBQueryFactory::CSysMdbDBQueryFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbDBQuery),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbDBQueryFactory::CSysMdbDBQueryFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbDBQuery),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbDBQueryFactory::~CSysMdbDBQueryFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbDBQueryFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbDBQueryFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysMdbDBQueryFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbDBQuery thisSysMdbDBQuery;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbDBQuery.readCSV(input,pNames))
		add(&thisSysMdbDBQuery);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbDBQueryFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbDBQuery.csv");
	return readCSV(szFileName);
}

int CSysMdbDBQueryFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbDBQuery *pSysMdbDBQuery;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbDBQuery::writeCSVHead(output);
	pSysMdbDBQuery=(CWriteableSysMdbDBQuery *)(pMem->getFirst());
	while (pSysMdbDBQuery!=NULL) {
		if (!pSysMdbDBQuery->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbDBQuery=(CWriteableSysMdbDBQuery *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbDBQueryFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbDBQuery.csv");
	return writeCSV(szFileName);
}

void CSysMdbDBQueryFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbDBQueryFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbDBQuery *pSysMdbDBQuery;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbDBQueryFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbDBQuery=(CWriteableSysMdbDBQuery *)(pMem->getFirst());
	while (pSysMdbDBQuery!=NULL) {
		pSysMdbDBQuery->dump(fp,index++);
		pSysMdbDBQuery=(CWriteableSysMdbDBQuery *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbDBQueryFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysMdbDBQuery *CSysMdbDBQueryFactory::internalAdd(CWriteableSysMdbDBQuery *pSysMdbDBQuery, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbDBQuery++;
#endif
	CSysMdbDBQuery *pTarget;	
	beforeAdd(pSysMdbDBQuery);
	pTarget=(CSysMdbDBQuery *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbDBQuery in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbDBQuery, sizeof(CSysMdbDBQuery));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbDBQuery *CSysMdbDBQueryFactory::add(CWriteableSysMdbDBQuery *pSysMdbDBQuery, CTransaction *pTransaction)
{
	pSysMdbDBQuery->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbDBQuery,true);
	}
	else {
		CSysMdbDBQuery *pNewSysMdbDBQuery;
		pNewSysMdbDBQuery = internalAdd(pSysMdbDBQuery,false);
		pTransaction->addResource(CSysMdbDBQueryResource::alloc(CREATE_ACTION,this,pNewSysMdbDBQuery,NULL));
		return pNewSysMdbDBQuery;
	}
}

void CSysMdbDBQueryFactory::internalUpdate(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pNewSysMdbDBQuery, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbDBQuery++;
	}
	else {
		updateWithoutIndexActionForSysMdbDBQuery++;
	}
#endif
	CWriteableSysMdbDBQuery theOldSysMdbDBQuery;
	beforeUpdate(pSysMdbDBQuery,pNewSysMdbDBQuery);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbDBQuery,pSysMdbDBQuery,sizeof(CSysMdbDBQuery));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbDBQuery,pNewSysMdbDBQuery,sizeof(CSysMdbDBQuery));
	pMem->updateObject(pSysMdbDBQuery);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbDBQuery);
	if (bNoTransaction) {
		commitUpdate(pSysMdbDBQuery,&theOldSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::update(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pNewSysMdbDBQuery, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbDBQuery->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbDBQuery,pNewSysMdbDBQuery,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbDBQueryResource::alloc(UPDATE_ACTION,this,pSysMdbDBQuery,pNewSysMdbDBQuery,updateIndex));
		internalUpdate(pSysMdbDBQuery,pNewSysMdbDBQuery,updateIndex,false);
	}
}

void CSysMdbDBQueryFactory::internalRemove(CSysMdbDBQuery *pSysMdbDBQuery, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbDBQuery++;
#endif
	CWriteableSysMdbDBQuery theOldSysMdbDBQuery;
	beforeRemove(pSysMdbDBQuery);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbDBQuery,pSysMdbDBQuery,sizeof(CSysMdbDBQuery));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysMdbDBQuery);
	}
	pMem->free(pSysMdbDBQuery);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::remove(CSysMdbDBQuery *pSysMdbDBQuery, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbDBQuery,true);
	}
	else {
		pTransaction->addResource(CSysMdbDBQueryResource::alloc(DELETE_ACTION,this,pSysMdbDBQuery,NULL));
		internalRemove(pSysMdbDBQuery,false);		
	}
}

CSysMdbDBQuery* CSysMdbDBQueryFactory::addOrUpdate(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pNewSysMdbDBQuery, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbDBQuery == NULL) {
		return add(pNewSysMdbDBQuery,pTransaction);
	}
	else {
		update(pSysMdbDBQuery,pNewSysMdbDBQuery,pTransaction,updateIndex);
		return pSysMdbDBQuery;
	}
}

void CSysMdbDBQueryFactory::retrieve(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pTargetSysMdbDBQuery)
{
	forceCopy(pTargetSysMdbDBQuery, pSysMdbDBQuery, sizeof(CSysMdbDBQuery));
}
	
int CSysMdbDBQueryFactory::addActionTrigger(CSysMdbDBQueryActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbDBQueryFactory::removeActionTrigger(CSysMdbDBQueryActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbDBQueryFactory::addCommitTrigger(CSysMdbDBQueryCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbDBQueryFactory::removeCommitTrigger(CSysMdbDBQueryCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbDBQuery *CSysMdbDBQueryFactory::getFirst(void)
{
	CSysMdbDBQuery *pResult=(CSysMdbDBQuery *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbDBQuery *CSysMdbDBQueryFactory::getNext(void)
{
	CSysMdbDBQuery *pResult=(CSysMdbDBQuery *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbDBQueryFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbDBQueryFactory::beforeAdd(CWriteableSysMdbDBQuery *pSysMdbDBQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbDBQuery);
	}
}
	
void CSysMdbDBQueryFactory::afterAdd(CSysMdbDBQuery *pSysMdbDBQuery)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::beforeUpdate(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pNewSysMdbDBQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbDBQuery,pNewSysMdbDBQuery);
	}
}
	
void CSysMdbDBQueryFactory::afterUpdate(CSysMdbDBQuery *pSysMdbDBQuery)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbDBQuery);
	}
}
	
void CSysMdbDBQueryFactory::beforeRemove(CSysMdbDBQuery *pSysMdbDBQuery)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::commitAdd(CSysMdbDBQuery *pSysMdbDBQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbDBQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::commitUpdate(CSysMdbDBQuery *pSysMdbDBQuery, CWriteableSysMdbDBQuery *pOldSysMdbDBQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbDBQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbDBQuery,pOldSysMdbDBQuery);
	}
}
	
void CSysMdbDBQueryFactory::commitRemove(CWriteableSysMdbDBQuery *pSysMdbDBQuery)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbDBQuery++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbDBQuery);
	}
}

void CSysMdbDBQueryFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetArea(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetArea=0;
int updateWithIndexActionForSysNetArea=0;
int updateWithoutIndexActionForSysNetArea=0;
int removeActionForSysNetArea=0;
int addCommitForSysNetArea=0;
int updateCommitForSysNetArea=0;
int removeCommitForSysNetArea=0;
#endif
void CSysNetAreaFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetArea,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetArea_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetArea_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetArea,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetAreaActionTrigger *>;
	pCommitTriggers=new vector<CSysNetAreaCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetAreaFactory::CSysNetAreaFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetArea),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetAreaFactory::CSysNetAreaFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetArea),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetAreaFactory::~CSysNetAreaFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetAreaFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetAreaFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetAreaFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetArea thisSysNetArea;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetArea.readCSV(input,pNames))
		add(&thisSysNetArea);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetAreaFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetArea.csv");
	return readCSV(szFileName);
}

int CSysNetAreaFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetArea *pSysNetArea;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetArea::writeCSVHead(output);
	pSysNetArea=(CWriteableSysNetArea *)(pMem->getFirst());
	while (pSysNetArea!=NULL) {
		if (!pSysNetArea->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetArea=(CWriteableSysNetArea *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetAreaFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetArea.csv");
	return writeCSV(szFileName);
}

void CSysNetAreaFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetAreaFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetArea *pSysNetArea;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetAreaFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetArea=(CWriteableSysNetArea *)(pMem->getFirst());
	while (pSysNetArea!=NULL) {
		pSysNetArea->dump(fp,index++);
		pSysNetArea=(CWriteableSysNetArea *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetAreaFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetArea *CSysNetAreaFactory::internalAdd(CWriteableSysNetArea *pSysNetArea, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetArea++;
#endif
	CSysNetArea *pTarget;	
	beforeAdd(pSysNetArea);
	pTarget=(CSysNetArea *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetArea in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetArea, sizeof(CSysNetArea));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetArea *CSysNetAreaFactory::add(CWriteableSysNetArea *pSysNetArea, CTransaction *pTransaction)
{
	pSysNetArea->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetArea,true);
	}
	else {
		CSysNetArea *pNewSysNetArea;
		pNewSysNetArea = internalAdd(pSysNetArea,false);
		pTransaction->addResource(CSysNetAreaResource::alloc(CREATE_ACTION,this,pNewSysNetArea,NULL));
		return pNewSysNetArea;
	}
}

void CSysNetAreaFactory::internalUpdate(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pNewSysNetArea, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetArea++;
	}
	else {
		updateWithoutIndexActionForSysNetArea++;
	}
#endif
	CWriteableSysNetArea theOldSysNetArea;
	beforeUpdate(pSysNetArea,pNewSysNetArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetArea,pSysNetArea,sizeof(CSysNetArea));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetArea,pNewSysNetArea,sizeof(CSysNetArea));
	pMem->updateObject(pSysNetArea);
	if (updateIndex) {
	}
	afterUpdate(pSysNetArea);
	if (bNoTransaction) {
		commitUpdate(pSysNetArea,&theOldSysNetArea);
	}
}

void CSysNetAreaFactory::update(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pNewSysNetArea, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetArea->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetArea,pNewSysNetArea,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetAreaResource::alloc(UPDATE_ACTION,this,pSysNetArea,pNewSysNetArea,updateIndex));
		internalUpdate(pSysNetArea,pNewSysNetArea,updateIndex,false);
	}
}

void CSysNetAreaFactory::internalRemove(CSysNetArea *pSysNetArea, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetArea++;
#endif
	CWriteableSysNetArea theOldSysNetArea;
	beforeRemove(pSysNetArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetArea,pSysNetArea,sizeof(CSysNetArea));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetArea);
	}
	pMem->free(pSysNetArea);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetArea);
	}
}

void CSysNetAreaFactory::remove(CSysNetArea *pSysNetArea, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetArea,true);
	}
	else {
		pTransaction->addResource(CSysNetAreaResource::alloc(DELETE_ACTION,this,pSysNetArea,NULL));
		internalRemove(pSysNetArea,false);		
	}
}

CSysNetArea* CSysNetAreaFactory::addOrUpdate(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pNewSysNetArea, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetArea == NULL) {
		return add(pNewSysNetArea,pTransaction);
	}
	else {
		update(pSysNetArea,pNewSysNetArea,pTransaction,updateIndex);
		return pSysNetArea;
	}
}

void CSysNetAreaFactory::retrieve(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pTargetSysNetArea)
{
	forceCopy(pTargetSysNetArea, pSysNetArea, sizeof(CSysNetArea));
}
	
int CSysNetAreaFactory::addActionTrigger(CSysNetAreaActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetAreaFactory::removeActionTrigger(CSysNetAreaActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetAreaFactory::addCommitTrigger(CSysNetAreaCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetAreaFactory::removeCommitTrigger(CSysNetAreaCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetArea *CSysNetAreaFactory::getFirst(void)
{
	CSysNetArea *pResult=(CSysNetArea *)(pMem->getFirst());
	return pResult;
}
	
CSysNetArea *CSysNetAreaFactory::getNext(void)
{
	CSysNetArea *pResult=(CSysNetArea *)(pMem->getNext());
	return pResult;
}
	
void CSysNetAreaFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetAreaFactory::beforeAdd(CWriteableSysNetArea *pSysNetArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetArea);
	}
}
	
void CSysNetAreaFactory::afterAdd(CSysNetArea *pSysNetArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetArea);
	}
}

void CSysNetAreaFactory::beforeUpdate(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pNewSysNetArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetArea,pNewSysNetArea);
	}
}
	
void CSysNetAreaFactory::afterUpdate(CSysNetArea *pSysNetArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetArea);
	}
}
	
void CSysNetAreaFactory::beforeRemove(CSysNetArea *pSysNetArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetArea);
	}
}

void CSysNetAreaFactory::commitAdd(CSysNetArea *pSysNetArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetArea);
	}
}

void CSysNetAreaFactory::commitUpdate(CSysNetArea *pSysNetArea, CWriteableSysNetArea *pOldSysNetArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetArea,pOldSysNetArea);
	}
}
	
void CSysNetAreaFactory::commitRemove(CWriteableSysNetArea *pSysNetArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetArea);
	}
}

void CSysNetAreaFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetSubArea(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetSubArea=0;
int updateWithIndexActionForSysNetSubArea=0;
int updateWithoutIndexActionForSysNetSubArea=0;
int removeActionForSysNetSubArea=0;
int addCommitForSysNetSubArea=0;
int updateCommitForSysNetSubArea=0;
int removeCommitForSysNetSubArea=0;
#endif
void CSysNetSubAreaFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubArea,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetSubArea_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetSubArea_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubArea,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetSubAreaActionTrigger *>;
	pCommitTriggers=new vector<CSysNetSubAreaCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetSubAreaFactory::CSysNetSubAreaFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubArea),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetSubAreaFactory::CSysNetSubAreaFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubArea),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetSubAreaFactory::~CSysNetSubAreaFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetSubAreaFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetSubAreaFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetSubAreaFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetSubArea thisSysNetSubArea;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetSubArea.readCSV(input,pNames))
		add(&thisSysNetSubArea);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetSubAreaFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetSubArea.csv");
	return readCSV(szFileName);
}

int CSysNetSubAreaFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetSubArea *pSysNetSubArea;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetSubArea::writeCSVHead(output);
	pSysNetSubArea=(CWriteableSysNetSubArea *)(pMem->getFirst());
	while (pSysNetSubArea!=NULL) {
		if (!pSysNetSubArea->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetSubArea=(CWriteableSysNetSubArea *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetSubAreaFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetSubArea.csv");
	return writeCSV(szFileName);
}

void CSysNetSubAreaFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetSubAreaFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetSubArea *pSysNetSubArea;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetSubAreaFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetSubArea=(CWriteableSysNetSubArea *)(pMem->getFirst());
	while (pSysNetSubArea!=NULL) {
		pSysNetSubArea->dump(fp,index++);
		pSysNetSubArea=(CWriteableSysNetSubArea *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetSubAreaFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetSubArea *CSysNetSubAreaFactory::internalAdd(CWriteableSysNetSubArea *pSysNetSubArea, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetSubArea++;
#endif
	CSysNetSubArea *pTarget;	
	beforeAdd(pSysNetSubArea);
	pTarget=(CSysNetSubArea *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetSubArea in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetSubArea, sizeof(CSysNetSubArea));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetSubArea *CSysNetSubAreaFactory::add(CWriteableSysNetSubArea *pSysNetSubArea, CTransaction *pTransaction)
{
	pSysNetSubArea->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetSubArea,true);
	}
	else {
		CSysNetSubArea *pNewSysNetSubArea;
		pNewSysNetSubArea = internalAdd(pSysNetSubArea,false);
		pTransaction->addResource(CSysNetSubAreaResource::alloc(CREATE_ACTION,this,pNewSysNetSubArea,NULL));
		return pNewSysNetSubArea;
	}
}

void CSysNetSubAreaFactory::internalUpdate(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pNewSysNetSubArea, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetSubArea++;
	}
	else {
		updateWithoutIndexActionForSysNetSubArea++;
	}
#endif
	CWriteableSysNetSubArea theOldSysNetSubArea;
	beforeUpdate(pSysNetSubArea,pNewSysNetSubArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubArea,pSysNetSubArea,sizeof(CSysNetSubArea));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetSubArea,pNewSysNetSubArea,sizeof(CSysNetSubArea));
	pMem->updateObject(pSysNetSubArea);
	if (updateIndex) {
	}
	afterUpdate(pSysNetSubArea);
	if (bNoTransaction) {
		commitUpdate(pSysNetSubArea,&theOldSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::update(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pNewSysNetSubArea, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetSubArea->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetSubArea,pNewSysNetSubArea,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetSubAreaResource::alloc(UPDATE_ACTION,this,pSysNetSubArea,pNewSysNetSubArea,updateIndex));
		internalUpdate(pSysNetSubArea,pNewSysNetSubArea,updateIndex,false);
	}
}

void CSysNetSubAreaFactory::internalRemove(CSysNetSubArea *pSysNetSubArea, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetSubArea++;
#endif
	CWriteableSysNetSubArea theOldSysNetSubArea;
	beforeRemove(pSysNetSubArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubArea,pSysNetSubArea,sizeof(CSysNetSubArea));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetSubArea);
	}
	pMem->free(pSysNetSubArea);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::remove(CSysNetSubArea *pSysNetSubArea, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetSubArea,true);
	}
	else {
		pTransaction->addResource(CSysNetSubAreaResource::alloc(DELETE_ACTION,this,pSysNetSubArea,NULL));
		internalRemove(pSysNetSubArea,false);		
	}
}

CSysNetSubArea* CSysNetSubAreaFactory::addOrUpdate(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pNewSysNetSubArea, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetSubArea == NULL) {
		return add(pNewSysNetSubArea,pTransaction);
	}
	else {
		update(pSysNetSubArea,pNewSysNetSubArea,pTransaction,updateIndex);
		return pSysNetSubArea;
	}
}

void CSysNetSubAreaFactory::retrieve(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pTargetSysNetSubArea)
{
	forceCopy(pTargetSysNetSubArea, pSysNetSubArea, sizeof(CSysNetSubArea));
}
	
int CSysNetSubAreaFactory::addActionTrigger(CSysNetSubAreaActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetSubAreaFactory::removeActionTrigger(CSysNetSubAreaActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetSubAreaFactory::addCommitTrigger(CSysNetSubAreaCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetSubAreaFactory::removeCommitTrigger(CSysNetSubAreaCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetSubArea *CSysNetSubAreaFactory::getFirst(void)
{
	CSysNetSubArea *pResult=(CSysNetSubArea *)(pMem->getFirst());
	return pResult;
}
	
CSysNetSubArea *CSysNetSubAreaFactory::getNext(void)
{
	CSysNetSubArea *pResult=(CSysNetSubArea *)(pMem->getNext());
	return pResult;
}
	
void CSysNetSubAreaFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetSubAreaFactory::beforeAdd(CWriteableSysNetSubArea *pSysNetSubArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetSubArea);
	}
}
	
void CSysNetSubAreaFactory::afterAdd(CSysNetSubArea *pSysNetSubArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::beforeUpdate(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pNewSysNetSubArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetSubArea,pNewSysNetSubArea);
	}
}
	
void CSysNetSubAreaFactory::afterUpdate(CSysNetSubArea *pSysNetSubArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetSubArea);
	}
}
	
void CSysNetSubAreaFactory::beforeRemove(CSysNetSubArea *pSysNetSubArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::commitAdd(CSysNetSubArea *pSysNetSubArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetSubArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::commitUpdate(CSysNetSubArea *pSysNetSubArea, CWriteableSysNetSubArea *pOldSysNetSubArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetSubArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetSubArea,pOldSysNetSubArea);
	}
}
	
void CSysNetSubAreaFactory::commitRemove(CWriteableSysNetSubArea *pSysNetSubArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetSubArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetSubArea);
	}
}

void CSysNetSubAreaFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetSubAreaIP(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetSubAreaIP=0;
int updateWithIndexActionForSysNetSubAreaIP=0;
int updateWithoutIndexActionForSysNetSubAreaIP=0;
int removeActionForSysNetSubAreaIP=0;
int addCommitForSysNetSubAreaIP=0;
int updateCommitForSysNetSubAreaIP=0;
int removeCommitForSysNetSubAreaIP=0;
#endif
void CSysNetSubAreaIPFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubAreaIP,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetSubAreaIP_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetSubAreaIP_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubAreaIP,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetSubAreaIPActionTrigger *>;
	pCommitTriggers=new vector<CSysNetSubAreaIPCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetSubAreaIPFactory::CSysNetSubAreaIPFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubAreaIP),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetSubAreaIPFactory::CSysNetSubAreaIPFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubAreaIP),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetSubAreaIPFactory::~CSysNetSubAreaIPFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetSubAreaIPFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetSubAreaIPFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetSubAreaIPFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetSubAreaIP thisSysNetSubAreaIP;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetSubAreaIP.readCSV(input,pNames))
		add(&thisSysNetSubAreaIP);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetSubAreaIPFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetSubAreaIP.csv");
	return readCSV(szFileName);
}

int CSysNetSubAreaIPFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetSubAreaIP *pSysNetSubAreaIP;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetSubAreaIP::writeCSVHead(output);
	pSysNetSubAreaIP=(CWriteableSysNetSubAreaIP *)(pMem->getFirst());
	while (pSysNetSubAreaIP!=NULL) {
		if (!pSysNetSubAreaIP->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetSubAreaIP=(CWriteableSysNetSubAreaIP *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetSubAreaIPFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetSubAreaIP.csv");
	return writeCSV(szFileName);
}

void CSysNetSubAreaIPFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetSubAreaIPFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetSubAreaIP *pSysNetSubAreaIP;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetSubAreaIPFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetSubAreaIP=(CWriteableSysNetSubAreaIP *)(pMem->getFirst());
	while (pSysNetSubAreaIP!=NULL) {
		pSysNetSubAreaIP->dump(fp,index++);
		pSysNetSubAreaIP=(CWriteableSysNetSubAreaIP *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetSubAreaIPFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetSubAreaIP *CSysNetSubAreaIPFactory::internalAdd(CWriteableSysNetSubAreaIP *pSysNetSubAreaIP, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetSubAreaIP++;
#endif
	CSysNetSubAreaIP *pTarget;	
	beforeAdd(pSysNetSubAreaIP);
	pTarget=(CSysNetSubAreaIP *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetSubAreaIP in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetSubAreaIP, sizeof(CSysNetSubAreaIP));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetSubAreaIP *CSysNetSubAreaIPFactory::add(CWriteableSysNetSubAreaIP *pSysNetSubAreaIP, CTransaction *pTransaction)
{
	pSysNetSubAreaIP->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetSubAreaIP,true);
	}
	else {
		CSysNetSubAreaIP *pNewSysNetSubAreaIP;
		pNewSysNetSubAreaIP = internalAdd(pSysNetSubAreaIP,false);
		pTransaction->addResource(CSysNetSubAreaIPResource::alloc(CREATE_ACTION,this,pNewSysNetSubAreaIP,NULL));
		return pNewSysNetSubAreaIP;
	}
}

void CSysNetSubAreaIPFactory::internalUpdate(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pNewSysNetSubAreaIP, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetSubAreaIP++;
	}
	else {
		updateWithoutIndexActionForSysNetSubAreaIP++;
	}
#endif
	CWriteableSysNetSubAreaIP theOldSysNetSubAreaIP;
	beforeUpdate(pSysNetSubAreaIP,pNewSysNetSubAreaIP);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubAreaIP,pSysNetSubAreaIP,sizeof(CSysNetSubAreaIP));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetSubAreaIP,pNewSysNetSubAreaIP,sizeof(CSysNetSubAreaIP));
	pMem->updateObject(pSysNetSubAreaIP);
	if (updateIndex) {
	}
	afterUpdate(pSysNetSubAreaIP);
	if (bNoTransaction) {
		commitUpdate(pSysNetSubAreaIP,&theOldSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::update(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pNewSysNetSubAreaIP, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetSubAreaIP->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetSubAreaIP,pNewSysNetSubAreaIP,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetSubAreaIPResource::alloc(UPDATE_ACTION,this,pSysNetSubAreaIP,pNewSysNetSubAreaIP,updateIndex));
		internalUpdate(pSysNetSubAreaIP,pNewSysNetSubAreaIP,updateIndex,false);
	}
}

void CSysNetSubAreaIPFactory::internalRemove(CSysNetSubAreaIP *pSysNetSubAreaIP, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetSubAreaIP++;
#endif
	CWriteableSysNetSubAreaIP theOldSysNetSubAreaIP;
	beforeRemove(pSysNetSubAreaIP);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubAreaIP,pSysNetSubAreaIP,sizeof(CSysNetSubAreaIP));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetSubAreaIP);
	}
	pMem->free(pSysNetSubAreaIP);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::remove(CSysNetSubAreaIP *pSysNetSubAreaIP, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetSubAreaIP,true);
	}
	else {
		pTransaction->addResource(CSysNetSubAreaIPResource::alloc(DELETE_ACTION,this,pSysNetSubAreaIP,NULL));
		internalRemove(pSysNetSubAreaIP,false);		
	}
}

CSysNetSubAreaIP* CSysNetSubAreaIPFactory::addOrUpdate(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pNewSysNetSubAreaIP, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetSubAreaIP == NULL) {
		return add(pNewSysNetSubAreaIP,pTransaction);
	}
	else {
		update(pSysNetSubAreaIP,pNewSysNetSubAreaIP,pTransaction,updateIndex);
		return pSysNetSubAreaIP;
	}
}

void CSysNetSubAreaIPFactory::retrieve(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pTargetSysNetSubAreaIP)
{
	forceCopy(pTargetSysNetSubAreaIP, pSysNetSubAreaIP, sizeof(CSysNetSubAreaIP));
}
	
int CSysNetSubAreaIPFactory::addActionTrigger(CSysNetSubAreaIPActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetSubAreaIPFactory::removeActionTrigger(CSysNetSubAreaIPActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetSubAreaIPFactory::addCommitTrigger(CSysNetSubAreaIPCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetSubAreaIPFactory::removeCommitTrigger(CSysNetSubAreaIPCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetSubAreaIP *CSysNetSubAreaIPFactory::getFirst(void)
{
	CSysNetSubAreaIP *pResult=(CSysNetSubAreaIP *)(pMem->getFirst());
	return pResult;
}
	
CSysNetSubAreaIP *CSysNetSubAreaIPFactory::getNext(void)
{
	CSysNetSubAreaIP *pResult=(CSysNetSubAreaIP *)(pMem->getNext());
	return pResult;
}
	
void CSysNetSubAreaIPFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetSubAreaIPFactory::beforeAdd(CWriteableSysNetSubAreaIP *pSysNetSubAreaIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetSubAreaIP);
	}
}
	
void CSysNetSubAreaIPFactory::afterAdd(CSysNetSubAreaIP *pSysNetSubAreaIP)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::beforeUpdate(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pNewSysNetSubAreaIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetSubAreaIP,pNewSysNetSubAreaIP);
	}
}
	
void CSysNetSubAreaIPFactory::afterUpdate(CSysNetSubAreaIP *pSysNetSubAreaIP)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetSubAreaIP);
	}
}
	
void CSysNetSubAreaIPFactory::beforeRemove(CSysNetSubAreaIP *pSysNetSubAreaIP)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::commitAdd(CSysNetSubAreaIP *pSysNetSubAreaIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetSubAreaIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::commitUpdate(CSysNetSubAreaIP *pSysNetSubAreaIP, CWriteableSysNetSubAreaIP *pOldSysNetSubAreaIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetSubAreaIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetSubAreaIP,pOldSysNetSubAreaIP);
	}
}
	
void CSysNetSubAreaIPFactory::commitRemove(CWriteableSysNetSubAreaIP *pSysNetSubAreaIP)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetSubAreaIP++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetSubAreaIP);
	}
}

void CSysNetSubAreaIPFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetFuncArea(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetFuncArea=0;
int updateWithIndexActionForSysNetFuncArea=0;
int updateWithoutIndexActionForSysNetFuncArea=0;
int removeActionForSysNetFuncArea=0;
int addCommitForSysNetFuncArea=0;
int updateCommitForSysNetFuncArea=0;
int removeCommitForSysNetFuncArea=0;
#endif
void CSysNetFuncAreaFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetFuncArea,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetFuncArea_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetFuncArea_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetFuncArea,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetFuncAreaActionTrigger *>;
	pCommitTriggers=new vector<CSysNetFuncAreaCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetFuncAreaFactory::CSysNetFuncAreaFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetFuncArea),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetFuncAreaFactory::CSysNetFuncAreaFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetFuncArea),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetFuncAreaFactory::~CSysNetFuncAreaFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetFuncAreaFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetFuncAreaFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetFuncAreaFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetFuncArea thisSysNetFuncArea;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetFuncArea.readCSV(input,pNames))
		add(&thisSysNetFuncArea);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetFuncAreaFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetFuncArea.csv");
	return readCSV(szFileName);
}

int CSysNetFuncAreaFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetFuncArea *pSysNetFuncArea;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetFuncArea::writeCSVHead(output);
	pSysNetFuncArea=(CWriteableSysNetFuncArea *)(pMem->getFirst());
	while (pSysNetFuncArea!=NULL) {
		if (!pSysNetFuncArea->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetFuncArea=(CWriteableSysNetFuncArea *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetFuncAreaFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetFuncArea.csv");
	return writeCSV(szFileName);
}

void CSysNetFuncAreaFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetFuncAreaFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetFuncArea *pSysNetFuncArea;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetFuncAreaFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetFuncArea=(CWriteableSysNetFuncArea *)(pMem->getFirst());
	while (pSysNetFuncArea!=NULL) {
		pSysNetFuncArea->dump(fp,index++);
		pSysNetFuncArea=(CWriteableSysNetFuncArea *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetFuncAreaFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetFuncArea *CSysNetFuncAreaFactory::internalAdd(CWriteableSysNetFuncArea *pSysNetFuncArea, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetFuncArea++;
#endif
	CSysNetFuncArea *pTarget;	
	beforeAdd(pSysNetFuncArea);
	pTarget=(CSysNetFuncArea *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetFuncArea in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetFuncArea, sizeof(CSysNetFuncArea));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetFuncArea *CSysNetFuncAreaFactory::add(CWriteableSysNetFuncArea *pSysNetFuncArea, CTransaction *pTransaction)
{
	pSysNetFuncArea->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetFuncArea,true);
	}
	else {
		CSysNetFuncArea *pNewSysNetFuncArea;
		pNewSysNetFuncArea = internalAdd(pSysNetFuncArea,false);
		pTransaction->addResource(CSysNetFuncAreaResource::alloc(CREATE_ACTION,this,pNewSysNetFuncArea,NULL));
		return pNewSysNetFuncArea;
	}
}

void CSysNetFuncAreaFactory::internalUpdate(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pNewSysNetFuncArea, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetFuncArea++;
	}
	else {
		updateWithoutIndexActionForSysNetFuncArea++;
	}
#endif
	CWriteableSysNetFuncArea theOldSysNetFuncArea;
	beforeUpdate(pSysNetFuncArea,pNewSysNetFuncArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetFuncArea,pSysNetFuncArea,sizeof(CSysNetFuncArea));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetFuncArea,pNewSysNetFuncArea,sizeof(CSysNetFuncArea));
	pMem->updateObject(pSysNetFuncArea);
	if (updateIndex) {
	}
	afterUpdate(pSysNetFuncArea);
	if (bNoTransaction) {
		commitUpdate(pSysNetFuncArea,&theOldSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::update(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pNewSysNetFuncArea, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetFuncArea->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetFuncArea,pNewSysNetFuncArea,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetFuncAreaResource::alloc(UPDATE_ACTION,this,pSysNetFuncArea,pNewSysNetFuncArea,updateIndex));
		internalUpdate(pSysNetFuncArea,pNewSysNetFuncArea,updateIndex,false);
	}
}

void CSysNetFuncAreaFactory::internalRemove(CSysNetFuncArea *pSysNetFuncArea, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetFuncArea++;
#endif
	CWriteableSysNetFuncArea theOldSysNetFuncArea;
	beforeRemove(pSysNetFuncArea);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetFuncArea,pSysNetFuncArea,sizeof(CSysNetFuncArea));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetFuncArea);
	}
	pMem->free(pSysNetFuncArea);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::remove(CSysNetFuncArea *pSysNetFuncArea, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetFuncArea,true);
	}
	else {
		pTransaction->addResource(CSysNetFuncAreaResource::alloc(DELETE_ACTION,this,pSysNetFuncArea,NULL));
		internalRemove(pSysNetFuncArea,false);		
	}
}

CSysNetFuncArea* CSysNetFuncAreaFactory::addOrUpdate(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pNewSysNetFuncArea, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetFuncArea == NULL) {
		return add(pNewSysNetFuncArea,pTransaction);
	}
	else {
		update(pSysNetFuncArea,pNewSysNetFuncArea,pTransaction,updateIndex);
		return pSysNetFuncArea;
	}
}

void CSysNetFuncAreaFactory::retrieve(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pTargetSysNetFuncArea)
{
	forceCopy(pTargetSysNetFuncArea, pSysNetFuncArea, sizeof(CSysNetFuncArea));
}
	
int CSysNetFuncAreaFactory::addActionTrigger(CSysNetFuncAreaActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetFuncAreaFactory::removeActionTrigger(CSysNetFuncAreaActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetFuncAreaFactory::addCommitTrigger(CSysNetFuncAreaCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetFuncAreaFactory::removeCommitTrigger(CSysNetFuncAreaCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetFuncArea *CSysNetFuncAreaFactory::getFirst(void)
{
	CSysNetFuncArea *pResult=(CSysNetFuncArea *)(pMem->getFirst());
	return pResult;
}
	
CSysNetFuncArea *CSysNetFuncAreaFactory::getNext(void)
{
	CSysNetFuncArea *pResult=(CSysNetFuncArea *)(pMem->getNext());
	return pResult;
}
	
void CSysNetFuncAreaFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetFuncAreaFactory::beforeAdd(CWriteableSysNetFuncArea *pSysNetFuncArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetFuncArea);
	}
}
	
void CSysNetFuncAreaFactory::afterAdd(CSysNetFuncArea *pSysNetFuncArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::beforeUpdate(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pNewSysNetFuncArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetFuncArea,pNewSysNetFuncArea);
	}
}
	
void CSysNetFuncAreaFactory::afterUpdate(CSysNetFuncArea *pSysNetFuncArea)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetFuncArea);
	}
}
	
void CSysNetFuncAreaFactory::beforeRemove(CSysNetFuncArea *pSysNetFuncArea)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::commitAdd(CSysNetFuncArea *pSysNetFuncArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetFuncArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::commitUpdate(CSysNetFuncArea *pSysNetFuncArea, CWriteableSysNetFuncArea *pOldSysNetFuncArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetFuncArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetFuncArea,pOldSysNetFuncArea);
	}
}
	
void CSysNetFuncAreaFactory::commitRemove(CWriteableSysNetFuncArea *pSysNetFuncArea)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetFuncArea++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetFuncArea);
	}
}

void CSysNetFuncAreaFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDevice(const void *pV1, const void *pV2);
extern int compareForSysIPDECODETypeIndexinSysNetDevice(const void *pV1, const void *pV2);
extern int compareForSysSubAreaIDTypeIndexinSysNetDevice(const void *pV1, const void *pV2);
extern int compareForSysObjectIDTypeIndexinSysNetDevice(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDevice=0;
int updateWithIndexActionForSysNetDevice=0;
int updateWithoutIndexActionForSysNetDevice=0;
int removeActionForSysNetDevice=0;
int addCommitForSysNetDevice=0;
int updateCommitForSysNetDevice=0;
int removeCommitForSysNetDevice=0;
#endif
void CSysNetDeviceFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDevice,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDevice_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDevice_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDevice,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysIPDECODETypeIndex=new CAVLTree(maxUnit,compareForSysIPDECODETypeIndexinSysNetDevice,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDevice_SysIPDECODETypeIndex",pSysIPDECODETypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDevice_SysIPDECODETypeIndex");
			if(it != pIndexMap->end()) {
				pSysIPDECODETypeIndex=new CAVLTree(maxUnit,compareForSysIPDECODETypeIndexinSysNetDevice,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIPDECODETypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysSubAreaIDTypeIndex=new CAVLTree(maxUnit,compareForSysSubAreaIDTypeIndexinSysNetDevice,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDevice_SysSubAreaIDTypeIndex",pSysSubAreaIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDevice_SysSubAreaIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysSubAreaIDTypeIndex=new CAVLTree(maxUnit,compareForSysSubAreaIDTypeIndexinSysNetDevice,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysSubAreaIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetDevice,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDevice_SysObjectIDTypeIndex",pSysObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDevice_SysObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetDevice,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByIPDECODE=NULL;
	pLastFoundInSearchBySubAreaID=NULL;
	pActionTriggers=new vector<CSysNetDeviceActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDeviceCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDeviceFactory::CSysNetDeviceFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDevice),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDeviceFactory::CSysNetDeviceFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDevice),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDeviceFactory::~CSysNetDeviceFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysIPDECODETypeIndex!=NULL)
			delete pSysIPDECODETypeIndex;
	}
	if (runLevel>=0) {
		if (pSysSubAreaIDTypeIndex!=NULL)
			delete pSysSubAreaIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysObjectIDTypeIndex!=NULL)
			delete pSysObjectIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDeviceFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDeviceFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysIPDECODETypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysSubAreaIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDeviceFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDevice thisSysNetDevice;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDevice.readCSV(input,pNames))
		add(&thisSysNetDevice);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDeviceFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDevice.csv");
	return readCSV(szFileName);
}

int CSysNetDeviceFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDevice *pSysNetDevice;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDevice::writeCSVHead(output);
	pSysNetDevice=(CWriteableSysNetDevice *)(pMem->getFirst());
	while (pSysNetDevice!=NULL) {
		if (!pSysNetDevice->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDevice=(CWriteableSysNetDevice *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDeviceFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDevice.csv");
	return writeCSV(szFileName);
}

void CSysNetDeviceFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDeviceFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDevice *pSysNetDevice;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDeviceFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDevice=(CWriteableSysNetDevice *)(pMem->getFirst());
	while (pSysNetDevice!=NULL) {
		pSysNetDevice->dump(fp,index++);
		pSysNetDevice=(CWriteableSysNetDevice *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDeviceFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysIPDECODETypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysSubAreaIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeAll();
	}
}

CSysNetDevice *CSysNetDeviceFactory::internalAdd(CWriteableSysNetDevice *pSysNetDevice, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDevice++;
#endif
	CSysNetDevice *pTarget;	
	beforeAdd(pSysNetDevice);
	pTarget=(CSysNetDevice *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDevice in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDevice, sizeof(CSysNetDevice));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysIPDECODETypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysSubAreaIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDevice *CSysNetDeviceFactory::add(CWriteableSysNetDevice *pSysNetDevice, CTransaction *pTransaction)
{
	pSysNetDevice->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDevice,true);
	}
	else {
		CSysNetDevice *pNewSysNetDevice;
		pNewSysNetDevice = internalAdd(pSysNetDevice,false);
		pTransaction->addResource(CSysNetDeviceResource::alloc(CREATE_ACTION,this,pNewSysNetDevice,NULL));
		return pNewSysNetDevice;
	}
}

void CSysNetDeviceFactory::internalUpdate(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pNewSysNetDevice, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDevice++;
	}
	else {
		updateWithoutIndexActionForSysNetDevice++;
	}
#endif
	CWriteableSysNetDevice theOldSysNetDevice;
	beforeUpdate(pSysNetDevice,pNewSysNetDevice);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDevice,pSysNetDevice,sizeof(CSysNetDevice));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDevice,pNewSysNetDevice,sizeof(CSysNetDevice));
	pMem->updateObject(pSysNetDevice);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDevice);
	if (bNoTransaction) {
		commitUpdate(pSysNetDevice,&theOldSysNetDevice);
	}
}

void CSysNetDeviceFactory::update(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pNewSysNetDevice, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDevice->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDevice,pNewSysNetDevice,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceResource::alloc(UPDATE_ACTION,this,pSysNetDevice,pNewSysNetDevice,updateIndex));
		internalUpdate(pSysNetDevice,pNewSysNetDevice,updateIndex,false);
	}
}

void CSysNetDeviceFactory::internalRemove(CSysNetDevice *pSysNetDevice, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDevice++;
#endif
	CWriteableSysNetDevice theOldSysNetDevice;
	beforeRemove(pSysNetDevice);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDevice,pSysNetDevice,sizeof(CSysNetDevice));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDevice);
	}
	if (runLevel>=0) {
		pSysIPDECODETypeIndex->removeObject(pSysNetDevice);
	}
	if (runLevel>=0) {
		pSysSubAreaIDTypeIndex->removeObject(pSysNetDevice);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeObject(pSysNetDevice);
	}
	pMem->free(pSysNetDevice);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDevice);
	}
}

void CSysNetDeviceFactory::remove(CSysNetDevice *pSysNetDevice, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDevice,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceResource::alloc(DELETE_ACTION,this,pSysNetDevice,NULL));
		internalRemove(pSysNetDevice,false);		
	}
}

CSysNetDevice* CSysNetDeviceFactory::addOrUpdate(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pNewSysNetDevice, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDevice == NULL) {
		return add(pNewSysNetDevice,pTransaction);
	}
	else {
		update(pSysNetDevice,pNewSysNetDevice,pTransaction,updateIndex);
		return pSysNetDevice;
	}
}

void CSysNetDeviceFactory::retrieve(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pTargetSysNetDevice)
{
	forceCopy(pTargetSysNetDevice, pSysNetDevice, sizeof(CSysNetDevice));
}
	
int CSysNetDeviceFactory::addActionTrigger(CSysNetDeviceActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDeviceFactory::removeActionTrigger(CSysNetDeviceActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDeviceFactory::addCommitTrigger(CSysNetDeviceCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDeviceFactory::removeCommitTrigger(CSysNetDeviceCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDevice *CSysNetDeviceFactory::getFirst(void)
{
	CSysNetDevice *pResult=(CSysNetDevice *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDevice *CSysNetDeviceFactory::getNext(void)
{
	CSysNetDevice *pResult=(CSysNetDevice *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDeviceFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDeviceFactory::beforeAdd(CWriteableSysNetDevice *pSysNetDevice)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDevice);
	}
}
	
void CSysNetDeviceFactory::afterAdd(CSysNetDevice *pSysNetDevice)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDevice);
	}
}

void CSysNetDeviceFactory::beforeUpdate(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pNewSysNetDevice)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDevice,pNewSysNetDevice);
	}
}
	
void CSysNetDeviceFactory::afterUpdate(CSysNetDevice *pSysNetDevice)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDevice);
	}
}
	
void CSysNetDeviceFactory::beforeRemove(CSysNetDevice *pSysNetDevice)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDevice);
	}
}

void CSysNetDeviceFactory::commitAdd(CSysNetDevice *pSysNetDevice)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDevice++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDevice);
	}
}

void CSysNetDeviceFactory::commitUpdate(CSysNetDevice *pSysNetDevice, CWriteableSysNetDevice *pOldSysNetDevice)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDevice++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDevice,pOldSysNetDevice);
	}
}
	
void CSysNetDeviceFactory::commitRemove(CWriteableSysNetDevice *pSysNetDevice)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDevice++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDevice);
	}
}

void CSysNetDeviceFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDeviceLinked(const void *pV1, const void *pV2);
extern int compareForSysNetObjectIDTypeIndexinSysNetDeviceLinked(const void *pV1, const void *pV2);
extern int compareForSysLinkObjectIDTypeIndexinSysNetDeviceLinked(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDeviceLinked=0;
int updateWithIndexActionForSysNetDeviceLinked=0;
int updateWithoutIndexActionForSysNetDeviceLinked=0;
int removeActionForSysNetDeviceLinked=0;
int addCommitForSysNetDeviceLinked=0;
int updateCommitForSysNetDeviceLinked=0;
int removeCommitForSysNetDeviceLinked=0;
#endif
void CSysNetDeviceLinkedFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDeviceLinked_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDeviceLinked_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysNetObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysNetObjectIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDeviceLinked_SysNetObjectIDTypeIndex",pSysNetObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDeviceLinked_SysNetObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysNetObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysNetObjectIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysNetObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysLinkObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysLinkObjectIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDeviceLinked_SysLinkObjectIDTypeIndex",pSysLinkObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDeviceLinked_SysLinkObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysLinkObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysLinkObjectIDTypeIndexinSysNetDeviceLinked,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysLinkObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByNetObjectID=NULL;
	pLastFoundInSearchByLinkNetObjectID=NULL;
	pActionTriggers=new vector<CSysNetDeviceLinkedActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDeviceLinkedCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDeviceLinkedFactory::CSysNetDeviceLinkedFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceLinked),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDeviceLinkedFactory::CSysNetDeviceLinkedFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceLinked),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDeviceLinkedFactory::~CSysNetDeviceLinkedFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysNetObjectIDTypeIndex!=NULL)
			delete pSysNetObjectIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysLinkObjectIDTypeIndex!=NULL)
			delete pSysLinkObjectIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDeviceLinkedFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDeviceLinkedFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysLinkObjectIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDeviceLinkedFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDeviceLinked thisSysNetDeviceLinked;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDeviceLinked.readCSV(input,pNames))
		add(&thisSysNetDeviceLinked);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDeviceLinkedFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDeviceLinked.csv");
	return readCSV(szFileName);
}

int CSysNetDeviceLinkedFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDeviceLinked *pSysNetDeviceLinked;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDeviceLinked::writeCSVHead(output);
	pSysNetDeviceLinked=(CWriteableSysNetDeviceLinked *)(pMem->getFirst());
	while (pSysNetDeviceLinked!=NULL) {
		if (!pSysNetDeviceLinked->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDeviceLinked=(CWriteableSysNetDeviceLinked *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDeviceLinkedFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDeviceLinked.csv");
	return writeCSV(szFileName);
}

void CSysNetDeviceLinkedFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDeviceLinkedFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDeviceLinked *pSysNetDeviceLinked;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDeviceLinkedFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDeviceLinked=(CWriteableSysNetDeviceLinked *)(pMem->getFirst());
	while (pSysNetDeviceLinked!=NULL) {
		pSysNetDeviceLinked->dump(fp,index++);
		pSysNetDeviceLinked=(CWriteableSysNetDeviceLinked *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDeviceLinkedFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysLinkObjectIDTypeIndex->removeAll();
	}
}

CSysNetDeviceLinked *CSysNetDeviceLinkedFactory::internalAdd(CWriteableSysNetDeviceLinked *pSysNetDeviceLinked, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDeviceLinked++;
#endif
	CSysNetDeviceLinked *pTarget;	
	beforeAdd(pSysNetDeviceLinked);
	pTarget=(CSysNetDeviceLinked *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDeviceLinked in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDeviceLinked, sizeof(CSysNetDeviceLinked));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysLinkObjectIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDeviceLinked *CSysNetDeviceLinkedFactory::add(CWriteableSysNetDeviceLinked *pSysNetDeviceLinked, CTransaction *pTransaction)
{
	pSysNetDeviceLinked->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDeviceLinked,true);
	}
	else {
		CSysNetDeviceLinked *pNewSysNetDeviceLinked;
		pNewSysNetDeviceLinked = internalAdd(pSysNetDeviceLinked,false);
		pTransaction->addResource(CSysNetDeviceLinkedResource::alloc(CREATE_ACTION,this,pNewSysNetDeviceLinked,NULL));
		return pNewSysNetDeviceLinked;
	}
}

void CSysNetDeviceLinkedFactory::internalUpdate(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pNewSysNetDeviceLinked, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDeviceLinked++;
	}
	else {
		updateWithoutIndexActionForSysNetDeviceLinked++;
	}
#endif
	CWriteableSysNetDeviceLinked theOldSysNetDeviceLinked;
	beforeUpdate(pSysNetDeviceLinked,pNewSysNetDeviceLinked);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceLinked,pSysNetDeviceLinked,sizeof(CSysNetDeviceLinked));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDeviceLinked,pNewSysNetDeviceLinked,sizeof(CSysNetDeviceLinked));
	pMem->updateObject(pSysNetDeviceLinked);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDeviceLinked);
	if (bNoTransaction) {
		commitUpdate(pSysNetDeviceLinked,&theOldSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::update(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pNewSysNetDeviceLinked, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDeviceLinked->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDeviceLinked,pNewSysNetDeviceLinked,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceLinkedResource::alloc(UPDATE_ACTION,this,pSysNetDeviceLinked,pNewSysNetDeviceLinked,updateIndex));
		internalUpdate(pSysNetDeviceLinked,pNewSysNetDeviceLinked,updateIndex,false);
	}
}

void CSysNetDeviceLinkedFactory::internalRemove(CSysNetDeviceLinked *pSysNetDeviceLinked, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDeviceLinked++;
#endif
	CWriteableSysNetDeviceLinked theOldSysNetDeviceLinked;
	beforeRemove(pSysNetDeviceLinked);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceLinked,pSysNetDeviceLinked,sizeof(CSysNetDeviceLinked));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDeviceLinked);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->removeObject(pSysNetDeviceLinked);
	}
	if (runLevel>=0) {
		pSysLinkObjectIDTypeIndex->removeObject(pSysNetDeviceLinked);
	}
	pMem->free(pSysNetDeviceLinked);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::remove(CSysNetDeviceLinked *pSysNetDeviceLinked, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDeviceLinked,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceLinkedResource::alloc(DELETE_ACTION,this,pSysNetDeviceLinked,NULL));
		internalRemove(pSysNetDeviceLinked,false);		
	}
}

CSysNetDeviceLinked* CSysNetDeviceLinkedFactory::addOrUpdate(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pNewSysNetDeviceLinked, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDeviceLinked == NULL) {
		return add(pNewSysNetDeviceLinked,pTransaction);
	}
	else {
		update(pSysNetDeviceLinked,pNewSysNetDeviceLinked,pTransaction,updateIndex);
		return pSysNetDeviceLinked;
	}
}

void CSysNetDeviceLinkedFactory::retrieve(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pTargetSysNetDeviceLinked)
{
	forceCopy(pTargetSysNetDeviceLinked, pSysNetDeviceLinked, sizeof(CSysNetDeviceLinked));
}
	
int CSysNetDeviceLinkedFactory::addActionTrigger(CSysNetDeviceLinkedActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDeviceLinkedFactory::removeActionTrigger(CSysNetDeviceLinkedActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDeviceLinkedFactory::addCommitTrigger(CSysNetDeviceLinkedCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDeviceLinkedFactory::removeCommitTrigger(CSysNetDeviceLinkedCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDeviceLinked *CSysNetDeviceLinkedFactory::getFirst(void)
{
	CSysNetDeviceLinked *pResult=(CSysNetDeviceLinked *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDeviceLinked *CSysNetDeviceLinkedFactory::getNext(void)
{
	CSysNetDeviceLinked *pResult=(CSysNetDeviceLinked *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDeviceLinkedFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDeviceLinkedFactory::beforeAdd(CWriteableSysNetDeviceLinked *pSysNetDeviceLinked)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDeviceLinked);
	}
}
	
void CSysNetDeviceLinkedFactory::afterAdd(CSysNetDeviceLinked *pSysNetDeviceLinked)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::beforeUpdate(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pNewSysNetDeviceLinked)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDeviceLinked,pNewSysNetDeviceLinked);
	}
}
	
void CSysNetDeviceLinkedFactory::afterUpdate(CSysNetDeviceLinked *pSysNetDeviceLinked)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDeviceLinked);
	}
}
	
void CSysNetDeviceLinkedFactory::beforeRemove(CSysNetDeviceLinked *pSysNetDeviceLinked)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::commitAdd(CSysNetDeviceLinked *pSysNetDeviceLinked)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDeviceLinked++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::commitUpdate(CSysNetDeviceLinked *pSysNetDeviceLinked, CWriteableSysNetDeviceLinked *pOldSysNetDeviceLinked)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDeviceLinked++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDeviceLinked,pOldSysNetDeviceLinked);
	}
}
	
void CSysNetDeviceLinkedFactory::commitRemove(CWriteableSysNetDeviceLinked *pSysNetDeviceLinked)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDeviceLinked++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDeviceLinked);
	}
}

void CSysNetDeviceLinkedFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetOID(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetOID=0;
int updateWithIndexActionForSysNetOID=0;
int updateWithoutIndexActionForSysNetOID=0;
int removeActionForSysNetOID=0;
int addCommitForSysNetOID=0;
int updateCommitForSysNetOID=0;
int removeCommitForSysNetOID=0;
#endif
void CSysNetOIDFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetOID,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetOID_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetOID_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetOID,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetOIDActionTrigger *>;
	pCommitTriggers=new vector<CSysNetOIDCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetOIDFactory::CSysNetOIDFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetOID),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetOIDFactory::CSysNetOIDFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetOID),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetOIDFactory::~CSysNetOIDFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetOIDFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetOIDFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetOIDFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetOID thisSysNetOID;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetOID.readCSV(input,pNames))
		add(&thisSysNetOID);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetOIDFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetOID.csv");
	return readCSV(szFileName);
}

int CSysNetOIDFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetOID *pSysNetOID;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetOID::writeCSVHead(output);
	pSysNetOID=(CWriteableSysNetOID *)(pMem->getFirst());
	while (pSysNetOID!=NULL) {
		if (!pSysNetOID->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetOID=(CWriteableSysNetOID *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetOIDFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetOID.csv");
	return writeCSV(szFileName);
}

void CSysNetOIDFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetOIDFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetOID *pSysNetOID;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetOIDFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetOID=(CWriteableSysNetOID *)(pMem->getFirst());
	while (pSysNetOID!=NULL) {
		pSysNetOID->dump(fp,index++);
		pSysNetOID=(CWriteableSysNetOID *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetOIDFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetOID *CSysNetOIDFactory::internalAdd(CWriteableSysNetOID *pSysNetOID, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetOID++;
#endif
	CSysNetOID *pTarget;	
	beforeAdd(pSysNetOID);
	pTarget=(CSysNetOID *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetOID in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetOID, sizeof(CSysNetOID));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetOID *CSysNetOIDFactory::add(CWriteableSysNetOID *pSysNetOID, CTransaction *pTransaction)
{
	pSysNetOID->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetOID,true);
	}
	else {
		CSysNetOID *pNewSysNetOID;
		pNewSysNetOID = internalAdd(pSysNetOID,false);
		pTransaction->addResource(CSysNetOIDResource::alloc(CREATE_ACTION,this,pNewSysNetOID,NULL));
		return pNewSysNetOID;
	}
}

void CSysNetOIDFactory::internalUpdate(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pNewSysNetOID, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetOID++;
	}
	else {
		updateWithoutIndexActionForSysNetOID++;
	}
#endif
	CWriteableSysNetOID theOldSysNetOID;
	beforeUpdate(pSysNetOID,pNewSysNetOID);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetOID,pSysNetOID,sizeof(CSysNetOID));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetOID,pNewSysNetOID,sizeof(CSysNetOID));
	pMem->updateObject(pSysNetOID);
	if (updateIndex) {
	}
	afterUpdate(pSysNetOID);
	if (bNoTransaction) {
		commitUpdate(pSysNetOID,&theOldSysNetOID);
	}
}

void CSysNetOIDFactory::update(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pNewSysNetOID, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetOID->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetOID,pNewSysNetOID,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetOIDResource::alloc(UPDATE_ACTION,this,pSysNetOID,pNewSysNetOID,updateIndex));
		internalUpdate(pSysNetOID,pNewSysNetOID,updateIndex,false);
	}
}

void CSysNetOIDFactory::internalRemove(CSysNetOID *pSysNetOID, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetOID++;
#endif
	CWriteableSysNetOID theOldSysNetOID;
	beforeRemove(pSysNetOID);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetOID,pSysNetOID,sizeof(CSysNetOID));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetOID);
	}
	pMem->free(pSysNetOID);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetOID);
	}
}

void CSysNetOIDFactory::remove(CSysNetOID *pSysNetOID, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetOID,true);
	}
	else {
		pTransaction->addResource(CSysNetOIDResource::alloc(DELETE_ACTION,this,pSysNetOID,NULL));
		internalRemove(pSysNetOID,false);		
	}
}

CSysNetOID* CSysNetOIDFactory::addOrUpdate(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pNewSysNetOID, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetOID == NULL) {
		return add(pNewSysNetOID,pTransaction);
	}
	else {
		update(pSysNetOID,pNewSysNetOID,pTransaction,updateIndex);
		return pSysNetOID;
	}
}

void CSysNetOIDFactory::retrieve(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pTargetSysNetOID)
{
	forceCopy(pTargetSysNetOID, pSysNetOID, sizeof(CSysNetOID));
}
	
int CSysNetOIDFactory::addActionTrigger(CSysNetOIDActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetOIDFactory::removeActionTrigger(CSysNetOIDActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetOIDFactory::addCommitTrigger(CSysNetOIDCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetOIDFactory::removeCommitTrigger(CSysNetOIDCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetOID *CSysNetOIDFactory::getFirst(void)
{
	CSysNetOID *pResult=(CSysNetOID *)(pMem->getFirst());
	return pResult;
}
	
CSysNetOID *CSysNetOIDFactory::getNext(void)
{
	CSysNetOID *pResult=(CSysNetOID *)(pMem->getNext());
	return pResult;
}
	
void CSysNetOIDFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetOIDFactory::beforeAdd(CWriteableSysNetOID *pSysNetOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetOID);
	}
}
	
void CSysNetOIDFactory::afterAdd(CSysNetOID *pSysNetOID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetOID);
	}
}

void CSysNetOIDFactory::beforeUpdate(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pNewSysNetOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetOID,pNewSysNetOID);
	}
}
	
void CSysNetOIDFactory::afterUpdate(CSysNetOID *pSysNetOID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetOID);
	}
}
	
void CSysNetOIDFactory::beforeRemove(CSysNetOID *pSysNetOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetOID);
	}
}

void CSysNetOIDFactory::commitAdd(CSysNetOID *pSysNetOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetOID);
	}
}

void CSysNetOIDFactory::commitUpdate(CSysNetOID *pSysNetOID, CWriteableSysNetOID *pOldSysNetOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetOID,pOldSysNetOID);
	}
}
	
void CSysNetOIDFactory::commitRemove(CWriteableSysNetOID *pSysNetOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetOID);
	}
}

void CSysNetOIDFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDeviceType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDeviceType=0;
int updateWithIndexActionForSysNetDeviceType=0;
int updateWithoutIndexActionForSysNetDeviceType=0;
int removeActionForSysNetDeviceType=0;
int addCommitForSysNetDeviceType=0;
int updateCommitForSysNetDeviceType=0;
int removeCommitForSysNetDeviceType=0;
#endif
void CSysNetDeviceTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDeviceType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDeviceType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetDeviceTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDeviceTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDeviceTypeFactory::CSysNetDeviceTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDeviceTypeFactory::CSysNetDeviceTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDeviceTypeFactory::~CSysNetDeviceTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDeviceTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDeviceTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDeviceTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDeviceType thisSysNetDeviceType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDeviceType.readCSV(input,pNames))
		add(&thisSysNetDeviceType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDeviceTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDeviceType.csv");
	return readCSV(szFileName);
}

int CSysNetDeviceTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDeviceType *pSysNetDeviceType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDeviceType::writeCSVHead(output);
	pSysNetDeviceType=(CWriteableSysNetDeviceType *)(pMem->getFirst());
	while (pSysNetDeviceType!=NULL) {
		if (!pSysNetDeviceType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDeviceType=(CWriteableSysNetDeviceType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDeviceTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDeviceType.csv");
	return writeCSV(szFileName);
}

void CSysNetDeviceTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDeviceTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDeviceType *pSysNetDeviceType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDeviceTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDeviceType=(CWriteableSysNetDeviceType *)(pMem->getFirst());
	while (pSysNetDeviceType!=NULL) {
		pSysNetDeviceType->dump(fp,index++);
		pSysNetDeviceType=(CWriteableSysNetDeviceType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDeviceTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetDeviceType *CSysNetDeviceTypeFactory::internalAdd(CWriteableSysNetDeviceType *pSysNetDeviceType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDeviceType++;
#endif
	CSysNetDeviceType *pTarget;	
	beforeAdd(pSysNetDeviceType);
	pTarget=(CSysNetDeviceType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDeviceType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDeviceType, sizeof(CSysNetDeviceType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDeviceType *CSysNetDeviceTypeFactory::add(CWriteableSysNetDeviceType *pSysNetDeviceType, CTransaction *pTransaction)
{
	pSysNetDeviceType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDeviceType,true);
	}
	else {
		CSysNetDeviceType *pNewSysNetDeviceType;
		pNewSysNetDeviceType = internalAdd(pSysNetDeviceType,false);
		pTransaction->addResource(CSysNetDeviceTypeResource::alloc(CREATE_ACTION,this,pNewSysNetDeviceType,NULL));
		return pNewSysNetDeviceType;
	}
}

void CSysNetDeviceTypeFactory::internalUpdate(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pNewSysNetDeviceType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDeviceType++;
	}
	else {
		updateWithoutIndexActionForSysNetDeviceType++;
	}
#endif
	CWriteableSysNetDeviceType theOldSysNetDeviceType;
	beforeUpdate(pSysNetDeviceType,pNewSysNetDeviceType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceType,pSysNetDeviceType,sizeof(CSysNetDeviceType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDeviceType,pNewSysNetDeviceType,sizeof(CSysNetDeviceType));
	pMem->updateObject(pSysNetDeviceType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDeviceType);
	if (bNoTransaction) {
		commitUpdate(pSysNetDeviceType,&theOldSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::update(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pNewSysNetDeviceType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDeviceType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDeviceType,pNewSysNetDeviceType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceTypeResource::alloc(UPDATE_ACTION,this,pSysNetDeviceType,pNewSysNetDeviceType,updateIndex));
		internalUpdate(pSysNetDeviceType,pNewSysNetDeviceType,updateIndex,false);
	}
}

void CSysNetDeviceTypeFactory::internalRemove(CSysNetDeviceType *pSysNetDeviceType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDeviceType++;
#endif
	CWriteableSysNetDeviceType theOldSysNetDeviceType;
	beforeRemove(pSysNetDeviceType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceType,pSysNetDeviceType,sizeof(CSysNetDeviceType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDeviceType);
	}
	pMem->free(pSysNetDeviceType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::remove(CSysNetDeviceType *pSysNetDeviceType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDeviceType,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceTypeResource::alloc(DELETE_ACTION,this,pSysNetDeviceType,NULL));
		internalRemove(pSysNetDeviceType,false);		
	}
}

CSysNetDeviceType* CSysNetDeviceTypeFactory::addOrUpdate(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pNewSysNetDeviceType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDeviceType == NULL) {
		return add(pNewSysNetDeviceType,pTransaction);
	}
	else {
		update(pSysNetDeviceType,pNewSysNetDeviceType,pTransaction,updateIndex);
		return pSysNetDeviceType;
	}
}

void CSysNetDeviceTypeFactory::retrieve(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pTargetSysNetDeviceType)
{
	forceCopy(pTargetSysNetDeviceType, pSysNetDeviceType, sizeof(CSysNetDeviceType));
}
	
int CSysNetDeviceTypeFactory::addActionTrigger(CSysNetDeviceTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDeviceTypeFactory::removeActionTrigger(CSysNetDeviceTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDeviceTypeFactory::addCommitTrigger(CSysNetDeviceTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDeviceTypeFactory::removeCommitTrigger(CSysNetDeviceTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDeviceType *CSysNetDeviceTypeFactory::getFirst(void)
{
	CSysNetDeviceType *pResult=(CSysNetDeviceType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDeviceType *CSysNetDeviceTypeFactory::getNext(void)
{
	CSysNetDeviceType *pResult=(CSysNetDeviceType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDeviceTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDeviceTypeFactory::beforeAdd(CWriteableSysNetDeviceType *pSysNetDeviceType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDeviceType);
	}
}
	
void CSysNetDeviceTypeFactory::afterAdd(CSysNetDeviceType *pSysNetDeviceType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::beforeUpdate(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pNewSysNetDeviceType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDeviceType,pNewSysNetDeviceType);
	}
}
	
void CSysNetDeviceTypeFactory::afterUpdate(CSysNetDeviceType *pSysNetDeviceType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDeviceType);
	}
}
	
void CSysNetDeviceTypeFactory::beforeRemove(CSysNetDeviceType *pSysNetDeviceType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::commitAdd(CSysNetDeviceType *pSysNetDeviceType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDeviceType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::commitUpdate(CSysNetDeviceType *pSysNetDeviceType, CWriteableSysNetDeviceType *pOldSysNetDeviceType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDeviceType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDeviceType,pOldSysNetDeviceType);
	}
}
	
void CSysNetDeviceTypeFactory::commitRemove(CWriteableSysNetDeviceType *pSysNetDeviceType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDeviceType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDeviceType);
	}
}

void CSysNetDeviceTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetTimePolicy(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetTimePolicy=0;
int updateWithIndexActionForSysNetTimePolicy=0;
int updateWithoutIndexActionForSysNetTimePolicy=0;
int removeActionForSysNetTimePolicy=0;
int addCommitForSysNetTimePolicy=0;
int updateCommitForSysNetTimePolicy=0;
int removeCommitForSysNetTimePolicy=0;
#endif
void CSysNetTimePolicyFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetTimePolicy,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetTimePolicy_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetTimePolicy_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetTimePolicy,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetTimePolicyActionTrigger *>;
	pCommitTriggers=new vector<CSysNetTimePolicyCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetTimePolicyFactory::CSysNetTimePolicyFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetTimePolicy),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetTimePolicyFactory::CSysNetTimePolicyFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetTimePolicy),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetTimePolicyFactory::~CSysNetTimePolicyFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetTimePolicyFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetTimePolicyFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetTimePolicyFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetTimePolicy thisSysNetTimePolicy;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetTimePolicy.readCSV(input,pNames))
		add(&thisSysNetTimePolicy);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetTimePolicyFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetTimePolicy.csv");
	return readCSV(szFileName);
}

int CSysNetTimePolicyFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetTimePolicy *pSysNetTimePolicy;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetTimePolicy::writeCSVHead(output);
	pSysNetTimePolicy=(CWriteableSysNetTimePolicy *)(pMem->getFirst());
	while (pSysNetTimePolicy!=NULL) {
		if (!pSysNetTimePolicy->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetTimePolicy=(CWriteableSysNetTimePolicy *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetTimePolicyFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetTimePolicy.csv");
	return writeCSV(szFileName);
}

void CSysNetTimePolicyFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetTimePolicyFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetTimePolicy *pSysNetTimePolicy;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetTimePolicyFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetTimePolicy=(CWriteableSysNetTimePolicy *)(pMem->getFirst());
	while (pSysNetTimePolicy!=NULL) {
		pSysNetTimePolicy->dump(fp,index++);
		pSysNetTimePolicy=(CWriteableSysNetTimePolicy *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetTimePolicyFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetTimePolicy *CSysNetTimePolicyFactory::internalAdd(CWriteableSysNetTimePolicy *pSysNetTimePolicy, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetTimePolicy++;
#endif
	CSysNetTimePolicy *pTarget;	
	beforeAdd(pSysNetTimePolicy);
	pTarget=(CSysNetTimePolicy *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetTimePolicy in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetTimePolicy, sizeof(CSysNetTimePolicy));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetTimePolicy *CSysNetTimePolicyFactory::add(CWriteableSysNetTimePolicy *pSysNetTimePolicy, CTransaction *pTransaction)
{
	pSysNetTimePolicy->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetTimePolicy,true);
	}
	else {
		CSysNetTimePolicy *pNewSysNetTimePolicy;
		pNewSysNetTimePolicy = internalAdd(pSysNetTimePolicy,false);
		pTransaction->addResource(CSysNetTimePolicyResource::alloc(CREATE_ACTION,this,pNewSysNetTimePolicy,NULL));
		return pNewSysNetTimePolicy;
	}
}

void CSysNetTimePolicyFactory::internalUpdate(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pNewSysNetTimePolicy, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetTimePolicy++;
	}
	else {
		updateWithoutIndexActionForSysNetTimePolicy++;
	}
#endif
	CWriteableSysNetTimePolicy theOldSysNetTimePolicy;
	beforeUpdate(pSysNetTimePolicy,pNewSysNetTimePolicy);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetTimePolicy,pSysNetTimePolicy,sizeof(CSysNetTimePolicy));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetTimePolicy,pNewSysNetTimePolicy,sizeof(CSysNetTimePolicy));
	pMem->updateObject(pSysNetTimePolicy);
	if (updateIndex) {
	}
	afterUpdate(pSysNetTimePolicy);
	if (bNoTransaction) {
		commitUpdate(pSysNetTimePolicy,&theOldSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::update(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pNewSysNetTimePolicy, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetTimePolicy->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetTimePolicy,pNewSysNetTimePolicy,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetTimePolicyResource::alloc(UPDATE_ACTION,this,pSysNetTimePolicy,pNewSysNetTimePolicy,updateIndex));
		internalUpdate(pSysNetTimePolicy,pNewSysNetTimePolicy,updateIndex,false);
	}
}

void CSysNetTimePolicyFactory::internalRemove(CSysNetTimePolicy *pSysNetTimePolicy, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetTimePolicy++;
#endif
	CWriteableSysNetTimePolicy theOldSysNetTimePolicy;
	beforeRemove(pSysNetTimePolicy);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetTimePolicy,pSysNetTimePolicy,sizeof(CSysNetTimePolicy));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetTimePolicy);
	}
	pMem->free(pSysNetTimePolicy);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::remove(CSysNetTimePolicy *pSysNetTimePolicy, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetTimePolicy,true);
	}
	else {
		pTransaction->addResource(CSysNetTimePolicyResource::alloc(DELETE_ACTION,this,pSysNetTimePolicy,NULL));
		internalRemove(pSysNetTimePolicy,false);		
	}
}

CSysNetTimePolicy* CSysNetTimePolicyFactory::addOrUpdate(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pNewSysNetTimePolicy, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetTimePolicy == NULL) {
		return add(pNewSysNetTimePolicy,pTransaction);
	}
	else {
		update(pSysNetTimePolicy,pNewSysNetTimePolicy,pTransaction,updateIndex);
		return pSysNetTimePolicy;
	}
}

void CSysNetTimePolicyFactory::retrieve(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pTargetSysNetTimePolicy)
{
	forceCopy(pTargetSysNetTimePolicy, pSysNetTimePolicy, sizeof(CSysNetTimePolicy));
}
	
int CSysNetTimePolicyFactory::addActionTrigger(CSysNetTimePolicyActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetTimePolicyFactory::removeActionTrigger(CSysNetTimePolicyActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetTimePolicyFactory::addCommitTrigger(CSysNetTimePolicyCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetTimePolicyFactory::removeCommitTrigger(CSysNetTimePolicyCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetTimePolicy *CSysNetTimePolicyFactory::getFirst(void)
{
	CSysNetTimePolicy *pResult=(CSysNetTimePolicy *)(pMem->getFirst());
	return pResult;
}
	
CSysNetTimePolicy *CSysNetTimePolicyFactory::getNext(void)
{
	CSysNetTimePolicy *pResult=(CSysNetTimePolicy *)(pMem->getNext());
	return pResult;
}
	
void CSysNetTimePolicyFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetTimePolicyFactory::beforeAdd(CWriteableSysNetTimePolicy *pSysNetTimePolicy)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetTimePolicy);
	}
}
	
void CSysNetTimePolicyFactory::afterAdd(CSysNetTimePolicy *pSysNetTimePolicy)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::beforeUpdate(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pNewSysNetTimePolicy)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetTimePolicy,pNewSysNetTimePolicy);
	}
}
	
void CSysNetTimePolicyFactory::afterUpdate(CSysNetTimePolicy *pSysNetTimePolicy)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetTimePolicy);
	}
}
	
void CSysNetTimePolicyFactory::beforeRemove(CSysNetTimePolicy *pSysNetTimePolicy)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::commitAdd(CSysNetTimePolicy *pSysNetTimePolicy)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetTimePolicy++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::commitUpdate(CSysNetTimePolicy *pSysNetTimePolicy, CWriteableSysNetTimePolicy *pOldSysNetTimePolicy)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetTimePolicy++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetTimePolicy,pOldSysNetTimePolicy);
	}
}
	
void CSysNetTimePolicyFactory::commitRemove(CWriteableSysNetTimePolicy *pSysNetTimePolicy)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetTimePolicy++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetTimePolicy);
	}
}

void CSysNetTimePolicyFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetGatherTask(const void *pV1, const void *pV2);
extern int compareForSysNetObjectIDTypeIndexinSysNetGatherTask(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetGatherTask=0;
int updateWithIndexActionForSysNetGatherTask=0;
int updateWithoutIndexActionForSysNetGatherTask=0;
int removeActionForSysNetGatherTask=0;
int addCommitForSysNetGatherTask=0;
int updateCommitForSysNetGatherTask=0;
int removeCommitForSysNetGatherTask=0;
#endif
void CSysNetGatherTaskFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetGatherTask,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetGatherTask_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetGatherTask_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetGatherTask,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysNetObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysNetObjectIDTypeIndexinSysNetGatherTask,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetGatherTask_SysNetObjectIDTypeIndex",pSysNetObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetGatherTask_SysNetObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysNetObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysNetObjectIDTypeIndexinSysNetGatherTask,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysNetObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByNetObjectID=NULL;
	pActionTriggers=new vector<CSysNetGatherTaskActionTrigger *>;
	pCommitTriggers=new vector<CSysNetGatherTaskCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetGatherTaskFactory::CSysNetGatherTaskFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetGatherTask),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetGatherTaskFactory::CSysNetGatherTaskFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetGatherTask),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetGatherTaskFactory::~CSysNetGatherTaskFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysNetObjectIDTypeIndex!=NULL)
			delete pSysNetObjectIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetGatherTaskFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetGatherTaskFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetGatherTaskFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetGatherTask thisSysNetGatherTask;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetGatherTask.readCSV(input,pNames))
		add(&thisSysNetGatherTask);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetGatherTaskFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetGatherTask.csv");
	return readCSV(szFileName);
}

int CSysNetGatherTaskFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetGatherTask *pSysNetGatherTask;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetGatherTask::writeCSVHead(output);
	pSysNetGatherTask=(CWriteableSysNetGatherTask *)(pMem->getFirst());
	while (pSysNetGatherTask!=NULL) {
		if (!pSysNetGatherTask->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetGatherTask=(CWriteableSysNetGatherTask *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetGatherTaskFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetGatherTask.csv");
	return writeCSV(szFileName);
}

void CSysNetGatherTaskFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetGatherTaskFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetGatherTask *pSysNetGatherTask;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetGatherTaskFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetGatherTask=(CWriteableSysNetGatherTask *)(pMem->getFirst());
	while (pSysNetGatherTask!=NULL) {
		pSysNetGatherTask->dump(fp,index++);
		pSysNetGatherTask=(CWriteableSysNetGatherTask *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetGatherTaskFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->removeAll();
	}
}

CSysNetGatherTask *CSysNetGatherTaskFactory::internalAdd(CWriteableSysNetGatherTask *pSysNetGatherTask, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetGatherTask++;
#endif
	CSysNetGatherTask *pTarget;	
	beforeAdd(pSysNetGatherTask);
	pTarget=(CSysNetGatherTask *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetGatherTask in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetGatherTask, sizeof(CSysNetGatherTask));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetGatherTask *CSysNetGatherTaskFactory::add(CWriteableSysNetGatherTask *pSysNetGatherTask, CTransaction *pTransaction)
{
	pSysNetGatherTask->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetGatherTask,true);
	}
	else {
		CSysNetGatherTask *pNewSysNetGatherTask;
		pNewSysNetGatherTask = internalAdd(pSysNetGatherTask,false);
		pTransaction->addResource(CSysNetGatherTaskResource::alloc(CREATE_ACTION,this,pNewSysNetGatherTask,NULL));
		return pNewSysNetGatherTask;
	}
}

void CSysNetGatherTaskFactory::internalUpdate(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pNewSysNetGatherTask, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetGatherTask++;
	}
	else {
		updateWithoutIndexActionForSysNetGatherTask++;
	}
#endif
	CWriteableSysNetGatherTask theOldSysNetGatherTask;
	beforeUpdate(pSysNetGatherTask,pNewSysNetGatherTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetGatherTask,pSysNetGatherTask,sizeof(CSysNetGatherTask));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetGatherTask,pNewSysNetGatherTask,sizeof(CSysNetGatherTask));
	pMem->updateObject(pSysNetGatherTask);
	if (updateIndex) {
	}
	afterUpdate(pSysNetGatherTask);
	if (bNoTransaction) {
		commitUpdate(pSysNetGatherTask,&theOldSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::update(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pNewSysNetGatherTask, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetGatherTask->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetGatherTask,pNewSysNetGatherTask,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetGatherTaskResource::alloc(UPDATE_ACTION,this,pSysNetGatherTask,pNewSysNetGatherTask,updateIndex));
		internalUpdate(pSysNetGatherTask,pNewSysNetGatherTask,updateIndex,false);
	}
}

void CSysNetGatherTaskFactory::internalRemove(CSysNetGatherTask *pSysNetGatherTask, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetGatherTask++;
#endif
	CWriteableSysNetGatherTask theOldSysNetGatherTask;
	beforeRemove(pSysNetGatherTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetGatherTask,pSysNetGatherTask,sizeof(CSysNetGatherTask));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetGatherTask);
	}
	if (runLevel>=0) {
		pSysNetObjectIDTypeIndex->removeObject(pSysNetGatherTask);
	}
	pMem->free(pSysNetGatherTask);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::remove(CSysNetGatherTask *pSysNetGatherTask, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetGatherTask,true);
	}
	else {
		pTransaction->addResource(CSysNetGatherTaskResource::alloc(DELETE_ACTION,this,pSysNetGatherTask,NULL));
		internalRemove(pSysNetGatherTask,false);		
	}
}

CSysNetGatherTask* CSysNetGatherTaskFactory::addOrUpdate(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pNewSysNetGatherTask, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetGatherTask == NULL) {
		return add(pNewSysNetGatherTask,pTransaction);
	}
	else {
		update(pSysNetGatherTask,pNewSysNetGatherTask,pTransaction,updateIndex);
		return pSysNetGatherTask;
	}
}

void CSysNetGatherTaskFactory::retrieve(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pTargetSysNetGatherTask)
{
	forceCopy(pTargetSysNetGatherTask, pSysNetGatherTask, sizeof(CSysNetGatherTask));
}
	
int CSysNetGatherTaskFactory::addActionTrigger(CSysNetGatherTaskActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetGatherTaskFactory::removeActionTrigger(CSysNetGatherTaskActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetGatherTaskFactory::addCommitTrigger(CSysNetGatherTaskCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetGatherTaskFactory::removeCommitTrigger(CSysNetGatherTaskCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetGatherTask *CSysNetGatherTaskFactory::getFirst(void)
{
	CSysNetGatherTask *pResult=(CSysNetGatherTask *)(pMem->getFirst());
	return pResult;
}
	
CSysNetGatherTask *CSysNetGatherTaskFactory::getNext(void)
{
	CSysNetGatherTask *pResult=(CSysNetGatherTask *)(pMem->getNext());
	return pResult;
}
	
void CSysNetGatherTaskFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetGatherTaskFactory::beforeAdd(CWriteableSysNetGatherTask *pSysNetGatherTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetGatherTask);
	}
}
	
void CSysNetGatherTaskFactory::afterAdd(CSysNetGatherTask *pSysNetGatherTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::beforeUpdate(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pNewSysNetGatherTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetGatherTask,pNewSysNetGatherTask);
	}
}
	
void CSysNetGatherTaskFactory::afterUpdate(CSysNetGatherTask *pSysNetGatherTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetGatherTask);
	}
}
	
void CSysNetGatherTaskFactory::beforeRemove(CSysNetGatherTask *pSysNetGatherTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::commitAdd(CSysNetGatherTask *pSysNetGatherTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetGatherTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::commitUpdate(CSysNetGatherTask *pSysNetGatherTask, CWriteableSysNetGatherTask *pOldSysNetGatherTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetGatherTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetGatherTask,pOldSysNetGatherTask);
	}
}
	
void CSysNetGatherTaskFactory::commitRemove(CWriteableSysNetGatherTask *pSysNetGatherTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetGatherTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetGatherTask);
	}
}

void CSysNetGatherTaskFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDeviceCategory(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDeviceCategory=0;
int updateWithIndexActionForSysNetDeviceCategory=0;
int updateWithoutIndexActionForSysNetDeviceCategory=0;
int removeActionForSysNetDeviceCategory=0;
int addCommitForSysNetDeviceCategory=0;
int updateCommitForSysNetDeviceCategory=0;
int removeCommitForSysNetDeviceCategory=0;
#endif
void CSysNetDeviceCategoryFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceCategory,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDeviceCategory_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDeviceCategory_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDeviceCategory,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetDeviceCategoryActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDeviceCategoryCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDeviceCategoryFactory::CSysNetDeviceCategoryFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceCategory),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDeviceCategoryFactory::CSysNetDeviceCategoryFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDeviceCategory),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDeviceCategoryFactory::~CSysNetDeviceCategoryFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDeviceCategoryFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDeviceCategoryFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDeviceCategoryFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDeviceCategory thisSysNetDeviceCategory;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDeviceCategory.readCSV(input,pNames))
		add(&thisSysNetDeviceCategory);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDeviceCategoryFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDeviceCategory.csv");
	return readCSV(szFileName);
}

int CSysNetDeviceCategoryFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDeviceCategory *pSysNetDeviceCategory;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDeviceCategory::writeCSVHead(output);
	pSysNetDeviceCategory=(CWriteableSysNetDeviceCategory *)(pMem->getFirst());
	while (pSysNetDeviceCategory!=NULL) {
		if (!pSysNetDeviceCategory->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDeviceCategory=(CWriteableSysNetDeviceCategory *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDeviceCategoryFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDeviceCategory.csv");
	return writeCSV(szFileName);
}

void CSysNetDeviceCategoryFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDeviceCategoryFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDeviceCategory *pSysNetDeviceCategory;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDeviceCategoryFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDeviceCategory=(CWriteableSysNetDeviceCategory *)(pMem->getFirst());
	while (pSysNetDeviceCategory!=NULL) {
		pSysNetDeviceCategory->dump(fp,index++);
		pSysNetDeviceCategory=(CWriteableSysNetDeviceCategory *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDeviceCategoryFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetDeviceCategory *CSysNetDeviceCategoryFactory::internalAdd(CWriteableSysNetDeviceCategory *pSysNetDeviceCategory, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDeviceCategory++;
#endif
	CSysNetDeviceCategory *pTarget;	
	beforeAdd(pSysNetDeviceCategory);
	pTarget=(CSysNetDeviceCategory *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDeviceCategory in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDeviceCategory, sizeof(CSysNetDeviceCategory));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDeviceCategory *CSysNetDeviceCategoryFactory::add(CWriteableSysNetDeviceCategory *pSysNetDeviceCategory, CTransaction *pTransaction)
{
	pSysNetDeviceCategory->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDeviceCategory,true);
	}
	else {
		CSysNetDeviceCategory *pNewSysNetDeviceCategory;
		pNewSysNetDeviceCategory = internalAdd(pSysNetDeviceCategory,false);
		pTransaction->addResource(CSysNetDeviceCategoryResource::alloc(CREATE_ACTION,this,pNewSysNetDeviceCategory,NULL));
		return pNewSysNetDeviceCategory;
	}
}

void CSysNetDeviceCategoryFactory::internalUpdate(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pNewSysNetDeviceCategory, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDeviceCategory++;
	}
	else {
		updateWithoutIndexActionForSysNetDeviceCategory++;
	}
#endif
	CWriteableSysNetDeviceCategory theOldSysNetDeviceCategory;
	beforeUpdate(pSysNetDeviceCategory,pNewSysNetDeviceCategory);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceCategory,pSysNetDeviceCategory,sizeof(CSysNetDeviceCategory));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDeviceCategory,pNewSysNetDeviceCategory,sizeof(CSysNetDeviceCategory));
	pMem->updateObject(pSysNetDeviceCategory);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDeviceCategory);
	if (bNoTransaction) {
		commitUpdate(pSysNetDeviceCategory,&theOldSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::update(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pNewSysNetDeviceCategory, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDeviceCategory->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDeviceCategory,pNewSysNetDeviceCategory,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceCategoryResource::alloc(UPDATE_ACTION,this,pSysNetDeviceCategory,pNewSysNetDeviceCategory,updateIndex));
		internalUpdate(pSysNetDeviceCategory,pNewSysNetDeviceCategory,updateIndex,false);
	}
}

void CSysNetDeviceCategoryFactory::internalRemove(CSysNetDeviceCategory *pSysNetDeviceCategory, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDeviceCategory++;
#endif
	CWriteableSysNetDeviceCategory theOldSysNetDeviceCategory;
	beforeRemove(pSysNetDeviceCategory);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDeviceCategory,pSysNetDeviceCategory,sizeof(CSysNetDeviceCategory));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDeviceCategory);
	}
	pMem->free(pSysNetDeviceCategory);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::remove(CSysNetDeviceCategory *pSysNetDeviceCategory, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDeviceCategory,true);
	}
	else {
		pTransaction->addResource(CSysNetDeviceCategoryResource::alloc(DELETE_ACTION,this,pSysNetDeviceCategory,NULL));
		internalRemove(pSysNetDeviceCategory,false);		
	}
}

CSysNetDeviceCategory* CSysNetDeviceCategoryFactory::addOrUpdate(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pNewSysNetDeviceCategory, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDeviceCategory == NULL) {
		return add(pNewSysNetDeviceCategory,pTransaction);
	}
	else {
		update(pSysNetDeviceCategory,pNewSysNetDeviceCategory,pTransaction,updateIndex);
		return pSysNetDeviceCategory;
	}
}

void CSysNetDeviceCategoryFactory::retrieve(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pTargetSysNetDeviceCategory)
{
	forceCopy(pTargetSysNetDeviceCategory, pSysNetDeviceCategory, sizeof(CSysNetDeviceCategory));
}
	
int CSysNetDeviceCategoryFactory::addActionTrigger(CSysNetDeviceCategoryActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDeviceCategoryFactory::removeActionTrigger(CSysNetDeviceCategoryActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDeviceCategoryFactory::addCommitTrigger(CSysNetDeviceCategoryCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDeviceCategoryFactory::removeCommitTrigger(CSysNetDeviceCategoryCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDeviceCategory *CSysNetDeviceCategoryFactory::getFirst(void)
{
	CSysNetDeviceCategory *pResult=(CSysNetDeviceCategory *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDeviceCategory *CSysNetDeviceCategoryFactory::getNext(void)
{
	CSysNetDeviceCategory *pResult=(CSysNetDeviceCategory *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDeviceCategoryFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDeviceCategoryFactory::beforeAdd(CWriteableSysNetDeviceCategory *pSysNetDeviceCategory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDeviceCategory);
	}
}
	
void CSysNetDeviceCategoryFactory::afterAdd(CSysNetDeviceCategory *pSysNetDeviceCategory)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::beforeUpdate(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pNewSysNetDeviceCategory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDeviceCategory,pNewSysNetDeviceCategory);
	}
}
	
void CSysNetDeviceCategoryFactory::afterUpdate(CSysNetDeviceCategory *pSysNetDeviceCategory)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDeviceCategory);
	}
}
	
void CSysNetDeviceCategoryFactory::beforeRemove(CSysNetDeviceCategory *pSysNetDeviceCategory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::commitAdd(CSysNetDeviceCategory *pSysNetDeviceCategory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDeviceCategory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::commitUpdate(CSysNetDeviceCategory *pSysNetDeviceCategory, CWriteableSysNetDeviceCategory *pOldSysNetDeviceCategory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDeviceCategory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDeviceCategory,pOldSysNetDeviceCategory);
	}
}
	
void CSysNetDeviceCategoryFactory::commitRemove(CWriteableSysNetDeviceCategory *pSysNetDeviceCategory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDeviceCategory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDeviceCategory);
	}
}

void CSysNetDeviceCategoryFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetManufactory(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetManufactory=0;
int updateWithIndexActionForSysNetManufactory=0;
int updateWithoutIndexActionForSysNetManufactory=0;
int removeActionForSysNetManufactory=0;
int addCommitForSysNetManufactory=0;
int updateCommitForSysNetManufactory=0;
int removeCommitForSysNetManufactory=0;
#endif
void CSysNetManufactoryFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetManufactory,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetManufactory_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetManufactory_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetManufactory,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetManufactoryActionTrigger *>;
	pCommitTriggers=new vector<CSysNetManufactoryCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetManufactoryFactory::CSysNetManufactoryFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetManufactory),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetManufactoryFactory::CSysNetManufactoryFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetManufactory),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetManufactoryFactory::~CSysNetManufactoryFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetManufactoryFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetManufactoryFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetManufactoryFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetManufactory thisSysNetManufactory;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetManufactory.readCSV(input,pNames))
		add(&thisSysNetManufactory);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetManufactoryFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetManufactory.csv");
	return readCSV(szFileName);
}

int CSysNetManufactoryFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetManufactory *pSysNetManufactory;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetManufactory::writeCSVHead(output);
	pSysNetManufactory=(CWriteableSysNetManufactory *)(pMem->getFirst());
	while (pSysNetManufactory!=NULL) {
		if (!pSysNetManufactory->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetManufactory=(CWriteableSysNetManufactory *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetManufactoryFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetManufactory.csv");
	return writeCSV(szFileName);
}

void CSysNetManufactoryFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetManufactoryFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetManufactory *pSysNetManufactory;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetManufactoryFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetManufactory=(CWriteableSysNetManufactory *)(pMem->getFirst());
	while (pSysNetManufactory!=NULL) {
		pSysNetManufactory->dump(fp,index++);
		pSysNetManufactory=(CWriteableSysNetManufactory *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetManufactoryFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetManufactory *CSysNetManufactoryFactory::internalAdd(CWriteableSysNetManufactory *pSysNetManufactory, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetManufactory++;
#endif
	CSysNetManufactory *pTarget;	
	beforeAdd(pSysNetManufactory);
	pTarget=(CSysNetManufactory *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetManufactory in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetManufactory, sizeof(CSysNetManufactory));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetManufactory *CSysNetManufactoryFactory::add(CWriteableSysNetManufactory *pSysNetManufactory, CTransaction *pTransaction)
{
	pSysNetManufactory->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetManufactory,true);
	}
	else {
		CSysNetManufactory *pNewSysNetManufactory;
		pNewSysNetManufactory = internalAdd(pSysNetManufactory,false);
		pTransaction->addResource(CSysNetManufactoryResource::alloc(CREATE_ACTION,this,pNewSysNetManufactory,NULL));
		return pNewSysNetManufactory;
	}
}

void CSysNetManufactoryFactory::internalUpdate(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pNewSysNetManufactory, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetManufactory++;
	}
	else {
		updateWithoutIndexActionForSysNetManufactory++;
	}
#endif
	CWriteableSysNetManufactory theOldSysNetManufactory;
	beforeUpdate(pSysNetManufactory,pNewSysNetManufactory);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetManufactory,pSysNetManufactory,sizeof(CSysNetManufactory));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetManufactory,pNewSysNetManufactory,sizeof(CSysNetManufactory));
	pMem->updateObject(pSysNetManufactory);
	if (updateIndex) {
	}
	afterUpdate(pSysNetManufactory);
	if (bNoTransaction) {
		commitUpdate(pSysNetManufactory,&theOldSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::update(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pNewSysNetManufactory, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetManufactory->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetManufactory,pNewSysNetManufactory,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetManufactoryResource::alloc(UPDATE_ACTION,this,pSysNetManufactory,pNewSysNetManufactory,updateIndex));
		internalUpdate(pSysNetManufactory,pNewSysNetManufactory,updateIndex,false);
	}
}

void CSysNetManufactoryFactory::internalRemove(CSysNetManufactory *pSysNetManufactory, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetManufactory++;
#endif
	CWriteableSysNetManufactory theOldSysNetManufactory;
	beforeRemove(pSysNetManufactory);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetManufactory,pSysNetManufactory,sizeof(CSysNetManufactory));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetManufactory);
	}
	pMem->free(pSysNetManufactory);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::remove(CSysNetManufactory *pSysNetManufactory, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetManufactory,true);
	}
	else {
		pTransaction->addResource(CSysNetManufactoryResource::alloc(DELETE_ACTION,this,pSysNetManufactory,NULL));
		internalRemove(pSysNetManufactory,false);		
	}
}

CSysNetManufactory* CSysNetManufactoryFactory::addOrUpdate(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pNewSysNetManufactory, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetManufactory == NULL) {
		return add(pNewSysNetManufactory,pTransaction);
	}
	else {
		update(pSysNetManufactory,pNewSysNetManufactory,pTransaction,updateIndex);
		return pSysNetManufactory;
	}
}

void CSysNetManufactoryFactory::retrieve(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pTargetSysNetManufactory)
{
	forceCopy(pTargetSysNetManufactory, pSysNetManufactory, sizeof(CSysNetManufactory));
}
	
int CSysNetManufactoryFactory::addActionTrigger(CSysNetManufactoryActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetManufactoryFactory::removeActionTrigger(CSysNetManufactoryActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetManufactoryFactory::addCommitTrigger(CSysNetManufactoryCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetManufactoryFactory::removeCommitTrigger(CSysNetManufactoryCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetManufactory *CSysNetManufactoryFactory::getFirst(void)
{
	CSysNetManufactory *pResult=(CSysNetManufactory *)(pMem->getFirst());
	return pResult;
}
	
CSysNetManufactory *CSysNetManufactoryFactory::getNext(void)
{
	CSysNetManufactory *pResult=(CSysNetManufactory *)(pMem->getNext());
	return pResult;
}
	
void CSysNetManufactoryFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetManufactoryFactory::beforeAdd(CWriteableSysNetManufactory *pSysNetManufactory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetManufactory);
	}
}
	
void CSysNetManufactoryFactory::afterAdd(CSysNetManufactory *pSysNetManufactory)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::beforeUpdate(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pNewSysNetManufactory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetManufactory,pNewSysNetManufactory);
	}
}
	
void CSysNetManufactoryFactory::afterUpdate(CSysNetManufactory *pSysNetManufactory)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetManufactory);
	}
}
	
void CSysNetManufactoryFactory::beforeRemove(CSysNetManufactory *pSysNetManufactory)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::commitAdd(CSysNetManufactory *pSysNetManufactory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetManufactory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::commitUpdate(CSysNetManufactory *pSysNetManufactory, CWriteableSysNetManufactory *pOldSysNetManufactory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetManufactory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetManufactory,pOldSysNetManufactory);
	}
}
	
void CSysNetManufactoryFactory::commitRemove(CWriteableSysNetManufactory *pSysNetManufactory)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetManufactory++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetManufactory);
	}
}

void CSysNetManufactoryFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetCommunity(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetCommunity=0;
int updateWithIndexActionForSysNetCommunity=0;
int updateWithoutIndexActionForSysNetCommunity=0;
int removeActionForSysNetCommunity=0;
int addCommitForSysNetCommunity=0;
int updateCommitForSysNetCommunity=0;
int removeCommitForSysNetCommunity=0;
#endif
void CSysNetCommunityFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetCommunity,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetCommunity_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetCommunity_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetCommunity,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetCommunityActionTrigger *>;
	pCommitTriggers=new vector<CSysNetCommunityCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetCommunityFactory::CSysNetCommunityFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetCommunity),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetCommunityFactory::CSysNetCommunityFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetCommunity),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetCommunityFactory::~CSysNetCommunityFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetCommunityFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetCommunityFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetCommunityFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetCommunity thisSysNetCommunity;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetCommunity.readCSV(input,pNames))
		add(&thisSysNetCommunity);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetCommunityFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetCommunity.csv");
	return readCSV(szFileName);
}

int CSysNetCommunityFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetCommunity *pSysNetCommunity;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetCommunity::writeCSVHead(output);
	pSysNetCommunity=(CWriteableSysNetCommunity *)(pMem->getFirst());
	while (pSysNetCommunity!=NULL) {
		if (!pSysNetCommunity->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetCommunity=(CWriteableSysNetCommunity *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetCommunityFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetCommunity.csv");
	return writeCSV(szFileName);
}

void CSysNetCommunityFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetCommunityFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetCommunity *pSysNetCommunity;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetCommunityFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetCommunity=(CWriteableSysNetCommunity *)(pMem->getFirst());
	while (pSysNetCommunity!=NULL) {
		pSysNetCommunity->dump(fp,index++);
		pSysNetCommunity=(CWriteableSysNetCommunity *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetCommunityFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetCommunity *CSysNetCommunityFactory::internalAdd(CWriteableSysNetCommunity *pSysNetCommunity, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetCommunity++;
#endif
	CSysNetCommunity *pTarget;	
	beforeAdd(pSysNetCommunity);
	pTarget=(CSysNetCommunity *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetCommunity in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetCommunity, sizeof(CSysNetCommunity));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetCommunity *CSysNetCommunityFactory::add(CWriteableSysNetCommunity *pSysNetCommunity, CTransaction *pTransaction)
{
	pSysNetCommunity->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetCommunity,true);
	}
	else {
		CSysNetCommunity *pNewSysNetCommunity;
		pNewSysNetCommunity = internalAdd(pSysNetCommunity,false);
		pTransaction->addResource(CSysNetCommunityResource::alloc(CREATE_ACTION,this,pNewSysNetCommunity,NULL));
		return pNewSysNetCommunity;
	}
}

void CSysNetCommunityFactory::internalUpdate(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pNewSysNetCommunity, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetCommunity++;
	}
	else {
		updateWithoutIndexActionForSysNetCommunity++;
	}
#endif
	CWriteableSysNetCommunity theOldSysNetCommunity;
	beforeUpdate(pSysNetCommunity,pNewSysNetCommunity);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetCommunity,pSysNetCommunity,sizeof(CSysNetCommunity));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetCommunity,pNewSysNetCommunity,sizeof(CSysNetCommunity));
	pMem->updateObject(pSysNetCommunity);
	if (updateIndex) {
	}
	afterUpdate(pSysNetCommunity);
	if (bNoTransaction) {
		commitUpdate(pSysNetCommunity,&theOldSysNetCommunity);
	}
}

void CSysNetCommunityFactory::update(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pNewSysNetCommunity, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetCommunity->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetCommunity,pNewSysNetCommunity,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetCommunityResource::alloc(UPDATE_ACTION,this,pSysNetCommunity,pNewSysNetCommunity,updateIndex));
		internalUpdate(pSysNetCommunity,pNewSysNetCommunity,updateIndex,false);
	}
}

void CSysNetCommunityFactory::internalRemove(CSysNetCommunity *pSysNetCommunity, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetCommunity++;
#endif
	CWriteableSysNetCommunity theOldSysNetCommunity;
	beforeRemove(pSysNetCommunity);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetCommunity,pSysNetCommunity,sizeof(CSysNetCommunity));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetCommunity);
	}
	pMem->free(pSysNetCommunity);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetCommunity);
	}
}

void CSysNetCommunityFactory::remove(CSysNetCommunity *pSysNetCommunity, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetCommunity,true);
	}
	else {
		pTransaction->addResource(CSysNetCommunityResource::alloc(DELETE_ACTION,this,pSysNetCommunity,NULL));
		internalRemove(pSysNetCommunity,false);		
	}
}

CSysNetCommunity* CSysNetCommunityFactory::addOrUpdate(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pNewSysNetCommunity, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetCommunity == NULL) {
		return add(pNewSysNetCommunity,pTransaction);
	}
	else {
		update(pSysNetCommunity,pNewSysNetCommunity,pTransaction,updateIndex);
		return pSysNetCommunity;
	}
}

void CSysNetCommunityFactory::retrieve(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pTargetSysNetCommunity)
{
	forceCopy(pTargetSysNetCommunity, pSysNetCommunity, sizeof(CSysNetCommunity));
}
	
int CSysNetCommunityFactory::addActionTrigger(CSysNetCommunityActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetCommunityFactory::removeActionTrigger(CSysNetCommunityActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetCommunityFactory::addCommitTrigger(CSysNetCommunityCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetCommunityFactory::removeCommitTrigger(CSysNetCommunityCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetCommunity *CSysNetCommunityFactory::getFirst(void)
{
	CSysNetCommunity *pResult=(CSysNetCommunity *)(pMem->getFirst());
	return pResult;
}
	
CSysNetCommunity *CSysNetCommunityFactory::getNext(void)
{
	CSysNetCommunity *pResult=(CSysNetCommunity *)(pMem->getNext());
	return pResult;
}
	
void CSysNetCommunityFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetCommunityFactory::beforeAdd(CWriteableSysNetCommunity *pSysNetCommunity)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetCommunity);
	}
}
	
void CSysNetCommunityFactory::afterAdd(CSysNetCommunity *pSysNetCommunity)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetCommunity);
	}
}

void CSysNetCommunityFactory::beforeUpdate(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pNewSysNetCommunity)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetCommunity,pNewSysNetCommunity);
	}
}
	
void CSysNetCommunityFactory::afterUpdate(CSysNetCommunity *pSysNetCommunity)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetCommunity);
	}
}
	
void CSysNetCommunityFactory::beforeRemove(CSysNetCommunity *pSysNetCommunity)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetCommunity);
	}
}

void CSysNetCommunityFactory::commitAdd(CSysNetCommunity *pSysNetCommunity)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetCommunity++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetCommunity);
	}
}

void CSysNetCommunityFactory::commitUpdate(CSysNetCommunity *pSysNetCommunity, CWriteableSysNetCommunity *pOldSysNetCommunity)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetCommunity++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetCommunity,pOldSysNetCommunity);
	}
}
	
void CSysNetCommunityFactory::commitRemove(CWriteableSysNetCommunity *pSysNetCommunity)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetCommunity++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetCommunity);
	}
}

void CSysNetCommunityFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetPortType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetPortType=0;
int updateWithIndexActionForSysNetPortType=0;
int updateWithoutIndexActionForSysNetPortType=0;
int removeActionForSysNetPortType=0;
int addCommitForSysNetPortType=0;
int updateCommitForSysNetPortType=0;
int removeCommitForSysNetPortType=0;
#endif
void CSysNetPortTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPortType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetPortType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetPortType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPortType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetPortTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetPortTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetPortTypeFactory::CSysNetPortTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPortType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetPortTypeFactory::CSysNetPortTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPortType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetPortTypeFactory::~CSysNetPortTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetPortTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetPortTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetPortTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetPortType thisSysNetPortType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetPortType.readCSV(input,pNames))
		add(&thisSysNetPortType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetPortTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetPortType.csv");
	return readCSV(szFileName);
}

int CSysNetPortTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetPortType *pSysNetPortType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetPortType::writeCSVHead(output);
	pSysNetPortType=(CWriteableSysNetPortType *)(pMem->getFirst());
	while (pSysNetPortType!=NULL) {
		if (!pSysNetPortType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetPortType=(CWriteableSysNetPortType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetPortTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetPortType.csv");
	return writeCSV(szFileName);
}

void CSysNetPortTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetPortTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetPortType *pSysNetPortType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetPortTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetPortType=(CWriteableSysNetPortType *)(pMem->getFirst());
	while (pSysNetPortType!=NULL) {
		pSysNetPortType->dump(fp,index++);
		pSysNetPortType=(CWriteableSysNetPortType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetPortTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetPortType *CSysNetPortTypeFactory::internalAdd(CWriteableSysNetPortType *pSysNetPortType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetPortType++;
#endif
	CSysNetPortType *pTarget;	
	beforeAdd(pSysNetPortType);
	pTarget=(CSysNetPortType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetPortType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetPortType, sizeof(CSysNetPortType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetPortType *CSysNetPortTypeFactory::add(CWriteableSysNetPortType *pSysNetPortType, CTransaction *pTransaction)
{
	pSysNetPortType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetPortType,true);
	}
	else {
		CSysNetPortType *pNewSysNetPortType;
		pNewSysNetPortType = internalAdd(pSysNetPortType,false);
		pTransaction->addResource(CSysNetPortTypeResource::alloc(CREATE_ACTION,this,pNewSysNetPortType,NULL));
		return pNewSysNetPortType;
	}
}

void CSysNetPortTypeFactory::internalUpdate(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pNewSysNetPortType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetPortType++;
	}
	else {
		updateWithoutIndexActionForSysNetPortType++;
	}
#endif
	CWriteableSysNetPortType theOldSysNetPortType;
	beforeUpdate(pSysNetPortType,pNewSysNetPortType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPortType,pSysNetPortType,sizeof(CSysNetPortType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetPortType,pNewSysNetPortType,sizeof(CSysNetPortType));
	pMem->updateObject(pSysNetPortType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetPortType);
	if (bNoTransaction) {
		commitUpdate(pSysNetPortType,&theOldSysNetPortType);
	}
}

void CSysNetPortTypeFactory::update(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pNewSysNetPortType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetPortType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetPortType,pNewSysNetPortType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetPortTypeResource::alloc(UPDATE_ACTION,this,pSysNetPortType,pNewSysNetPortType,updateIndex));
		internalUpdate(pSysNetPortType,pNewSysNetPortType,updateIndex,false);
	}
}

void CSysNetPortTypeFactory::internalRemove(CSysNetPortType *pSysNetPortType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetPortType++;
#endif
	CWriteableSysNetPortType theOldSysNetPortType;
	beforeRemove(pSysNetPortType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPortType,pSysNetPortType,sizeof(CSysNetPortType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetPortType);
	}
	pMem->free(pSysNetPortType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetPortType);
	}
}

void CSysNetPortTypeFactory::remove(CSysNetPortType *pSysNetPortType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetPortType,true);
	}
	else {
		pTransaction->addResource(CSysNetPortTypeResource::alloc(DELETE_ACTION,this,pSysNetPortType,NULL));
		internalRemove(pSysNetPortType,false);		
	}
}

CSysNetPortType* CSysNetPortTypeFactory::addOrUpdate(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pNewSysNetPortType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetPortType == NULL) {
		return add(pNewSysNetPortType,pTransaction);
	}
	else {
		update(pSysNetPortType,pNewSysNetPortType,pTransaction,updateIndex);
		return pSysNetPortType;
	}
}

void CSysNetPortTypeFactory::retrieve(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pTargetSysNetPortType)
{
	forceCopy(pTargetSysNetPortType, pSysNetPortType, sizeof(CSysNetPortType));
}
	
int CSysNetPortTypeFactory::addActionTrigger(CSysNetPortTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetPortTypeFactory::removeActionTrigger(CSysNetPortTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetPortTypeFactory::addCommitTrigger(CSysNetPortTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetPortTypeFactory::removeCommitTrigger(CSysNetPortTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetPortType *CSysNetPortTypeFactory::getFirst(void)
{
	CSysNetPortType *pResult=(CSysNetPortType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetPortType *CSysNetPortTypeFactory::getNext(void)
{
	CSysNetPortType *pResult=(CSysNetPortType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetPortTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetPortTypeFactory::beforeAdd(CWriteableSysNetPortType *pSysNetPortType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetPortType);
	}
}
	
void CSysNetPortTypeFactory::afterAdd(CSysNetPortType *pSysNetPortType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetPortType);
	}
}

void CSysNetPortTypeFactory::beforeUpdate(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pNewSysNetPortType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetPortType,pNewSysNetPortType);
	}
}
	
void CSysNetPortTypeFactory::afterUpdate(CSysNetPortType *pSysNetPortType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetPortType);
	}
}
	
void CSysNetPortTypeFactory::beforeRemove(CSysNetPortType *pSysNetPortType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetPortType);
	}
}

void CSysNetPortTypeFactory::commitAdd(CSysNetPortType *pSysNetPortType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetPortType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetPortType);
	}
}

void CSysNetPortTypeFactory::commitUpdate(CSysNetPortType *pSysNetPortType, CWriteableSysNetPortType *pOldSysNetPortType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetPortType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetPortType,pOldSysNetPortType);
	}
}
	
void CSysNetPortTypeFactory::commitRemove(CWriteableSysNetPortType *pSysNetPortType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetPortType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetPortType);
	}
}

void CSysNetPortTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetInterface(const void *pV1, const void *pV2);
extern int compareForSysDeviceIDTypeIndexinSysNetInterface(const void *pV1, const void *pV2);
extern int compareForSysObjectIDTypeIndexinSysNetInterface(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetInterface=0;
int updateWithIndexActionForSysNetInterface=0;
int updateWithoutIndexActionForSysNetInterface=0;
int removeActionForSysNetInterface=0;
int addCommitForSysNetInterface=0;
int updateCommitForSysNetInterface=0;
int removeCommitForSysNetInterface=0;
#endif
void CSysNetInterfaceFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetInterface,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetInterface_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetInterface_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetInterface,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysDeviceIDTypeIndex=new CAVLTree(maxUnit,compareForSysDeviceIDTypeIndexinSysNetInterface,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetInterface_SysDeviceIDTypeIndex",pSysDeviceIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetInterface_SysDeviceIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysDeviceIDTypeIndex=new CAVLTree(maxUnit,compareForSysDeviceIDTypeIndexinSysNetInterface,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysDeviceIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetInterface,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetInterface_SysObjectIDTypeIndex",pSysObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetInterface_SysObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetInterface,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByDeviceID=NULL;
	pActionTriggers=new vector<CSysNetInterfaceActionTrigger *>;
	pCommitTriggers=new vector<CSysNetInterfaceCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetInterfaceFactory::CSysNetInterfaceFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetInterface),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetInterfaceFactory::CSysNetInterfaceFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetInterface),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetInterfaceFactory::~CSysNetInterfaceFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysDeviceIDTypeIndex!=NULL)
			delete pSysDeviceIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysObjectIDTypeIndex!=NULL)
			delete pSysObjectIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetInterfaceFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetInterfaceFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetInterfaceFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetInterface thisSysNetInterface;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetInterface.readCSV(input,pNames))
		add(&thisSysNetInterface);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetInterfaceFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetInterface.csv");
	return readCSV(szFileName);
}

int CSysNetInterfaceFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetInterface *pSysNetInterface;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetInterface::writeCSVHead(output);
	pSysNetInterface=(CWriteableSysNetInterface *)(pMem->getFirst());
	while (pSysNetInterface!=NULL) {
		if (!pSysNetInterface->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetInterface=(CWriteableSysNetInterface *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetInterfaceFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetInterface.csv");
	return writeCSV(szFileName);
}

void CSysNetInterfaceFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetInterfaceFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetInterface *pSysNetInterface;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetInterfaceFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetInterface=(CWriteableSysNetInterface *)(pMem->getFirst());
	while (pSysNetInterface!=NULL) {
		pSysNetInterface->dump(fp,index++);
		pSysNetInterface=(CWriteableSysNetInterface *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetInterfaceFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeAll();
	}
}

CSysNetInterface *CSysNetInterfaceFactory::internalAdd(CWriteableSysNetInterface *pSysNetInterface, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetInterface++;
#endif
	CSysNetInterface *pTarget;	
	beforeAdd(pSysNetInterface);
	pTarget=(CSysNetInterface *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetInterface in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetInterface, sizeof(CSysNetInterface));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetInterface *CSysNetInterfaceFactory::add(CWriteableSysNetInterface *pSysNetInterface, CTransaction *pTransaction)
{
	pSysNetInterface->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetInterface,true);
	}
	else {
		CSysNetInterface *pNewSysNetInterface;
		pNewSysNetInterface = internalAdd(pSysNetInterface,false);
		pTransaction->addResource(CSysNetInterfaceResource::alloc(CREATE_ACTION,this,pNewSysNetInterface,NULL));
		return pNewSysNetInterface;
	}
}

void CSysNetInterfaceFactory::internalUpdate(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pNewSysNetInterface, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetInterface++;
	}
	else {
		updateWithoutIndexActionForSysNetInterface++;
	}
#endif
	CWriteableSysNetInterface theOldSysNetInterface;
	beforeUpdate(pSysNetInterface,pNewSysNetInterface);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetInterface,pSysNetInterface,sizeof(CSysNetInterface));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetInterface,pNewSysNetInterface,sizeof(CSysNetInterface));
	pMem->updateObject(pSysNetInterface);
	if (updateIndex) {
	}
	afterUpdate(pSysNetInterface);
	if (bNoTransaction) {
		commitUpdate(pSysNetInterface,&theOldSysNetInterface);
	}
}

void CSysNetInterfaceFactory::update(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pNewSysNetInterface, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetInterface->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetInterface,pNewSysNetInterface,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetInterfaceResource::alloc(UPDATE_ACTION,this,pSysNetInterface,pNewSysNetInterface,updateIndex));
		internalUpdate(pSysNetInterface,pNewSysNetInterface,updateIndex,false);
	}
}

void CSysNetInterfaceFactory::internalRemove(CSysNetInterface *pSysNetInterface, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetInterface++;
#endif
	CWriteableSysNetInterface theOldSysNetInterface;
	beforeRemove(pSysNetInterface);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetInterface,pSysNetInterface,sizeof(CSysNetInterface));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetInterface);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->removeObject(pSysNetInterface);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeObject(pSysNetInterface);
	}
	pMem->free(pSysNetInterface);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetInterface);
	}
}

void CSysNetInterfaceFactory::remove(CSysNetInterface *pSysNetInterface, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetInterface,true);
	}
	else {
		pTransaction->addResource(CSysNetInterfaceResource::alloc(DELETE_ACTION,this,pSysNetInterface,NULL));
		internalRemove(pSysNetInterface,false);		
	}
}

CSysNetInterface* CSysNetInterfaceFactory::addOrUpdate(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pNewSysNetInterface, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetInterface == NULL) {
		return add(pNewSysNetInterface,pTransaction);
	}
	else {
		update(pSysNetInterface,pNewSysNetInterface,pTransaction,updateIndex);
		return pSysNetInterface;
	}
}

void CSysNetInterfaceFactory::retrieve(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pTargetSysNetInterface)
{
	forceCopy(pTargetSysNetInterface, pSysNetInterface, sizeof(CSysNetInterface));
}
	
int CSysNetInterfaceFactory::addActionTrigger(CSysNetInterfaceActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetInterfaceFactory::removeActionTrigger(CSysNetInterfaceActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetInterfaceFactory::addCommitTrigger(CSysNetInterfaceCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetInterfaceFactory::removeCommitTrigger(CSysNetInterfaceCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetInterface *CSysNetInterfaceFactory::getFirst(void)
{
	CSysNetInterface *pResult=(CSysNetInterface *)(pMem->getFirst());
	return pResult;
}
	
CSysNetInterface *CSysNetInterfaceFactory::getNext(void)
{
	CSysNetInterface *pResult=(CSysNetInterface *)(pMem->getNext());
	return pResult;
}
	
void CSysNetInterfaceFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetInterfaceFactory::beforeAdd(CWriteableSysNetInterface *pSysNetInterface)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetInterface);
	}
}
	
void CSysNetInterfaceFactory::afterAdd(CSysNetInterface *pSysNetInterface)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetInterface);
	}
}

void CSysNetInterfaceFactory::beforeUpdate(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pNewSysNetInterface)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetInterface,pNewSysNetInterface);
	}
}
	
void CSysNetInterfaceFactory::afterUpdate(CSysNetInterface *pSysNetInterface)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetInterface);
	}
}
	
void CSysNetInterfaceFactory::beforeRemove(CSysNetInterface *pSysNetInterface)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetInterface);
	}
}

void CSysNetInterfaceFactory::commitAdd(CSysNetInterface *pSysNetInterface)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetInterface++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetInterface);
	}
}

void CSysNetInterfaceFactory::commitUpdate(CSysNetInterface *pSysNetInterface, CWriteableSysNetInterface *pOldSysNetInterface)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetInterface++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetInterface,pOldSysNetInterface);
	}
}
	
void CSysNetInterfaceFactory::commitRemove(CWriteableSysNetInterface *pSysNetInterface)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetInterface++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetInterface);
	}
}

void CSysNetInterfaceFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetGeneralOID(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetGeneralOID=0;
int updateWithIndexActionForSysNetGeneralOID=0;
int updateWithoutIndexActionForSysNetGeneralOID=0;
int removeActionForSysNetGeneralOID=0;
int addCommitForSysNetGeneralOID=0;
int updateCommitForSysNetGeneralOID=0;
int removeCommitForSysNetGeneralOID=0;
#endif
void CSysNetGeneralOIDFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetGeneralOID,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetGeneralOID_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetGeneralOID_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetGeneralOID,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetGeneralOIDActionTrigger *>;
	pCommitTriggers=new vector<CSysNetGeneralOIDCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetGeneralOIDFactory::CSysNetGeneralOIDFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetGeneralOID),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetGeneralOIDFactory::CSysNetGeneralOIDFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetGeneralOID),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetGeneralOIDFactory::~CSysNetGeneralOIDFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetGeneralOIDFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetGeneralOIDFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetGeneralOIDFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetGeneralOID thisSysNetGeneralOID;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetGeneralOID.readCSV(input,pNames))
		add(&thisSysNetGeneralOID);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetGeneralOIDFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetGeneralOID.csv");
	return readCSV(szFileName);
}

int CSysNetGeneralOIDFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetGeneralOID *pSysNetGeneralOID;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetGeneralOID::writeCSVHead(output);
	pSysNetGeneralOID=(CWriteableSysNetGeneralOID *)(pMem->getFirst());
	while (pSysNetGeneralOID!=NULL) {
		if (!pSysNetGeneralOID->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetGeneralOID=(CWriteableSysNetGeneralOID *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetGeneralOIDFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetGeneralOID.csv");
	return writeCSV(szFileName);
}

void CSysNetGeneralOIDFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetGeneralOIDFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetGeneralOID *pSysNetGeneralOID;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetGeneralOIDFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetGeneralOID=(CWriteableSysNetGeneralOID *)(pMem->getFirst());
	while (pSysNetGeneralOID!=NULL) {
		pSysNetGeneralOID->dump(fp,index++);
		pSysNetGeneralOID=(CWriteableSysNetGeneralOID *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetGeneralOIDFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetGeneralOID *CSysNetGeneralOIDFactory::internalAdd(CWriteableSysNetGeneralOID *pSysNetGeneralOID, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetGeneralOID++;
#endif
	CSysNetGeneralOID *pTarget;	
	beforeAdd(pSysNetGeneralOID);
	pTarget=(CSysNetGeneralOID *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetGeneralOID in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetGeneralOID, sizeof(CSysNetGeneralOID));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetGeneralOID *CSysNetGeneralOIDFactory::add(CWriteableSysNetGeneralOID *pSysNetGeneralOID, CTransaction *pTransaction)
{
	pSysNetGeneralOID->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetGeneralOID,true);
	}
	else {
		CSysNetGeneralOID *pNewSysNetGeneralOID;
		pNewSysNetGeneralOID = internalAdd(pSysNetGeneralOID,false);
		pTransaction->addResource(CSysNetGeneralOIDResource::alloc(CREATE_ACTION,this,pNewSysNetGeneralOID,NULL));
		return pNewSysNetGeneralOID;
	}
}

void CSysNetGeneralOIDFactory::internalUpdate(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pNewSysNetGeneralOID, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetGeneralOID++;
	}
	else {
		updateWithoutIndexActionForSysNetGeneralOID++;
	}
#endif
	CWriteableSysNetGeneralOID theOldSysNetGeneralOID;
	beforeUpdate(pSysNetGeneralOID,pNewSysNetGeneralOID);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetGeneralOID,pSysNetGeneralOID,sizeof(CSysNetGeneralOID));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetGeneralOID,pNewSysNetGeneralOID,sizeof(CSysNetGeneralOID));
	pMem->updateObject(pSysNetGeneralOID);
	if (updateIndex) {
	}
	afterUpdate(pSysNetGeneralOID);
	if (bNoTransaction) {
		commitUpdate(pSysNetGeneralOID,&theOldSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::update(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pNewSysNetGeneralOID, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetGeneralOID->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetGeneralOID,pNewSysNetGeneralOID,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetGeneralOIDResource::alloc(UPDATE_ACTION,this,pSysNetGeneralOID,pNewSysNetGeneralOID,updateIndex));
		internalUpdate(pSysNetGeneralOID,pNewSysNetGeneralOID,updateIndex,false);
	}
}

void CSysNetGeneralOIDFactory::internalRemove(CSysNetGeneralOID *pSysNetGeneralOID, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetGeneralOID++;
#endif
	CWriteableSysNetGeneralOID theOldSysNetGeneralOID;
	beforeRemove(pSysNetGeneralOID);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetGeneralOID,pSysNetGeneralOID,sizeof(CSysNetGeneralOID));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetGeneralOID);
	}
	pMem->free(pSysNetGeneralOID);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::remove(CSysNetGeneralOID *pSysNetGeneralOID, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetGeneralOID,true);
	}
	else {
		pTransaction->addResource(CSysNetGeneralOIDResource::alloc(DELETE_ACTION,this,pSysNetGeneralOID,NULL));
		internalRemove(pSysNetGeneralOID,false);		
	}
}

CSysNetGeneralOID* CSysNetGeneralOIDFactory::addOrUpdate(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pNewSysNetGeneralOID, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetGeneralOID == NULL) {
		return add(pNewSysNetGeneralOID,pTransaction);
	}
	else {
		update(pSysNetGeneralOID,pNewSysNetGeneralOID,pTransaction,updateIndex);
		return pSysNetGeneralOID;
	}
}

void CSysNetGeneralOIDFactory::retrieve(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pTargetSysNetGeneralOID)
{
	forceCopy(pTargetSysNetGeneralOID, pSysNetGeneralOID, sizeof(CSysNetGeneralOID));
}
	
int CSysNetGeneralOIDFactory::addActionTrigger(CSysNetGeneralOIDActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetGeneralOIDFactory::removeActionTrigger(CSysNetGeneralOIDActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetGeneralOIDFactory::addCommitTrigger(CSysNetGeneralOIDCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetGeneralOIDFactory::removeCommitTrigger(CSysNetGeneralOIDCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetGeneralOID *CSysNetGeneralOIDFactory::getFirst(void)
{
	CSysNetGeneralOID *pResult=(CSysNetGeneralOID *)(pMem->getFirst());
	return pResult;
}
	
CSysNetGeneralOID *CSysNetGeneralOIDFactory::getNext(void)
{
	CSysNetGeneralOID *pResult=(CSysNetGeneralOID *)(pMem->getNext());
	return pResult;
}
	
void CSysNetGeneralOIDFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetGeneralOIDFactory::beforeAdd(CWriteableSysNetGeneralOID *pSysNetGeneralOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetGeneralOID);
	}
}
	
void CSysNetGeneralOIDFactory::afterAdd(CSysNetGeneralOID *pSysNetGeneralOID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::beforeUpdate(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pNewSysNetGeneralOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetGeneralOID,pNewSysNetGeneralOID);
	}
}
	
void CSysNetGeneralOIDFactory::afterUpdate(CSysNetGeneralOID *pSysNetGeneralOID)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetGeneralOID);
	}
}
	
void CSysNetGeneralOIDFactory::beforeRemove(CSysNetGeneralOID *pSysNetGeneralOID)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::commitAdd(CSysNetGeneralOID *pSysNetGeneralOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetGeneralOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::commitUpdate(CSysNetGeneralOID *pSysNetGeneralOID, CWriteableSysNetGeneralOID *pOldSysNetGeneralOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetGeneralOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetGeneralOID,pOldSysNetGeneralOID);
	}
}
	
void CSysNetGeneralOIDFactory::commitRemove(CWriteableSysNetGeneralOID *pSysNetGeneralOID)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetGeneralOID++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetGeneralOID);
	}
}

void CSysNetGeneralOIDFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorType=0;
int updateWithIndexActionForSysNetMonitorType=0;
int updateWithoutIndexActionForSysNetMonitorType=0;
int removeActionForSysNetMonitorType=0;
int addCommitForSysNetMonitorType=0;
int updateCommitForSysNetMonitorType=0;
int removeCommitForSysNetMonitorType=0;
#endif
void CSysNetMonitorTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorTypeFactory::CSysNetMonitorTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorTypeFactory::CSysNetMonitorTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorTypeFactory::~CSysNetMonitorTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorType thisSysNetMonitorType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorType.readCSV(input,pNames))
		add(&thisSysNetMonitorType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorType.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorType *pSysNetMonitorType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorType::writeCSVHead(output);
	pSysNetMonitorType=(CWriteableSysNetMonitorType *)(pMem->getFirst());
	while (pSysNetMonitorType!=NULL) {
		if (!pSysNetMonitorType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorType=(CWriteableSysNetMonitorType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorType.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorType *pSysNetMonitorType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorType=(CWriteableSysNetMonitorType *)(pMem->getFirst());
	while (pSysNetMonitorType!=NULL) {
		pSysNetMonitorType->dump(fp,index++);
		pSysNetMonitorType=(CWriteableSysNetMonitorType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorType *CSysNetMonitorTypeFactory::internalAdd(CWriteableSysNetMonitorType *pSysNetMonitorType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorType++;
#endif
	CSysNetMonitorType *pTarget;	
	beforeAdd(pSysNetMonitorType);
	pTarget=(CSysNetMonitorType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorType, sizeof(CSysNetMonitorType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorType *CSysNetMonitorTypeFactory::add(CWriteableSysNetMonitorType *pSysNetMonitorType, CTransaction *pTransaction)
{
	pSysNetMonitorType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorType,true);
	}
	else {
		CSysNetMonitorType *pNewSysNetMonitorType;
		pNewSysNetMonitorType = internalAdd(pSysNetMonitorType,false);
		pTransaction->addResource(CSysNetMonitorTypeResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorType,NULL));
		return pNewSysNetMonitorType;
	}
}

void CSysNetMonitorTypeFactory::internalUpdate(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pNewSysNetMonitorType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorType++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorType++;
	}
#endif
	CWriteableSysNetMonitorType theOldSysNetMonitorType;
	beforeUpdate(pSysNetMonitorType,pNewSysNetMonitorType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorType,pSysNetMonitorType,sizeof(CSysNetMonitorType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorType,pNewSysNetMonitorType,sizeof(CSysNetMonitorType));
	pMem->updateObject(pSysNetMonitorType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorType);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorType,&theOldSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::update(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pNewSysNetMonitorType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorType,pNewSysNetMonitorType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTypeResource::alloc(UPDATE_ACTION,this,pSysNetMonitorType,pNewSysNetMonitorType,updateIndex));
		internalUpdate(pSysNetMonitorType,pNewSysNetMonitorType,updateIndex,false);
	}
}

void CSysNetMonitorTypeFactory::internalRemove(CSysNetMonitorType *pSysNetMonitorType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorType++;
#endif
	CWriteableSysNetMonitorType theOldSysNetMonitorType;
	beforeRemove(pSysNetMonitorType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorType,pSysNetMonitorType,sizeof(CSysNetMonitorType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorType);
	}
	pMem->free(pSysNetMonitorType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::remove(CSysNetMonitorType *pSysNetMonitorType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorType,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTypeResource::alloc(DELETE_ACTION,this,pSysNetMonitorType,NULL));
		internalRemove(pSysNetMonitorType,false);		
	}
}

CSysNetMonitorType* CSysNetMonitorTypeFactory::addOrUpdate(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pNewSysNetMonitorType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorType == NULL) {
		return add(pNewSysNetMonitorType,pTransaction);
	}
	else {
		update(pSysNetMonitorType,pNewSysNetMonitorType,pTransaction,updateIndex);
		return pSysNetMonitorType;
	}
}

void CSysNetMonitorTypeFactory::retrieve(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pTargetSysNetMonitorType)
{
	forceCopy(pTargetSysNetMonitorType, pSysNetMonitorType, sizeof(CSysNetMonitorType));
}
	
int CSysNetMonitorTypeFactory::addActionTrigger(CSysNetMonitorTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorTypeFactory::removeActionTrigger(CSysNetMonitorTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorTypeFactory::addCommitTrigger(CSysNetMonitorTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorTypeFactory::removeCommitTrigger(CSysNetMonitorTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorType *CSysNetMonitorTypeFactory::getFirst(void)
{
	CSysNetMonitorType *pResult=(CSysNetMonitorType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorType *CSysNetMonitorTypeFactory::getNext(void)
{
	CSysNetMonitorType *pResult=(CSysNetMonitorType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorTypeFactory::beforeAdd(CWriteableSysNetMonitorType *pSysNetMonitorType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorType);
	}
}
	
void CSysNetMonitorTypeFactory::afterAdd(CSysNetMonitorType *pSysNetMonitorType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::beforeUpdate(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pNewSysNetMonitorType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorType,pNewSysNetMonitorType);
	}
}
	
void CSysNetMonitorTypeFactory::afterUpdate(CSysNetMonitorType *pSysNetMonitorType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorType);
	}
}
	
void CSysNetMonitorTypeFactory::beforeRemove(CSysNetMonitorType *pSysNetMonitorType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::commitAdd(CSysNetMonitorType *pSysNetMonitorType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::commitUpdate(CSysNetMonitorType *pSysNetMonitorType, CWriteableSysNetMonitorType *pOldSysNetMonitorType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorType,pOldSysNetMonitorType);
	}
}
	
void CSysNetMonitorTypeFactory::commitRemove(CWriteableSysNetMonitorType *pSysNetMonitorType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorType);
	}
}

void CSysNetMonitorTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorAttrScope(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorAttrScope=0;
int updateWithIndexActionForSysNetMonitorAttrScope=0;
int updateWithoutIndexActionForSysNetMonitorAttrScope=0;
int removeActionForSysNetMonitorAttrScope=0;
int addCommitForSysNetMonitorAttrScope=0;
int updateCommitForSysNetMonitorAttrScope=0;
int removeCommitForSysNetMonitorAttrScope=0;
#endif
void CSysNetMonitorAttrScopeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorAttrScope,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorAttrScope_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorAttrScope_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorAttrScope,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorAttrScopeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorAttrScopeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorAttrScopeFactory::CSysNetMonitorAttrScopeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorAttrScope),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorAttrScopeFactory::CSysNetMonitorAttrScopeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorAttrScope),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorAttrScopeFactory::~CSysNetMonitorAttrScopeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorAttrScopeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorAttrScopeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorAttrScopeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorAttrScope thisSysNetMonitorAttrScope;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorAttrScope.readCSV(input,pNames))
		add(&thisSysNetMonitorAttrScope);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorAttrScopeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorAttrScope.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorAttrScopeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorAttrScope::writeCSVHead(output);
	pSysNetMonitorAttrScope=(CWriteableSysNetMonitorAttrScope *)(pMem->getFirst());
	while (pSysNetMonitorAttrScope!=NULL) {
		if (!pSysNetMonitorAttrScope->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorAttrScope=(CWriteableSysNetMonitorAttrScope *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorAttrScopeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorAttrScope.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorAttrScopeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorAttrScopeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorAttrScopeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorAttrScope=(CWriteableSysNetMonitorAttrScope *)(pMem->getFirst());
	while (pSysNetMonitorAttrScope!=NULL) {
		pSysNetMonitorAttrScope->dump(fp,index++);
		pSysNetMonitorAttrScope=(CWriteableSysNetMonitorAttrScope *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorAttrScopeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorAttrScope *CSysNetMonitorAttrScopeFactory::internalAdd(CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorAttrScope++;
#endif
	CSysNetMonitorAttrScope *pTarget;	
	beforeAdd(pSysNetMonitorAttrScope);
	pTarget=(CSysNetMonitorAttrScope *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorAttrScope in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorAttrScope, sizeof(CSysNetMonitorAttrScope));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorAttrScope *CSysNetMonitorAttrScopeFactory::add(CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CTransaction *pTransaction)
{
	pSysNetMonitorAttrScope->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorAttrScope,true);
	}
	else {
		CSysNetMonitorAttrScope *pNewSysNetMonitorAttrScope;
		pNewSysNetMonitorAttrScope = internalAdd(pSysNetMonitorAttrScope,false);
		pTransaction->addResource(CSysNetMonitorAttrScopeResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorAttrScope,NULL));
		return pNewSysNetMonitorAttrScope;
	}
}

void CSysNetMonitorAttrScopeFactory::internalUpdate(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pNewSysNetMonitorAttrScope, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorAttrScope++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorAttrScope++;
	}
#endif
	CWriteableSysNetMonitorAttrScope theOldSysNetMonitorAttrScope;
	beforeUpdate(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorAttrScope,pSysNetMonitorAttrScope,sizeof(CSysNetMonitorAttrScope));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope,sizeof(CSysNetMonitorAttrScope));
	pMem->updateObject(pSysNetMonitorAttrScope);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorAttrScope);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorAttrScope,&theOldSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::update(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pNewSysNetMonitorAttrScope, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorAttrScope->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorAttrScopeResource::alloc(UPDATE_ACTION,this,pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope,updateIndex));
		internalUpdate(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope,updateIndex,false);
	}
}

void CSysNetMonitorAttrScopeFactory::internalRemove(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorAttrScope++;
#endif
	CWriteableSysNetMonitorAttrScope theOldSysNetMonitorAttrScope;
	beforeRemove(pSysNetMonitorAttrScope);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorAttrScope,pSysNetMonitorAttrScope,sizeof(CSysNetMonitorAttrScope));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorAttrScope);
	}
	pMem->free(pSysNetMonitorAttrScope);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::remove(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorAttrScope,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorAttrScopeResource::alloc(DELETE_ACTION,this,pSysNetMonitorAttrScope,NULL));
		internalRemove(pSysNetMonitorAttrScope,false);		
	}
}

CSysNetMonitorAttrScope* CSysNetMonitorAttrScopeFactory::addOrUpdate(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pNewSysNetMonitorAttrScope, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorAttrScope == NULL) {
		return add(pNewSysNetMonitorAttrScope,pTransaction);
	}
	else {
		update(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope,pTransaction,updateIndex);
		return pSysNetMonitorAttrScope;
	}
}

void CSysNetMonitorAttrScopeFactory::retrieve(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pTargetSysNetMonitorAttrScope)
{
	forceCopy(pTargetSysNetMonitorAttrScope, pSysNetMonitorAttrScope, sizeof(CSysNetMonitorAttrScope));
}
	
int CSysNetMonitorAttrScopeFactory::addActionTrigger(CSysNetMonitorAttrScopeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorAttrScopeFactory::removeActionTrigger(CSysNetMonitorAttrScopeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorAttrScopeFactory::addCommitTrigger(CSysNetMonitorAttrScopeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorAttrScopeFactory::removeCommitTrigger(CSysNetMonitorAttrScopeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorAttrScope *CSysNetMonitorAttrScopeFactory::getFirst(void)
{
	CSysNetMonitorAttrScope *pResult=(CSysNetMonitorAttrScope *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorAttrScope *CSysNetMonitorAttrScopeFactory::getNext(void)
{
	CSysNetMonitorAttrScope *pResult=(CSysNetMonitorAttrScope *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorAttrScopeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorAttrScopeFactory::beforeAdd(CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorAttrScope);
	}
}
	
void CSysNetMonitorAttrScopeFactory::afterAdd(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::beforeUpdate(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pNewSysNetMonitorAttrScope)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorAttrScope,pNewSysNetMonitorAttrScope);
	}
}
	
void CSysNetMonitorAttrScopeFactory::afterUpdate(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorAttrScope);
	}
}
	
void CSysNetMonitorAttrScopeFactory::beforeRemove(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::commitAdd(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorAttrScope++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::commitUpdate(CSysNetMonitorAttrScope *pSysNetMonitorAttrScope, CWriteableSysNetMonitorAttrScope *pOldSysNetMonitorAttrScope)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorAttrScope++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorAttrScope,pOldSysNetMonitorAttrScope);
	}
}
	
void CSysNetMonitorAttrScopeFactory::commitRemove(CWriteableSysNetMonitorAttrScope *pSysNetMonitorAttrScope)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorAttrScope++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorAttrScope);
	}
}

void CSysNetMonitorAttrScopeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorAttrType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorAttrType=0;
int updateWithIndexActionForSysNetMonitorAttrType=0;
int updateWithoutIndexActionForSysNetMonitorAttrType=0;
int removeActionForSysNetMonitorAttrType=0;
int addCommitForSysNetMonitorAttrType=0;
int updateCommitForSysNetMonitorAttrType=0;
int removeCommitForSysNetMonitorAttrType=0;
#endif
void CSysNetMonitorAttrTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorAttrType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorAttrType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorAttrType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorAttrType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorAttrTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorAttrTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorAttrTypeFactory::CSysNetMonitorAttrTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorAttrType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorAttrTypeFactory::CSysNetMonitorAttrTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorAttrType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorAttrTypeFactory::~CSysNetMonitorAttrTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorAttrTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorAttrTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorAttrTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorAttrType thisSysNetMonitorAttrType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorAttrType.readCSV(input,pNames))
		add(&thisSysNetMonitorAttrType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorAttrTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorAttrType.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorAttrTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorAttrType::writeCSVHead(output);
	pSysNetMonitorAttrType=(CWriteableSysNetMonitorAttrType *)(pMem->getFirst());
	while (pSysNetMonitorAttrType!=NULL) {
		if (!pSysNetMonitorAttrType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorAttrType=(CWriteableSysNetMonitorAttrType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorAttrTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorAttrType.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorAttrTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorAttrTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorAttrTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorAttrType=(CWriteableSysNetMonitorAttrType *)(pMem->getFirst());
	while (pSysNetMonitorAttrType!=NULL) {
		pSysNetMonitorAttrType->dump(fp,index++);
		pSysNetMonitorAttrType=(CWriteableSysNetMonitorAttrType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorAttrTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorAttrType *CSysNetMonitorAttrTypeFactory::internalAdd(CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorAttrType++;
#endif
	CSysNetMonitorAttrType *pTarget;	
	beforeAdd(pSysNetMonitorAttrType);
	pTarget=(CSysNetMonitorAttrType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorAttrType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorAttrType, sizeof(CSysNetMonitorAttrType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorAttrType *CSysNetMonitorAttrTypeFactory::add(CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType, CTransaction *pTransaction)
{
	pSysNetMonitorAttrType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorAttrType,true);
	}
	else {
		CSysNetMonitorAttrType *pNewSysNetMonitorAttrType;
		pNewSysNetMonitorAttrType = internalAdd(pSysNetMonitorAttrType,false);
		pTransaction->addResource(CSysNetMonitorAttrTypeResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorAttrType,NULL));
		return pNewSysNetMonitorAttrType;
	}
}

void CSysNetMonitorAttrTypeFactory::internalUpdate(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pNewSysNetMonitorAttrType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorAttrType++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorAttrType++;
	}
#endif
	CWriteableSysNetMonitorAttrType theOldSysNetMonitorAttrType;
	beforeUpdate(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorAttrType,pSysNetMonitorAttrType,sizeof(CSysNetMonitorAttrType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType,sizeof(CSysNetMonitorAttrType));
	pMem->updateObject(pSysNetMonitorAttrType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorAttrType);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorAttrType,&theOldSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::update(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pNewSysNetMonitorAttrType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorAttrType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorAttrTypeResource::alloc(UPDATE_ACTION,this,pSysNetMonitorAttrType,pNewSysNetMonitorAttrType,updateIndex));
		internalUpdate(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType,updateIndex,false);
	}
}

void CSysNetMonitorAttrTypeFactory::internalRemove(CSysNetMonitorAttrType *pSysNetMonitorAttrType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorAttrType++;
#endif
	CWriteableSysNetMonitorAttrType theOldSysNetMonitorAttrType;
	beforeRemove(pSysNetMonitorAttrType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorAttrType,pSysNetMonitorAttrType,sizeof(CSysNetMonitorAttrType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorAttrType);
	}
	pMem->free(pSysNetMonitorAttrType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::remove(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorAttrType,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorAttrTypeResource::alloc(DELETE_ACTION,this,pSysNetMonitorAttrType,NULL));
		internalRemove(pSysNetMonitorAttrType,false);		
	}
}

CSysNetMonitorAttrType* CSysNetMonitorAttrTypeFactory::addOrUpdate(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pNewSysNetMonitorAttrType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorAttrType == NULL) {
		return add(pNewSysNetMonitorAttrType,pTransaction);
	}
	else {
		update(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType,pTransaction,updateIndex);
		return pSysNetMonitorAttrType;
	}
}

void CSysNetMonitorAttrTypeFactory::retrieve(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pTargetSysNetMonitorAttrType)
{
	forceCopy(pTargetSysNetMonitorAttrType, pSysNetMonitorAttrType, sizeof(CSysNetMonitorAttrType));
}
	
int CSysNetMonitorAttrTypeFactory::addActionTrigger(CSysNetMonitorAttrTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorAttrTypeFactory::removeActionTrigger(CSysNetMonitorAttrTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorAttrTypeFactory::addCommitTrigger(CSysNetMonitorAttrTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorAttrTypeFactory::removeCommitTrigger(CSysNetMonitorAttrTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorAttrType *CSysNetMonitorAttrTypeFactory::getFirst(void)
{
	CSysNetMonitorAttrType *pResult=(CSysNetMonitorAttrType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorAttrType *CSysNetMonitorAttrTypeFactory::getNext(void)
{
	CSysNetMonitorAttrType *pResult=(CSysNetMonitorAttrType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorAttrTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorAttrTypeFactory::beforeAdd(CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorAttrType);
	}
}
	
void CSysNetMonitorAttrTypeFactory::afterAdd(CSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::beforeUpdate(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pNewSysNetMonitorAttrType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorAttrType,pNewSysNetMonitorAttrType);
	}
}
	
void CSysNetMonitorAttrTypeFactory::afterUpdate(CSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorAttrType);
	}
}
	
void CSysNetMonitorAttrTypeFactory::beforeRemove(CSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::commitAdd(CSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorAttrType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::commitUpdate(CSysNetMonitorAttrType *pSysNetMonitorAttrType, CWriteableSysNetMonitorAttrType *pOldSysNetMonitorAttrType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorAttrType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorAttrType,pOldSysNetMonitorAttrType);
	}
}
	
void CSysNetMonitorAttrTypeFactory::commitRemove(CWriteableSysNetMonitorAttrType *pSysNetMonitorAttrType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorAttrType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorAttrType);
	}
}

void CSysNetMonitorAttrTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorCommandType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorCommandType=0;
int updateWithIndexActionForSysNetMonitorCommandType=0;
int updateWithoutIndexActionForSysNetMonitorCommandType=0;
int removeActionForSysNetMonitorCommandType=0;
int addCommitForSysNetMonitorCommandType=0;
int updateCommitForSysNetMonitorCommandType=0;
int removeCommitForSysNetMonitorCommandType=0;
#endif
void CSysNetMonitorCommandTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorCommandType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorCommandType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorCommandType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorCommandType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorCommandTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorCommandTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorCommandTypeFactory::CSysNetMonitorCommandTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorCommandType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorCommandTypeFactory::CSysNetMonitorCommandTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorCommandType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorCommandTypeFactory::~CSysNetMonitorCommandTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorCommandTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorCommandTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorCommandTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorCommandType thisSysNetMonitorCommandType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorCommandType.readCSV(input,pNames))
		add(&thisSysNetMonitorCommandType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorCommandTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorCommandType.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorCommandTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorCommandType::writeCSVHead(output);
	pSysNetMonitorCommandType=(CWriteableSysNetMonitorCommandType *)(pMem->getFirst());
	while (pSysNetMonitorCommandType!=NULL) {
		if (!pSysNetMonitorCommandType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorCommandType=(CWriteableSysNetMonitorCommandType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorCommandTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorCommandType.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorCommandTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorCommandTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorCommandTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorCommandType=(CWriteableSysNetMonitorCommandType *)(pMem->getFirst());
	while (pSysNetMonitorCommandType!=NULL) {
		pSysNetMonitorCommandType->dump(fp,index++);
		pSysNetMonitorCommandType=(CWriteableSysNetMonitorCommandType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorCommandTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorCommandType *CSysNetMonitorCommandTypeFactory::internalAdd(CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorCommandType++;
#endif
	CSysNetMonitorCommandType *pTarget;	
	beforeAdd(pSysNetMonitorCommandType);
	pTarget=(CSysNetMonitorCommandType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorCommandType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorCommandType, sizeof(CSysNetMonitorCommandType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorCommandType *CSysNetMonitorCommandTypeFactory::add(CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType, CTransaction *pTransaction)
{
	pSysNetMonitorCommandType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorCommandType,true);
	}
	else {
		CSysNetMonitorCommandType *pNewSysNetMonitorCommandType;
		pNewSysNetMonitorCommandType = internalAdd(pSysNetMonitorCommandType,false);
		pTransaction->addResource(CSysNetMonitorCommandTypeResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorCommandType,NULL));
		return pNewSysNetMonitorCommandType;
	}
}

void CSysNetMonitorCommandTypeFactory::internalUpdate(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pNewSysNetMonitorCommandType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorCommandType++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorCommandType++;
	}
#endif
	CWriteableSysNetMonitorCommandType theOldSysNetMonitorCommandType;
	beforeUpdate(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorCommandType,pSysNetMonitorCommandType,sizeof(CSysNetMonitorCommandType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType,sizeof(CSysNetMonitorCommandType));
	pMem->updateObject(pSysNetMonitorCommandType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorCommandType);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorCommandType,&theOldSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::update(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pNewSysNetMonitorCommandType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorCommandType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorCommandTypeResource::alloc(UPDATE_ACTION,this,pSysNetMonitorCommandType,pNewSysNetMonitorCommandType,updateIndex));
		internalUpdate(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType,updateIndex,false);
	}
}

void CSysNetMonitorCommandTypeFactory::internalRemove(CSysNetMonitorCommandType *pSysNetMonitorCommandType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorCommandType++;
#endif
	CWriteableSysNetMonitorCommandType theOldSysNetMonitorCommandType;
	beforeRemove(pSysNetMonitorCommandType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorCommandType,pSysNetMonitorCommandType,sizeof(CSysNetMonitorCommandType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorCommandType);
	}
	pMem->free(pSysNetMonitorCommandType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::remove(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorCommandType,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorCommandTypeResource::alloc(DELETE_ACTION,this,pSysNetMonitorCommandType,NULL));
		internalRemove(pSysNetMonitorCommandType,false);		
	}
}

CSysNetMonitorCommandType* CSysNetMonitorCommandTypeFactory::addOrUpdate(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pNewSysNetMonitorCommandType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorCommandType == NULL) {
		return add(pNewSysNetMonitorCommandType,pTransaction);
	}
	else {
		update(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType,pTransaction,updateIndex);
		return pSysNetMonitorCommandType;
	}
}

void CSysNetMonitorCommandTypeFactory::retrieve(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pTargetSysNetMonitorCommandType)
{
	forceCopy(pTargetSysNetMonitorCommandType, pSysNetMonitorCommandType, sizeof(CSysNetMonitorCommandType));
}
	
int CSysNetMonitorCommandTypeFactory::addActionTrigger(CSysNetMonitorCommandTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorCommandTypeFactory::removeActionTrigger(CSysNetMonitorCommandTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorCommandTypeFactory::addCommitTrigger(CSysNetMonitorCommandTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorCommandTypeFactory::removeCommitTrigger(CSysNetMonitorCommandTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorCommandType *CSysNetMonitorCommandTypeFactory::getFirst(void)
{
	CSysNetMonitorCommandType *pResult=(CSysNetMonitorCommandType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorCommandType *CSysNetMonitorCommandTypeFactory::getNext(void)
{
	CSysNetMonitorCommandType *pResult=(CSysNetMonitorCommandType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorCommandTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorCommandTypeFactory::beforeAdd(CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorCommandType);
	}
}
	
void CSysNetMonitorCommandTypeFactory::afterAdd(CSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::beforeUpdate(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pNewSysNetMonitorCommandType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorCommandType,pNewSysNetMonitorCommandType);
	}
}
	
void CSysNetMonitorCommandTypeFactory::afterUpdate(CSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorCommandType);
	}
}
	
void CSysNetMonitorCommandTypeFactory::beforeRemove(CSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::commitAdd(CSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorCommandType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::commitUpdate(CSysNetMonitorCommandType *pSysNetMonitorCommandType, CWriteableSysNetMonitorCommandType *pOldSysNetMonitorCommandType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorCommandType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorCommandType,pOldSysNetMonitorCommandType);
	}
}
	
void CSysNetMonitorCommandTypeFactory::commitRemove(CWriteableSysNetMonitorCommandType *pSysNetMonitorCommandType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorCommandType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorCommandType);
	}
}

void CSysNetMonitorCommandTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorActionGroup(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorActionGroup=0;
int updateWithIndexActionForSysNetMonitorActionGroup=0;
int updateWithoutIndexActionForSysNetMonitorActionGroup=0;
int removeActionForSysNetMonitorActionGroup=0;
int addCommitForSysNetMonitorActionGroup=0;
int updateCommitForSysNetMonitorActionGroup=0;
int removeCommitForSysNetMonitorActionGroup=0;
#endif
void CSysNetMonitorActionGroupFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorActionGroup,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorActionGroup_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorActionGroup_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorActionGroup,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorActionGroupActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorActionGroupCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorActionGroupFactory::CSysNetMonitorActionGroupFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorActionGroup),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorActionGroupFactory::CSysNetMonitorActionGroupFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorActionGroup),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorActionGroupFactory::~CSysNetMonitorActionGroupFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorActionGroupFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorActionGroupFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorActionGroupFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorActionGroup thisSysNetMonitorActionGroup;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorActionGroup.readCSV(input,pNames))
		add(&thisSysNetMonitorActionGroup);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorActionGroupFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorActionGroup.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorActionGroupFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorActionGroup::writeCSVHead(output);
	pSysNetMonitorActionGroup=(CWriteableSysNetMonitorActionGroup *)(pMem->getFirst());
	while (pSysNetMonitorActionGroup!=NULL) {
		if (!pSysNetMonitorActionGroup->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorActionGroup=(CWriteableSysNetMonitorActionGroup *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorActionGroupFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorActionGroup.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorActionGroupFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorActionGroupFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorActionGroupFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorActionGroup=(CWriteableSysNetMonitorActionGroup *)(pMem->getFirst());
	while (pSysNetMonitorActionGroup!=NULL) {
		pSysNetMonitorActionGroup->dump(fp,index++);
		pSysNetMonitorActionGroup=(CWriteableSysNetMonitorActionGroup *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorActionGroupFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorActionGroup *CSysNetMonitorActionGroupFactory::internalAdd(CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorActionGroup++;
#endif
	CSysNetMonitorActionGroup *pTarget;	
	beforeAdd(pSysNetMonitorActionGroup);
	pTarget=(CSysNetMonitorActionGroup *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorActionGroup in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorActionGroup, sizeof(CSysNetMonitorActionGroup));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorActionGroup *CSysNetMonitorActionGroupFactory::add(CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CTransaction *pTransaction)
{
	pSysNetMonitorActionGroup->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorActionGroup,true);
	}
	else {
		CSysNetMonitorActionGroup *pNewSysNetMonitorActionGroup;
		pNewSysNetMonitorActionGroup = internalAdd(pSysNetMonitorActionGroup,false);
		pTransaction->addResource(CSysNetMonitorActionGroupResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorActionGroup,NULL));
		return pNewSysNetMonitorActionGroup;
	}
}

void CSysNetMonitorActionGroupFactory::internalUpdate(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pNewSysNetMonitorActionGroup, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorActionGroup++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorActionGroup++;
	}
#endif
	CWriteableSysNetMonitorActionGroup theOldSysNetMonitorActionGroup;
	beforeUpdate(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorActionGroup,pSysNetMonitorActionGroup,sizeof(CSysNetMonitorActionGroup));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup,sizeof(CSysNetMonitorActionGroup));
	pMem->updateObject(pSysNetMonitorActionGroup);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorActionGroup);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorActionGroup,&theOldSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::update(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pNewSysNetMonitorActionGroup, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorActionGroup->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorActionGroupResource::alloc(UPDATE_ACTION,this,pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup,updateIndex));
		internalUpdate(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup,updateIndex,false);
	}
}

void CSysNetMonitorActionGroupFactory::internalRemove(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorActionGroup++;
#endif
	CWriteableSysNetMonitorActionGroup theOldSysNetMonitorActionGroup;
	beforeRemove(pSysNetMonitorActionGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorActionGroup,pSysNetMonitorActionGroup,sizeof(CSysNetMonitorActionGroup));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorActionGroup);
	}
	pMem->free(pSysNetMonitorActionGroup);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::remove(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorActionGroup,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorActionGroupResource::alloc(DELETE_ACTION,this,pSysNetMonitorActionGroup,NULL));
		internalRemove(pSysNetMonitorActionGroup,false);		
	}
}

CSysNetMonitorActionGroup* CSysNetMonitorActionGroupFactory::addOrUpdate(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pNewSysNetMonitorActionGroup, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorActionGroup == NULL) {
		return add(pNewSysNetMonitorActionGroup,pTransaction);
	}
	else {
		update(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup,pTransaction,updateIndex);
		return pSysNetMonitorActionGroup;
	}
}

void CSysNetMonitorActionGroupFactory::retrieve(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pTargetSysNetMonitorActionGroup)
{
	forceCopy(pTargetSysNetMonitorActionGroup, pSysNetMonitorActionGroup, sizeof(CSysNetMonitorActionGroup));
}
	
int CSysNetMonitorActionGroupFactory::addActionTrigger(CSysNetMonitorActionGroupActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorActionGroupFactory::removeActionTrigger(CSysNetMonitorActionGroupActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorActionGroupFactory::addCommitTrigger(CSysNetMonitorActionGroupCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorActionGroupFactory::removeCommitTrigger(CSysNetMonitorActionGroupCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorActionGroup *CSysNetMonitorActionGroupFactory::getFirst(void)
{
	CSysNetMonitorActionGroup *pResult=(CSysNetMonitorActionGroup *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorActionGroup *CSysNetMonitorActionGroupFactory::getNext(void)
{
	CSysNetMonitorActionGroup *pResult=(CSysNetMonitorActionGroup *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorActionGroupFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorActionGroupFactory::beforeAdd(CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorActionGroup);
	}
}
	
void CSysNetMonitorActionGroupFactory::afterAdd(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::beforeUpdate(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pNewSysNetMonitorActionGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorActionGroup,pNewSysNetMonitorActionGroup);
	}
}
	
void CSysNetMonitorActionGroupFactory::afterUpdate(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorActionGroup);
	}
}
	
void CSysNetMonitorActionGroupFactory::beforeRemove(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::commitAdd(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorActionGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::commitUpdate(CSysNetMonitorActionGroup *pSysNetMonitorActionGroup, CWriteableSysNetMonitorActionGroup *pOldSysNetMonitorActionGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorActionGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorActionGroup,pOldSysNetMonitorActionGroup);
	}
}
	
void CSysNetMonitorActionGroupFactory::commitRemove(CWriteableSysNetMonitorActionGroup *pSysNetMonitorActionGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorActionGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorActionGroup);
	}
}

void CSysNetMonitorActionGroupFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorDeviceGroup(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorDeviceGroup=0;
int updateWithIndexActionForSysNetMonitorDeviceGroup=0;
int updateWithoutIndexActionForSysNetMonitorDeviceGroup=0;
int removeActionForSysNetMonitorDeviceGroup=0;
int addCommitForSysNetMonitorDeviceGroup=0;
int updateCommitForSysNetMonitorDeviceGroup=0;
int removeCommitForSysNetMonitorDeviceGroup=0;
#endif
void CSysNetMonitorDeviceGroupFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorDeviceGroup,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorDeviceGroup_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorDeviceGroup_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorDeviceGroup,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorDeviceGroupActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorDeviceGroupCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorDeviceGroupFactory::CSysNetMonitorDeviceGroupFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorDeviceGroup),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorDeviceGroupFactory::CSysNetMonitorDeviceGroupFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorDeviceGroup),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorDeviceGroupFactory::~CSysNetMonitorDeviceGroupFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorDeviceGroupFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorDeviceGroupFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorDeviceGroupFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorDeviceGroup thisSysNetMonitorDeviceGroup;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorDeviceGroup.readCSV(input,pNames))
		add(&thisSysNetMonitorDeviceGroup);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorDeviceGroupFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorDeviceGroup.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorDeviceGroupFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorDeviceGroup::writeCSVHead(output);
	pSysNetMonitorDeviceGroup=(CWriteableSysNetMonitorDeviceGroup *)(pMem->getFirst());
	while (pSysNetMonitorDeviceGroup!=NULL) {
		if (!pSysNetMonitorDeviceGroup->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorDeviceGroup=(CWriteableSysNetMonitorDeviceGroup *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorDeviceGroupFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorDeviceGroup.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorDeviceGroupFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorDeviceGroupFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorDeviceGroupFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorDeviceGroup=(CWriteableSysNetMonitorDeviceGroup *)(pMem->getFirst());
	while (pSysNetMonitorDeviceGroup!=NULL) {
		pSysNetMonitorDeviceGroup->dump(fp,index++);
		pSysNetMonitorDeviceGroup=(CWriteableSysNetMonitorDeviceGroup *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorDeviceGroupFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorDeviceGroup *CSysNetMonitorDeviceGroupFactory::internalAdd(CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorDeviceGroup++;
#endif
	CSysNetMonitorDeviceGroup *pTarget;	
	beforeAdd(pSysNetMonitorDeviceGroup);
	pTarget=(CSysNetMonitorDeviceGroup *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorDeviceGroup in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorDeviceGroup, sizeof(CSysNetMonitorDeviceGroup));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorDeviceGroup *CSysNetMonitorDeviceGroupFactory::add(CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CTransaction *pTransaction)
{
	pSysNetMonitorDeviceGroup->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorDeviceGroup,true);
	}
	else {
		CSysNetMonitorDeviceGroup *pNewSysNetMonitorDeviceGroup;
		pNewSysNetMonitorDeviceGroup = internalAdd(pSysNetMonitorDeviceGroup,false);
		pTransaction->addResource(CSysNetMonitorDeviceGroupResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorDeviceGroup,NULL));
		return pNewSysNetMonitorDeviceGroup;
	}
}

void CSysNetMonitorDeviceGroupFactory::internalUpdate(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pNewSysNetMonitorDeviceGroup, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorDeviceGroup++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorDeviceGroup++;
	}
#endif
	CWriteableSysNetMonitorDeviceGroup theOldSysNetMonitorDeviceGroup;
	beforeUpdate(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorDeviceGroup,pSysNetMonitorDeviceGroup,sizeof(CSysNetMonitorDeviceGroup));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup,sizeof(CSysNetMonitorDeviceGroup));
	pMem->updateObject(pSysNetMonitorDeviceGroup);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorDeviceGroup);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorDeviceGroup,&theOldSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::update(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pNewSysNetMonitorDeviceGroup, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorDeviceGroup->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorDeviceGroupResource::alloc(UPDATE_ACTION,this,pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup,updateIndex));
		internalUpdate(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup,updateIndex,false);
	}
}

void CSysNetMonitorDeviceGroupFactory::internalRemove(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorDeviceGroup++;
#endif
	CWriteableSysNetMonitorDeviceGroup theOldSysNetMonitorDeviceGroup;
	beforeRemove(pSysNetMonitorDeviceGroup);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorDeviceGroup,pSysNetMonitorDeviceGroup,sizeof(CSysNetMonitorDeviceGroup));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorDeviceGroup);
	}
	pMem->free(pSysNetMonitorDeviceGroup);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::remove(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorDeviceGroup,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorDeviceGroupResource::alloc(DELETE_ACTION,this,pSysNetMonitorDeviceGroup,NULL));
		internalRemove(pSysNetMonitorDeviceGroup,false);		
	}
}

CSysNetMonitorDeviceGroup* CSysNetMonitorDeviceGroupFactory::addOrUpdate(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pNewSysNetMonitorDeviceGroup, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorDeviceGroup == NULL) {
		return add(pNewSysNetMonitorDeviceGroup,pTransaction);
	}
	else {
		update(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup,pTransaction,updateIndex);
		return pSysNetMonitorDeviceGroup;
	}
}

void CSysNetMonitorDeviceGroupFactory::retrieve(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pTargetSysNetMonitorDeviceGroup)
{
	forceCopy(pTargetSysNetMonitorDeviceGroup, pSysNetMonitorDeviceGroup, sizeof(CSysNetMonitorDeviceGroup));
}
	
int CSysNetMonitorDeviceGroupFactory::addActionTrigger(CSysNetMonitorDeviceGroupActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorDeviceGroupFactory::removeActionTrigger(CSysNetMonitorDeviceGroupActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorDeviceGroupFactory::addCommitTrigger(CSysNetMonitorDeviceGroupCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorDeviceGroupFactory::removeCommitTrigger(CSysNetMonitorDeviceGroupCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorDeviceGroup *CSysNetMonitorDeviceGroupFactory::getFirst(void)
{
	CSysNetMonitorDeviceGroup *pResult=(CSysNetMonitorDeviceGroup *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorDeviceGroup *CSysNetMonitorDeviceGroupFactory::getNext(void)
{
	CSysNetMonitorDeviceGroup *pResult=(CSysNetMonitorDeviceGroup *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorDeviceGroupFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorDeviceGroupFactory::beforeAdd(CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorDeviceGroup);
	}
}
	
void CSysNetMonitorDeviceGroupFactory::afterAdd(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::beforeUpdate(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pNewSysNetMonitorDeviceGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorDeviceGroup,pNewSysNetMonitorDeviceGroup);
	}
}
	
void CSysNetMonitorDeviceGroupFactory::afterUpdate(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorDeviceGroup);
	}
}
	
void CSysNetMonitorDeviceGroupFactory::beforeRemove(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::commitAdd(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorDeviceGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::commitUpdate(CSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup, CWriteableSysNetMonitorDeviceGroup *pOldSysNetMonitorDeviceGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorDeviceGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorDeviceGroup,pOldSysNetMonitorDeviceGroup);
	}
}
	
void CSysNetMonitorDeviceGroupFactory::commitRemove(CWriteableSysNetMonitorDeviceGroup *pSysNetMonitorDeviceGroup)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorDeviceGroup++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorDeviceGroup);
	}
}

void CSysNetMonitorDeviceGroupFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorTaskInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorTaskInfo=0;
int updateWithIndexActionForSysNetMonitorTaskInfo=0;
int updateWithoutIndexActionForSysNetMonitorTaskInfo=0;
int removeActionForSysNetMonitorTaskInfo=0;
int addCommitForSysNetMonitorTaskInfo=0;
int updateCommitForSysNetMonitorTaskInfo=0;
int removeCommitForSysNetMonitorTaskInfo=0;
#endif
void CSysNetMonitorTaskInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorTaskInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorTaskInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorTaskInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorTaskInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorTaskInfoFactory::CSysNetMonitorTaskInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorTaskInfoFactory::CSysNetMonitorTaskInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorTaskInfoFactory::~CSysNetMonitorTaskInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorTaskInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorTaskInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorTaskInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorTaskInfo thisSysNetMonitorTaskInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorTaskInfo.readCSV(input,pNames))
		add(&thisSysNetMonitorTaskInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorTaskInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorTaskInfo.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorTaskInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorTaskInfo::writeCSVHead(output);
	pSysNetMonitorTaskInfo=(CWriteableSysNetMonitorTaskInfo *)(pMem->getFirst());
	while (pSysNetMonitorTaskInfo!=NULL) {
		if (!pSysNetMonitorTaskInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorTaskInfo=(CWriteableSysNetMonitorTaskInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorTaskInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorTaskInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorTaskInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorTaskInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorTaskInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorTaskInfo=(CWriteableSysNetMonitorTaskInfo *)(pMem->getFirst());
	while (pSysNetMonitorTaskInfo!=NULL) {
		pSysNetMonitorTaskInfo->dump(fp,index++);
		pSysNetMonitorTaskInfo=(CWriteableSysNetMonitorTaskInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorTaskInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorTaskInfo *CSysNetMonitorTaskInfoFactory::internalAdd(CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorTaskInfo++;
#endif
	CSysNetMonitorTaskInfo *pTarget;	
	beforeAdd(pSysNetMonitorTaskInfo);
	pTarget=(CSysNetMonitorTaskInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorTaskInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorTaskInfo, sizeof(CSysNetMonitorTaskInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorTaskInfo *CSysNetMonitorTaskInfoFactory::add(CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CTransaction *pTransaction)
{
	pSysNetMonitorTaskInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorTaskInfo,true);
	}
	else {
		CSysNetMonitorTaskInfo *pNewSysNetMonitorTaskInfo;
		pNewSysNetMonitorTaskInfo = internalAdd(pSysNetMonitorTaskInfo,false);
		pTransaction->addResource(CSysNetMonitorTaskInfoResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorTaskInfo,NULL));
		return pNewSysNetMonitorTaskInfo;
	}
}

void CSysNetMonitorTaskInfoFactory::internalUpdate(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pNewSysNetMonitorTaskInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorTaskInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorTaskInfo++;
	}
#endif
	CWriteableSysNetMonitorTaskInfo theOldSysNetMonitorTaskInfo;
	beforeUpdate(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskInfo,pSysNetMonitorTaskInfo,sizeof(CSysNetMonitorTaskInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo,sizeof(CSysNetMonitorTaskInfo));
	pMem->updateObject(pSysNetMonitorTaskInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorTaskInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorTaskInfo,&theOldSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::update(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pNewSysNetMonitorTaskInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorTaskInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskInfoResource::alloc(UPDATE_ACTION,this,pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo,updateIndex));
		internalUpdate(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo,updateIndex,false);
	}
}

void CSysNetMonitorTaskInfoFactory::internalRemove(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorTaskInfo++;
#endif
	CWriteableSysNetMonitorTaskInfo theOldSysNetMonitorTaskInfo;
	beforeRemove(pSysNetMonitorTaskInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskInfo,pSysNetMonitorTaskInfo,sizeof(CSysNetMonitorTaskInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorTaskInfo);
	}
	pMem->free(pSysNetMonitorTaskInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::remove(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorTaskInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskInfoResource::alloc(DELETE_ACTION,this,pSysNetMonitorTaskInfo,NULL));
		internalRemove(pSysNetMonitorTaskInfo,false);		
	}
}

CSysNetMonitorTaskInfo* CSysNetMonitorTaskInfoFactory::addOrUpdate(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pNewSysNetMonitorTaskInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorTaskInfo == NULL) {
		return add(pNewSysNetMonitorTaskInfo,pTransaction);
	}
	else {
		update(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo,pTransaction,updateIndex);
		return pSysNetMonitorTaskInfo;
	}
}

void CSysNetMonitorTaskInfoFactory::retrieve(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pTargetSysNetMonitorTaskInfo)
{
	forceCopy(pTargetSysNetMonitorTaskInfo, pSysNetMonitorTaskInfo, sizeof(CSysNetMonitorTaskInfo));
}
	
int CSysNetMonitorTaskInfoFactory::addActionTrigger(CSysNetMonitorTaskInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorTaskInfoFactory::removeActionTrigger(CSysNetMonitorTaskInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorTaskInfoFactory::addCommitTrigger(CSysNetMonitorTaskInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorTaskInfoFactory::removeCommitTrigger(CSysNetMonitorTaskInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorTaskInfo *CSysNetMonitorTaskInfoFactory::getFirst(void)
{
	CSysNetMonitorTaskInfo *pResult=(CSysNetMonitorTaskInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorTaskInfo *CSysNetMonitorTaskInfoFactory::getNext(void)
{
	CSysNetMonitorTaskInfo *pResult=(CSysNetMonitorTaskInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorTaskInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorTaskInfoFactory::beforeAdd(CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorTaskInfo);
	}
}
	
void CSysNetMonitorTaskInfoFactory::afterAdd(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::beforeUpdate(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pNewSysNetMonitorTaskInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorTaskInfo,pNewSysNetMonitorTaskInfo);
	}
}
	
void CSysNetMonitorTaskInfoFactory::afterUpdate(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorTaskInfo);
	}
}
	
void CSysNetMonitorTaskInfoFactory::beforeRemove(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::commitAdd(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorTaskInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::commitUpdate(CSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo, CWriteableSysNetMonitorTaskInfo *pOldSysNetMonitorTaskInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorTaskInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorTaskInfo,pOldSysNetMonitorTaskInfo);
	}
}
	
void CSysNetMonitorTaskInfoFactory::commitRemove(CWriteableSysNetMonitorTaskInfo *pSysNetMonitorTaskInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorTaskInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorTaskInfo);
	}
}

void CSysNetMonitorTaskInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorTaskObjectSet(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorTaskObjectSet=0;
int updateWithIndexActionForSysNetMonitorTaskObjectSet=0;
int updateWithoutIndexActionForSysNetMonitorTaskObjectSet=0;
int removeActionForSysNetMonitorTaskObjectSet=0;
int addCommitForSysNetMonitorTaskObjectSet=0;
int updateCommitForSysNetMonitorTaskObjectSet=0;
int removeCommitForSysNetMonitorTaskObjectSet=0;
#endif
void CSysNetMonitorTaskObjectSetFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskObjectSet,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorTaskObjectSet_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorTaskObjectSet_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskObjectSet,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByDeviceGroup_ID=NULL;
	pActionTriggers=new vector<CSysNetMonitorTaskObjectSetActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorTaskObjectSetCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorTaskObjectSetFactory::CSysNetMonitorTaskObjectSetFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskObjectSet),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorTaskObjectSetFactory::CSysNetMonitorTaskObjectSetFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskObjectSet),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorTaskObjectSetFactory::~CSysNetMonitorTaskObjectSetFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorTaskObjectSetFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorTaskObjectSetFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorTaskObjectSetFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorTaskObjectSet thisSysNetMonitorTaskObjectSet;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorTaskObjectSet.readCSV(input,pNames))
		add(&thisSysNetMonitorTaskObjectSet);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorTaskObjectSetFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorTaskObjectSet.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorTaskObjectSetFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorTaskObjectSet::writeCSVHead(output);
	pSysNetMonitorTaskObjectSet=(CWriteableSysNetMonitorTaskObjectSet *)(pMem->getFirst());
	while (pSysNetMonitorTaskObjectSet!=NULL) {
		if (!pSysNetMonitorTaskObjectSet->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorTaskObjectSet=(CWriteableSysNetMonitorTaskObjectSet *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorTaskObjectSetFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorTaskObjectSet.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorTaskObjectSetFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorTaskObjectSetFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorTaskObjectSetFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorTaskObjectSet=(CWriteableSysNetMonitorTaskObjectSet *)(pMem->getFirst());
	while (pSysNetMonitorTaskObjectSet!=NULL) {
		pSysNetMonitorTaskObjectSet->dump(fp,index++);
		pSysNetMonitorTaskObjectSet=(CWriteableSysNetMonitorTaskObjectSet *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorTaskObjectSetFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorTaskObjectSet *CSysNetMonitorTaskObjectSetFactory::internalAdd(CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorTaskObjectSet++;
#endif
	CSysNetMonitorTaskObjectSet *pTarget;	
	beforeAdd(pSysNetMonitorTaskObjectSet);
	pTarget=(CSysNetMonitorTaskObjectSet *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorTaskObjectSet in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorTaskObjectSet, sizeof(CSysNetMonitorTaskObjectSet));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorTaskObjectSet *CSysNetMonitorTaskObjectSetFactory::add(CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CTransaction *pTransaction)
{
	pSysNetMonitorTaskObjectSet->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorTaskObjectSet,true);
	}
	else {
		CSysNetMonitorTaskObjectSet *pNewSysNetMonitorTaskObjectSet;
		pNewSysNetMonitorTaskObjectSet = internalAdd(pSysNetMonitorTaskObjectSet,false);
		pTransaction->addResource(CSysNetMonitorTaskObjectSetResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorTaskObjectSet,NULL));
		return pNewSysNetMonitorTaskObjectSet;
	}
}

void CSysNetMonitorTaskObjectSetFactory::internalUpdate(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pNewSysNetMonitorTaskObjectSet, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorTaskObjectSet++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorTaskObjectSet++;
	}
#endif
	CWriteableSysNetMonitorTaskObjectSet theOldSysNetMonitorTaskObjectSet;
	beforeUpdate(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskObjectSet,pSysNetMonitorTaskObjectSet,sizeof(CSysNetMonitorTaskObjectSet));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet,sizeof(CSysNetMonitorTaskObjectSet));
	pMem->updateObject(pSysNetMonitorTaskObjectSet);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorTaskObjectSet);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorTaskObjectSet,&theOldSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::update(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pNewSysNetMonitorTaskObjectSet, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorTaskObjectSet->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskObjectSetResource::alloc(UPDATE_ACTION,this,pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet,updateIndex));
		internalUpdate(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet,updateIndex,false);
	}
}

void CSysNetMonitorTaskObjectSetFactory::internalRemove(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorTaskObjectSet++;
#endif
	CWriteableSysNetMonitorTaskObjectSet theOldSysNetMonitorTaskObjectSet;
	beforeRemove(pSysNetMonitorTaskObjectSet);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskObjectSet,pSysNetMonitorTaskObjectSet,sizeof(CSysNetMonitorTaskObjectSet));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorTaskObjectSet);
	}
	pMem->free(pSysNetMonitorTaskObjectSet);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::remove(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorTaskObjectSet,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskObjectSetResource::alloc(DELETE_ACTION,this,pSysNetMonitorTaskObjectSet,NULL));
		internalRemove(pSysNetMonitorTaskObjectSet,false);		
	}
}

CSysNetMonitorTaskObjectSet* CSysNetMonitorTaskObjectSetFactory::addOrUpdate(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pNewSysNetMonitorTaskObjectSet, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorTaskObjectSet == NULL) {
		return add(pNewSysNetMonitorTaskObjectSet,pTransaction);
	}
	else {
		update(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet,pTransaction,updateIndex);
		return pSysNetMonitorTaskObjectSet;
	}
}

void CSysNetMonitorTaskObjectSetFactory::retrieve(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pTargetSysNetMonitorTaskObjectSet)
{
	forceCopy(pTargetSysNetMonitorTaskObjectSet, pSysNetMonitorTaskObjectSet, sizeof(CSysNetMonitorTaskObjectSet));
}
	
int CSysNetMonitorTaskObjectSetFactory::addActionTrigger(CSysNetMonitorTaskObjectSetActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorTaskObjectSetFactory::removeActionTrigger(CSysNetMonitorTaskObjectSetActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorTaskObjectSetFactory::addCommitTrigger(CSysNetMonitorTaskObjectSetCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorTaskObjectSetFactory::removeCommitTrigger(CSysNetMonitorTaskObjectSetCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorTaskObjectSet *CSysNetMonitorTaskObjectSetFactory::getFirst(void)
{
	CSysNetMonitorTaskObjectSet *pResult=(CSysNetMonitorTaskObjectSet *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorTaskObjectSet *CSysNetMonitorTaskObjectSetFactory::getNext(void)
{
	CSysNetMonitorTaskObjectSet *pResult=(CSysNetMonitorTaskObjectSet *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorTaskObjectSetFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorTaskObjectSetFactory::beforeAdd(CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorTaskObjectSet);
	}
}
	
void CSysNetMonitorTaskObjectSetFactory::afterAdd(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::beforeUpdate(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pNewSysNetMonitorTaskObjectSet)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorTaskObjectSet,pNewSysNetMonitorTaskObjectSet);
	}
}
	
void CSysNetMonitorTaskObjectSetFactory::afterUpdate(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorTaskObjectSet);
	}
}
	
void CSysNetMonitorTaskObjectSetFactory::beforeRemove(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::commitAdd(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorTaskObjectSet++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::commitUpdate(CSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet, CWriteableSysNetMonitorTaskObjectSet *pOldSysNetMonitorTaskObjectSet)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorTaskObjectSet++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorTaskObjectSet,pOldSysNetMonitorTaskObjectSet);
	}
}
	
void CSysNetMonitorTaskObjectSetFactory::commitRemove(CWriteableSysNetMonitorTaskObjectSet *pSysNetMonitorTaskObjectSet)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorTaskObjectSet++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorTaskObjectSet);
	}
}

void CSysNetMonitorTaskObjectSetFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTaskIndexinSysNetMonitorTaskResult(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorTaskResult=0;
int updateWithIndexActionForSysNetMonitorTaskResult=0;
int updateWithoutIndexActionForSysNetMonitorTaskResult=0;
int removeActionForSysNetMonitorTaskResult=0;
int addCommitForSysNetMonitorTaskResult=0;
int updateCommitForSysNetMonitorTaskResult=0;
int removeCommitForSysNetMonitorTaskResult=0;
#endif
void CSysNetMonitorTaskResultFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTaskIndex=new CAVLTree(maxUnit,compareForSysTaskIndexinSysNetMonitorTaskResult,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorTaskResult_SysTaskIndex",pSysTaskIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorTaskResult_SysTaskIndex");
			if(it != pIndexMap->end()) {
				pSysTaskIndex=new CAVLTree(maxUnit,compareForSysTaskIndexinSysNetMonitorTaskResult,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTaskIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByTask_ID=NULL;
	pLastFoundInSearchByOnlyDate=NULL;
	pLastFoundInSearchByIDTaskTime=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysNetMonitorTaskResultActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorTaskResultCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorTaskResultFactory::CSysNetMonitorTaskResultFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskResult),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorTaskResultFactory::CSysNetMonitorTaskResultFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskResult),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorTaskResultFactory::~CSysNetMonitorTaskResultFactory(void)
{
	if (runLevel>=0) {
		if (pSysTaskIndex!=NULL)
			delete pSysTaskIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorTaskResultFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorTaskResultFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTaskIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorTaskResultFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorTaskResult thisSysNetMonitorTaskResult;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorTaskResult.readCSV(input,pNames))
		add(&thisSysNetMonitorTaskResult);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorTaskResultFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorTaskResult.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorTaskResultFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorTaskResult::writeCSVHead(output);
	pSysNetMonitorTaskResult=(CWriteableSysNetMonitorTaskResult *)(pMem->getFirst());
	while (pSysNetMonitorTaskResult!=NULL) {
		if (!pSysNetMonitorTaskResult->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorTaskResult=(CWriteableSysNetMonitorTaskResult *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorTaskResultFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorTaskResult.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorTaskResultFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorTaskResultFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorTaskResultFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorTaskResult=(CWriteableSysNetMonitorTaskResult *)(pMem->getFirst());
	while (pSysNetMonitorTaskResult!=NULL) {
		pSysNetMonitorTaskResult->dump(fp,index++);
		pSysNetMonitorTaskResult=(CWriteableSysNetMonitorTaskResult *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorTaskResultFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTaskIndex->removeAll();
	}
}

CSysNetMonitorTaskResult *CSysNetMonitorTaskResultFactory::internalAdd(CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorTaskResult++;
#endif
	CSysNetMonitorTaskResult *pTarget;	
	beforeAdd(pSysNetMonitorTaskResult);
	pTarget=(CSysNetMonitorTaskResult *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorTaskResult in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorTaskResult, sizeof(CSysNetMonitorTaskResult));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTaskIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorTaskResult *CSysNetMonitorTaskResultFactory::add(CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CTransaction *pTransaction)
{
	pSysNetMonitorTaskResult->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorTaskResult,true);
	}
	else {
		CSysNetMonitorTaskResult *pNewSysNetMonitorTaskResult;
		pNewSysNetMonitorTaskResult = internalAdd(pSysNetMonitorTaskResult,false);
		pTransaction->addResource(CSysNetMonitorTaskResultResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorTaskResult,NULL));
		return pNewSysNetMonitorTaskResult;
	}
}

void CSysNetMonitorTaskResultFactory::internalUpdate(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pNewSysNetMonitorTaskResult, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorTaskResult++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorTaskResult++;
	}
#endif
	CWriteableSysNetMonitorTaskResult theOldSysNetMonitorTaskResult;
	beforeUpdate(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskResult,pSysNetMonitorTaskResult,sizeof(CSysNetMonitorTaskResult));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult,sizeof(CSysNetMonitorTaskResult));
	pMem->updateObject(pSysNetMonitorTaskResult);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorTaskResult);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorTaskResult,&theOldSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::update(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pNewSysNetMonitorTaskResult, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorTaskResult->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskResultResource::alloc(UPDATE_ACTION,this,pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult,updateIndex));
		internalUpdate(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult,updateIndex,false);
	}
}

void CSysNetMonitorTaskResultFactory::internalRemove(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorTaskResult++;
#endif
	CWriteableSysNetMonitorTaskResult theOldSysNetMonitorTaskResult;
	beforeRemove(pSysNetMonitorTaskResult);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskResult,pSysNetMonitorTaskResult,sizeof(CSysNetMonitorTaskResult));
	}
	if (runLevel>=0) {
		pSysTaskIndex->removeObject(pSysNetMonitorTaskResult);
	}
	pMem->free(pSysNetMonitorTaskResult);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::remove(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorTaskResult,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskResultResource::alloc(DELETE_ACTION,this,pSysNetMonitorTaskResult,NULL));
		internalRemove(pSysNetMonitorTaskResult,false);		
	}
}

CSysNetMonitorTaskResult* CSysNetMonitorTaskResultFactory::addOrUpdate(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pNewSysNetMonitorTaskResult, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorTaskResult == NULL) {
		return add(pNewSysNetMonitorTaskResult,pTransaction);
	}
	else {
		update(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult,pTransaction,updateIndex);
		return pSysNetMonitorTaskResult;
	}
}

void CSysNetMonitorTaskResultFactory::retrieve(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pTargetSysNetMonitorTaskResult)
{
	forceCopy(pTargetSysNetMonitorTaskResult, pSysNetMonitorTaskResult, sizeof(CSysNetMonitorTaskResult));
}
	
int CSysNetMonitorTaskResultFactory::addActionTrigger(CSysNetMonitorTaskResultActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorTaskResultFactory::removeActionTrigger(CSysNetMonitorTaskResultActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorTaskResultFactory::addCommitTrigger(CSysNetMonitorTaskResultCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorTaskResultFactory::removeCommitTrigger(CSysNetMonitorTaskResultCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorTaskResult *CSysNetMonitorTaskResultFactory::getFirst(void)
{
	CSysNetMonitorTaskResult *pResult=(CSysNetMonitorTaskResult *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorTaskResult *CSysNetMonitorTaskResultFactory::getNext(void)
{
	CSysNetMonitorTaskResult *pResult=(CSysNetMonitorTaskResult *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorTaskResultFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorTaskResultFactory::beforeAdd(CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorTaskResult);
	}
}
	
void CSysNetMonitorTaskResultFactory::afterAdd(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::beforeUpdate(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pNewSysNetMonitorTaskResult)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorTaskResult,pNewSysNetMonitorTaskResult);
	}
}
	
void CSysNetMonitorTaskResultFactory::afterUpdate(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorTaskResult);
	}
}
	
void CSysNetMonitorTaskResultFactory::beforeRemove(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::commitAdd(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorTaskResult++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::commitUpdate(CSysNetMonitorTaskResult *pSysNetMonitorTaskResult, CWriteableSysNetMonitorTaskResult *pOldSysNetMonitorTaskResult)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorTaskResult++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorTaskResult,pOldSysNetMonitorTaskResult);
	}
}
	
void CSysNetMonitorTaskResultFactory::commitRemove(CWriteableSysNetMonitorTaskResult *pSysNetMonitorTaskResult)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorTaskResult++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorTaskResult);
	}
}

void CSysNetMonitorTaskResultFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetPartyLinkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetPartyLinkInfo=0;
int updateWithIndexActionForSysNetPartyLinkInfo=0;
int updateWithoutIndexActionForSysNetPartyLinkInfo=0;
int removeActionForSysNetPartyLinkInfo=0;
int addCommitForSysNetPartyLinkInfo=0;
int updateCommitForSysNetPartyLinkInfo=0;
int removeCommitForSysNetPartyLinkInfo=0;
#endif
void CSysNetPartyLinkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPartyLinkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetPartyLinkInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetPartyLinkInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPartyLinkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetPartyLinkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetPartyLinkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetPartyLinkInfoFactory::CSysNetPartyLinkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartyLinkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetPartyLinkInfoFactory::CSysNetPartyLinkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartyLinkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetPartyLinkInfoFactory::~CSysNetPartyLinkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetPartyLinkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetPartyLinkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetPartyLinkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetPartyLinkInfo thisSysNetPartyLinkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetPartyLinkInfo.readCSV(input,pNames))
		add(&thisSysNetPartyLinkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetPartyLinkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetPartyLinkInfo.csv");
	return readCSV(szFileName);
}

int CSysNetPartyLinkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetPartyLinkInfo::writeCSVHead(output);
	pSysNetPartyLinkInfo=(CWriteableSysNetPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetPartyLinkInfo!=NULL) {
		if (!pSysNetPartyLinkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetPartyLinkInfo=(CWriteableSysNetPartyLinkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetPartyLinkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetPartyLinkInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetPartyLinkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetPartyLinkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetPartyLinkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetPartyLinkInfo=(CWriteableSysNetPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetPartyLinkInfo!=NULL) {
		pSysNetPartyLinkInfo->dump(fp,index++);
		pSysNetPartyLinkInfo=(CWriteableSysNetPartyLinkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetPartyLinkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetPartyLinkInfo *CSysNetPartyLinkInfoFactory::internalAdd(CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetPartyLinkInfo++;
#endif
	CSysNetPartyLinkInfo *pTarget;	
	beforeAdd(pSysNetPartyLinkInfo);
	pTarget=(CSysNetPartyLinkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetPartyLinkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetPartyLinkInfo, sizeof(CSysNetPartyLinkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetPartyLinkInfo *CSysNetPartyLinkInfoFactory::add(CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CTransaction *pTransaction)
{
	pSysNetPartyLinkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetPartyLinkInfo,true);
	}
	else {
		CSysNetPartyLinkInfo *pNewSysNetPartyLinkInfo;
		pNewSysNetPartyLinkInfo = internalAdd(pSysNetPartyLinkInfo,false);
		pTransaction->addResource(CSysNetPartyLinkInfoResource::alloc(CREATE_ACTION,this,pNewSysNetPartyLinkInfo,NULL));
		return pNewSysNetPartyLinkInfo;
	}
}

void CSysNetPartyLinkInfoFactory::internalUpdate(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pNewSysNetPartyLinkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetPartyLinkInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetPartyLinkInfo++;
	}
#endif
	CWriteableSysNetPartyLinkInfo theOldSysNetPartyLinkInfo;
	beforeUpdate(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartyLinkInfo,pSysNetPartyLinkInfo,sizeof(CSysNetPartyLinkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo,sizeof(CSysNetPartyLinkInfo));
	pMem->updateObject(pSysNetPartyLinkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetPartyLinkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetPartyLinkInfo,&theOldSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::update(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pNewSysNetPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetPartyLinkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetPartyLinkInfoResource::alloc(UPDATE_ACTION,this,pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo,updateIndex));
		internalUpdate(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo,updateIndex,false);
	}
}

void CSysNetPartyLinkInfoFactory::internalRemove(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetPartyLinkInfo++;
#endif
	CWriteableSysNetPartyLinkInfo theOldSysNetPartyLinkInfo;
	beforeRemove(pSysNetPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartyLinkInfo,pSysNetPartyLinkInfo,sizeof(CSysNetPartyLinkInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetPartyLinkInfo);
	}
	pMem->free(pSysNetPartyLinkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::remove(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetPartyLinkInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetPartyLinkInfoResource::alloc(DELETE_ACTION,this,pSysNetPartyLinkInfo,NULL));
		internalRemove(pSysNetPartyLinkInfo,false);		
	}
}

CSysNetPartyLinkInfo* CSysNetPartyLinkInfoFactory::addOrUpdate(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pNewSysNetPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetPartyLinkInfo == NULL) {
		return add(pNewSysNetPartyLinkInfo,pTransaction);
	}
	else {
		update(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo,pTransaction,updateIndex);
		return pSysNetPartyLinkInfo;
	}
}

void CSysNetPartyLinkInfoFactory::retrieve(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pTargetSysNetPartyLinkInfo)
{
	forceCopy(pTargetSysNetPartyLinkInfo, pSysNetPartyLinkInfo, sizeof(CSysNetPartyLinkInfo));
}
	
int CSysNetPartyLinkInfoFactory::addActionTrigger(CSysNetPartyLinkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetPartyLinkInfoFactory::removeActionTrigger(CSysNetPartyLinkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetPartyLinkInfoFactory::addCommitTrigger(CSysNetPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetPartyLinkInfoFactory::removeCommitTrigger(CSysNetPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetPartyLinkInfo *CSysNetPartyLinkInfoFactory::getFirst(void)
{
	CSysNetPartyLinkInfo *pResult=(CSysNetPartyLinkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetPartyLinkInfo *CSysNetPartyLinkInfoFactory::getNext(void)
{
	CSysNetPartyLinkInfo *pResult=(CSysNetPartyLinkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetPartyLinkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetPartyLinkInfoFactory::beforeAdd(CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetPartyLinkInfo);
	}
}
	
void CSysNetPartyLinkInfoFactory::afterAdd(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::beforeUpdate(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pNewSysNetPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetPartyLinkInfo,pNewSysNetPartyLinkInfo);
	}
}
	
void CSysNetPartyLinkInfoFactory::afterUpdate(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetPartyLinkInfo);
	}
}
	
void CSysNetPartyLinkInfoFactory::beforeRemove(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::commitAdd(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::commitUpdate(CSysNetPartyLinkInfo *pSysNetPartyLinkInfo, CWriteableSysNetPartyLinkInfo *pOldSysNetPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetPartyLinkInfo,pOldSysNetPartyLinkInfo);
	}
}
	
void CSysNetPartyLinkInfoFactory::commitRemove(CWriteableSysNetPartyLinkInfo *pSysNetPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetPartyLinkInfo);
	}
}

void CSysNetPartyLinkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDelPartyLinkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDelPartyLinkInfo=0;
int updateWithIndexActionForSysNetDelPartyLinkInfo=0;
int updateWithoutIndexActionForSysNetDelPartyLinkInfo=0;
int removeActionForSysNetDelPartyLinkInfo=0;
int addCommitForSysNetDelPartyLinkInfo=0;
int updateCommitForSysNetDelPartyLinkInfo=0;
int removeCommitForSysNetDelPartyLinkInfo=0;
#endif
void CSysNetDelPartyLinkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDelPartyLinkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDelPartyLinkInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDelPartyLinkInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDelPartyLinkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetDelPartyLinkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDelPartyLinkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDelPartyLinkInfoFactory::CSysNetDelPartyLinkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDelPartyLinkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDelPartyLinkInfoFactory::CSysNetDelPartyLinkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDelPartyLinkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDelPartyLinkInfoFactory::~CSysNetDelPartyLinkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDelPartyLinkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDelPartyLinkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDelPartyLinkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDelPartyLinkInfo thisSysNetDelPartyLinkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDelPartyLinkInfo.readCSV(input,pNames))
		add(&thisSysNetDelPartyLinkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDelPartyLinkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDelPartyLinkInfo.csv");
	return readCSV(szFileName);
}

int CSysNetDelPartyLinkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDelPartyLinkInfo::writeCSVHead(output);
	pSysNetDelPartyLinkInfo=(CWriteableSysNetDelPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetDelPartyLinkInfo!=NULL) {
		if (!pSysNetDelPartyLinkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDelPartyLinkInfo=(CWriteableSysNetDelPartyLinkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDelPartyLinkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDelPartyLinkInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetDelPartyLinkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDelPartyLinkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDelPartyLinkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDelPartyLinkInfo=(CWriteableSysNetDelPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetDelPartyLinkInfo!=NULL) {
		pSysNetDelPartyLinkInfo->dump(fp,index++);
		pSysNetDelPartyLinkInfo=(CWriteableSysNetDelPartyLinkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDelPartyLinkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetDelPartyLinkInfo *CSysNetDelPartyLinkInfoFactory::internalAdd(CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDelPartyLinkInfo++;
#endif
	CSysNetDelPartyLinkInfo *pTarget;	
	beforeAdd(pSysNetDelPartyLinkInfo);
	pTarget=(CSysNetDelPartyLinkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDelPartyLinkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDelPartyLinkInfo, sizeof(CSysNetDelPartyLinkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDelPartyLinkInfo *CSysNetDelPartyLinkInfoFactory::add(CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CTransaction *pTransaction)
{
	pSysNetDelPartyLinkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDelPartyLinkInfo,true);
	}
	else {
		CSysNetDelPartyLinkInfo *pNewSysNetDelPartyLinkInfo;
		pNewSysNetDelPartyLinkInfo = internalAdd(pSysNetDelPartyLinkInfo,false);
		pTransaction->addResource(CSysNetDelPartyLinkInfoResource::alloc(CREATE_ACTION,this,pNewSysNetDelPartyLinkInfo,NULL));
		return pNewSysNetDelPartyLinkInfo;
	}
}

void CSysNetDelPartyLinkInfoFactory::internalUpdate(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pNewSysNetDelPartyLinkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDelPartyLinkInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetDelPartyLinkInfo++;
	}
#endif
	CWriteableSysNetDelPartyLinkInfo theOldSysNetDelPartyLinkInfo;
	beforeUpdate(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDelPartyLinkInfo,pSysNetDelPartyLinkInfo,sizeof(CSysNetDelPartyLinkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo,sizeof(CSysNetDelPartyLinkInfo));
	pMem->updateObject(pSysNetDelPartyLinkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDelPartyLinkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetDelPartyLinkInfo,&theOldSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::update(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pNewSysNetDelPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDelPartyLinkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDelPartyLinkInfoResource::alloc(UPDATE_ACTION,this,pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo,updateIndex));
		internalUpdate(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo,updateIndex,false);
	}
}

void CSysNetDelPartyLinkInfoFactory::internalRemove(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDelPartyLinkInfo++;
#endif
	CWriteableSysNetDelPartyLinkInfo theOldSysNetDelPartyLinkInfo;
	beforeRemove(pSysNetDelPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDelPartyLinkInfo,pSysNetDelPartyLinkInfo,sizeof(CSysNetDelPartyLinkInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDelPartyLinkInfo);
	}
	pMem->free(pSysNetDelPartyLinkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::remove(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDelPartyLinkInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetDelPartyLinkInfoResource::alloc(DELETE_ACTION,this,pSysNetDelPartyLinkInfo,NULL));
		internalRemove(pSysNetDelPartyLinkInfo,false);		
	}
}

CSysNetDelPartyLinkInfo* CSysNetDelPartyLinkInfoFactory::addOrUpdate(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pNewSysNetDelPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDelPartyLinkInfo == NULL) {
		return add(pNewSysNetDelPartyLinkInfo,pTransaction);
	}
	else {
		update(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo,pTransaction,updateIndex);
		return pSysNetDelPartyLinkInfo;
	}
}

void CSysNetDelPartyLinkInfoFactory::retrieve(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pTargetSysNetDelPartyLinkInfo)
{
	forceCopy(pTargetSysNetDelPartyLinkInfo, pSysNetDelPartyLinkInfo, sizeof(CSysNetDelPartyLinkInfo));
}
	
int CSysNetDelPartyLinkInfoFactory::addActionTrigger(CSysNetDelPartyLinkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDelPartyLinkInfoFactory::removeActionTrigger(CSysNetDelPartyLinkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDelPartyLinkInfoFactory::addCommitTrigger(CSysNetDelPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDelPartyLinkInfoFactory::removeCommitTrigger(CSysNetDelPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDelPartyLinkInfo *CSysNetDelPartyLinkInfoFactory::getFirst(void)
{
	CSysNetDelPartyLinkInfo *pResult=(CSysNetDelPartyLinkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDelPartyLinkInfo *CSysNetDelPartyLinkInfoFactory::getNext(void)
{
	CSysNetDelPartyLinkInfo *pResult=(CSysNetDelPartyLinkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDelPartyLinkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDelPartyLinkInfoFactory::beforeAdd(CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDelPartyLinkInfo);
	}
}
	
void CSysNetDelPartyLinkInfoFactory::afterAdd(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::beforeUpdate(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pNewSysNetDelPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDelPartyLinkInfo,pNewSysNetDelPartyLinkInfo);
	}
}
	
void CSysNetDelPartyLinkInfoFactory::afterUpdate(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDelPartyLinkInfo);
	}
}
	
void CSysNetDelPartyLinkInfoFactory::beforeRemove(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::commitAdd(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDelPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::commitUpdate(CSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo, CWriteableSysNetDelPartyLinkInfo *pOldSysNetDelPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDelPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDelPartyLinkInfo,pOldSysNetDelPartyLinkInfo);
	}
}
	
void CSysNetDelPartyLinkInfoFactory::commitRemove(CWriteableSysNetDelPartyLinkInfo *pSysNetDelPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDelPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDelPartyLinkInfo);
	}
}

void CSysNetDelPartyLinkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetPartyLinkAddrChange(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetPartyLinkAddrChange=0;
int updateWithIndexActionForSysNetPartyLinkAddrChange=0;
int updateWithoutIndexActionForSysNetPartyLinkAddrChange=0;
int removeActionForSysNetPartyLinkAddrChange=0;
int addCommitForSysNetPartyLinkAddrChange=0;
int updateCommitForSysNetPartyLinkAddrChange=0;
int removeCommitForSysNetPartyLinkAddrChange=0;
#endif
void CSysNetPartyLinkAddrChangeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPartyLinkAddrChange,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetPartyLinkAddrChange_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetPartyLinkAddrChange_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPartyLinkAddrChange,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetPartyLinkAddrChangeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetPartyLinkAddrChangeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetPartyLinkAddrChangeFactory::CSysNetPartyLinkAddrChangeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartyLinkAddrChange),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetPartyLinkAddrChangeFactory::CSysNetPartyLinkAddrChangeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartyLinkAddrChange),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetPartyLinkAddrChangeFactory::~CSysNetPartyLinkAddrChangeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetPartyLinkAddrChangeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetPartyLinkAddrChangeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetPartyLinkAddrChangeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetPartyLinkAddrChange thisSysNetPartyLinkAddrChange;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetPartyLinkAddrChange.readCSV(input,pNames))
		add(&thisSysNetPartyLinkAddrChange);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetPartyLinkAddrChangeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetPartyLinkAddrChange.csv");
	return readCSV(szFileName);
}

int CSysNetPartyLinkAddrChangeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetPartyLinkAddrChange::writeCSVHead(output);
	pSysNetPartyLinkAddrChange=(CWriteableSysNetPartyLinkAddrChange *)(pMem->getFirst());
	while (pSysNetPartyLinkAddrChange!=NULL) {
		if (!pSysNetPartyLinkAddrChange->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetPartyLinkAddrChange=(CWriteableSysNetPartyLinkAddrChange *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetPartyLinkAddrChangeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetPartyLinkAddrChange.csv");
	return writeCSV(szFileName);
}

void CSysNetPartyLinkAddrChangeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetPartyLinkAddrChangeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetPartyLinkAddrChangeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetPartyLinkAddrChange=(CWriteableSysNetPartyLinkAddrChange *)(pMem->getFirst());
	while (pSysNetPartyLinkAddrChange!=NULL) {
		pSysNetPartyLinkAddrChange->dump(fp,index++);
		pSysNetPartyLinkAddrChange=(CWriteableSysNetPartyLinkAddrChange *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetPartyLinkAddrChangeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetPartyLinkAddrChange *CSysNetPartyLinkAddrChangeFactory::internalAdd(CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetPartyLinkAddrChange++;
#endif
	CSysNetPartyLinkAddrChange *pTarget;	
	beforeAdd(pSysNetPartyLinkAddrChange);
	pTarget=(CSysNetPartyLinkAddrChange *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetPartyLinkAddrChange in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetPartyLinkAddrChange, sizeof(CSysNetPartyLinkAddrChange));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetPartyLinkAddrChange *CSysNetPartyLinkAddrChangeFactory::add(CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CTransaction *pTransaction)
{
	pSysNetPartyLinkAddrChange->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetPartyLinkAddrChange,true);
	}
	else {
		CSysNetPartyLinkAddrChange *pNewSysNetPartyLinkAddrChange;
		pNewSysNetPartyLinkAddrChange = internalAdd(pSysNetPartyLinkAddrChange,false);
		pTransaction->addResource(CSysNetPartyLinkAddrChangeResource::alloc(CREATE_ACTION,this,pNewSysNetPartyLinkAddrChange,NULL));
		return pNewSysNetPartyLinkAddrChange;
	}
}

void CSysNetPartyLinkAddrChangeFactory::internalUpdate(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pNewSysNetPartyLinkAddrChange, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetPartyLinkAddrChange++;
	}
	else {
		updateWithoutIndexActionForSysNetPartyLinkAddrChange++;
	}
#endif
	CWriteableSysNetPartyLinkAddrChange theOldSysNetPartyLinkAddrChange;
	beforeUpdate(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartyLinkAddrChange,pSysNetPartyLinkAddrChange,sizeof(CSysNetPartyLinkAddrChange));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange,sizeof(CSysNetPartyLinkAddrChange));
	pMem->updateObject(pSysNetPartyLinkAddrChange);
	if (updateIndex) {
	}
	afterUpdate(pSysNetPartyLinkAddrChange);
	if (bNoTransaction) {
		commitUpdate(pSysNetPartyLinkAddrChange,&theOldSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::update(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pNewSysNetPartyLinkAddrChange, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetPartyLinkAddrChange->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetPartyLinkAddrChangeResource::alloc(UPDATE_ACTION,this,pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange,updateIndex));
		internalUpdate(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange,updateIndex,false);
	}
}

void CSysNetPartyLinkAddrChangeFactory::internalRemove(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetPartyLinkAddrChange++;
#endif
	CWriteableSysNetPartyLinkAddrChange theOldSysNetPartyLinkAddrChange;
	beforeRemove(pSysNetPartyLinkAddrChange);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartyLinkAddrChange,pSysNetPartyLinkAddrChange,sizeof(CSysNetPartyLinkAddrChange));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetPartyLinkAddrChange);
	}
	pMem->free(pSysNetPartyLinkAddrChange);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::remove(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetPartyLinkAddrChange,true);
	}
	else {
		pTransaction->addResource(CSysNetPartyLinkAddrChangeResource::alloc(DELETE_ACTION,this,pSysNetPartyLinkAddrChange,NULL));
		internalRemove(pSysNetPartyLinkAddrChange,false);		
	}
}

CSysNetPartyLinkAddrChange* CSysNetPartyLinkAddrChangeFactory::addOrUpdate(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pNewSysNetPartyLinkAddrChange, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetPartyLinkAddrChange == NULL) {
		return add(pNewSysNetPartyLinkAddrChange,pTransaction);
	}
	else {
		update(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange,pTransaction,updateIndex);
		return pSysNetPartyLinkAddrChange;
	}
}

void CSysNetPartyLinkAddrChangeFactory::retrieve(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pTargetSysNetPartyLinkAddrChange)
{
	forceCopy(pTargetSysNetPartyLinkAddrChange, pSysNetPartyLinkAddrChange, sizeof(CSysNetPartyLinkAddrChange));
}
	
int CSysNetPartyLinkAddrChangeFactory::addActionTrigger(CSysNetPartyLinkAddrChangeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetPartyLinkAddrChangeFactory::removeActionTrigger(CSysNetPartyLinkAddrChangeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetPartyLinkAddrChangeFactory::addCommitTrigger(CSysNetPartyLinkAddrChangeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetPartyLinkAddrChangeFactory::removeCommitTrigger(CSysNetPartyLinkAddrChangeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetPartyLinkAddrChange *CSysNetPartyLinkAddrChangeFactory::getFirst(void)
{
	CSysNetPartyLinkAddrChange *pResult=(CSysNetPartyLinkAddrChange *)(pMem->getFirst());
	return pResult;
}
	
CSysNetPartyLinkAddrChange *CSysNetPartyLinkAddrChangeFactory::getNext(void)
{
	CSysNetPartyLinkAddrChange *pResult=(CSysNetPartyLinkAddrChange *)(pMem->getNext());
	return pResult;
}
	
void CSysNetPartyLinkAddrChangeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetPartyLinkAddrChangeFactory::beforeAdd(CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetPartyLinkAddrChange);
	}
}
	
void CSysNetPartyLinkAddrChangeFactory::afterAdd(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::beforeUpdate(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pNewSysNetPartyLinkAddrChange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetPartyLinkAddrChange,pNewSysNetPartyLinkAddrChange);
	}
}
	
void CSysNetPartyLinkAddrChangeFactory::afterUpdate(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetPartyLinkAddrChange);
	}
}
	
void CSysNetPartyLinkAddrChangeFactory::beforeRemove(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::commitAdd(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetPartyLinkAddrChange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::commitUpdate(CSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange, CWriteableSysNetPartyLinkAddrChange *pOldSysNetPartyLinkAddrChange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetPartyLinkAddrChange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetPartyLinkAddrChange,pOldSysNetPartyLinkAddrChange);
	}
}
	
void CSysNetPartyLinkAddrChangeFactory::commitRemove(CWriteableSysNetPartyLinkAddrChange *pSysNetPartyLinkAddrChange)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetPartyLinkAddrChange++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetPartyLinkAddrChange);
	}
}

void CSysNetPartyLinkAddrChangeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorActionAttr(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorActionAttr=0;
int updateWithIndexActionForSysNetMonitorActionAttr=0;
int updateWithoutIndexActionForSysNetMonitorActionAttr=0;
int removeActionForSysNetMonitorActionAttr=0;
int addCommitForSysNetMonitorActionAttr=0;
int updateCommitForSysNetMonitorActionAttr=0;
int removeCommitForSysNetMonitorActionAttr=0;
#endif
void CSysNetMonitorActionAttrFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorActionAttr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorActionAttr_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorActionAttr_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorActionAttr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorActionAttrActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorActionAttrCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorActionAttrFactory::CSysNetMonitorActionAttrFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorActionAttr),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorActionAttrFactory::CSysNetMonitorActionAttrFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorActionAttr),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorActionAttrFactory::~CSysNetMonitorActionAttrFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorActionAttrFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorActionAttrFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorActionAttrFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorActionAttr thisSysNetMonitorActionAttr;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorActionAttr.readCSV(input,pNames))
		add(&thisSysNetMonitorActionAttr);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorActionAttrFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorActionAttr.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorActionAttrFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorActionAttr::writeCSVHead(output);
	pSysNetMonitorActionAttr=(CWriteableSysNetMonitorActionAttr *)(pMem->getFirst());
	while (pSysNetMonitorActionAttr!=NULL) {
		if (!pSysNetMonitorActionAttr->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorActionAttr=(CWriteableSysNetMonitorActionAttr *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorActionAttrFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorActionAttr.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorActionAttrFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorActionAttrFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorActionAttrFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorActionAttr=(CWriteableSysNetMonitorActionAttr *)(pMem->getFirst());
	while (pSysNetMonitorActionAttr!=NULL) {
		pSysNetMonitorActionAttr->dump(fp,index++);
		pSysNetMonitorActionAttr=(CWriteableSysNetMonitorActionAttr *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorActionAttrFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorActionAttr *CSysNetMonitorActionAttrFactory::internalAdd(CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorActionAttr++;
#endif
	CSysNetMonitorActionAttr *pTarget;	
	beforeAdd(pSysNetMonitorActionAttr);
	pTarget=(CSysNetMonitorActionAttr *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorActionAttr in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorActionAttr, sizeof(CSysNetMonitorActionAttr));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorActionAttr *CSysNetMonitorActionAttrFactory::add(CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CTransaction *pTransaction)
{
	pSysNetMonitorActionAttr->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorActionAttr,true);
	}
	else {
		CSysNetMonitorActionAttr *pNewSysNetMonitorActionAttr;
		pNewSysNetMonitorActionAttr = internalAdd(pSysNetMonitorActionAttr,false);
		pTransaction->addResource(CSysNetMonitorActionAttrResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorActionAttr,NULL));
		return pNewSysNetMonitorActionAttr;
	}
}

void CSysNetMonitorActionAttrFactory::internalUpdate(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pNewSysNetMonitorActionAttr, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorActionAttr++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorActionAttr++;
	}
#endif
	CWriteableSysNetMonitorActionAttr theOldSysNetMonitorActionAttr;
	beforeUpdate(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorActionAttr,pSysNetMonitorActionAttr,sizeof(CSysNetMonitorActionAttr));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr,sizeof(CSysNetMonitorActionAttr));
	pMem->updateObject(pSysNetMonitorActionAttr);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorActionAttr);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorActionAttr,&theOldSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::update(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pNewSysNetMonitorActionAttr, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorActionAttr->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorActionAttrResource::alloc(UPDATE_ACTION,this,pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr,updateIndex));
		internalUpdate(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr,updateIndex,false);
	}
}

void CSysNetMonitorActionAttrFactory::internalRemove(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorActionAttr++;
#endif
	CWriteableSysNetMonitorActionAttr theOldSysNetMonitorActionAttr;
	beforeRemove(pSysNetMonitorActionAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorActionAttr,pSysNetMonitorActionAttr,sizeof(CSysNetMonitorActionAttr));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorActionAttr);
	}
	pMem->free(pSysNetMonitorActionAttr);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::remove(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorActionAttr,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorActionAttrResource::alloc(DELETE_ACTION,this,pSysNetMonitorActionAttr,NULL));
		internalRemove(pSysNetMonitorActionAttr,false);		
	}
}

CSysNetMonitorActionAttr* CSysNetMonitorActionAttrFactory::addOrUpdate(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pNewSysNetMonitorActionAttr, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorActionAttr == NULL) {
		return add(pNewSysNetMonitorActionAttr,pTransaction);
	}
	else {
		update(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr,pTransaction,updateIndex);
		return pSysNetMonitorActionAttr;
	}
}

void CSysNetMonitorActionAttrFactory::retrieve(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pTargetSysNetMonitorActionAttr)
{
	forceCopy(pTargetSysNetMonitorActionAttr, pSysNetMonitorActionAttr, sizeof(CSysNetMonitorActionAttr));
}
	
int CSysNetMonitorActionAttrFactory::addActionTrigger(CSysNetMonitorActionAttrActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorActionAttrFactory::removeActionTrigger(CSysNetMonitorActionAttrActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorActionAttrFactory::addCommitTrigger(CSysNetMonitorActionAttrCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorActionAttrFactory::removeCommitTrigger(CSysNetMonitorActionAttrCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorActionAttr *CSysNetMonitorActionAttrFactory::getFirst(void)
{
	CSysNetMonitorActionAttr *pResult=(CSysNetMonitorActionAttr *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorActionAttr *CSysNetMonitorActionAttrFactory::getNext(void)
{
	CSysNetMonitorActionAttr *pResult=(CSysNetMonitorActionAttr *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorActionAttrFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorActionAttrFactory::beforeAdd(CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorActionAttr);
	}
}
	
void CSysNetMonitorActionAttrFactory::afterAdd(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::beforeUpdate(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pNewSysNetMonitorActionAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorActionAttr,pNewSysNetMonitorActionAttr);
	}
}
	
void CSysNetMonitorActionAttrFactory::afterUpdate(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorActionAttr);
	}
}
	
void CSysNetMonitorActionAttrFactory::beforeRemove(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::commitAdd(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorActionAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::commitUpdate(CSysNetMonitorActionAttr *pSysNetMonitorActionAttr, CWriteableSysNetMonitorActionAttr *pOldSysNetMonitorActionAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorActionAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorActionAttr,pOldSysNetMonitorActionAttr);
	}
}
	
void CSysNetMonitorActionAttrFactory::commitRemove(CWriteableSysNetMonitorActionAttr *pSysNetMonitorActionAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorActionAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorActionAttr);
	}
}

void CSysNetMonitorActionAttrFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetModule(const void *pV1, const void *pV2);
extern int compareForSysDeviceIDTypeIndexinSysNetModule(const void *pV1, const void *pV2);
extern int compareForSysObjectIDTypeIndexinSysNetModule(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetModule=0;
int updateWithIndexActionForSysNetModule=0;
int updateWithoutIndexActionForSysNetModule=0;
int removeActionForSysNetModule=0;
int addCommitForSysNetModule=0;
int updateCommitForSysNetModule=0;
int removeCommitForSysNetModule=0;
#endif
void CSysNetModuleFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetModule,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetModule_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetModule_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetModule,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysDeviceIDTypeIndex=new CAVLTree(maxUnit,compareForSysDeviceIDTypeIndexinSysNetModule,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetModule_SysDeviceIDTypeIndex",pSysDeviceIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetModule_SysDeviceIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysDeviceIDTypeIndex=new CAVLTree(maxUnit,compareForSysDeviceIDTypeIndexinSysNetModule,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysDeviceIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetModule,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetModule_SysObjectIDTypeIndex",pSysObjectIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetModule_SysObjectIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysObjectIDTypeIndex=new CAVLTree(maxUnit,compareForSysObjectIDTypeIndexinSysNetModule,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysObjectIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByDeviceID=NULL;
	pActionTriggers=new vector<CSysNetModuleActionTrigger *>;
	pCommitTriggers=new vector<CSysNetModuleCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetModuleFactory::CSysNetModuleFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetModule),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetModuleFactory::CSysNetModuleFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetModule),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetModuleFactory::~CSysNetModuleFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysDeviceIDTypeIndex!=NULL)
			delete pSysDeviceIDTypeIndex;
	}
	if (runLevel>=0) {
		if (pSysObjectIDTypeIndex!=NULL)
			delete pSysObjectIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetModuleFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetModuleFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetModuleFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetModule thisSysNetModule;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetModule.readCSV(input,pNames))
		add(&thisSysNetModule);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetModuleFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetModule.csv");
	return readCSV(szFileName);
}

int CSysNetModuleFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetModule *pSysNetModule;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetModule::writeCSVHead(output);
	pSysNetModule=(CWriteableSysNetModule *)(pMem->getFirst());
	while (pSysNetModule!=NULL) {
		if (!pSysNetModule->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetModule=(CWriteableSysNetModule *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetModuleFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetModule.csv");
	return writeCSV(szFileName);
}

void CSysNetModuleFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetModuleFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetModule *pSysNetModule;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetModuleFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetModule=(CWriteableSysNetModule *)(pMem->getFirst());
	while (pSysNetModule!=NULL) {
		pSysNetModule->dump(fp,index++);
		pSysNetModule=(CWriteableSysNetModule *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetModuleFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->removeAll();
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeAll();
	}
}

CSysNetModule *CSysNetModuleFactory::internalAdd(CWriteableSysNetModule *pSysNetModule, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetModule++;
#endif
	CSysNetModule *pTarget;	
	beforeAdd(pSysNetModule);
	pTarget=(CSysNetModule *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetModule in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetModule, sizeof(CSysNetModule));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetModule *CSysNetModuleFactory::add(CWriteableSysNetModule *pSysNetModule, CTransaction *pTransaction)
{
	pSysNetModule->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetModule,true);
	}
	else {
		CSysNetModule *pNewSysNetModule;
		pNewSysNetModule = internalAdd(pSysNetModule,false);
		pTransaction->addResource(CSysNetModuleResource::alloc(CREATE_ACTION,this,pNewSysNetModule,NULL));
		return pNewSysNetModule;
	}
}

void CSysNetModuleFactory::internalUpdate(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pNewSysNetModule, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetModule++;
	}
	else {
		updateWithoutIndexActionForSysNetModule++;
	}
#endif
	CWriteableSysNetModule theOldSysNetModule;
	beforeUpdate(pSysNetModule,pNewSysNetModule);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetModule,pSysNetModule,sizeof(CSysNetModule));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetModule,pNewSysNetModule,sizeof(CSysNetModule));
	pMem->updateObject(pSysNetModule);
	if (updateIndex) {
	}
	afterUpdate(pSysNetModule);
	if (bNoTransaction) {
		commitUpdate(pSysNetModule,&theOldSysNetModule);
	}
}

void CSysNetModuleFactory::update(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pNewSysNetModule, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetModule->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetModule,pNewSysNetModule,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetModuleResource::alloc(UPDATE_ACTION,this,pSysNetModule,pNewSysNetModule,updateIndex));
		internalUpdate(pSysNetModule,pNewSysNetModule,updateIndex,false);
	}
}

void CSysNetModuleFactory::internalRemove(CSysNetModule *pSysNetModule, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetModule++;
#endif
	CWriteableSysNetModule theOldSysNetModule;
	beforeRemove(pSysNetModule);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetModule,pSysNetModule,sizeof(CSysNetModule));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetModule);
	}
	if (runLevel>=0) {
		pSysDeviceIDTypeIndex->removeObject(pSysNetModule);
	}
	if (runLevel>=0) {
		pSysObjectIDTypeIndex->removeObject(pSysNetModule);
	}
	pMem->free(pSysNetModule);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetModule);
	}
}

void CSysNetModuleFactory::remove(CSysNetModule *pSysNetModule, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetModule,true);
	}
	else {
		pTransaction->addResource(CSysNetModuleResource::alloc(DELETE_ACTION,this,pSysNetModule,NULL));
		internalRemove(pSysNetModule,false);		
	}
}

CSysNetModule* CSysNetModuleFactory::addOrUpdate(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pNewSysNetModule, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetModule == NULL) {
		return add(pNewSysNetModule,pTransaction);
	}
	else {
		update(pSysNetModule,pNewSysNetModule,pTransaction,updateIndex);
		return pSysNetModule;
	}
}

void CSysNetModuleFactory::retrieve(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pTargetSysNetModule)
{
	forceCopy(pTargetSysNetModule, pSysNetModule, sizeof(CSysNetModule));
}
	
int CSysNetModuleFactory::addActionTrigger(CSysNetModuleActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetModuleFactory::removeActionTrigger(CSysNetModuleActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetModuleFactory::addCommitTrigger(CSysNetModuleCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetModuleFactory::removeCommitTrigger(CSysNetModuleCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetModule *CSysNetModuleFactory::getFirst(void)
{
	CSysNetModule *pResult=(CSysNetModule *)(pMem->getFirst());
	return pResult;
}
	
CSysNetModule *CSysNetModuleFactory::getNext(void)
{
	CSysNetModule *pResult=(CSysNetModule *)(pMem->getNext());
	return pResult;
}
	
void CSysNetModuleFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetModuleFactory::beforeAdd(CWriteableSysNetModule *pSysNetModule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetModule);
	}
}
	
void CSysNetModuleFactory::afterAdd(CSysNetModule *pSysNetModule)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetModule);
	}
}

void CSysNetModuleFactory::beforeUpdate(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pNewSysNetModule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetModule,pNewSysNetModule);
	}
}
	
void CSysNetModuleFactory::afterUpdate(CSysNetModule *pSysNetModule)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetModule);
	}
}
	
void CSysNetModuleFactory::beforeRemove(CSysNetModule *pSysNetModule)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetModule);
	}
}

void CSysNetModuleFactory::commitAdd(CSysNetModule *pSysNetModule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetModule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetModule);
	}
}

void CSysNetModuleFactory::commitUpdate(CSysNetModule *pSysNetModule, CWriteableSysNetModule *pOldSysNetModule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetModule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetModule,pOldSysNetModule);
	}
}
	
void CSysNetModuleFactory::commitRemove(CWriteableSysNetModule *pSysNetModule)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetModule++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetModule);
	}
}

void CSysNetModuleFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetEventExpr(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetEventExpr=0;
int updateWithIndexActionForSysNetEventExpr=0;
int updateWithoutIndexActionForSysNetEventExpr=0;
int removeActionForSysNetEventExpr=0;
int addCommitForSysNetEventExpr=0;
int updateCommitForSysNetEventExpr=0;
int removeCommitForSysNetEventExpr=0;
#endif
void CSysNetEventExprFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventExpr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetEventExpr_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetEventExpr_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventExpr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetEventExprActionTrigger *>;
	pCommitTriggers=new vector<CSysNetEventExprCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetEventExprFactory::CSysNetEventExprFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventExpr),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetEventExprFactory::CSysNetEventExprFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventExpr),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetEventExprFactory::~CSysNetEventExprFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetEventExprFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetEventExprFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetEventExprFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetEventExpr thisSysNetEventExpr;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetEventExpr.readCSV(input,pNames))
		add(&thisSysNetEventExpr);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetEventExprFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetEventExpr.csv");
	return readCSV(szFileName);
}

int CSysNetEventExprFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetEventExpr *pSysNetEventExpr;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetEventExpr::writeCSVHead(output);
	pSysNetEventExpr=(CWriteableSysNetEventExpr *)(pMem->getFirst());
	while (pSysNetEventExpr!=NULL) {
		if (!pSysNetEventExpr->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetEventExpr=(CWriteableSysNetEventExpr *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetEventExprFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetEventExpr.csv");
	return writeCSV(szFileName);
}

void CSysNetEventExprFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetEventExprFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetEventExpr *pSysNetEventExpr;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetEventExprFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetEventExpr=(CWriteableSysNetEventExpr *)(pMem->getFirst());
	while (pSysNetEventExpr!=NULL) {
		pSysNetEventExpr->dump(fp,index++);
		pSysNetEventExpr=(CWriteableSysNetEventExpr *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetEventExprFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetEventExpr *CSysNetEventExprFactory::internalAdd(CWriteableSysNetEventExpr *pSysNetEventExpr, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetEventExpr++;
#endif
	CSysNetEventExpr *pTarget;	
	beforeAdd(pSysNetEventExpr);
	pTarget=(CSysNetEventExpr *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetEventExpr in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetEventExpr, sizeof(CSysNetEventExpr));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetEventExpr *CSysNetEventExprFactory::add(CWriteableSysNetEventExpr *pSysNetEventExpr, CTransaction *pTransaction)
{
	pSysNetEventExpr->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetEventExpr,true);
	}
	else {
		CSysNetEventExpr *pNewSysNetEventExpr;
		pNewSysNetEventExpr = internalAdd(pSysNetEventExpr,false);
		pTransaction->addResource(CSysNetEventExprResource::alloc(CREATE_ACTION,this,pNewSysNetEventExpr,NULL));
		return pNewSysNetEventExpr;
	}
}

void CSysNetEventExprFactory::internalUpdate(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pNewSysNetEventExpr, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetEventExpr++;
	}
	else {
		updateWithoutIndexActionForSysNetEventExpr++;
	}
#endif
	CWriteableSysNetEventExpr theOldSysNetEventExpr;
	beforeUpdate(pSysNetEventExpr,pNewSysNetEventExpr);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventExpr,pSysNetEventExpr,sizeof(CSysNetEventExpr));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetEventExpr,pNewSysNetEventExpr,sizeof(CSysNetEventExpr));
	pMem->updateObject(pSysNetEventExpr);
	if (updateIndex) {
	}
	afterUpdate(pSysNetEventExpr);
	if (bNoTransaction) {
		commitUpdate(pSysNetEventExpr,&theOldSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::update(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pNewSysNetEventExpr, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetEventExpr->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetEventExpr,pNewSysNetEventExpr,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetEventExprResource::alloc(UPDATE_ACTION,this,pSysNetEventExpr,pNewSysNetEventExpr,updateIndex));
		internalUpdate(pSysNetEventExpr,pNewSysNetEventExpr,updateIndex,false);
	}
}

void CSysNetEventExprFactory::internalRemove(CSysNetEventExpr *pSysNetEventExpr, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetEventExpr++;
#endif
	CWriteableSysNetEventExpr theOldSysNetEventExpr;
	beforeRemove(pSysNetEventExpr);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventExpr,pSysNetEventExpr,sizeof(CSysNetEventExpr));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetEventExpr);
	}
	pMem->free(pSysNetEventExpr);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::remove(CSysNetEventExpr *pSysNetEventExpr, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetEventExpr,true);
	}
	else {
		pTransaction->addResource(CSysNetEventExprResource::alloc(DELETE_ACTION,this,pSysNetEventExpr,NULL));
		internalRemove(pSysNetEventExpr,false);		
	}
}

CSysNetEventExpr* CSysNetEventExprFactory::addOrUpdate(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pNewSysNetEventExpr, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetEventExpr == NULL) {
		return add(pNewSysNetEventExpr,pTransaction);
	}
	else {
		update(pSysNetEventExpr,pNewSysNetEventExpr,pTransaction,updateIndex);
		return pSysNetEventExpr;
	}
}

void CSysNetEventExprFactory::retrieve(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pTargetSysNetEventExpr)
{
	forceCopy(pTargetSysNetEventExpr, pSysNetEventExpr, sizeof(CSysNetEventExpr));
}
	
int CSysNetEventExprFactory::addActionTrigger(CSysNetEventExprActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetEventExprFactory::removeActionTrigger(CSysNetEventExprActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetEventExprFactory::addCommitTrigger(CSysNetEventExprCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetEventExprFactory::removeCommitTrigger(CSysNetEventExprCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetEventExpr *CSysNetEventExprFactory::getFirst(void)
{
	CSysNetEventExpr *pResult=(CSysNetEventExpr *)(pMem->getFirst());
	return pResult;
}
	
CSysNetEventExpr *CSysNetEventExprFactory::getNext(void)
{
	CSysNetEventExpr *pResult=(CSysNetEventExpr *)(pMem->getNext());
	return pResult;
}
	
void CSysNetEventExprFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetEventExprFactory::beforeAdd(CWriteableSysNetEventExpr *pSysNetEventExpr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetEventExpr);
	}
}
	
void CSysNetEventExprFactory::afterAdd(CSysNetEventExpr *pSysNetEventExpr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::beforeUpdate(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pNewSysNetEventExpr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetEventExpr,pNewSysNetEventExpr);
	}
}
	
void CSysNetEventExprFactory::afterUpdate(CSysNetEventExpr *pSysNetEventExpr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetEventExpr);
	}
}
	
void CSysNetEventExprFactory::beforeRemove(CSysNetEventExpr *pSysNetEventExpr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::commitAdd(CSysNetEventExpr *pSysNetEventExpr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetEventExpr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::commitUpdate(CSysNetEventExpr *pSysNetEventExpr, CWriteableSysNetEventExpr *pOldSysNetEventExpr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetEventExpr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetEventExpr,pOldSysNetEventExpr);
	}
}
	
void CSysNetEventExprFactory::commitRemove(CWriteableSysNetEventExpr *pSysNetEventExpr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetEventExpr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetEventExpr);
	}
}

void CSysNetEventExprFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetEventType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetEventType=0;
int updateWithIndexActionForSysNetEventType=0;
int updateWithoutIndexActionForSysNetEventType=0;
int removeActionForSysNetEventType=0;
int addCommitForSysNetEventType=0;
int updateCommitForSysNetEventType=0;
int removeCommitForSysNetEventType=0;
#endif
void CSysNetEventTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetEventType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetEventType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetEventTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetEventTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetEventTypeFactory::CSysNetEventTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetEventTypeFactory::CSysNetEventTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetEventTypeFactory::~CSysNetEventTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetEventTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetEventTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetEventTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetEventType thisSysNetEventType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetEventType.readCSV(input,pNames))
		add(&thisSysNetEventType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetEventTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetEventType.csv");
	return readCSV(szFileName);
}

int CSysNetEventTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetEventType *pSysNetEventType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetEventType::writeCSVHead(output);
	pSysNetEventType=(CWriteableSysNetEventType *)(pMem->getFirst());
	while (pSysNetEventType!=NULL) {
		if (!pSysNetEventType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetEventType=(CWriteableSysNetEventType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetEventTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetEventType.csv");
	return writeCSV(szFileName);
}

void CSysNetEventTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetEventTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetEventType *pSysNetEventType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetEventTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetEventType=(CWriteableSysNetEventType *)(pMem->getFirst());
	while (pSysNetEventType!=NULL) {
		pSysNetEventType->dump(fp,index++);
		pSysNetEventType=(CWriteableSysNetEventType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetEventTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetEventType *CSysNetEventTypeFactory::internalAdd(CWriteableSysNetEventType *pSysNetEventType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetEventType++;
#endif
	CSysNetEventType *pTarget;	
	beforeAdd(pSysNetEventType);
	pTarget=(CSysNetEventType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetEventType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetEventType, sizeof(CSysNetEventType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetEventType *CSysNetEventTypeFactory::add(CWriteableSysNetEventType *pSysNetEventType, CTransaction *pTransaction)
{
	pSysNetEventType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetEventType,true);
	}
	else {
		CSysNetEventType *pNewSysNetEventType;
		pNewSysNetEventType = internalAdd(pSysNetEventType,false);
		pTransaction->addResource(CSysNetEventTypeResource::alloc(CREATE_ACTION,this,pNewSysNetEventType,NULL));
		return pNewSysNetEventType;
	}
}

void CSysNetEventTypeFactory::internalUpdate(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pNewSysNetEventType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetEventType++;
	}
	else {
		updateWithoutIndexActionForSysNetEventType++;
	}
#endif
	CWriteableSysNetEventType theOldSysNetEventType;
	beforeUpdate(pSysNetEventType,pNewSysNetEventType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventType,pSysNetEventType,sizeof(CSysNetEventType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetEventType,pNewSysNetEventType,sizeof(CSysNetEventType));
	pMem->updateObject(pSysNetEventType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetEventType);
	if (bNoTransaction) {
		commitUpdate(pSysNetEventType,&theOldSysNetEventType);
	}
}

void CSysNetEventTypeFactory::update(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pNewSysNetEventType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetEventType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetEventType,pNewSysNetEventType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetEventTypeResource::alloc(UPDATE_ACTION,this,pSysNetEventType,pNewSysNetEventType,updateIndex));
		internalUpdate(pSysNetEventType,pNewSysNetEventType,updateIndex,false);
	}
}

void CSysNetEventTypeFactory::internalRemove(CSysNetEventType *pSysNetEventType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetEventType++;
#endif
	CWriteableSysNetEventType theOldSysNetEventType;
	beforeRemove(pSysNetEventType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventType,pSysNetEventType,sizeof(CSysNetEventType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetEventType);
	}
	pMem->free(pSysNetEventType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetEventType);
	}
}

void CSysNetEventTypeFactory::remove(CSysNetEventType *pSysNetEventType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetEventType,true);
	}
	else {
		pTransaction->addResource(CSysNetEventTypeResource::alloc(DELETE_ACTION,this,pSysNetEventType,NULL));
		internalRemove(pSysNetEventType,false);		
	}
}

CSysNetEventType* CSysNetEventTypeFactory::addOrUpdate(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pNewSysNetEventType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetEventType == NULL) {
		return add(pNewSysNetEventType,pTransaction);
	}
	else {
		update(pSysNetEventType,pNewSysNetEventType,pTransaction,updateIndex);
		return pSysNetEventType;
	}
}

void CSysNetEventTypeFactory::retrieve(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pTargetSysNetEventType)
{
	forceCopy(pTargetSysNetEventType, pSysNetEventType, sizeof(CSysNetEventType));
}
	
int CSysNetEventTypeFactory::addActionTrigger(CSysNetEventTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetEventTypeFactory::removeActionTrigger(CSysNetEventTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetEventTypeFactory::addCommitTrigger(CSysNetEventTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetEventTypeFactory::removeCommitTrigger(CSysNetEventTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetEventType *CSysNetEventTypeFactory::getFirst(void)
{
	CSysNetEventType *pResult=(CSysNetEventType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetEventType *CSysNetEventTypeFactory::getNext(void)
{
	CSysNetEventType *pResult=(CSysNetEventType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetEventTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetEventTypeFactory::beforeAdd(CWriteableSysNetEventType *pSysNetEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetEventType);
	}
}
	
void CSysNetEventTypeFactory::afterAdd(CSysNetEventType *pSysNetEventType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetEventType);
	}
}

void CSysNetEventTypeFactory::beforeUpdate(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pNewSysNetEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetEventType,pNewSysNetEventType);
	}
}
	
void CSysNetEventTypeFactory::afterUpdate(CSysNetEventType *pSysNetEventType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetEventType);
	}
}
	
void CSysNetEventTypeFactory::beforeRemove(CSysNetEventType *pSysNetEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetEventType);
	}
}

void CSysNetEventTypeFactory::commitAdd(CSysNetEventType *pSysNetEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetEventType);
	}
}

void CSysNetEventTypeFactory::commitUpdate(CSysNetEventType *pSysNetEventType, CWriteableSysNetEventType *pOldSysNetEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetEventType,pOldSysNetEventType);
	}
}
	
void CSysNetEventTypeFactory::commitRemove(CWriteableSysNetEventType *pSysNetEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetEventType);
	}
}

void CSysNetEventTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetSubEventType(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetSubEventType=0;
int updateWithIndexActionForSysNetSubEventType=0;
int updateWithoutIndexActionForSysNetSubEventType=0;
int removeActionForSysNetSubEventType=0;
int addCommitForSysNetSubEventType=0;
int updateCommitForSysNetSubEventType=0;
int removeCommitForSysNetSubEventType=0;
#endif
void CSysNetSubEventTypeFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubEventType,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetSubEventType_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetSubEventType_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetSubEventType,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetSubEventTypeActionTrigger *>;
	pCommitTriggers=new vector<CSysNetSubEventTypeCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetSubEventTypeFactory::CSysNetSubEventTypeFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubEventType),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetSubEventTypeFactory::CSysNetSubEventTypeFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetSubEventType),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetSubEventTypeFactory::~CSysNetSubEventTypeFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetSubEventTypeFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetSubEventTypeFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetSubEventTypeFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetSubEventType thisSysNetSubEventType;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetSubEventType.readCSV(input,pNames))
		add(&thisSysNetSubEventType);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetSubEventTypeFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetSubEventType.csv");
	return readCSV(szFileName);
}

int CSysNetSubEventTypeFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetSubEventType *pSysNetSubEventType;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetSubEventType::writeCSVHead(output);
	pSysNetSubEventType=(CWriteableSysNetSubEventType *)(pMem->getFirst());
	while (pSysNetSubEventType!=NULL) {
		if (!pSysNetSubEventType->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetSubEventType=(CWriteableSysNetSubEventType *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetSubEventTypeFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetSubEventType.csv");
	return writeCSV(szFileName);
}

void CSysNetSubEventTypeFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetSubEventTypeFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetSubEventType *pSysNetSubEventType;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetSubEventTypeFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetSubEventType=(CWriteableSysNetSubEventType *)(pMem->getFirst());
	while (pSysNetSubEventType!=NULL) {
		pSysNetSubEventType->dump(fp,index++);
		pSysNetSubEventType=(CWriteableSysNetSubEventType *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetSubEventTypeFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetSubEventType *CSysNetSubEventTypeFactory::internalAdd(CWriteableSysNetSubEventType *pSysNetSubEventType, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetSubEventType++;
#endif
	CSysNetSubEventType *pTarget;	
	beforeAdd(pSysNetSubEventType);
	pTarget=(CSysNetSubEventType *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetSubEventType in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetSubEventType, sizeof(CSysNetSubEventType));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetSubEventType *CSysNetSubEventTypeFactory::add(CWriteableSysNetSubEventType *pSysNetSubEventType, CTransaction *pTransaction)
{
	pSysNetSubEventType->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetSubEventType,true);
	}
	else {
		CSysNetSubEventType *pNewSysNetSubEventType;
		pNewSysNetSubEventType = internalAdd(pSysNetSubEventType,false);
		pTransaction->addResource(CSysNetSubEventTypeResource::alloc(CREATE_ACTION,this,pNewSysNetSubEventType,NULL));
		return pNewSysNetSubEventType;
	}
}

void CSysNetSubEventTypeFactory::internalUpdate(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pNewSysNetSubEventType, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetSubEventType++;
	}
	else {
		updateWithoutIndexActionForSysNetSubEventType++;
	}
#endif
	CWriteableSysNetSubEventType theOldSysNetSubEventType;
	beforeUpdate(pSysNetSubEventType,pNewSysNetSubEventType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubEventType,pSysNetSubEventType,sizeof(CSysNetSubEventType));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetSubEventType,pNewSysNetSubEventType,sizeof(CSysNetSubEventType));
	pMem->updateObject(pSysNetSubEventType);
	if (updateIndex) {
	}
	afterUpdate(pSysNetSubEventType);
	if (bNoTransaction) {
		commitUpdate(pSysNetSubEventType,&theOldSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::update(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pNewSysNetSubEventType, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetSubEventType->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetSubEventType,pNewSysNetSubEventType,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetSubEventTypeResource::alloc(UPDATE_ACTION,this,pSysNetSubEventType,pNewSysNetSubEventType,updateIndex));
		internalUpdate(pSysNetSubEventType,pNewSysNetSubEventType,updateIndex,false);
	}
}

void CSysNetSubEventTypeFactory::internalRemove(CSysNetSubEventType *pSysNetSubEventType, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetSubEventType++;
#endif
	CWriteableSysNetSubEventType theOldSysNetSubEventType;
	beforeRemove(pSysNetSubEventType);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetSubEventType,pSysNetSubEventType,sizeof(CSysNetSubEventType));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetSubEventType);
	}
	pMem->free(pSysNetSubEventType);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::remove(CSysNetSubEventType *pSysNetSubEventType, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetSubEventType,true);
	}
	else {
		pTransaction->addResource(CSysNetSubEventTypeResource::alloc(DELETE_ACTION,this,pSysNetSubEventType,NULL));
		internalRemove(pSysNetSubEventType,false);		
	}
}

CSysNetSubEventType* CSysNetSubEventTypeFactory::addOrUpdate(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pNewSysNetSubEventType, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetSubEventType == NULL) {
		return add(pNewSysNetSubEventType,pTransaction);
	}
	else {
		update(pSysNetSubEventType,pNewSysNetSubEventType,pTransaction,updateIndex);
		return pSysNetSubEventType;
	}
}

void CSysNetSubEventTypeFactory::retrieve(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pTargetSysNetSubEventType)
{
	forceCopy(pTargetSysNetSubEventType, pSysNetSubEventType, sizeof(CSysNetSubEventType));
}
	
int CSysNetSubEventTypeFactory::addActionTrigger(CSysNetSubEventTypeActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetSubEventTypeFactory::removeActionTrigger(CSysNetSubEventTypeActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetSubEventTypeFactory::addCommitTrigger(CSysNetSubEventTypeCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetSubEventTypeFactory::removeCommitTrigger(CSysNetSubEventTypeCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetSubEventType *CSysNetSubEventTypeFactory::getFirst(void)
{
	CSysNetSubEventType *pResult=(CSysNetSubEventType *)(pMem->getFirst());
	return pResult;
}
	
CSysNetSubEventType *CSysNetSubEventTypeFactory::getNext(void)
{
	CSysNetSubEventType *pResult=(CSysNetSubEventType *)(pMem->getNext());
	return pResult;
}
	
void CSysNetSubEventTypeFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetSubEventTypeFactory::beforeAdd(CWriteableSysNetSubEventType *pSysNetSubEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetSubEventType);
	}
}
	
void CSysNetSubEventTypeFactory::afterAdd(CSysNetSubEventType *pSysNetSubEventType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::beforeUpdate(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pNewSysNetSubEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetSubEventType,pNewSysNetSubEventType);
	}
}
	
void CSysNetSubEventTypeFactory::afterUpdate(CSysNetSubEventType *pSysNetSubEventType)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetSubEventType);
	}
}
	
void CSysNetSubEventTypeFactory::beforeRemove(CSysNetSubEventType *pSysNetSubEventType)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::commitAdd(CSysNetSubEventType *pSysNetSubEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetSubEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::commitUpdate(CSysNetSubEventType *pSysNetSubEventType, CWriteableSysNetSubEventType *pOldSysNetSubEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetSubEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetSubEventType,pOldSysNetSubEventType);
	}
}
	
void CSysNetSubEventTypeFactory::commitRemove(CWriteableSysNetSubEventType *pSysNetSubEventType)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetSubEventType++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetSubEventType);
	}
}

void CSysNetSubEventTypeFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetEventLevel(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetEventLevel=0;
int updateWithIndexActionForSysNetEventLevel=0;
int updateWithoutIndexActionForSysNetEventLevel=0;
int removeActionForSysNetEventLevel=0;
int addCommitForSysNetEventLevel=0;
int updateCommitForSysNetEventLevel=0;
int removeCommitForSysNetEventLevel=0;
#endif
void CSysNetEventLevelFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventLevel,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetEventLevel_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetEventLevel_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetEventLevel,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetEventLevelActionTrigger *>;
	pCommitTriggers=new vector<CSysNetEventLevelCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetEventLevelFactory::CSysNetEventLevelFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventLevel),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetEventLevelFactory::CSysNetEventLevelFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetEventLevel),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetEventLevelFactory::~CSysNetEventLevelFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetEventLevelFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetEventLevelFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetEventLevelFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetEventLevel thisSysNetEventLevel;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetEventLevel.readCSV(input,pNames))
		add(&thisSysNetEventLevel);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetEventLevelFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetEventLevel.csv");
	return readCSV(szFileName);
}

int CSysNetEventLevelFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetEventLevel *pSysNetEventLevel;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetEventLevel::writeCSVHead(output);
	pSysNetEventLevel=(CWriteableSysNetEventLevel *)(pMem->getFirst());
	while (pSysNetEventLevel!=NULL) {
		if (!pSysNetEventLevel->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetEventLevel=(CWriteableSysNetEventLevel *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetEventLevelFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetEventLevel.csv");
	return writeCSV(szFileName);
}

void CSysNetEventLevelFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetEventLevelFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetEventLevel *pSysNetEventLevel;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetEventLevelFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetEventLevel=(CWriteableSysNetEventLevel *)(pMem->getFirst());
	while (pSysNetEventLevel!=NULL) {
		pSysNetEventLevel->dump(fp,index++);
		pSysNetEventLevel=(CWriteableSysNetEventLevel *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetEventLevelFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetEventLevel *CSysNetEventLevelFactory::internalAdd(CWriteableSysNetEventLevel *pSysNetEventLevel, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetEventLevel++;
#endif
	CSysNetEventLevel *pTarget;	
	beforeAdd(pSysNetEventLevel);
	pTarget=(CSysNetEventLevel *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetEventLevel in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetEventLevel, sizeof(CSysNetEventLevel));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetEventLevel *CSysNetEventLevelFactory::add(CWriteableSysNetEventLevel *pSysNetEventLevel, CTransaction *pTransaction)
{
	pSysNetEventLevel->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetEventLevel,true);
	}
	else {
		CSysNetEventLevel *pNewSysNetEventLevel;
		pNewSysNetEventLevel = internalAdd(pSysNetEventLevel,false);
		pTransaction->addResource(CSysNetEventLevelResource::alloc(CREATE_ACTION,this,pNewSysNetEventLevel,NULL));
		return pNewSysNetEventLevel;
	}
}

void CSysNetEventLevelFactory::internalUpdate(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pNewSysNetEventLevel, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetEventLevel++;
	}
	else {
		updateWithoutIndexActionForSysNetEventLevel++;
	}
#endif
	CWriteableSysNetEventLevel theOldSysNetEventLevel;
	beforeUpdate(pSysNetEventLevel,pNewSysNetEventLevel);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventLevel,pSysNetEventLevel,sizeof(CSysNetEventLevel));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetEventLevel,pNewSysNetEventLevel,sizeof(CSysNetEventLevel));
	pMem->updateObject(pSysNetEventLevel);
	if (updateIndex) {
	}
	afterUpdate(pSysNetEventLevel);
	if (bNoTransaction) {
		commitUpdate(pSysNetEventLevel,&theOldSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::update(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pNewSysNetEventLevel, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetEventLevel->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetEventLevel,pNewSysNetEventLevel,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetEventLevelResource::alloc(UPDATE_ACTION,this,pSysNetEventLevel,pNewSysNetEventLevel,updateIndex));
		internalUpdate(pSysNetEventLevel,pNewSysNetEventLevel,updateIndex,false);
	}
}

void CSysNetEventLevelFactory::internalRemove(CSysNetEventLevel *pSysNetEventLevel, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetEventLevel++;
#endif
	CWriteableSysNetEventLevel theOldSysNetEventLevel;
	beforeRemove(pSysNetEventLevel);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetEventLevel,pSysNetEventLevel,sizeof(CSysNetEventLevel));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetEventLevel);
	}
	pMem->free(pSysNetEventLevel);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::remove(CSysNetEventLevel *pSysNetEventLevel, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetEventLevel,true);
	}
	else {
		pTransaction->addResource(CSysNetEventLevelResource::alloc(DELETE_ACTION,this,pSysNetEventLevel,NULL));
		internalRemove(pSysNetEventLevel,false);		
	}
}

CSysNetEventLevel* CSysNetEventLevelFactory::addOrUpdate(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pNewSysNetEventLevel, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetEventLevel == NULL) {
		return add(pNewSysNetEventLevel,pTransaction);
	}
	else {
		update(pSysNetEventLevel,pNewSysNetEventLevel,pTransaction,updateIndex);
		return pSysNetEventLevel;
	}
}

void CSysNetEventLevelFactory::retrieve(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pTargetSysNetEventLevel)
{
	forceCopy(pTargetSysNetEventLevel, pSysNetEventLevel, sizeof(CSysNetEventLevel));
}
	
int CSysNetEventLevelFactory::addActionTrigger(CSysNetEventLevelActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetEventLevelFactory::removeActionTrigger(CSysNetEventLevelActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetEventLevelFactory::addCommitTrigger(CSysNetEventLevelCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetEventLevelFactory::removeCommitTrigger(CSysNetEventLevelCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetEventLevel *CSysNetEventLevelFactory::getFirst(void)
{
	CSysNetEventLevel *pResult=(CSysNetEventLevel *)(pMem->getFirst());
	return pResult;
}
	
CSysNetEventLevel *CSysNetEventLevelFactory::getNext(void)
{
	CSysNetEventLevel *pResult=(CSysNetEventLevel *)(pMem->getNext());
	return pResult;
}
	
void CSysNetEventLevelFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetEventLevelFactory::beforeAdd(CWriteableSysNetEventLevel *pSysNetEventLevel)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetEventLevel);
	}
}
	
void CSysNetEventLevelFactory::afterAdd(CSysNetEventLevel *pSysNetEventLevel)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::beforeUpdate(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pNewSysNetEventLevel)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetEventLevel,pNewSysNetEventLevel);
	}
}
	
void CSysNetEventLevelFactory::afterUpdate(CSysNetEventLevel *pSysNetEventLevel)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetEventLevel);
	}
}
	
void CSysNetEventLevelFactory::beforeRemove(CSysNetEventLevel *pSysNetEventLevel)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::commitAdd(CSysNetEventLevel *pSysNetEventLevel)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetEventLevel++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::commitUpdate(CSysNetEventLevel *pSysNetEventLevel, CWriteableSysNetEventLevel *pOldSysNetEventLevel)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetEventLevel++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetEventLevel,pOldSysNetEventLevel);
	}
}
	
void CSysNetEventLevelFactory::commitRemove(CWriteableSysNetEventLevel *pSysNetEventLevel)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetEventLevel++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetEventLevel);
	}
}

void CSysNetEventLevelFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorDeviceTask(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorDeviceTask=0;
int updateWithIndexActionForSysNetMonitorDeviceTask=0;
int updateWithoutIndexActionForSysNetMonitorDeviceTask=0;
int removeActionForSysNetMonitorDeviceTask=0;
int addCommitForSysNetMonitorDeviceTask=0;
int updateCommitForSysNetMonitorDeviceTask=0;
int removeCommitForSysNetMonitorDeviceTask=0;
#endif
void CSysNetMonitorDeviceTaskFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorDeviceTask,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorDeviceTask_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorDeviceTask_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorDeviceTask,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByID=NULL;
	pActionTriggers=new vector<CSysNetMonitorDeviceTaskActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorDeviceTaskCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorDeviceTaskFactory::CSysNetMonitorDeviceTaskFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorDeviceTask),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorDeviceTaskFactory::CSysNetMonitorDeviceTaskFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorDeviceTask),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorDeviceTaskFactory::~CSysNetMonitorDeviceTaskFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorDeviceTaskFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorDeviceTaskFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorDeviceTaskFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorDeviceTask thisSysNetMonitorDeviceTask;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorDeviceTask.readCSV(input,pNames))
		add(&thisSysNetMonitorDeviceTask);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorDeviceTaskFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorDeviceTask.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorDeviceTaskFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorDeviceTask::writeCSVHead(output);
	pSysNetMonitorDeviceTask=(CWriteableSysNetMonitorDeviceTask *)(pMem->getFirst());
	while (pSysNetMonitorDeviceTask!=NULL) {
		if (!pSysNetMonitorDeviceTask->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorDeviceTask=(CWriteableSysNetMonitorDeviceTask *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorDeviceTaskFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorDeviceTask.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorDeviceTaskFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorDeviceTaskFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorDeviceTaskFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorDeviceTask=(CWriteableSysNetMonitorDeviceTask *)(pMem->getFirst());
	while (pSysNetMonitorDeviceTask!=NULL) {
		pSysNetMonitorDeviceTask->dump(fp,index++);
		pSysNetMonitorDeviceTask=(CWriteableSysNetMonitorDeviceTask *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorDeviceTaskFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorDeviceTask *CSysNetMonitorDeviceTaskFactory::internalAdd(CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorDeviceTask++;
#endif
	CSysNetMonitorDeviceTask *pTarget;	
	beforeAdd(pSysNetMonitorDeviceTask);
	pTarget=(CSysNetMonitorDeviceTask *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorDeviceTask in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorDeviceTask, sizeof(CSysNetMonitorDeviceTask));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorDeviceTask *CSysNetMonitorDeviceTaskFactory::add(CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CTransaction *pTransaction)
{
	pSysNetMonitorDeviceTask->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorDeviceTask,true);
	}
	else {
		CSysNetMonitorDeviceTask *pNewSysNetMonitorDeviceTask;
		pNewSysNetMonitorDeviceTask = internalAdd(pSysNetMonitorDeviceTask,false);
		pTransaction->addResource(CSysNetMonitorDeviceTaskResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorDeviceTask,NULL));
		return pNewSysNetMonitorDeviceTask;
	}
}

void CSysNetMonitorDeviceTaskFactory::internalUpdate(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pNewSysNetMonitorDeviceTask, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorDeviceTask++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorDeviceTask++;
	}
#endif
	CWriteableSysNetMonitorDeviceTask theOldSysNetMonitorDeviceTask;
	beforeUpdate(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorDeviceTask,pSysNetMonitorDeviceTask,sizeof(CSysNetMonitorDeviceTask));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask,sizeof(CSysNetMonitorDeviceTask));
	pMem->updateObject(pSysNetMonitorDeviceTask);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorDeviceTask);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorDeviceTask,&theOldSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::update(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pNewSysNetMonitorDeviceTask, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorDeviceTask->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorDeviceTaskResource::alloc(UPDATE_ACTION,this,pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask,updateIndex));
		internalUpdate(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask,updateIndex,false);
	}
}

void CSysNetMonitorDeviceTaskFactory::internalRemove(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorDeviceTask++;
#endif
	CWriteableSysNetMonitorDeviceTask theOldSysNetMonitorDeviceTask;
	beforeRemove(pSysNetMonitorDeviceTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorDeviceTask,pSysNetMonitorDeviceTask,sizeof(CSysNetMonitorDeviceTask));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorDeviceTask);
	}
	pMem->free(pSysNetMonitorDeviceTask);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::remove(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorDeviceTask,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorDeviceTaskResource::alloc(DELETE_ACTION,this,pSysNetMonitorDeviceTask,NULL));
		internalRemove(pSysNetMonitorDeviceTask,false);		
	}
}

CSysNetMonitorDeviceTask* CSysNetMonitorDeviceTaskFactory::addOrUpdate(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pNewSysNetMonitorDeviceTask, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorDeviceTask == NULL) {
		return add(pNewSysNetMonitorDeviceTask,pTransaction);
	}
	else {
		update(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask,pTransaction,updateIndex);
		return pSysNetMonitorDeviceTask;
	}
}

void CSysNetMonitorDeviceTaskFactory::retrieve(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pTargetSysNetMonitorDeviceTask)
{
	forceCopy(pTargetSysNetMonitorDeviceTask, pSysNetMonitorDeviceTask, sizeof(CSysNetMonitorDeviceTask));
}
	
int CSysNetMonitorDeviceTaskFactory::addActionTrigger(CSysNetMonitorDeviceTaskActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorDeviceTaskFactory::removeActionTrigger(CSysNetMonitorDeviceTaskActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorDeviceTaskFactory::addCommitTrigger(CSysNetMonitorDeviceTaskCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorDeviceTaskFactory::removeCommitTrigger(CSysNetMonitorDeviceTaskCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorDeviceTask *CSysNetMonitorDeviceTaskFactory::getFirst(void)
{
	CSysNetMonitorDeviceTask *pResult=(CSysNetMonitorDeviceTask *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorDeviceTask *CSysNetMonitorDeviceTaskFactory::getNext(void)
{
	CSysNetMonitorDeviceTask *pResult=(CSysNetMonitorDeviceTask *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorDeviceTaskFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorDeviceTaskFactory::beforeAdd(CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorDeviceTask);
	}
}
	
void CSysNetMonitorDeviceTaskFactory::afterAdd(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::beforeUpdate(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pNewSysNetMonitorDeviceTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorDeviceTask,pNewSysNetMonitorDeviceTask);
	}
}
	
void CSysNetMonitorDeviceTaskFactory::afterUpdate(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorDeviceTask);
	}
}
	
void CSysNetMonitorDeviceTaskFactory::beforeRemove(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::commitAdd(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorDeviceTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::commitUpdate(CSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask, CWriteableSysNetMonitorDeviceTask *pOldSysNetMonitorDeviceTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorDeviceTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorDeviceTask,pOldSysNetMonitorDeviceTask);
	}
}
	
void CSysNetMonitorDeviceTaskFactory::commitRemove(CWriteableSysNetMonitorDeviceTask *pSysNetMonitorDeviceTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorDeviceTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorDeviceTask);
	}
}

void CSysNetMonitorDeviceTaskFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMonitorTaskInstAttrs(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMonitorTaskInstAttrs=0;
int updateWithIndexActionForSysNetMonitorTaskInstAttrs=0;
int updateWithoutIndexActionForSysNetMonitorTaskInstAttrs=0;
int removeActionForSysNetMonitorTaskInstAttrs=0;
int addCommitForSysNetMonitorTaskInstAttrs=0;
int updateCommitForSysNetMonitorTaskInstAttrs=0;
int removeCommitForSysNetMonitorTaskInstAttrs=0;
#endif
void CSysNetMonitorTaskInstAttrsFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskInstAttrs,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMonitorTaskInstAttrs_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMonitorTaskInstAttrs_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMonitorTaskInstAttrs,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMonitorTaskInstAttrsActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMonitorTaskInstAttrsCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMonitorTaskInstAttrsFactory::CSysNetMonitorTaskInstAttrsFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskInstAttrs),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMonitorTaskInstAttrsFactory::CSysNetMonitorTaskInstAttrsFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMonitorTaskInstAttrs),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMonitorTaskInstAttrsFactory::~CSysNetMonitorTaskInstAttrsFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMonitorTaskInstAttrsFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMonitorTaskInstAttrsFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMonitorTaskInstAttrsFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMonitorTaskInstAttrs thisSysNetMonitorTaskInstAttrs;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMonitorTaskInstAttrs.readCSV(input,pNames))
		add(&thisSysNetMonitorTaskInstAttrs);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMonitorTaskInstAttrsFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMonitorTaskInstAttrs.csv");
	return readCSV(szFileName);
}

int CSysNetMonitorTaskInstAttrsFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMonitorTaskInstAttrs::writeCSVHead(output);
	pSysNetMonitorTaskInstAttrs=(CWriteableSysNetMonitorTaskInstAttrs *)(pMem->getFirst());
	while (pSysNetMonitorTaskInstAttrs!=NULL) {
		if (!pSysNetMonitorTaskInstAttrs->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMonitorTaskInstAttrs=(CWriteableSysNetMonitorTaskInstAttrs *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMonitorTaskInstAttrsFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMonitorTaskInstAttrs.csv");
	return writeCSV(szFileName);
}

void CSysNetMonitorTaskInstAttrsFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMonitorTaskInstAttrsFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMonitorTaskInstAttrsFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMonitorTaskInstAttrs=(CWriteableSysNetMonitorTaskInstAttrs *)(pMem->getFirst());
	while (pSysNetMonitorTaskInstAttrs!=NULL) {
		pSysNetMonitorTaskInstAttrs->dump(fp,index++);
		pSysNetMonitorTaskInstAttrs=(CWriteableSysNetMonitorTaskInstAttrs *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMonitorTaskInstAttrsFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMonitorTaskInstAttrs *CSysNetMonitorTaskInstAttrsFactory::internalAdd(CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMonitorTaskInstAttrs++;
#endif
	CSysNetMonitorTaskInstAttrs *pTarget;	
	beforeAdd(pSysNetMonitorTaskInstAttrs);
	pTarget=(CSysNetMonitorTaskInstAttrs *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMonitorTaskInstAttrs in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMonitorTaskInstAttrs, sizeof(CSysNetMonitorTaskInstAttrs));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMonitorTaskInstAttrs *CSysNetMonitorTaskInstAttrsFactory::add(CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CTransaction *pTransaction)
{
	pSysNetMonitorTaskInstAttrs->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMonitorTaskInstAttrs,true);
	}
	else {
		CSysNetMonitorTaskInstAttrs *pNewSysNetMonitorTaskInstAttrs;
		pNewSysNetMonitorTaskInstAttrs = internalAdd(pSysNetMonitorTaskInstAttrs,false);
		pTransaction->addResource(CSysNetMonitorTaskInstAttrsResource::alloc(CREATE_ACTION,this,pNewSysNetMonitorTaskInstAttrs,NULL));
		return pNewSysNetMonitorTaskInstAttrs;
	}
}

void CSysNetMonitorTaskInstAttrsFactory::internalUpdate(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pNewSysNetMonitorTaskInstAttrs, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMonitorTaskInstAttrs++;
	}
	else {
		updateWithoutIndexActionForSysNetMonitorTaskInstAttrs++;
	}
#endif
	CWriteableSysNetMonitorTaskInstAttrs theOldSysNetMonitorTaskInstAttrs;
	beforeUpdate(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskInstAttrs,pSysNetMonitorTaskInstAttrs,sizeof(CSysNetMonitorTaskInstAttrs));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs,sizeof(CSysNetMonitorTaskInstAttrs));
	pMem->updateObject(pSysNetMonitorTaskInstAttrs);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMonitorTaskInstAttrs);
	if (bNoTransaction) {
		commitUpdate(pSysNetMonitorTaskInstAttrs,&theOldSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::update(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pNewSysNetMonitorTaskInstAttrs, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMonitorTaskInstAttrs->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskInstAttrsResource::alloc(UPDATE_ACTION,this,pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs,updateIndex));
		internalUpdate(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs,updateIndex,false);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::internalRemove(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMonitorTaskInstAttrs++;
#endif
	CWriteableSysNetMonitorTaskInstAttrs theOldSysNetMonitorTaskInstAttrs;
	beforeRemove(pSysNetMonitorTaskInstAttrs);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMonitorTaskInstAttrs,pSysNetMonitorTaskInstAttrs,sizeof(CSysNetMonitorTaskInstAttrs));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMonitorTaskInstAttrs);
	}
	pMem->free(pSysNetMonitorTaskInstAttrs);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::remove(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMonitorTaskInstAttrs,true);
	}
	else {
		pTransaction->addResource(CSysNetMonitorTaskInstAttrsResource::alloc(DELETE_ACTION,this,pSysNetMonitorTaskInstAttrs,NULL));
		internalRemove(pSysNetMonitorTaskInstAttrs,false);		
	}
}

CSysNetMonitorTaskInstAttrs* CSysNetMonitorTaskInstAttrsFactory::addOrUpdate(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pNewSysNetMonitorTaskInstAttrs, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMonitorTaskInstAttrs == NULL) {
		return add(pNewSysNetMonitorTaskInstAttrs,pTransaction);
	}
	else {
		update(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs,pTransaction,updateIndex);
		return pSysNetMonitorTaskInstAttrs;
	}
}

void CSysNetMonitorTaskInstAttrsFactory::retrieve(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pTargetSysNetMonitorTaskInstAttrs)
{
	forceCopy(pTargetSysNetMonitorTaskInstAttrs, pSysNetMonitorTaskInstAttrs, sizeof(CSysNetMonitorTaskInstAttrs));
}
	
int CSysNetMonitorTaskInstAttrsFactory::addActionTrigger(CSysNetMonitorTaskInstAttrsActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMonitorTaskInstAttrsFactory::removeActionTrigger(CSysNetMonitorTaskInstAttrsActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMonitorTaskInstAttrsFactory::addCommitTrigger(CSysNetMonitorTaskInstAttrsCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMonitorTaskInstAttrsFactory::removeCommitTrigger(CSysNetMonitorTaskInstAttrsCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMonitorTaskInstAttrs *CSysNetMonitorTaskInstAttrsFactory::getFirst(void)
{
	CSysNetMonitorTaskInstAttrs *pResult=(CSysNetMonitorTaskInstAttrs *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMonitorTaskInstAttrs *CSysNetMonitorTaskInstAttrsFactory::getNext(void)
{
	CSysNetMonitorTaskInstAttrs *pResult=(CSysNetMonitorTaskInstAttrs *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMonitorTaskInstAttrsFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMonitorTaskInstAttrsFactory::beforeAdd(CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMonitorTaskInstAttrs);
	}
}
	
void CSysNetMonitorTaskInstAttrsFactory::afterAdd(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::beforeUpdate(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pNewSysNetMonitorTaskInstAttrs)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMonitorTaskInstAttrs,pNewSysNetMonitorTaskInstAttrs);
	}
}
	
void CSysNetMonitorTaskInstAttrsFactory::afterUpdate(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMonitorTaskInstAttrs);
	}
}
	
void CSysNetMonitorTaskInstAttrsFactory::beforeRemove(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::commitAdd(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMonitorTaskInstAttrs++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::commitUpdate(CSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs, CWriteableSysNetMonitorTaskInstAttrs *pOldSysNetMonitorTaskInstAttrs)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMonitorTaskInstAttrs++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMonitorTaskInstAttrs,pOldSysNetMonitorTaskInstAttrs);
	}
}
	
void CSysNetMonitorTaskInstAttrsFactory::commitRemove(CWriteableSysNetMonitorTaskInstAttrs *pSysNetMonitorTaskInstAttrs)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMonitorTaskInstAttrs++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMonitorTaskInstAttrs);
	}
}

void CSysNetMonitorTaskInstAttrsFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetBaseLine(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetBaseLine=0;
int updateWithIndexActionForSysNetBaseLine=0;
int updateWithoutIndexActionForSysNetBaseLine=0;
int removeActionForSysNetBaseLine=0;
int addCommitForSysNetBaseLine=0;
int updateCommitForSysNetBaseLine=0;
int removeCommitForSysNetBaseLine=0;
#endif
void CSysNetBaseLineFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetBaseLine,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetBaseLine_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetBaseLine_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetBaseLine,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByID=NULL;
	pActionTriggers=new vector<CSysNetBaseLineActionTrigger *>;
	pCommitTriggers=new vector<CSysNetBaseLineCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetBaseLineFactory::CSysNetBaseLineFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetBaseLine),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetBaseLineFactory::CSysNetBaseLineFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetBaseLine),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetBaseLineFactory::~CSysNetBaseLineFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetBaseLineFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetBaseLineFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetBaseLineFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetBaseLine thisSysNetBaseLine;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetBaseLine.readCSV(input,pNames))
		add(&thisSysNetBaseLine);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetBaseLineFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetBaseLine.csv");
	return readCSV(szFileName);
}

int CSysNetBaseLineFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetBaseLine *pSysNetBaseLine;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetBaseLine::writeCSVHead(output);
	pSysNetBaseLine=(CWriteableSysNetBaseLine *)(pMem->getFirst());
	while (pSysNetBaseLine!=NULL) {
		if (!pSysNetBaseLine->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetBaseLine=(CWriteableSysNetBaseLine *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetBaseLineFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetBaseLine.csv");
	return writeCSV(szFileName);
}

void CSysNetBaseLineFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetBaseLineFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetBaseLine *pSysNetBaseLine;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetBaseLineFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetBaseLine=(CWriteableSysNetBaseLine *)(pMem->getFirst());
	while (pSysNetBaseLine!=NULL) {
		pSysNetBaseLine->dump(fp,index++);
		pSysNetBaseLine=(CWriteableSysNetBaseLine *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetBaseLineFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetBaseLine *CSysNetBaseLineFactory::internalAdd(CWriteableSysNetBaseLine *pSysNetBaseLine, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetBaseLine++;
#endif
	CSysNetBaseLine *pTarget;	
	beforeAdd(pSysNetBaseLine);
	pTarget=(CSysNetBaseLine *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetBaseLine in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetBaseLine, sizeof(CSysNetBaseLine));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetBaseLine *CSysNetBaseLineFactory::add(CWriteableSysNetBaseLine *pSysNetBaseLine, CTransaction *pTransaction)
{
	pSysNetBaseLine->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetBaseLine,true);
	}
	else {
		CSysNetBaseLine *pNewSysNetBaseLine;
		pNewSysNetBaseLine = internalAdd(pSysNetBaseLine,false);
		pTransaction->addResource(CSysNetBaseLineResource::alloc(CREATE_ACTION,this,pNewSysNetBaseLine,NULL));
		return pNewSysNetBaseLine;
	}
}

void CSysNetBaseLineFactory::internalUpdate(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pNewSysNetBaseLine, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetBaseLine++;
	}
	else {
		updateWithoutIndexActionForSysNetBaseLine++;
	}
#endif
	CWriteableSysNetBaseLine theOldSysNetBaseLine;
	beforeUpdate(pSysNetBaseLine,pNewSysNetBaseLine);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetBaseLine,pSysNetBaseLine,sizeof(CSysNetBaseLine));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetBaseLine,pNewSysNetBaseLine,sizeof(CSysNetBaseLine));
	pMem->updateObject(pSysNetBaseLine);
	if (updateIndex) {
	}
	afterUpdate(pSysNetBaseLine);
	if (bNoTransaction) {
		commitUpdate(pSysNetBaseLine,&theOldSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::update(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pNewSysNetBaseLine, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetBaseLine->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetBaseLine,pNewSysNetBaseLine,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetBaseLineResource::alloc(UPDATE_ACTION,this,pSysNetBaseLine,pNewSysNetBaseLine,updateIndex));
		internalUpdate(pSysNetBaseLine,pNewSysNetBaseLine,updateIndex,false);
	}
}

void CSysNetBaseLineFactory::internalRemove(CSysNetBaseLine *pSysNetBaseLine, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetBaseLine++;
#endif
	CWriteableSysNetBaseLine theOldSysNetBaseLine;
	beforeRemove(pSysNetBaseLine);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetBaseLine,pSysNetBaseLine,sizeof(CSysNetBaseLine));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetBaseLine);
	}
	pMem->free(pSysNetBaseLine);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::remove(CSysNetBaseLine *pSysNetBaseLine, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetBaseLine,true);
	}
	else {
		pTransaction->addResource(CSysNetBaseLineResource::alloc(DELETE_ACTION,this,pSysNetBaseLine,NULL));
		internalRemove(pSysNetBaseLine,false);		
	}
}

CSysNetBaseLine* CSysNetBaseLineFactory::addOrUpdate(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pNewSysNetBaseLine, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetBaseLine == NULL) {
		return add(pNewSysNetBaseLine,pTransaction);
	}
	else {
		update(pSysNetBaseLine,pNewSysNetBaseLine,pTransaction,updateIndex);
		return pSysNetBaseLine;
	}
}

void CSysNetBaseLineFactory::retrieve(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pTargetSysNetBaseLine)
{
	forceCopy(pTargetSysNetBaseLine, pSysNetBaseLine, sizeof(CSysNetBaseLine));
}
	
int CSysNetBaseLineFactory::addActionTrigger(CSysNetBaseLineActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetBaseLineFactory::removeActionTrigger(CSysNetBaseLineActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetBaseLineFactory::addCommitTrigger(CSysNetBaseLineCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetBaseLineFactory::removeCommitTrigger(CSysNetBaseLineCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetBaseLine *CSysNetBaseLineFactory::getFirst(void)
{
	CSysNetBaseLine *pResult=(CSysNetBaseLine *)(pMem->getFirst());
	return pResult;
}
	
CSysNetBaseLine *CSysNetBaseLineFactory::getNext(void)
{
	CSysNetBaseLine *pResult=(CSysNetBaseLine *)(pMem->getNext());
	return pResult;
}
	
void CSysNetBaseLineFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetBaseLineFactory::beforeAdd(CWriteableSysNetBaseLine *pSysNetBaseLine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetBaseLine);
	}
}
	
void CSysNetBaseLineFactory::afterAdd(CSysNetBaseLine *pSysNetBaseLine)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::beforeUpdate(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pNewSysNetBaseLine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetBaseLine,pNewSysNetBaseLine);
	}
}
	
void CSysNetBaseLineFactory::afterUpdate(CSysNetBaseLine *pSysNetBaseLine)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetBaseLine);
	}
}
	
void CSysNetBaseLineFactory::beforeRemove(CSysNetBaseLine *pSysNetBaseLine)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::commitAdd(CSysNetBaseLine *pSysNetBaseLine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetBaseLine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::commitUpdate(CSysNetBaseLine *pSysNetBaseLine, CWriteableSysNetBaseLine *pOldSysNetBaseLine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetBaseLine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetBaseLine,pOldSysNetBaseLine);
	}
}
	
void CSysNetBaseLineFactory::commitRemove(CWriteableSysNetBaseLine *pSysNetBaseLine)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetBaseLine++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetBaseLine);
	}
}

void CSysNetBaseLineFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetBaseLineTask(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetBaseLineTask=0;
int updateWithIndexActionForSysNetBaseLineTask=0;
int updateWithoutIndexActionForSysNetBaseLineTask=0;
int removeActionForSysNetBaseLineTask=0;
int addCommitForSysNetBaseLineTask=0;
int updateCommitForSysNetBaseLineTask=0;
int removeCommitForSysNetBaseLineTask=0;
#endif
void CSysNetBaseLineTaskFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetBaseLineTask,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetBaseLineTask_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetBaseLineTask_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetBaseLineTask,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetBaseLineTaskActionTrigger *>;
	pCommitTriggers=new vector<CSysNetBaseLineTaskCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetBaseLineTaskFactory::CSysNetBaseLineTaskFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetBaseLineTask),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetBaseLineTaskFactory::CSysNetBaseLineTaskFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetBaseLineTask),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetBaseLineTaskFactory::~CSysNetBaseLineTaskFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetBaseLineTaskFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetBaseLineTaskFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetBaseLineTaskFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetBaseLineTask thisSysNetBaseLineTask;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetBaseLineTask.readCSV(input,pNames))
		add(&thisSysNetBaseLineTask);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetBaseLineTaskFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetBaseLineTask.csv");
	return readCSV(szFileName);
}

int CSysNetBaseLineTaskFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetBaseLineTask *pSysNetBaseLineTask;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetBaseLineTask::writeCSVHead(output);
	pSysNetBaseLineTask=(CWriteableSysNetBaseLineTask *)(pMem->getFirst());
	while (pSysNetBaseLineTask!=NULL) {
		if (!pSysNetBaseLineTask->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetBaseLineTask=(CWriteableSysNetBaseLineTask *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetBaseLineTaskFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetBaseLineTask.csv");
	return writeCSV(szFileName);
}

void CSysNetBaseLineTaskFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetBaseLineTaskFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetBaseLineTask *pSysNetBaseLineTask;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetBaseLineTaskFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetBaseLineTask=(CWriteableSysNetBaseLineTask *)(pMem->getFirst());
	while (pSysNetBaseLineTask!=NULL) {
		pSysNetBaseLineTask->dump(fp,index++);
		pSysNetBaseLineTask=(CWriteableSysNetBaseLineTask *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetBaseLineTaskFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetBaseLineTask *CSysNetBaseLineTaskFactory::internalAdd(CWriteableSysNetBaseLineTask *pSysNetBaseLineTask, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetBaseLineTask++;
#endif
	CSysNetBaseLineTask *pTarget;	
	beforeAdd(pSysNetBaseLineTask);
	pTarget=(CSysNetBaseLineTask *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetBaseLineTask in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetBaseLineTask, sizeof(CSysNetBaseLineTask));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetBaseLineTask *CSysNetBaseLineTaskFactory::add(CWriteableSysNetBaseLineTask *pSysNetBaseLineTask, CTransaction *pTransaction)
{
	pSysNetBaseLineTask->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetBaseLineTask,true);
	}
	else {
		CSysNetBaseLineTask *pNewSysNetBaseLineTask;
		pNewSysNetBaseLineTask = internalAdd(pSysNetBaseLineTask,false);
		pTransaction->addResource(CSysNetBaseLineTaskResource::alloc(CREATE_ACTION,this,pNewSysNetBaseLineTask,NULL));
		return pNewSysNetBaseLineTask;
	}
}

void CSysNetBaseLineTaskFactory::internalUpdate(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pNewSysNetBaseLineTask, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetBaseLineTask++;
	}
	else {
		updateWithoutIndexActionForSysNetBaseLineTask++;
	}
#endif
	CWriteableSysNetBaseLineTask theOldSysNetBaseLineTask;
	beforeUpdate(pSysNetBaseLineTask,pNewSysNetBaseLineTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetBaseLineTask,pSysNetBaseLineTask,sizeof(CSysNetBaseLineTask));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetBaseLineTask,pNewSysNetBaseLineTask,sizeof(CSysNetBaseLineTask));
	pMem->updateObject(pSysNetBaseLineTask);
	if (updateIndex) {
	}
	afterUpdate(pSysNetBaseLineTask);
	if (bNoTransaction) {
		commitUpdate(pSysNetBaseLineTask,&theOldSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::update(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pNewSysNetBaseLineTask, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetBaseLineTask->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetBaseLineTask,pNewSysNetBaseLineTask,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetBaseLineTaskResource::alloc(UPDATE_ACTION,this,pSysNetBaseLineTask,pNewSysNetBaseLineTask,updateIndex));
		internalUpdate(pSysNetBaseLineTask,pNewSysNetBaseLineTask,updateIndex,false);
	}
}

void CSysNetBaseLineTaskFactory::internalRemove(CSysNetBaseLineTask *pSysNetBaseLineTask, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetBaseLineTask++;
#endif
	CWriteableSysNetBaseLineTask theOldSysNetBaseLineTask;
	beforeRemove(pSysNetBaseLineTask);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetBaseLineTask,pSysNetBaseLineTask,sizeof(CSysNetBaseLineTask));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetBaseLineTask);
	}
	pMem->free(pSysNetBaseLineTask);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::remove(CSysNetBaseLineTask *pSysNetBaseLineTask, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetBaseLineTask,true);
	}
	else {
		pTransaction->addResource(CSysNetBaseLineTaskResource::alloc(DELETE_ACTION,this,pSysNetBaseLineTask,NULL));
		internalRemove(pSysNetBaseLineTask,false);		
	}
}

CSysNetBaseLineTask* CSysNetBaseLineTaskFactory::addOrUpdate(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pNewSysNetBaseLineTask, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetBaseLineTask == NULL) {
		return add(pNewSysNetBaseLineTask,pTransaction);
	}
	else {
		update(pSysNetBaseLineTask,pNewSysNetBaseLineTask,pTransaction,updateIndex);
		return pSysNetBaseLineTask;
	}
}

void CSysNetBaseLineTaskFactory::retrieve(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pTargetSysNetBaseLineTask)
{
	forceCopy(pTargetSysNetBaseLineTask, pSysNetBaseLineTask, sizeof(CSysNetBaseLineTask));
}
	
int CSysNetBaseLineTaskFactory::addActionTrigger(CSysNetBaseLineTaskActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetBaseLineTaskFactory::removeActionTrigger(CSysNetBaseLineTaskActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetBaseLineTaskFactory::addCommitTrigger(CSysNetBaseLineTaskCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetBaseLineTaskFactory::removeCommitTrigger(CSysNetBaseLineTaskCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetBaseLineTask *CSysNetBaseLineTaskFactory::getFirst(void)
{
	CSysNetBaseLineTask *pResult=(CSysNetBaseLineTask *)(pMem->getFirst());
	return pResult;
}
	
CSysNetBaseLineTask *CSysNetBaseLineTaskFactory::getNext(void)
{
	CSysNetBaseLineTask *pResult=(CSysNetBaseLineTask *)(pMem->getNext());
	return pResult;
}
	
void CSysNetBaseLineTaskFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetBaseLineTaskFactory::beforeAdd(CWriteableSysNetBaseLineTask *pSysNetBaseLineTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetBaseLineTask);
	}
}
	
void CSysNetBaseLineTaskFactory::afterAdd(CSysNetBaseLineTask *pSysNetBaseLineTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::beforeUpdate(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pNewSysNetBaseLineTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetBaseLineTask,pNewSysNetBaseLineTask);
	}
}
	
void CSysNetBaseLineTaskFactory::afterUpdate(CSysNetBaseLineTask *pSysNetBaseLineTask)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetBaseLineTask);
	}
}
	
void CSysNetBaseLineTaskFactory::beforeRemove(CSysNetBaseLineTask *pSysNetBaseLineTask)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::commitAdd(CSysNetBaseLineTask *pSysNetBaseLineTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetBaseLineTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::commitUpdate(CSysNetBaseLineTask *pSysNetBaseLineTask, CWriteableSysNetBaseLineTask *pOldSysNetBaseLineTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetBaseLineTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetBaseLineTask,pOldSysNetBaseLineTask);
	}
}
	
void CSysNetBaseLineTaskFactory::commitRemove(CWriteableSysNetBaseLineTask *pSysNetBaseLineTask)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetBaseLineTask++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetBaseLineTask);
	}
}

void CSysNetBaseLineTaskFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysDateTimeIndexinSysMdbNetPartyLinkStatusInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbNetPartyLinkStatusInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbNetPartyLinkStatusInfo=0;
int updateWithIndexActionForSysMdbNetPartyLinkStatusInfo=0;
int updateWithoutIndexActionForSysMdbNetPartyLinkStatusInfo=0;
int removeActionForSysMdbNetPartyLinkStatusInfo=0;
int addCommitForSysMdbNetPartyLinkStatusInfo=0;
int updateCommitForSysMdbNetPartyLinkStatusInfo=0;
int removeCommitForSysMdbNetPartyLinkStatusInfo=0;
#endif
void CSysMdbNetPartyLinkStatusInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysDateTimeIndex=new CAVLTree(maxUnit,compareForSysDateTimeIndexinSysMdbNetPartyLinkStatusInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbNetPartyLinkStatusInfo_SysDateTimeIndex",pSysDateTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbNetPartyLinkStatusInfo_SysDateTimeIndex");
			if(it != pIndexMap->end()) {
				pSysDateTimeIndex=new CAVLTree(maxUnit,compareForSysDateTimeIndexinSysMdbNetPartyLinkStatusInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysDateTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbNetPartyLinkStatusInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbNetPartyLinkStatusInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbNetPartyLinkStatusInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbNetPartyLinkStatusInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByTime=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysMdbNetPartyLinkStatusInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbNetPartyLinkStatusInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbNetPartyLinkStatusInfoFactory::CSysMdbNetPartyLinkStatusInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbNetPartyLinkStatusInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbNetPartyLinkStatusInfoFactory::CSysMdbNetPartyLinkStatusInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbNetPartyLinkStatusInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbNetPartyLinkStatusInfoFactory::~CSysMdbNetPartyLinkStatusInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysDateTimeIndex!=NULL)
			delete pSysDateTimeIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbNetPartyLinkStatusInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbNetPartyLinkStatusInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysDateTimeIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbNetPartyLinkStatusInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbNetPartyLinkStatusInfo thisSysMdbNetPartyLinkStatusInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbNetPartyLinkStatusInfo.readCSV(input,pNames))
		add(&thisSysMdbNetPartyLinkStatusInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbNetPartyLinkStatusInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbNetPartyLinkStatusInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbNetPartyLinkStatusInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbNetPartyLinkStatusInfo::writeCSVHead(output);
	pSysMdbNetPartyLinkStatusInfo=(CWriteableSysMdbNetPartyLinkStatusInfo *)(pMem->getFirst());
	while (pSysMdbNetPartyLinkStatusInfo!=NULL) {
		if (!pSysMdbNetPartyLinkStatusInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbNetPartyLinkStatusInfo=(CWriteableSysMdbNetPartyLinkStatusInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbNetPartyLinkStatusInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbNetPartyLinkStatusInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbNetPartyLinkStatusInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbNetPartyLinkStatusInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbNetPartyLinkStatusInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbNetPartyLinkStatusInfo=(CWriteableSysMdbNetPartyLinkStatusInfo *)(pMem->getFirst());
	while (pSysMdbNetPartyLinkStatusInfo!=NULL) {
		pSysMdbNetPartyLinkStatusInfo->dump(fp,index++);
		pSysMdbNetPartyLinkStatusInfo=(CWriteableSysMdbNetPartyLinkStatusInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbNetPartyLinkStatusInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysDateTimeIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbNetPartyLinkStatusInfo *CSysMdbNetPartyLinkStatusInfoFactory::internalAdd(CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbNetPartyLinkStatusInfo++;
#endif
	CSysMdbNetPartyLinkStatusInfo *pTarget;	
	beforeAdd(pSysMdbNetPartyLinkStatusInfo);
	pTarget=(CSysMdbNetPartyLinkStatusInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbNetPartyLinkStatusInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbNetPartyLinkStatusInfo, sizeof(CSysMdbNetPartyLinkStatusInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysDateTimeIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbNetPartyLinkStatusInfo *CSysMdbNetPartyLinkStatusInfoFactory::add(CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CTransaction *pTransaction)
{
	pSysMdbNetPartyLinkStatusInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbNetPartyLinkStatusInfo,true);
	}
	else {
		CSysMdbNetPartyLinkStatusInfo *pNewSysMdbNetPartyLinkStatusInfo;
		pNewSysMdbNetPartyLinkStatusInfo = internalAdd(pSysMdbNetPartyLinkStatusInfo,false);
		pTransaction->addResource(CSysMdbNetPartyLinkStatusInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbNetPartyLinkStatusInfo,NULL));
		return pNewSysMdbNetPartyLinkStatusInfo;
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::internalUpdate(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pNewSysMdbNetPartyLinkStatusInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbNetPartyLinkStatusInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbNetPartyLinkStatusInfo++;
	}
#endif
	CWriteableSysMdbNetPartyLinkStatusInfo theOldSysMdbNetPartyLinkStatusInfo;
	beforeUpdate(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbNetPartyLinkStatusInfo,pSysMdbNetPartyLinkStatusInfo,sizeof(CSysMdbNetPartyLinkStatusInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo,sizeof(CSysMdbNetPartyLinkStatusInfo));
	pMem->updateObject(pSysMdbNetPartyLinkStatusInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbNetPartyLinkStatusInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbNetPartyLinkStatusInfo,&theOldSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::update(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pNewSysMdbNetPartyLinkStatusInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbNetPartyLinkStatusInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbNetPartyLinkStatusInfoResource::alloc(UPDATE_ACTION,this,pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo,updateIndex));
		internalUpdate(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo,updateIndex,false);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::internalRemove(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbNetPartyLinkStatusInfo++;
#endif
	CWriteableSysMdbNetPartyLinkStatusInfo theOldSysMdbNetPartyLinkStatusInfo;
	beforeRemove(pSysMdbNetPartyLinkStatusInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbNetPartyLinkStatusInfo,pSysMdbNetPartyLinkStatusInfo,sizeof(CSysMdbNetPartyLinkStatusInfo));
	}
	if (runLevel>=0) {
		pSysDateTimeIndex->removeObject(pSysMdbNetPartyLinkStatusInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbNetPartyLinkStatusInfo);
	}
	pMem->free(pSysMdbNetPartyLinkStatusInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::remove(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbNetPartyLinkStatusInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbNetPartyLinkStatusInfoResource::alloc(DELETE_ACTION,this,pSysMdbNetPartyLinkStatusInfo,NULL));
		internalRemove(pSysMdbNetPartyLinkStatusInfo,false);		
	}
}

CSysMdbNetPartyLinkStatusInfo* CSysMdbNetPartyLinkStatusInfoFactory::addOrUpdate(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pNewSysMdbNetPartyLinkStatusInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbNetPartyLinkStatusInfo == NULL) {
		return add(pNewSysMdbNetPartyLinkStatusInfo,pTransaction);
	}
	else {
		update(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo,pTransaction,updateIndex);
		return pSysMdbNetPartyLinkStatusInfo;
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::retrieve(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pTargetSysMdbNetPartyLinkStatusInfo)
{
	forceCopy(pTargetSysMdbNetPartyLinkStatusInfo, pSysMdbNetPartyLinkStatusInfo, sizeof(CSysMdbNetPartyLinkStatusInfo));
}
	
int CSysMdbNetPartyLinkStatusInfoFactory::addActionTrigger(CSysMdbNetPartyLinkStatusInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbNetPartyLinkStatusInfoFactory::removeActionTrigger(CSysMdbNetPartyLinkStatusInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbNetPartyLinkStatusInfoFactory::addCommitTrigger(CSysMdbNetPartyLinkStatusInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbNetPartyLinkStatusInfoFactory::removeCommitTrigger(CSysMdbNetPartyLinkStatusInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbNetPartyLinkStatusInfo *CSysMdbNetPartyLinkStatusInfoFactory::getFirst(void)
{
	CSysMdbNetPartyLinkStatusInfo *pResult=(CSysMdbNetPartyLinkStatusInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbNetPartyLinkStatusInfo *CSysMdbNetPartyLinkStatusInfoFactory::getNext(void)
{
	CSysMdbNetPartyLinkStatusInfo *pResult=(CSysMdbNetPartyLinkStatusInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbNetPartyLinkStatusInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbNetPartyLinkStatusInfoFactory::beforeAdd(CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbNetPartyLinkStatusInfo);
	}
}
	
void CSysMdbNetPartyLinkStatusInfoFactory::afterAdd(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::beforeUpdate(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pNewSysMdbNetPartyLinkStatusInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbNetPartyLinkStatusInfo,pNewSysMdbNetPartyLinkStatusInfo);
	}
}
	
void CSysMdbNetPartyLinkStatusInfoFactory::afterUpdate(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbNetPartyLinkStatusInfo);
	}
}
	
void CSysMdbNetPartyLinkStatusInfoFactory::beforeRemove(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::commitAdd(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbNetPartyLinkStatusInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::commitUpdate(CSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo, CWriteableSysMdbNetPartyLinkStatusInfo *pOldSysMdbNetPartyLinkStatusInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbNetPartyLinkStatusInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbNetPartyLinkStatusInfo,pOldSysMdbNetPartyLinkStatusInfo);
	}
}
	
void CSysMdbNetPartyLinkStatusInfoFactory::commitRemove(CWriteableSysMdbNetPartyLinkStatusInfo *pSysMdbNetPartyLinkStatusInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbNetPartyLinkStatusInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbNetPartyLinkStatusInfo);
	}
}

void CSysMdbNetPartyLinkStatusInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetMemberSDHLineInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetMemberSDHLineInfo=0;
int updateWithIndexActionForSysNetMemberSDHLineInfo=0;
int updateWithoutIndexActionForSysNetMemberSDHLineInfo=0;
int removeActionForSysNetMemberSDHLineInfo=0;
int addCommitForSysNetMemberSDHLineInfo=0;
int updateCommitForSysNetMemberSDHLineInfo=0;
int removeCommitForSysNetMemberSDHLineInfo=0;
#endif
void CSysNetMemberSDHLineInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMemberSDHLineInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetMemberSDHLineInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetMemberSDHLineInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetMemberSDHLineInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetMemberSDHLineInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetMemberSDHLineInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetMemberSDHLineInfoFactory::CSysNetMemberSDHLineInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMemberSDHLineInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetMemberSDHLineInfoFactory::CSysNetMemberSDHLineInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetMemberSDHLineInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetMemberSDHLineInfoFactory::~CSysNetMemberSDHLineInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetMemberSDHLineInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetMemberSDHLineInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetMemberSDHLineInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetMemberSDHLineInfo thisSysNetMemberSDHLineInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetMemberSDHLineInfo.readCSV(input,pNames))
		add(&thisSysNetMemberSDHLineInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetMemberSDHLineInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetMemberSDHLineInfo.csv");
	return readCSV(szFileName);
}

int CSysNetMemberSDHLineInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetMemberSDHLineInfo::writeCSVHead(output);
	pSysNetMemberSDHLineInfo=(CWriteableSysNetMemberSDHLineInfo *)(pMem->getFirst());
	while (pSysNetMemberSDHLineInfo!=NULL) {
		if (!pSysNetMemberSDHLineInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetMemberSDHLineInfo=(CWriteableSysNetMemberSDHLineInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetMemberSDHLineInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetMemberSDHLineInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetMemberSDHLineInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetMemberSDHLineInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetMemberSDHLineInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetMemberSDHLineInfo=(CWriteableSysNetMemberSDHLineInfo *)(pMem->getFirst());
	while (pSysNetMemberSDHLineInfo!=NULL) {
		pSysNetMemberSDHLineInfo->dump(fp,index++);
		pSysNetMemberSDHLineInfo=(CWriteableSysNetMemberSDHLineInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetMemberSDHLineInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetMemberSDHLineInfo *CSysNetMemberSDHLineInfoFactory::internalAdd(CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetMemberSDHLineInfo++;
#endif
	CSysNetMemberSDHLineInfo *pTarget;	
	beforeAdd(pSysNetMemberSDHLineInfo);
	pTarget=(CSysNetMemberSDHLineInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetMemberSDHLineInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetMemberSDHLineInfo, sizeof(CSysNetMemberSDHLineInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetMemberSDHLineInfo *CSysNetMemberSDHLineInfoFactory::add(CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CTransaction *pTransaction)
{
	pSysNetMemberSDHLineInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetMemberSDHLineInfo,true);
	}
	else {
		CSysNetMemberSDHLineInfo *pNewSysNetMemberSDHLineInfo;
		pNewSysNetMemberSDHLineInfo = internalAdd(pSysNetMemberSDHLineInfo,false);
		pTransaction->addResource(CSysNetMemberSDHLineInfoResource::alloc(CREATE_ACTION,this,pNewSysNetMemberSDHLineInfo,NULL));
		return pNewSysNetMemberSDHLineInfo;
	}
}

void CSysNetMemberSDHLineInfoFactory::internalUpdate(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pNewSysNetMemberSDHLineInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetMemberSDHLineInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetMemberSDHLineInfo++;
	}
#endif
	CWriteableSysNetMemberSDHLineInfo theOldSysNetMemberSDHLineInfo;
	beforeUpdate(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMemberSDHLineInfo,pSysNetMemberSDHLineInfo,sizeof(CSysNetMemberSDHLineInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo,sizeof(CSysNetMemberSDHLineInfo));
	pMem->updateObject(pSysNetMemberSDHLineInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetMemberSDHLineInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetMemberSDHLineInfo,&theOldSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::update(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pNewSysNetMemberSDHLineInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetMemberSDHLineInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetMemberSDHLineInfoResource::alloc(UPDATE_ACTION,this,pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo,updateIndex));
		internalUpdate(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo,updateIndex,false);
	}
}

void CSysNetMemberSDHLineInfoFactory::internalRemove(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetMemberSDHLineInfo++;
#endif
	CWriteableSysNetMemberSDHLineInfo theOldSysNetMemberSDHLineInfo;
	beforeRemove(pSysNetMemberSDHLineInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetMemberSDHLineInfo,pSysNetMemberSDHLineInfo,sizeof(CSysNetMemberSDHLineInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetMemberSDHLineInfo);
	}
	pMem->free(pSysNetMemberSDHLineInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::remove(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetMemberSDHLineInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetMemberSDHLineInfoResource::alloc(DELETE_ACTION,this,pSysNetMemberSDHLineInfo,NULL));
		internalRemove(pSysNetMemberSDHLineInfo,false);		
	}
}

CSysNetMemberSDHLineInfo* CSysNetMemberSDHLineInfoFactory::addOrUpdate(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pNewSysNetMemberSDHLineInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetMemberSDHLineInfo == NULL) {
		return add(pNewSysNetMemberSDHLineInfo,pTransaction);
	}
	else {
		update(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo,pTransaction,updateIndex);
		return pSysNetMemberSDHLineInfo;
	}
}

void CSysNetMemberSDHLineInfoFactory::retrieve(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pTargetSysNetMemberSDHLineInfo)
{
	forceCopy(pTargetSysNetMemberSDHLineInfo, pSysNetMemberSDHLineInfo, sizeof(CSysNetMemberSDHLineInfo));
}
	
int CSysNetMemberSDHLineInfoFactory::addActionTrigger(CSysNetMemberSDHLineInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetMemberSDHLineInfoFactory::removeActionTrigger(CSysNetMemberSDHLineInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetMemberSDHLineInfoFactory::addCommitTrigger(CSysNetMemberSDHLineInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetMemberSDHLineInfoFactory::removeCommitTrigger(CSysNetMemberSDHLineInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetMemberSDHLineInfo *CSysNetMemberSDHLineInfoFactory::getFirst(void)
{
	CSysNetMemberSDHLineInfo *pResult=(CSysNetMemberSDHLineInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetMemberSDHLineInfo *CSysNetMemberSDHLineInfoFactory::getNext(void)
{
	CSysNetMemberSDHLineInfo *pResult=(CSysNetMemberSDHLineInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetMemberSDHLineInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetMemberSDHLineInfoFactory::beforeAdd(CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetMemberSDHLineInfo);
	}
}
	
void CSysNetMemberSDHLineInfoFactory::afterAdd(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::beforeUpdate(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pNewSysNetMemberSDHLineInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetMemberSDHLineInfo,pNewSysNetMemberSDHLineInfo);
	}
}
	
void CSysNetMemberSDHLineInfoFactory::afterUpdate(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetMemberSDHLineInfo);
	}
}
	
void CSysNetMemberSDHLineInfoFactory::beforeRemove(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::commitAdd(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetMemberSDHLineInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::commitUpdate(CSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo, CWriteableSysNetMemberSDHLineInfo *pOldSysNetMemberSDHLineInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetMemberSDHLineInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetMemberSDHLineInfo,pOldSysNetMemberSDHLineInfo);
	}
}
	
void CSysNetMemberSDHLineInfoFactory::commitRemove(CWriteableSysNetMemberSDHLineInfo *pSysNetMemberSDHLineInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetMemberSDHLineInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetMemberSDHLineInfo);
	}
}

void CSysNetMemberSDHLineInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetDDNLinkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetDDNLinkInfo=0;
int updateWithIndexActionForSysNetDDNLinkInfo=0;
int updateWithoutIndexActionForSysNetDDNLinkInfo=0;
int removeActionForSysNetDDNLinkInfo=0;
int addCommitForSysNetDDNLinkInfo=0;
int updateCommitForSysNetDDNLinkInfo=0;
int removeCommitForSysNetDDNLinkInfo=0;
#endif
void CSysNetDDNLinkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDDNLinkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetDDNLinkInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetDDNLinkInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetDDNLinkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetDDNLinkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetDDNLinkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetDDNLinkInfoFactory::CSysNetDDNLinkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDDNLinkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetDDNLinkInfoFactory::CSysNetDDNLinkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetDDNLinkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetDDNLinkInfoFactory::~CSysNetDDNLinkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetDDNLinkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetDDNLinkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetDDNLinkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetDDNLinkInfo thisSysNetDDNLinkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetDDNLinkInfo.readCSV(input,pNames))
		add(&thisSysNetDDNLinkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetDDNLinkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetDDNLinkInfo.csv");
	return readCSV(szFileName);
}

int CSysNetDDNLinkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetDDNLinkInfo::writeCSVHead(output);
	pSysNetDDNLinkInfo=(CWriteableSysNetDDNLinkInfo *)(pMem->getFirst());
	while (pSysNetDDNLinkInfo!=NULL) {
		if (!pSysNetDDNLinkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetDDNLinkInfo=(CWriteableSysNetDDNLinkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetDDNLinkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetDDNLinkInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetDDNLinkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetDDNLinkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetDDNLinkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetDDNLinkInfo=(CWriteableSysNetDDNLinkInfo *)(pMem->getFirst());
	while (pSysNetDDNLinkInfo!=NULL) {
		pSysNetDDNLinkInfo->dump(fp,index++);
		pSysNetDDNLinkInfo=(CWriteableSysNetDDNLinkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetDDNLinkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetDDNLinkInfo *CSysNetDDNLinkInfoFactory::internalAdd(CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetDDNLinkInfo++;
#endif
	CSysNetDDNLinkInfo *pTarget;	
	beforeAdd(pSysNetDDNLinkInfo);
	pTarget=(CSysNetDDNLinkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetDDNLinkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetDDNLinkInfo, sizeof(CSysNetDDNLinkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetDDNLinkInfo *CSysNetDDNLinkInfoFactory::add(CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CTransaction *pTransaction)
{
	pSysNetDDNLinkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetDDNLinkInfo,true);
	}
	else {
		CSysNetDDNLinkInfo *pNewSysNetDDNLinkInfo;
		pNewSysNetDDNLinkInfo = internalAdd(pSysNetDDNLinkInfo,false);
		pTransaction->addResource(CSysNetDDNLinkInfoResource::alloc(CREATE_ACTION,this,pNewSysNetDDNLinkInfo,NULL));
		return pNewSysNetDDNLinkInfo;
	}
}

void CSysNetDDNLinkInfoFactory::internalUpdate(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pNewSysNetDDNLinkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetDDNLinkInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetDDNLinkInfo++;
	}
#endif
	CWriteableSysNetDDNLinkInfo theOldSysNetDDNLinkInfo;
	beforeUpdate(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDDNLinkInfo,pSysNetDDNLinkInfo,sizeof(CSysNetDDNLinkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo,sizeof(CSysNetDDNLinkInfo));
	pMem->updateObject(pSysNetDDNLinkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetDDNLinkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetDDNLinkInfo,&theOldSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::update(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pNewSysNetDDNLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetDDNLinkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetDDNLinkInfoResource::alloc(UPDATE_ACTION,this,pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo,updateIndex));
		internalUpdate(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo,updateIndex,false);
	}
}

void CSysNetDDNLinkInfoFactory::internalRemove(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetDDNLinkInfo++;
#endif
	CWriteableSysNetDDNLinkInfo theOldSysNetDDNLinkInfo;
	beforeRemove(pSysNetDDNLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetDDNLinkInfo,pSysNetDDNLinkInfo,sizeof(CSysNetDDNLinkInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetDDNLinkInfo);
	}
	pMem->free(pSysNetDDNLinkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::remove(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetDDNLinkInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetDDNLinkInfoResource::alloc(DELETE_ACTION,this,pSysNetDDNLinkInfo,NULL));
		internalRemove(pSysNetDDNLinkInfo,false);		
	}
}

CSysNetDDNLinkInfo* CSysNetDDNLinkInfoFactory::addOrUpdate(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pNewSysNetDDNLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetDDNLinkInfo == NULL) {
		return add(pNewSysNetDDNLinkInfo,pTransaction);
	}
	else {
		update(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo,pTransaction,updateIndex);
		return pSysNetDDNLinkInfo;
	}
}

void CSysNetDDNLinkInfoFactory::retrieve(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pTargetSysNetDDNLinkInfo)
{
	forceCopy(pTargetSysNetDDNLinkInfo, pSysNetDDNLinkInfo, sizeof(CSysNetDDNLinkInfo));
}
	
int CSysNetDDNLinkInfoFactory::addActionTrigger(CSysNetDDNLinkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetDDNLinkInfoFactory::removeActionTrigger(CSysNetDDNLinkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetDDNLinkInfoFactory::addCommitTrigger(CSysNetDDNLinkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetDDNLinkInfoFactory::removeCommitTrigger(CSysNetDDNLinkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetDDNLinkInfo *CSysNetDDNLinkInfoFactory::getFirst(void)
{
	CSysNetDDNLinkInfo *pResult=(CSysNetDDNLinkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetDDNLinkInfo *CSysNetDDNLinkInfoFactory::getNext(void)
{
	CSysNetDDNLinkInfo *pResult=(CSysNetDDNLinkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetDDNLinkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetDDNLinkInfoFactory::beforeAdd(CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetDDNLinkInfo);
	}
}
	
void CSysNetDDNLinkInfoFactory::afterAdd(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::beforeUpdate(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pNewSysNetDDNLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetDDNLinkInfo,pNewSysNetDDNLinkInfo);
	}
}
	
void CSysNetDDNLinkInfoFactory::afterUpdate(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetDDNLinkInfo);
	}
}
	
void CSysNetDDNLinkInfoFactory::beforeRemove(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::commitAdd(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetDDNLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::commitUpdate(CSysNetDDNLinkInfo *pSysNetDDNLinkInfo, CWriteableSysNetDDNLinkInfo *pOldSysNetDDNLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetDDNLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetDDNLinkInfo,pOldSysNetDDNLinkInfo);
	}
}
	
void CSysNetDDNLinkInfoFactory::commitRemove(CWriteableSysNetDDNLinkInfo *pSysNetDDNLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetDDNLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetDDNLinkInfo);
	}
}

void CSysNetDDNLinkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetPseudMemberLinkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetPseudMemberLinkInfo=0;
int updateWithIndexActionForSysNetPseudMemberLinkInfo=0;
int updateWithoutIndexActionForSysNetPseudMemberLinkInfo=0;
int removeActionForSysNetPseudMemberLinkInfo=0;
int addCommitForSysNetPseudMemberLinkInfo=0;
int updateCommitForSysNetPseudMemberLinkInfo=0;
int removeCommitForSysNetPseudMemberLinkInfo=0;
#endif
void CSysNetPseudMemberLinkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPseudMemberLinkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetPseudMemberLinkInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetPseudMemberLinkInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetPseudMemberLinkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetPseudMemberLinkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetPseudMemberLinkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetPseudMemberLinkInfoFactory::CSysNetPseudMemberLinkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPseudMemberLinkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetPseudMemberLinkInfoFactory::CSysNetPseudMemberLinkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPseudMemberLinkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetPseudMemberLinkInfoFactory::~CSysNetPseudMemberLinkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetPseudMemberLinkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetPseudMemberLinkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetPseudMemberLinkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetPseudMemberLinkInfo thisSysNetPseudMemberLinkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetPseudMemberLinkInfo.readCSV(input,pNames))
		add(&thisSysNetPseudMemberLinkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetPseudMemberLinkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetPseudMemberLinkInfo.csv");
	return readCSV(szFileName);
}

int CSysNetPseudMemberLinkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetPseudMemberLinkInfo::writeCSVHead(output);
	pSysNetPseudMemberLinkInfo=(CWriteableSysNetPseudMemberLinkInfo *)(pMem->getFirst());
	while (pSysNetPseudMemberLinkInfo!=NULL) {
		if (!pSysNetPseudMemberLinkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetPseudMemberLinkInfo=(CWriteableSysNetPseudMemberLinkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetPseudMemberLinkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetPseudMemberLinkInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetPseudMemberLinkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetPseudMemberLinkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetPseudMemberLinkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetPseudMemberLinkInfo=(CWriteableSysNetPseudMemberLinkInfo *)(pMem->getFirst());
	while (pSysNetPseudMemberLinkInfo!=NULL) {
		pSysNetPseudMemberLinkInfo->dump(fp,index++);
		pSysNetPseudMemberLinkInfo=(CWriteableSysNetPseudMemberLinkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetPseudMemberLinkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetPseudMemberLinkInfo *CSysNetPseudMemberLinkInfoFactory::internalAdd(CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetPseudMemberLinkInfo++;
#endif
	CSysNetPseudMemberLinkInfo *pTarget;	
	beforeAdd(pSysNetPseudMemberLinkInfo);
	pTarget=(CSysNetPseudMemberLinkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetPseudMemberLinkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetPseudMemberLinkInfo, sizeof(CSysNetPseudMemberLinkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetPseudMemberLinkInfo *CSysNetPseudMemberLinkInfoFactory::add(CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CTransaction *pTransaction)
{
	pSysNetPseudMemberLinkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetPseudMemberLinkInfo,true);
	}
	else {
		CSysNetPseudMemberLinkInfo *pNewSysNetPseudMemberLinkInfo;
		pNewSysNetPseudMemberLinkInfo = internalAdd(pSysNetPseudMemberLinkInfo,false);
		pTransaction->addResource(CSysNetPseudMemberLinkInfoResource::alloc(CREATE_ACTION,this,pNewSysNetPseudMemberLinkInfo,NULL));
		return pNewSysNetPseudMemberLinkInfo;
	}
}

void CSysNetPseudMemberLinkInfoFactory::internalUpdate(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pNewSysNetPseudMemberLinkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetPseudMemberLinkInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetPseudMemberLinkInfo++;
	}
#endif
	CWriteableSysNetPseudMemberLinkInfo theOldSysNetPseudMemberLinkInfo;
	beforeUpdate(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPseudMemberLinkInfo,pSysNetPseudMemberLinkInfo,sizeof(CSysNetPseudMemberLinkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo,sizeof(CSysNetPseudMemberLinkInfo));
	pMem->updateObject(pSysNetPseudMemberLinkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetPseudMemberLinkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetPseudMemberLinkInfo,&theOldSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::update(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pNewSysNetPseudMemberLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetPseudMemberLinkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetPseudMemberLinkInfoResource::alloc(UPDATE_ACTION,this,pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo,updateIndex));
		internalUpdate(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo,updateIndex,false);
	}
}

void CSysNetPseudMemberLinkInfoFactory::internalRemove(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetPseudMemberLinkInfo++;
#endif
	CWriteableSysNetPseudMemberLinkInfo theOldSysNetPseudMemberLinkInfo;
	beforeRemove(pSysNetPseudMemberLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPseudMemberLinkInfo,pSysNetPseudMemberLinkInfo,sizeof(CSysNetPseudMemberLinkInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetPseudMemberLinkInfo);
	}
	pMem->free(pSysNetPseudMemberLinkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::remove(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetPseudMemberLinkInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetPseudMemberLinkInfoResource::alloc(DELETE_ACTION,this,pSysNetPseudMemberLinkInfo,NULL));
		internalRemove(pSysNetPseudMemberLinkInfo,false);		
	}
}

CSysNetPseudMemberLinkInfo* CSysNetPseudMemberLinkInfoFactory::addOrUpdate(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pNewSysNetPseudMemberLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetPseudMemberLinkInfo == NULL) {
		return add(pNewSysNetPseudMemberLinkInfo,pTransaction);
	}
	else {
		update(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo,pTransaction,updateIndex);
		return pSysNetPseudMemberLinkInfo;
	}
}

void CSysNetPseudMemberLinkInfoFactory::retrieve(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pTargetSysNetPseudMemberLinkInfo)
{
	forceCopy(pTargetSysNetPseudMemberLinkInfo, pSysNetPseudMemberLinkInfo, sizeof(CSysNetPseudMemberLinkInfo));
}
	
int CSysNetPseudMemberLinkInfoFactory::addActionTrigger(CSysNetPseudMemberLinkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetPseudMemberLinkInfoFactory::removeActionTrigger(CSysNetPseudMemberLinkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetPseudMemberLinkInfoFactory::addCommitTrigger(CSysNetPseudMemberLinkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetPseudMemberLinkInfoFactory::removeCommitTrigger(CSysNetPseudMemberLinkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetPseudMemberLinkInfo *CSysNetPseudMemberLinkInfoFactory::getFirst(void)
{
	CSysNetPseudMemberLinkInfo *pResult=(CSysNetPseudMemberLinkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetPseudMemberLinkInfo *CSysNetPseudMemberLinkInfoFactory::getNext(void)
{
	CSysNetPseudMemberLinkInfo *pResult=(CSysNetPseudMemberLinkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetPseudMemberLinkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetPseudMemberLinkInfoFactory::beforeAdd(CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetPseudMemberLinkInfo);
	}
}
	
void CSysNetPseudMemberLinkInfoFactory::afterAdd(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::beforeUpdate(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pNewSysNetPseudMemberLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetPseudMemberLinkInfo,pNewSysNetPseudMemberLinkInfo);
	}
}
	
void CSysNetPseudMemberLinkInfoFactory::afterUpdate(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetPseudMemberLinkInfo);
	}
}
	
void CSysNetPseudMemberLinkInfoFactory::beforeRemove(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::commitAdd(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetPseudMemberLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::commitUpdate(CSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo, CWriteableSysNetPseudMemberLinkInfo *pOldSysNetPseudMemberLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetPseudMemberLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetPseudMemberLinkInfo,pOldSysNetPseudMemberLinkInfo);
	}
}
	
void CSysNetPseudMemberLinkInfoFactory::commitRemove(CWriteableSysNetPseudMemberLinkInfo *pSysNetPseudMemberLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetPseudMemberLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetPseudMemberLinkInfo);
	}
}

void CSysNetPseudMemberLinkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetOuterDeviceInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetOuterDeviceInfo=0;
int updateWithIndexActionForSysNetOuterDeviceInfo=0;
int updateWithoutIndexActionForSysNetOuterDeviceInfo=0;
int removeActionForSysNetOuterDeviceInfo=0;
int addCommitForSysNetOuterDeviceInfo=0;
int updateCommitForSysNetOuterDeviceInfo=0;
int removeCommitForSysNetOuterDeviceInfo=0;
#endif
void CSysNetOuterDeviceInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetOuterDeviceInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetOuterDeviceInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetOuterDeviceInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetOuterDeviceInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetOuterDeviceInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetOuterDeviceInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetOuterDeviceInfoFactory::CSysNetOuterDeviceInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetOuterDeviceInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetOuterDeviceInfoFactory::CSysNetOuterDeviceInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetOuterDeviceInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetOuterDeviceInfoFactory::~CSysNetOuterDeviceInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetOuterDeviceInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetOuterDeviceInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetOuterDeviceInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetOuterDeviceInfo thisSysNetOuterDeviceInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetOuterDeviceInfo.readCSV(input,pNames))
		add(&thisSysNetOuterDeviceInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetOuterDeviceInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetOuterDeviceInfo.csv");
	return readCSV(szFileName);
}

int CSysNetOuterDeviceInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetOuterDeviceInfo::writeCSVHead(output);
	pSysNetOuterDeviceInfo=(CWriteableSysNetOuterDeviceInfo *)(pMem->getFirst());
	while (pSysNetOuterDeviceInfo!=NULL) {
		if (!pSysNetOuterDeviceInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetOuterDeviceInfo=(CWriteableSysNetOuterDeviceInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetOuterDeviceInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetOuterDeviceInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetOuterDeviceInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetOuterDeviceInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetOuterDeviceInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetOuterDeviceInfo=(CWriteableSysNetOuterDeviceInfo *)(pMem->getFirst());
	while (pSysNetOuterDeviceInfo!=NULL) {
		pSysNetOuterDeviceInfo->dump(fp,index++);
		pSysNetOuterDeviceInfo=(CWriteableSysNetOuterDeviceInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetOuterDeviceInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetOuterDeviceInfo *CSysNetOuterDeviceInfoFactory::internalAdd(CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetOuterDeviceInfo++;
#endif
	CSysNetOuterDeviceInfo *pTarget;	
	beforeAdd(pSysNetOuterDeviceInfo);
	pTarget=(CSysNetOuterDeviceInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetOuterDeviceInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetOuterDeviceInfo, sizeof(CSysNetOuterDeviceInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetOuterDeviceInfo *CSysNetOuterDeviceInfoFactory::add(CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CTransaction *pTransaction)
{
	pSysNetOuterDeviceInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetOuterDeviceInfo,true);
	}
	else {
		CSysNetOuterDeviceInfo *pNewSysNetOuterDeviceInfo;
		pNewSysNetOuterDeviceInfo = internalAdd(pSysNetOuterDeviceInfo,false);
		pTransaction->addResource(CSysNetOuterDeviceInfoResource::alloc(CREATE_ACTION,this,pNewSysNetOuterDeviceInfo,NULL));
		return pNewSysNetOuterDeviceInfo;
	}
}

void CSysNetOuterDeviceInfoFactory::internalUpdate(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pNewSysNetOuterDeviceInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetOuterDeviceInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetOuterDeviceInfo++;
	}
#endif
	CWriteableSysNetOuterDeviceInfo theOldSysNetOuterDeviceInfo;
	beforeUpdate(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetOuterDeviceInfo,pSysNetOuterDeviceInfo,sizeof(CSysNetOuterDeviceInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo,sizeof(CSysNetOuterDeviceInfo));
	pMem->updateObject(pSysNetOuterDeviceInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetOuterDeviceInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetOuterDeviceInfo,&theOldSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::update(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pNewSysNetOuterDeviceInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetOuterDeviceInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetOuterDeviceInfoResource::alloc(UPDATE_ACTION,this,pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo,updateIndex));
		internalUpdate(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo,updateIndex,false);
	}
}

void CSysNetOuterDeviceInfoFactory::internalRemove(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetOuterDeviceInfo++;
#endif
	CWriteableSysNetOuterDeviceInfo theOldSysNetOuterDeviceInfo;
	beforeRemove(pSysNetOuterDeviceInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetOuterDeviceInfo,pSysNetOuterDeviceInfo,sizeof(CSysNetOuterDeviceInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetOuterDeviceInfo);
	}
	pMem->free(pSysNetOuterDeviceInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::remove(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetOuterDeviceInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetOuterDeviceInfoResource::alloc(DELETE_ACTION,this,pSysNetOuterDeviceInfo,NULL));
		internalRemove(pSysNetOuterDeviceInfo,false);		
	}
}

CSysNetOuterDeviceInfo* CSysNetOuterDeviceInfoFactory::addOrUpdate(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pNewSysNetOuterDeviceInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetOuterDeviceInfo == NULL) {
		return add(pNewSysNetOuterDeviceInfo,pTransaction);
	}
	else {
		update(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo,pTransaction,updateIndex);
		return pSysNetOuterDeviceInfo;
	}
}

void CSysNetOuterDeviceInfoFactory::retrieve(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pTargetSysNetOuterDeviceInfo)
{
	forceCopy(pTargetSysNetOuterDeviceInfo, pSysNetOuterDeviceInfo, sizeof(CSysNetOuterDeviceInfo));
}
	
int CSysNetOuterDeviceInfoFactory::addActionTrigger(CSysNetOuterDeviceInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetOuterDeviceInfoFactory::removeActionTrigger(CSysNetOuterDeviceInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetOuterDeviceInfoFactory::addCommitTrigger(CSysNetOuterDeviceInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetOuterDeviceInfoFactory::removeCommitTrigger(CSysNetOuterDeviceInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetOuterDeviceInfo *CSysNetOuterDeviceInfoFactory::getFirst(void)
{
	CSysNetOuterDeviceInfo *pResult=(CSysNetOuterDeviceInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetOuterDeviceInfo *CSysNetOuterDeviceInfoFactory::getNext(void)
{
	CSysNetOuterDeviceInfo *pResult=(CSysNetOuterDeviceInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetOuterDeviceInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetOuterDeviceInfoFactory::beforeAdd(CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetOuterDeviceInfo);
	}
}
	
void CSysNetOuterDeviceInfoFactory::afterAdd(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::beforeUpdate(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pNewSysNetOuterDeviceInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetOuterDeviceInfo,pNewSysNetOuterDeviceInfo);
	}
}
	
void CSysNetOuterDeviceInfoFactory::afterUpdate(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetOuterDeviceInfo);
	}
}
	
void CSysNetOuterDeviceInfoFactory::beforeRemove(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::commitAdd(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetOuterDeviceInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::commitUpdate(CSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo, CWriteableSysNetOuterDeviceInfo *pOldSysNetOuterDeviceInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetOuterDeviceInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetOuterDeviceInfo,pOldSysNetOuterDeviceInfo);
	}
}
	
void CSysNetOuterDeviceInfoFactory::commitRemove(CWriteableSysNetOuterDeviceInfo *pSysNetOuterDeviceInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetOuterDeviceInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetOuterDeviceInfo);
	}
}

void CSysNetOuterDeviceInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysLocalPingResultInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysLocalPingResultInfo=0;
int updateWithIndexActionForSysLocalPingResultInfo=0;
int updateWithoutIndexActionForSysLocalPingResultInfo=0;
int removeActionForSysLocalPingResultInfo=0;
int addCommitForSysLocalPingResultInfo=0;
int updateCommitForSysLocalPingResultInfo=0;
int removeCommitForSysLocalPingResultInfo=0;
#endif
void CSysLocalPingResultInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysLocalPingResultInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysLocalPingResultInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysLocalPingResultInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysLocalPingResultInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByIDType=NULL;
	pActionTriggers=new vector<CSysLocalPingResultInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysLocalPingResultInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysLocalPingResultInfoFactory::CSysLocalPingResultInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysLocalPingResultInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysLocalPingResultInfoFactory::CSysLocalPingResultInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysLocalPingResultInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysLocalPingResultInfoFactory::~CSysLocalPingResultInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysLocalPingResultInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysLocalPingResultInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysLocalPingResultInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysLocalPingResultInfo thisSysLocalPingResultInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysLocalPingResultInfo.readCSV(input,pNames))
		add(&thisSysLocalPingResultInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysLocalPingResultInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysLocalPingResultInfo.csv");
	return readCSV(szFileName);
}

int CSysLocalPingResultInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysLocalPingResultInfo::writeCSVHead(output);
	pSysLocalPingResultInfo=(CWriteableSysLocalPingResultInfo *)(pMem->getFirst());
	while (pSysLocalPingResultInfo!=NULL) {
		if (!pSysLocalPingResultInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysLocalPingResultInfo=(CWriteableSysLocalPingResultInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysLocalPingResultInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysLocalPingResultInfo.csv");
	return writeCSV(szFileName);
}

void CSysLocalPingResultInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysLocalPingResultInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysLocalPingResultInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysLocalPingResultInfo=(CWriteableSysLocalPingResultInfo *)(pMem->getFirst());
	while (pSysLocalPingResultInfo!=NULL) {
		pSysLocalPingResultInfo->dump(fp,index++);
		pSysLocalPingResultInfo=(CWriteableSysLocalPingResultInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysLocalPingResultInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysLocalPingResultInfo *CSysLocalPingResultInfoFactory::internalAdd(CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysLocalPingResultInfo++;
#endif
	CSysLocalPingResultInfo *pTarget;	
	beforeAdd(pSysLocalPingResultInfo);
	pTarget=(CSysLocalPingResultInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysLocalPingResultInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysLocalPingResultInfo, sizeof(CSysLocalPingResultInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysLocalPingResultInfo *CSysLocalPingResultInfoFactory::add(CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo, CTransaction *pTransaction)
{
	pSysLocalPingResultInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysLocalPingResultInfo,true);
	}
	else {
		CSysLocalPingResultInfo *pNewSysLocalPingResultInfo;
		pNewSysLocalPingResultInfo = internalAdd(pSysLocalPingResultInfo,false);
		pTransaction->addResource(CSysLocalPingResultInfoResource::alloc(CREATE_ACTION,this,pNewSysLocalPingResultInfo,NULL));
		return pNewSysLocalPingResultInfo;
	}
}

void CSysLocalPingResultInfoFactory::internalUpdate(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pNewSysLocalPingResultInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysLocalPingResultInfo++;
	}
	else {
		updateWithoutIndexActionForSysLocalPingResultInfo++;
	}
#endif
	CWriteableSysLocalPingResultInfo theOldSysLocalPingResultInfo;
	beforeUpdate(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysLocalPingResultInfo,pSysLocalPingResultInfo,sizeof(CSysLocalPingResultInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo,sizeof(CSysLocalPingResultInfo));
	pMem->updateObject(pSysLocalPingResultInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysLocalPingResultInfo);
	if (bNoTransaction) {
		commitUpdate(pSysLocalPingResultInfo,&theOldSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::update(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pNewSysLocalPingResultInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysLocalPingResultInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysLocalPingResultInfoResource::alloc(UPDATE_ACTION,this,pSysLocalPingResultInfo,pNewSysLocalPingResultInfo,updateIndex));
		internalUpdate(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo,updateIndex,false);
	}
}

void CSysLocalPingResultInfoFactory::internalRemove(CSysLocalPingResultInfo *pSysLocalPingResultInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysLocalPingResultInfo++;
#endif
	CWriteableSysLocalPingResultInfo theOldSysLocalPingResultInfo;
	beforeRemove(pSysLocalPingResultInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysLocalPingResultInfo,pSysLocalPingResultInfo,sizeof(CSysLocalPingResultInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysLocalPingResultInfo);
	}
	pMem->free(pSysLocalPingResultInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::remove(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysLocalPingResultInfo,true);
	}
	else {
		pTransaction->addResource(CSysLocalPingResultInfoResource::alloc(DELETE_ACTION,this,pSysLocalPingResultInfo,NULL));
		internalRemove(pSysLocalPingResultInfo,false);		
	}
}

CSysLocalPingResultInfo* CSysLocalPingResultInfoFactory::addOrUpdate(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pNewSysLocalPingResultInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysLocalPingResultInfo == NULL) {
		return add(pNewSysLocalPingResultInfo,pTransaction);
	}
	else {
		update(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo,pTransaction,updateIndex);
		return pSysLocalPingResultInfo;
	}
}

void CSysLocalPingResultInfoFactory::retrieve(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pTargetSysLocalPingResultInfo)
{
	forceCopy(pTargetSysLocalPingResultInfo, pSysLocalPingResultInfo, sizeof(CSysLocalPingResultInfo));
}
	
int CSysLocalPingResultInfoFactory::addActionTrigger(CSysLocalPingResultInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysLocalPingResultInfoFactory::removeActionTrigger(CSysLocalPingResultInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysLocalPingResultInfoFactory::addCommitTrigger(CSysLocalPingResultInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysLocalPingResultInfoFactory::removeCommitTrigger(CSysLocalPingResultInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysLocalPingResultInfo *CSysLocalPingResultInfoFactory::getFirst(void)
{
	CSysLocalPingResultInfo *pResult=(CSysLocalPingResultInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysLocalPingResultInfo *CSysLocalPingResultInfoFactory::getNext(void)
{
	CSysLocalPingResultInfo *pResult=(CSysLocalPingResultInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysLocalPingResultInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysLocalPingResultInfoFactory::beforeAdd(CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysLocalPingResultInfo);
	}
}
	
void CSysLocalPingResultInfoFactory::afterAdd(CSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::beforeUpdate(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pNewSysLocalPingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysLocalPingResultInfo,pNewSysLocalPingResultInfo);
	}
}
	
void CSysLocalPingResultInfoFactory::afterUpdate(CSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysLocalPingResultInfo);
	}
}
	
void CSysLocalPingResultInfoFactory::beforeRemove(CSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::commitAdd(CSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysLocalPingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::commitUpdate(CSysLocalPingResultInfo *pSysLocalPingResultInfo, CWriteableSysLocalPingResultInfo *pOldSysLocalPingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysLocalPingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysLocalPingResultInfo,pOldSysLocalPingResultInfo);
	}
}
	
void CSysLocalPingResultInfoFactory::commitRemove(CWriteableSysLocalPingResultInfo *pSysLocalPingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysLocalPingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysLocalPingResultInfo);
	}
}

void CSysLocalPingResultInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysRomotePingResultInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysRomotePingResultInfo=0;
int updateWithIndexActionForSysRomotePingResultInfo=0;
int updateWithoutIndexActionForSysRomotePingResultInfo=0;
int removeActionForSysRomotePingResultInfo=0;
int addCommitForSysRomotePingResultInfo=0;
int updateCommitForSysRomotePingResultInfo=0;
int removeCommitForSysRomotePingResultInfo=0;
#endif
void CSysRomotePingResultInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysRomotePingResultInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysRomotePingResultInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysRomotePingResultInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysRomotePingResultInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByIDType=NULL;
	pActionTriggers=new vector<CSysRomotePingResultInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysRomotePingResultInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysRomotePingResultInfoFactory::CSysRomotePingResultInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysRomotePingResultInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysRomotePingResultInfoFactory::CSysRomotePingResultInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysRomotePingResultInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysRomotePingResultInfoFactory::~CSysRomotePingResultInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysRomotePingResultInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysRomotePingResultInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysRomotePingResultInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysRomotePingResultInfo thisSysRomotePingResultInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysRomotePingResultInfo.readCSV(input,pNames))
		add(&thisSysRomotePingResultInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysRomotePingResultInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysRomotePingResultInfo.csv");
	return readCSV(szFileName);
}

int CSysRomotePingResultInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysRomotePingResultInfo::writeCSVHead(output);
	pSysRomotePingResultInfo=(CWriteableSysRomotePingResultInfo *)(pMem->getFirst());
	while (pSysRomotePingResultInfo!=NULL) {
		if (!pSysRomotePingResultInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysRomotePingResultInfo=(CWriteableSysRomotePingResultInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysRomotePingResultInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysRomotePingResultInfo.csv");
	return writeCSV(szFileName);
}

void CSysRomotePingResultInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysRomotePingResultInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysRomotePingResultInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysRomotePingResultInfo=(CWriteableSysRomotePingResultInfo *)(pMem->getFirst());
	while (pSysRomotePingResultInfo!=NULL) {
		pSysRomotePingResultInfo->dump(fp,index++);
		pSysRomotePingResultInfo=(CWriteableSysRomotePingResultInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysRomotePingResultInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysRomotePingResultInfo *CSysRomotePingResultInfoFactory::internalAdd(CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysRomotePingResultInfo++;
#endif
	CSysRomotePingResultInfo *pTarget;	
	beforeAdd(pSysRomotePingResultInfo);
	pTarget=(CSysRomotePingResultInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysRomotePingResultInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysRomotePingResultInfo, sizeof(CSysRomotePingResultInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysRomotePingResultInfo *CSysRomotePingResultInfoFactory::add(CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo, CTransaction *pTransaction)
{
	pSysRomotePingResultInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysRomotePingResultInfo,true);
	}
	else {
		CSysRomotePingResultInfo *pNewSysRomotePingResultInfo;
		pNewSysRomotePingResultInfo = internalAdd(pSysRomotePingResultInfo,false);
		pTransaction->addResource(CSysRomotePingResultInfoResource::alloc(CREATE_ACTION,this,pNewSysRomotePingResultInfo,NULL));
		return pNewSysRomotePingResultInfo;
	}
}

void CSysRomotePingResultInfoFactory::internalUpdate(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pNewSysRomotePingResultInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysRomotePingResultInfo++;
	}
	else {
		updateWithoutIndexActionForSysRomotePingResultInfo++;
	}
#endif
	CWriteableSysRomotePingResultInfo theOldSysRomotePingResultInfo;
	beforeUpdate(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysRomotePingResultInfo,pSysRomotePingResultInfo,sizeof(CSysRomotePingResultInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo,sizeof(CSysRomotePingResultInfo));
	pMem->updateObject(pSysRomotePingResultInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysRomotePingResultInfo);
	if (bNoTransaction) {
		commitUpdate(pSysRomotePingResultInfo,&theOldSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::update(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pNewSysRomotePingResultInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysRomotePingResultInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysRomotePingResultInfoResource::alloc(UPDATE_ACTION,this,pSysRomotePingResultInfo,pNewSysRomotePingResultInfo,updateIndex));
		internalUpdate(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo,updateIndex,false);
	}
}

void CSysRomotePingResultInfoFactory::internalRemove(CSysRomotePingResultInfo *pSysRomotePingResultInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysRomotePingResultInfo++;
#endif
	CWriteableSysRomotePingResultInfo theOldSysRomotePingResultInfo;
	beforeRemove(pSysRomotePingResultInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysRomotePingResultInfo,pSysRomotePingResultInfo,sizeof(CSysRomotePingResultInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysRomotePingResultInfo);
	}
	pMem->free(pSysRomotePingResultInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::remove(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysRomotePingResultInfo,true);
	}
	else {
		pTransaction->addResource(CSysRomotePingResultInfoResource::alloc(DELETE_ACTION,this,pSysRomotePingResultInfo,NULL));
		internalRemove(pSysRomotePingResultInfo,false);		
	}
}

CSysRomotePingResultInfo* CSysRomotePingResultInfoFactory::addOrUpdate(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pNewSysRomotePingResultInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysRomotePingResultInfo == NULL) {
		return add(pNewSysRomotePingResultInfo,pTransaction);
	}
	else {
		update(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo,pTransaction,updateIndex);
		return pSysRomotePingResultInfo;
	}
}

void CSysRomotePingResultInfoFactory::retrieve(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pTargetSysRomotePingResultInfo)
{
	forceCopy(pTargetSysRomotePingResultInfo, pSysRomotePingResultInfo, sizeof(CSysRomotePingResultInfo));
}
	
int CSysRomotePingResultInfoFactory::addActionTrigger(CSysRomotePingResultInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysRomotePingResultInfoFactory::removeActionTrigger(CSysRomotePingResultInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysRomotePingResultInfoFactory::addCommitTrigger(CSysRomotePingResultInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysRomotePingResultInfoFactory::removeCommitTrigger(CSysRomotePingResultInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysRomotePingResultInfo *CSysRomotePingResultInfoFactory::getFirst(void)
{
	CSysRomotePingResultInfo *pResult=(CSysRomotePingResultInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysRomotePingResultInfo *CSysRomotePingResultInfoFactory::getNext(void)
{
	CSysRomotePingResultInfo *pResult=(CSysRomotePingResultInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysRomotePingResultInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysRomotePingResultInfoFactory::beforeAdd(CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysRomotePingResultInfo);
	}
}
	
void CSysRomotePingResultInfoFactory::afterAdd(CSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::beforeUpdate(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pNewSysRomotePingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysRomotePingResultInfo,pNewSysRomotePingResultInfo);
	}
}
	
void CSysRomotePingResultInfoFactory::afterUpdate(CSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysRomotePingResultInfo);
	}
}
	
void CSysRomotePingResultInfoFactory::beforeRemove(CSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::commitAdd(CSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysRomotePingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::commitUpdate(CSysRomotePingResultInfo *pSysRomotePingResultInfo, CWriteableSysRomotePingResultInfo *pOldSysRomotePingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysRomotePingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysRomotePingResultInfo,pOldSysRomotePingResultInfo);
	}
}
	
void CSysRomotePingResultInfoFactory::commitRemove(CWriteableSysRomotePingResultInfo *pSysRomotePingResultInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysRomotePingResultInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysRomotePingResultInfo);
	}
}

void CSysRomotePingResultInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForMemUsrIndexinSysParticTradeOrderStates(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysParticTradeOrderStates=0;
int updateWithIndexActionForSysParticTradeOrderStates=0;
int updateWithoutIndexActionForSysParticTradeOrderStates=0;
int removeActionForSysParticTradeOrderStates=0;
int addCommitForSysParticTradeOrderStates=0;
int updateCommitForSysParticTradeOrderStates=0;
int removeCommitForSysParticTradeOrderStates=0;
#endif
void CSysParticTradeOrderStatesFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pMemUsrIndex=new CAVLTree(maxUnit,compareForMemUsrIndexinSysParticTradeOrderStates,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysParticTradeOrderStates_MemUsrIndex",pMemUsrIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysParticTradeOrderStates_MemUsrIndex");
			if(it != pIndexMap->end()) {
				pMemUsrIndex=new CAVLTree(maxUnit,compareForMemUsrIndexinSysParticTradeOrderStates,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pMemUsrIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pLastFoundInSearchByUserID=NULL;
	pActionTriggers=new vector<CSysParticTradeOrderStatesActionTrigger *>;
	pCommitTriggers=new vector<CSysParticTradeOrderStatesCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysParticTradeOrderStatesFactory::CSysParticTradeOrderStatesFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticTradeOrderStates),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysParticTradeOrderStatesFactory::CSysParticTradeOrderStatesFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysParticTradeOrderStates),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysParticTradeOrderStatesFactory::~CSysParticTradeOrderStatesFactory(void)
{
	if (runLevel>=0) {
		if (pMemUsrIndex!=NULL)
			delete pMemUsrIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysParticTradeOrderStatesFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysParticTradeOrderStatesFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pMemUsrIndex->output(pLogger,indent+1);
	}
}

int CSysParticTradeOrderStatesFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysParticTradeOrderStates thisSysParticTradeOrderStates;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysParticTradeOrderStates.readCSV(input,pNames))
		add(&thisSysParticTradeOrderStates);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysParticTradeOrderStatesFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysParticTradeOrderStates.csv");
	return readCSV(szFileName);
}

int CSysParticTradeOrderStatesFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysParticTradeOrderStates::writeCSVHead(output);
	pSysParticTradeOrderStates=(CWriteableSysParticTradeOrderStates *)(pMem->getFirst());
	while (pSysParticTradeOrderStates!=NULL) {
		if (!pSysParticTradeOrderStates->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysParticTradeOrderStates=(CWriteableSysParticTradeOrderStates *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysParticTradeOrderStatesFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysParticTradeOrderStates.csv");
	return writeCSV(szFileName);
}

void CSysParticTradeOrderStatesFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysParticTradeOrderStatesFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysParticTradeOrderStatesFactory={       Total Count=%d\n", pMem->getCount());
	pSysParticTradeOrderStates=(CWriteableSysParticTradeOrderStates *)(pMem->getFirst());
	while (pSysParticTradeOrderStates!=NULL) {
		pSysParticTradeOrderStates->dump(fp,index++);
		pSysParticTradeOrderStates=(CWriteableSysParticTradeOrderStates *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysParticTradeOrderStatesFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pMemUsrIndex->removeAll();
	}
}

CSysParticTradeOrderStates *CSysParticTradeOrderStatesFactory::internalAdd(CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysParticTradeOrderStates++;
#endif
	CSysParticTradeOrderStates *pTarget;	
	beforeAdd(pSysParticTradeOrderStates);
	pTarget=(CSysParticTradeOrderStates *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysParticTradeOrderStates in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysParticTradeOrderStates, sizeof(CSysParticTradeOrderStates));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pMemUsrIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysParticTradeOrderStates *CSysParticTradeOrderStatesFactory::add(CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates, CTransaction *pTransaction)
{
	pSysParticTradeOrderStates->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysParticTradeOrderStates,true);
	}
	else {
		CSysParticTradeOrderStates *pNewSysParticTradeOrderStates;
		pNewSysParticTradeOrderStates = internalAdd(pSysParticTradeOrderStates,false);
		pTransaction->addResource(CSysParticTradeOrderStatesResource::alloc(CREATE_ACTION,this,pNewSysParticTradeOrderStates,NULL));
		return pNewSysParticTradeOrderStates;
	}
}

void CSysParticTradeOrderStatesFactory::internalUpdate(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pNewSysParticTradeOrderStates, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysParticTradeOrderStates++;
	}
	else {
		updateWithoutIndexActionForSysParticTradeOrderStates++;
	}
#endif
	CWriteableSysParticTradeOrderStates theOldSysParticTradeOrderStates;
	beforeUpdate(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticTradeOrderStates,pSysParticTradeOrderStates,sizeof(CSysParticTradeOrderStates));
	}
	if (updateIndex) {
	}

	forceCopy(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates,sizeof(CSysParticTradeOrderStates));
	pMem->updateObject(pSysParticTradeOrderStates);
	if (updateIndex) {
	}
	afterUpdate(pSysParticTradeOrderStates);
	if (bNoTransaction) {
		commitUpdate(pSysParticTradeOrderStates,&theOldSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::update(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pNewSysParticTradeOrderStates, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysParticTradeOrderStates->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysParticTradeOrderStatesResource::alloc(UPDATE_ACTION,this,pSysParticTradeOrderStates,pNewSysParticTradeOrderStates,updateIndex));
		internalUpdate(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates,updateIndex,false);
	}
}

void CSysParticTradeOrderStatesFactory::internalRemove(CSysParticTradeOrderStates *pSysParticTradeOrderStates, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysParticTradeOrderStates++;
#endif
	CWriteableSysParticTradeOrderStates theOldSysParticTradeOrderStates;
	beforeRemove(pSysParticTradeOrderStates);
	if (bNoTransaction) {
		forceCopy(&theOldSysParticTradeOrderStates,pSysParticTradeOrderStates,sizeof(CSysParticTradeOrderStates));
	}
	if (runLevel>=0) {
		pMemUsrIndex->removeObject(pSysParticTradeOrderStates);
	}
	pMem->free(pSysParticTradeOrderStates);
	if(bNoTransaction) {
		commitRemove(&theOldSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::remove(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysParticTradeOrderStates,true);
	}
	else {
		pTransaction->addResource(CSysParticTradeOrderStatesResource::alloc(DELETE_ACTION,this,pSysParticTradeOrderStates,NULL));
		internalRemove(pSysParticTradeOrderStates,false);		
	}
}

CSysParticTradeOrderStates* CSysParticTradeOrderStatesFactory::addOrUpdate(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pNewSysParticTradeOrderStates, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysParticTradeOrderStates == NULL) {
		return add(pNewSysParticTradeOrderStates,pTransaction);
	}
	else {
		update(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates,pTransaction,updateIndex);
		return pSysParticTradeOrderStates;
	}
}

void CSysParticTradeOrderStatesFactory::retrieve(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pTargetSysParticTradeOrderStates)
{
	forceCopy(pTargetSysParticTradeOrderStates, pSysParticTradeOrderStates, sizeof(CSysParticTradeOrderStates));
}
	
int CSysParticTradeOrderStatesFactory::addActionTrigger(CSysParticTradeOrderStatesActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysParticTradeOrderStatesFactory::removeActionTrigger(CSysParticTradeOrderStatesActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysParticTradeOrderStatesFactory::addCommitTrigger(CSysParticTradeOrderStatesCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysParticTradeOrderStatesFactory::removeCommitTrigger(CSysParticTradeOrderStatesCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysParticTradeOrderStates *CSysParticTradeOrderStatesFactory::getFirst(void)
{
	CSysParticTradeOrderStates *pResult=(CSysParticTradeOrderStates *)(pMem->getFirst());
	return pResult;
}
	
CSysParticTradeOrderStates *CSysParticTradeOrderStatesFactory::getNext(void)
{
	CSysParticTradeOrderStates *pResult=(CSysParticTradeOrderStates *)(pMem->getNext());
	return pResult;
}
	
void CSysParticTradeOrderStatesFactory::endGet(void)
{
	pMem->endGet();
}

void CSysParticTradeOrderStatesFactory::beforeAdd(CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysParticTradeOrderStates);
	}
}
	
void CSysParticTradeOrderStatesFactory::afterAdd(CSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::beforeUpdate(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pNewSysParticTradeOrderStates)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysParticTradeOrderStates,pNewSysParticTradeOrderStates);
	}
}
	
void CSysParticTradeOrderStatesFactory::afterUpdate(CSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysParticTradeOrderStates);
	}
}
	
void CSysParticTradeOrderStatesFactory::beforeRemove(CSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::commitAdd(CSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysParticTradeOrderStates++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::commitUpdate(CSysParticTradeOrderStates *pSysParticTradeOrderStates, CWriteableSysParticTradeOrderStates *pOldSysParticTradeOrderStates)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysParticTradeOrderStates++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysParticTradeOrderStates,pOldSysParticTradeOrderStates);
	}
}
	
void CSysParticTradeOrderStatesFactory::commitRemove(CWriteableSysParticTradeOrderStates *pSysParticTradeOrderStates)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysParticTradeOrderStates++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysParticTradeOrderStates);
	}
}

void CSysParticTradeOrderStatesFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbRouterInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbRouterInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbRouterInfo=0;
int updateWithIndexActionForSysMdbRouterInfo=0;
int updateWithoutIndexActionForSysMdbRouterInfo=0;
int removeActionForSysMdbRouterInfo=0;
int addCommitForSysMdbRouterInfo=0;
int updateCommitForSysMdbRouterInfo=0;
int removeCommitForSysMdbRouterInfo=0;
#endif
void CSysMdbRouterInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbRouterInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbRouterInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbRouterInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbRouterInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbRouterInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbRouterInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbRouterInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbRouterInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbRouterInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbRouterInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbRouterInfoFactory::CSysMdbRouterInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbRouterInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbRouterInfoFactory::CSysMdbRouterInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbRouterInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbRouterInfoFactory::~CSysMdbRouterInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbRouterInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbRouterInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbRouterInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbRouterInfo thisSysMdbRouterInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbRouterInfo.readCSV(input,pNames))
		add(&thisSysMdbRouterInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbRouterInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbRouterInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbRouterInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbRouterInfo *pSysMdbRouterInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbRouterInfo::writeCSVHead(output);
	pSysMdbRouterInfo=(CWriteableSysMdbRouterInfo *)(pMem->getFirst());
	while (pSysMdbRouterInfo!=NULL) {
		if (!pSysMdbRouterInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbRouterInfo=(CWriteableSysMdbRouterInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbRouterInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbRouterInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbRouterInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbRouterInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbRouterInfo *pSysMdbRouterInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbRouterInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbRouterInfo=(CWriteableSysMdbRouterInfo *)(pMem->getFirst());
	while (pSysMdbRouterInfo!=NULL) {
		pSysMdbRouterInfo->dump(fp,index++);
		pSysMdbRouterInfo=(CWriteableSysMdbRouterInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbRouterInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbRouterInfo *CSysMdbRouterInfoFactory::internalAdd(CWriteableSysMdbRouterInfo *pSysMdbRouterInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbRouterInfo++;
#endif
	CSysMdbRouterInfo *pTarget;	
	beforeAdd(pSysMdbRouterInfo);
	pTarget=(CSysMdbRouterInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbRouterInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbRouterInfo, sizeof(CSysMdbRouterInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbRouterInfo *CSysMdbRouterInfoFactory::add(CWriteableSysMdbRouterInfo *pSysMdbRouterInfo, CTransaction *pTransaction)
{
	pSysMdbRouterInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbRouterInfo,true);
	}
	else {
		CSysMdbRouterInfo *pNewSysMdbRouterInfo;
		pNewSysMdbRouterInfo = internalAdd(pSysMdbRouterInfo,false);
		pTransaction->addResource(CSysMdbRouterInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbRouterInfo,NULL));
		return pNewSysMdbRouterInfo;
	}
}

void CSysMdbRouterInfoFactory::internalUpdate(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pNewSysMdbRouterInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbRouterInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbRouterInfo++;
	}
#endif
	CWriteableSysMdbRouterInfo theOldSysMdbRouterInfo;
	beforeUpdate(pSysMdbRouterInfo,pNewSysMdbRouterInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbRouterInfo,pSysMdbRouterInfo,sizeof(CSysMdbRouterInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbRouterInfo,pNewSysMdbRouterInfo,sizeof(CSysMdbRouterInfo));
	pMem->updateObject(pSysMdbRouterInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbRouterInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbRouterInfo,&theOldSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::update(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pNewSysMdbRouterInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbRouterInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbRouterInfo,pNewSysMdbRouterInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbRouterInfoResource::alloc(UPDATE_ACTION,this,pSysMdbRouterInfo,pNewSysMdbRouterInfo,updateIndex));
		internalUpdate(pSysMdbRouterInfo,pNewSysMdbRouterInfo,updateIndex,false);
	}
}

void CSysMdbRouterInfoFactory::internalRemove(CSysMdbRouterInfo *pSysMdbRouterInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbRouterInfo++;
#endif
	CWriteableSysMdbRouterInfo theOldSysMdbRouterInfo;
	beforeRemove(pSysMdbRouterInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbRouterInfo,pSysMdbRouterInfo,sizeof(CSysMdbRouterInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbRouterInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbRouterInfo);
	}
	pMem->free(pSysMdbRouterInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::remove(CSysMdbRouterInfo *pSysMdbRouterInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbRouterInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbRouterInfoResource::alloc(DELETE_ACTION,this,pSysMdbRouterInfo,NULL));
		internalRemove(pSysMdbRouterInfo,false);		
	}
}

CSysMdbRouterInfo* CSysMdbRouterInfoFactory::addOrUpdate(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pNewSysMdbRouterInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbRouterInfo == NULL) {
		return add(pNewSysMdbRouterInfo,pTransaction);
	}
	else {
		update(pSysMdbRouterInfo,pNewSysMdbRouterInfo,pTransaction,updateIndex);
		return pSysMdbRouterInfo;
	}
}

void CSysMdbRouterInfoFactory::retrieve(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pTargetSysMdbRouterInfo)
{
	forceCopy(pTargetSysMdbRouterInfo, pSysMdbRouterInfo, sizeof(CSysMdbRouterInfo));
}
	
int CSysMdbRouterInfoFactory::addActionTrigger(CSysMdbRouterInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbRouterInfoFactory::removeActionTrigger(CSysMdbRouterInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbRouterInfoFactory::addCommitTrigger(CSysMdbRouterInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbRouterInfoFactory::removeCommitTrigger(CSysMdbRouterInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbRouterInfo *CSysMdbRouterInfoFactory::getFirst(void)
{
	CSysMdbRouterInfo *pResult=(CSysMdbRouterInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbRouterInfo *CSysMdbRouterInfoFactory::getNext(void)
{
	CSysMdbRouterInfo *pResult=(CSysMdbRouterInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbRouterInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbRouterInfoFactory::beforeAdd(CWriteableSysMdbRouterInfo *pSysMdbRouterInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbRouterInfo);
	}
}
	
void CSysMdbRouterInfoFactory::afterAdd(CSysMdbRouterInfo *pSysMdbRouterInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::beforeUpdate(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pNewSysMdbRouterInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbRouterInfo,pNewSysMdbRouterInfo);
	}
}
	
void CSysMdbRouterInfoFactory::afterUpdate(CSysMdbRouterInfo *pSysMdbRouterInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbRouterInfo);
	}
}
	
void CSysMdbRouterInfoFactory::beforeRemove(CSysMdbRouterInfo *pSysMdbRouterInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::commitAdd(CSysMdbRouterInfo *pSysMdbRouterInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbRouterInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::commitUpdate(CSysMdbRouterInfo *pSysMdbRouterInfo, CWriteableSysMdbRouterInfo *pOldSysMdbRouterInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbRouterInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbRouterInfo,pOldSysMdbRouterInfo);
	}
}
	
void CSysMdbRouterInfoFactory::commitRemove(CWriteableSysMdbRouterInfo *pSysMdbRouterInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbRouterInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbRouterInfo);
	}
}

void CSysMdbRouterInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbDiskIO(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbDiskIO(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbDiskIO=0;
int updateWithIndexActionForSysMdbDiskIO=0;
int updateWithoutIndexActionForSysMdbDiskIO=0;
int removeActionForSysMdbDiskIO=0;
int addCommitForSysMdbDiskIO=0;
int updateCommitForSysMdbDiskIO=0;
int removeCommitForSysMdbDiskIO=0;
#endif
void CSysMdbDiskIOFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbDiskIO,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbDiskIO_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbDiskIO_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbDiskIO,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbDiskIO,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbDiskIO_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbDiskIO_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbDiskIO,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbDiskIOActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbDiskIOCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbDiskIOFactory::CSysMdbDiskIOFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbDiskIO),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbDiskIOFactory::CSysMdbDiskIOFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbDiskIO),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbDiskIOFactory::~CSysMdbDiskIOFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbDiskIOFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbDiskIOFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbDiskIOFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbDiskIO thisSysMdbDiskIO;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbDiskIO.readCSV(input,pNames))
		add(&thisSysMdbDiskIO);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbDiskIOFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbDiskIO.csv");
	return readCSV(szFileName);
}

int CSysMdbDiskIOFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbDiskIO *pSysMdbDiskIO;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbDiskIO::writeCSVHead(output);
	pSysMdbDiskIO=(CWriteableSysMdbDiskIO *)(pMem->getFirst());
	while (pSysMdbDiskIO!=NULL) {
		if (!pSysMdbDiskIO->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbDiskIO=(CWriteableSysMdbDiskIO *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbDiskIOFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbDiskIO.csv");
	return writeCSV(szFileName);
}

void CSysMdbDiskIOFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbDiskIOFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbDiskIO *pSysMdbDiskIO;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbDiskIOFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbDiskIO=(CWriteableSysMdbDiskIO *)(pMem->getFirst());
	while (pSysMdbDiskIO!=NULL) {
		pSysMdbDiskIO->dump(fp,index++);
		pSysMdbDiskIO=(CWriteableSysMdbDiskIO *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbDiskIOFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbDiskIO *CSysMdbDiskIOFactory::internalAdd(CWriteableSysMdbDiskIO *pSysMdbDiskIO, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbDiskIO++;
#endif
	CSysMdbDiskIO *pTarget;	
	beforeAdd(pSysMdbDiskIO);
	pTarget=(CSysMdbDiskIO *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbDiskIO in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbDiskIO, sizeof(CSysMdbDiskIO));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbDiskIO *CSysMdbDiskIOFactory::add(CWriteableSysMdbDiskIO *pSysMdbDiskIO, CTransaction *pTransaction)
{
	pSysMdbDiskIO->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbDiskIO,true);
	}
	else {
		CSysMdbDiskIO *pNewSysMdbDiskIO;
		pNewSysMdbDiskIO = internalAdd(pSysMdbDiskIO,false);
		pTransaction->addResource(CSysMdbDiskIOResource::alloc(CREATE_ACTION,this,pNewSysMdbDiskIO,NULL));
		return pNewSysMdbDiskIO;
	}
}

void CSysMdbDiskIOFactory::internalUpdate(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pNewSysMdbDiskIO, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbDiskIO++;
	}
	else {
		updateWithoutIndexActionForSysMdbDiskIO++;
	}
#endif
	CWriteableSysMdbDiskIO theOldSysMdbDiskIO;
	beforeUpdate(pSysMdbDiskIO,pNewSysMdbDiskIO);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbDiskIO,pSysMdbDiskIO,sizeof(CSysMdbDiskIO));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbDiskIO,pNewSysMdbDiskIO,sizeof(CSysMdbDiskIO));
	pMem->updateObject(pSysMdbDiskIO);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbDiskIO);
	if (bNoTransaction) {
		commitUpdate(pSysMdbDiskIO,&theOldSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::update(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pNewSysMdbDiskIO, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbDiskIO->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbDiskIO,pNewSysMdbDiskIO,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbDiskIOResource::alloc(UPDATE_ACTION,this,pSysMdbDiskIO,pNewSysMdbDiskIO,updateIndex));
		internalUpdate(pSysMdbDiskIO,pNewSysMdbDiskIO,updateIndex,false);
	}
}

void CSysMdbDiskIOFactory::internalRemove(CSysMdbDiskIO *pSysMdbDiskIO, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbDiskIO++;
#endif
	CWriteableSysMdbDiskIO theOldSysMdbDiskIO;
	beforeRemove(pSysMdbDiskIO);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbDiskIO,pSysMdbDiskIO,sizeof(CSysMdbDiskIO));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbDiskIO);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbDiskIO);
	}
	pMem->free(pSysMdbDiskIO);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::remove(CSysMdbDiskIO *pSysMdbDiskIO, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbDiskIO,true);
	}
	else {
		pTransaction->addResource(CSysMdbDiskIOResource::alloc(DELETE_ACTION,this,pSysMdbDiskIO,NULL));
		internalRemove(pSysMdbDiskIO,false);		
	}
}

CSysMdbDiskIO* CSysMdbDiskIOFactory::addOrUpdate(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pNewSysMdbDiskIO, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbDiskIO == NULL) {
		return add(pNewSysMdbDiskIO,pTransaction);
	}
	else {
		update(pSysMdbDiskIO,pNewSysMdbDiskIO,pTransaction,updateIndex);
		return pSysMdbDiskIO;
	}
}

void CSysMdbDiskIOFactory::retrieve(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pTargetSysMdbDiskIO)
{
	forceCopy(pTargetSysMdbDiskIO, pSysMdbDiskIO, sizeof(CSysMdbDiskIO));
}
	
int CSysMdbDiskIOFactory::addActionTrigger(CSysMdbDiskIOActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbDiskIOFactory::removeActionTrigger(CSysMdbDiskIOActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbDiskIOFactory::addCommitTrigger(CSysMdbDiskIOCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbDiskIOFactory::removeCommitTrigger(CSysMdbDiskIOCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbDiskIO *CSysMdbDiskIOFactory::getFirst(void)
{
	CSysMdbDiskIO *pResult=(CSysMdbDiskIO *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbDiskIO *CSysMdbDiskIOFactory::getNext(void)
{
	CSysMdbDiskIO *pResult=(CSysMdbDiskIO *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbDiskIOFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbDiskIOFactory::beforeAdd(CWriteableSysMdbDiskIO *pSysMdbDiskIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbDiskIO);
	}
}
	
void CSysMdbDiskIOFactory::afterAdd(CSysMdbDiskIO *pSysMdbDiskIO)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::beforeUpdate(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pNewSysMdbDiskIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbDiskIO,pNewSysMdbDiskIO);
	}
}
	
void CSysMdbDiskIOFactory::afterUpdate(CSysMdbDiskIO *pSysMdbDiskIO)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbDiskIO);
	}
}
	
void CSysMdbDiskIOFactory::beforeRemove(CSysMdbDiskIO *pSysMdbDiskIO)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::commitAdd(CSysMdbDiskIO *pSysMdbDiskIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbDiskIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::commitUpdate(CSysMdbDiskIO *pSysMdbDiskIO, CWriteableSysMdbDiskIO *pOldSysMdbDiskIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbDiskIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbDiskIO,pOldSysMdbDiskIO);
	}
}
	
void CSysMdbDiskIOFactory::commitRemove(CWriteableSysMdbDiskIO *pSysMdbDiskIO)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbDiskIO++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbDiskIO);
	}
}

void CSysMdbDiskIOFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbStatInfo(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbStatInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbStatInfo=0;
int updateWithIndexActionForSysMdbStatInfo=0;
int updateWithoutIndexActionForSysMdbStatInfo=0;
int removeActionForSysMdbStatInfo=0;
int addCommitForSysMdbStatInfo=0;
int updateCommitForSysMdbStatInfo=0;
int removeCommitForSysMdbStatInfo=0;
#endif
void CSysMdbStatInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbStatInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbStatInfo_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbStatInfo_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbStatInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbStatInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbStatInfo_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbStatInfo_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbStatInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByHostName=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByDataDelete=NULL;
	pActionTriggers=new vector<CSysMdbStatInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbStatInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbStatInfoFactory::CSysMdbStatInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbStatInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbStatInfoFactory::CSysMdbStatInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbStatInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbStatInfoFactory::~CSysMdbStatInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbStatInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbStatInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbStatInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbStatInfo thisSysMdbStatInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbStatInfo.readCSV(input,pNames))
		add(&thisSysMdbStatInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbStatInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbStatInfo.csv");
	return readCSV(szFileName);
}

int CSysMdbStatInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbStatInfo *pSysMdbStatInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbStatInfo::writeCSVHead(output);
	pSysMdbStatInfo=(CWriteableSysMdbStatInfo *)(pMem->getFirst());
	while (pSysMdbStatInfo!=NULL) {
		if (!pSysMdbStatInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbStatInfo=(CWriteableSysMdbStatInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbStatInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbStatInfo.csv");
	return writeCSV(szFileName);
}

void CSysMdbStatInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbStatInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbStatInfo *pSysMdbStatInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbStatInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbStatInfo=(CWriteableSysMdbStatInfo *)(pMem->getFirst());
	while (pSysMdbStatInfo!=NULL) {
		pSysMdbStatInfo->dump(fp,index++);
		pSysMdbStatInfo=(CWriteableSysMdbStatInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbStatInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbStatInfo *CSysMdbStatInfoFactory::internalAdd(CWriteableSysMdbStatInfo *pSysMdbStatInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbStatInfo++;
#endif
	CSysMdbStatInfo *pTarget;	
	beforeAdd(pSysMdbStatInfo);
	pTarget=(CSysMdbStatInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbStatInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbStatInfo, sizeof(CSysMdbStatInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbStatInfo *CSysMdbStatInfoFactory::add(CWriteableSysMdbStatInfo *pSysMdbStatInfo, CTransaction *pTransaction)
{
	pSysMdbStatInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbStatInfo,true);
	}
	else {
		CSysMdbStatInfo *pNewSysMdbStatInfo;
		pNewSysMdbStatInfo = internalAdd(pSysMdbStatInfo,false);
		pTransaction->addResource(CSysMdbStatInfoResource::alloc(CREATE_ACTION,this,pNewSysMdbStatInfo,NULL));
		return pNewSysMdbStatInfo;
	}
}

void CSysMdbStatInfoFactory::internalUpdate(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pNewSysMdbStatInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbStatInfo++;
	}
	else {
		updateWithoutIndexActionForSysMdbStatInfo++;
	}
#endif
	CWriteableSysMdbStatInfo theOldSysMdbStatInfo;
	beforeUpdate(pSysMdbStatInfo,pNewSysMdbStatInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbStatInfo,pSysMdbStatInfo,sizeof(CSysMdbStatInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbStatInfo,pNewSysMdbStatInfo,sizeof(CSysMdbStatInfo));
	pMem->updateObject(pSysMdbStatInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbStatInfo);
	if (bNoTransaction) {
		commitUpdate(pSysMdbStatInfo,&theOldSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::update(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pNewSysMdbStatInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbStatInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbStatInfo,pNewSysMdbStatInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbStatInfoResource::alloc(UPDATE_ACTION,this,pSysMdbStatInfo,pNewSysMdbStatInfo,updateIndex));
		internalUpdate(pSysMdbStatInfo,pNewSysMdbStatInfo,updateIndex,false);
	}
}

void CSysMdbStatInfoFactory::internalRemove(CSysMdbStatInfo *pSysMdbStatInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbStatInfo++;
#endif
	CWriteableSysMdbStatInfo theOldSysMdbStatInfo;
	beforeRemove(pSysMdbStatInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbStatInfo,pSysMdbStatInfo,sizeof(CSysMdbStatInfo));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbStatInfo);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbStatInfo);
	}
	pMem->free(pSysMdbStatInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::remove(CSysMdbStatInfo *pSysMdbStatInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbStatInfo,true);
	}
	else {
		pTransaction->addResource(CSysMdbStatInfoResource::alloc(DELETE_ACTION,this,pSysMdbStatInfo,NULL));
		internalRemove(pSysMdbStatInfo,false);		
	}
}

CSysMdbStatInfo* CSysMdbStatInfoFactory::addOrUpdate(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pNewSysMdbStatInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbStatInfo == NULL) {
		return add(pNewSysMdbStatInfo,pTransaction);
	}
	else {
		update(pSysMdbStatInfo,pNewSysMdbStatInfo,pTransaction,updateIndex);
		return pSysMdbStatInfo;
	}
}

void CSysMdbStatInfoFactory::retrieve(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pTargetSysMdbStatInfo)
{
	forceCopy(pTargetSysMdbStatInfo, pSysMdbStatInfo, sizeof(CSysMdbStatInfo));
}
	
int CSysMdbStatInfoFactory::addActionTrigger(CSysMdbStatInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbStatInfoFactory::removeActionTrigger(CSysMdbStatInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbStatInfoFactory::addCommitTrigger(CSysMdbStatInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbStatInfoFactory::removeCommitTrigger(CSysMdbStatInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbStatInfo *CSysMdbStatInfoFactory::getFirst(void)
{
	CSysMdbStatInfo *pResult=(CSysMdbStatInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbStatInfo *CSysMdbStatInfoFactory::getNext(void)
{
	CSysMdbStatInfo *pResult=(CSysMdbStatInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbStatInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbStatInfoFactory::beforeAdd(CWriteableSysMdbStatInfo *pSysMdbStatInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbStatInfo);
	}
}
	
void CSysMdbStatInfoFactory::afterAdd(CSysMdbStatInfo *pSysMdbStatInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::beforeUpdate(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pNewSysMdbStatInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbStatInfo,pNewSysMdbStatInfo);
	}
}
	
void CSysMdbStatInfoFactory::afterUpdate(CSysMdbStatInfo *pSysMdbStatInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbStatInfo);
	}
}
	
void CSysMdbStatInfoFactory::beforeRemove(CSysMdbStatInfo *pSysMdbStatInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::commitAdd(CSysMdbStatInfo *pSysMdbStatInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbStatInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::commitUpdate(CSysMdbStatInfo *pSysMdbStatInfo, CWriteableSysMdbStatInfo *pOldSysMdbStatInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbStatInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbStatInfo,pOldSysMdbStatInfo);
	}
}
	
void CSysMdbStatInfoFactory::commitRemove(CWriteableSysMdbStatInfo *pSysMdbStatInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbStatInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbStatInfo);
	}
}

void CSysMdbStatInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysHostNameIndexinSysMdbTradeFrontOrderRttStat(const void *pV1, const void *pV2);
extern int compareForDecIndexinSysMdbTradeFrontOrderRttStat(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMdbTradeFrontOrderRttStat=0;
int updateWithIndexActionForSysMdbTradeFrontOrderRttStat=0;
int updateWithoutIndexActionForSysMdbTradeFrontOrderRttStat=0;
int removeActionForSysMdbTradeFrontOrderRttStat=0;
int addCommitForSysMdbTradeFrontOrderRttStat=0;
int updateCommitForSysMdbTradeFrontOrderRttStat=0;
int removeCommitForSysMdbTradeFrontOrderRttStat=0;
#endif
void CSysMdbTradeFrontOrderRttStatFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTradeFrontOrderRttStat,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTradeFrontOrderRttStat_SysHostNameIndex",pSysHostNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTradeFrontOrderRttStat_SysHostNameIndex");
			if(it != pIndexMap->end()) {
				pSysHostNameIndex=new CAVLTree(maxUnit,compareForSysHostNameIndexinSysMdbTradeFrontOrderRttStat,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysHostNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	if (runLevel>=0) {
		if(!reuse) {
			pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTradeFrontOrderRttStat,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMdbTradeFrontOrderRttStat_DecIndex",pDecIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMdbTradeFrontOrderRttStat_DecIndex");
			if(it != pIndexMap->end()) {
				pDecIndex=new CAVLTree(maxUnit,compareForDecIndexinSysMdbTradeFrontOrderRttStat,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pDecIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByFrontIndex=NULL;
	pLastFoundInSearchByDsc=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysMdbTradeFrontOrderRttStatActionTrigger *>;
	pCommitTriggers=new vector<CSysMdbTradeFrontOrderRttStatCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMdbTradeFrontOrderRttStatFactory::CSysMdbTradeFrontOrderRttStatFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTradeFrontOrderRttStat),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMdbTradeFrontOrderRttStatFactory::CSysMdbTradeFrontOrderRttStatFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMdbTradeFrontOrderRttStat),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMdbTradeFrontOrderRttStatFactory::~CSysMdbTradeFrontOrderRttStatFactory(void)
{
	if (runLevel>=0) {
		if (pSysHostNameIndex!=NULL)
			delete pSysHostNameIndex;
	}
	if (runLevel>=0) {
		if (pDecIndex!=NULL)
			delete pDecIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMdbTradeFrontOrderRttStatFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMdbTradeFrontOrderRttStatFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysHostNameIndex->output(pLogger,indent+1);
	}
	if (runLevel>=0) {
		pDecIndex->output(pLogger,indent+1);
	}
}

int CSysMdbTradeFrontOrderRttStatFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMdbTradeFrontOrderRttStat thisSysMdbTradeFrontOrderRttStat;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMdbTradeFrontOrderRttStat.readCSV(input,pNames))
		add(&thisSysMdbTradeFrontOrderRttStat);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMdbTradeFrontOrderRttStatFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMdbTradeFrontOrderRttStat.csv");
	return readCSV(szFileName);
}

int CSysMdbTradeFrontOrderRttStatFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMdbTradeFrontOrderRttStat::writeCSVHead(output);
	pSysMdbTradeFrontOrderRttStat=(CWriteableSysMdbTradeFrontOrderRttStat *)(pMem->getFirst());
	while (pSysMdbTradeFrontOrderRttStat!=NULL) {
		if (!pSysMdbTradeFrontOrderRttStat->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMdbTradeFrontOrderRttStat=(CWriteableSysMdbTradeFrontOrderRttStat *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMdbTradeFrontOrderRttStatFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMdbTradeFrontOrderRttStat.csv");
	return writeCSV(szFileName);
}

void CSysMdbTradeFrontOrderRttStatFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMdbTradeFrontOrderRttStatFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMdbTradeFrontOrderRttStatFactory={       Total Count=%d\n", pMem->getCount());
	pSysMdbTradeFrontOrderRttStat=(CWriteableSysMdbTradeFrontOrderRttStat *)(pMem->getFirst());
	while (pSysMdbTradeFrontOrderRttStat!=NULL) {
		pSysMdbTradeFrontOrderRttStat->dump(fp,index++);
		pSysMdbTradeFrontOrderRttStat=(CWriteableSysMdbTradeFrontOrderRttStat *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMdbTradeFrontOrderRttStatFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysHostNameIndex->removeAll();
	}
	if (runLevel>=0) {
		pDecIndex->removeAll();
	}
}

CSysMdbTradeFrontOrderRttStat *CSysMdbTradeFrontOrderRttStatFactory::internalAdd(CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMdbTradeFrontOrderRttStat++;
#endif
	CSysMdbTradeFrontOrderRttStat *pTarget;	
	beforeAdd(pSysMdbTradeFrontOrderRttStat);
	pTarget=(CSysMdbTradeFrontOrderRttStat *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMdbTradeFrontOrderRttStat in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMdbTradeFrontOrderRttStat, sizeof(CSysMdbTradeFrontOrderRttStat));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysHostNameIndex->addObject(pTarget);
	}
	if (runLevel>=0) {
		pDecIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMdbTradeFrontOrderRttStat *CSysMdbTradeFrontOrderRttStatFactory::add(CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CTransaction *pTransaction)
{
	pSysMdbTradeFrontOrderRttStat->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMdbTradeFrontOrderRttStat,true);
	}
	else {
		CSysMdbTradeFrontOrderRttStat *pNewSysMdbTradeFrontOrderRttStat;
		pNewSysMdbTradeFrontOrderRttStat = internalAdd(pSysMdbTradeFrontOrderRttStat,false);
		pTransaction->addResource(CSysMdbTradeFrontOrderRttStatResource::alloc(CREATE_ACTION,this,pNewSysMdbTradeFrontOrderRttStat,NULL));
		return pNewSysMdbTradeFrontOrderRttStat;
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::internalUpdate(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pNewSysMdbTradeFrontOrderRttStat, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMdbTradeFrontOrderRttStat++;
	}
	else {
		updateWithoutIndexActionForSysMdbTradeFrontOrderRttStat++;
	}
#endif
	CWriteableSysMdbTradeFrontOrderRttStat theOldSysMdbTradeFrontOrderRttStat;
	beforeUpdate(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTradeFrontOrderRttStat,pSysMdbTradeFrontOrderRttStat,sizeof(CSysMdbTradeFrontOrderRttStat));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat,sizeof(CSysMdbTradeFrontOrderRttStat));
	pMem->updateObject(pSysMdbTradeFrontOrderRttStat);
	if (updateIndex) {
	}
	afterUpdate(pSysMdbTradeFrontOrderRttStat);
	if (bNoTransaction) {
		commitUpdate(pSysMdbTradeFrontOrderRttStat,&theOldSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::update(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pNewSysMdbTradeFrontOrderRttStat, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMdbTradeFrontOrderRttStat->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMdbTradeFrontOrderRttStatResource::alloc(UPDATE_ACTION,this,pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat,updateIndex));
		internalUpdate(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat,updateIndex,false);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::internalRemove(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMdbTradeFrontOrderRttStat++;
#endif
	CWriteableSysMdbTradeFrontOrderRttStat theOldSysMdbTradeFrontOrderRttStat;
	beforeRemove(pSysMdbTradeFrontOrderRttStat);
	if (bNoTransaction) {
		forceCopy(&theOldSysMdbTradeFrontOrderRttStat,pSysMdbTradeFrontOrderRttStat,sizeof(CSysMdbTradeFrontOrderRttStat));
	}
	if (runLevel>=0) {
		pSysHostNameIndex->removeObject(pSysMdbTradeFrontOrderRttStat);
	}
	if (runLevel>=0) {
		pDecIndex->removeObject(pSysMdbTradeFrontOrderRttStat);
	}
	pMem->free(pSysMdbTradeFrontOrderRttStat);
	if(bNoTransaction) {
		commitRemove(&theOldSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::remove(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMdbTradeFrontOrderRttStat,true);
	}
	else {
		pTransaction->addResource(CSysMdbTradeFrontOrderRttStatResource::alloc(DELETE_ACTION,this,pSysMdbTradeFrontOrderRttStat,NULL));
		internalRemove(pSysMdbTradeFrontOrderRttStat,false);		
	}
}

CSysMdbTradeFrontOrderRttStat* CSysMdbTradeFrontOrderRttStatFactory::addOrUpdate(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pNewSysMdbTradeFrontOrderRttStat, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMdbTradeFrontOrderRttStat == NULL) {
		return add(pNewSysMdbTradeFrontOrderRttStat,pTransaction);
	}
	else {
		update(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat,pTransaction,updateIndex);
		return pSysMdbTradeFrontOrderRttStat;
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::retrieve(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pTargetSysMdbTradeFrontOrderRttStat)
{
	forceCopy(pTargetSysMdbTradeFrontOrderRttStat, pSysMdbTradeFrontOrderRttStat, sizeof(CSysMdbTradeFrontOrderRttStat));
}
	
int CSysMdbTradeFrontOrderRttStatFactory::addActionTrigger(CSysMdbTradeFrontOrderRttStatActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMdbTradeFrontOrderRttStatFactory::removeActionTrigger(CSysMdbTradeFrontOrderRttStatActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMdbTradeFrontOrderRttStatFactory::addCommitTrigger(CSysMdbTradeFrontOrderRttStatCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMdbTradeFrontOrderRttStatFactory::removeCommitTrigger(CSysMdbTradeFrontOrderRttStatCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMdbTradeFrontOrderRttStat *CSysMdbTradeFrontOrderRttStatFactory::getFirst(void)
{
	CSysMdbTradeFrontOrderRttStat *pResult=(CSysMdbTradeFrontOrderRttStat *)(pMem->getFirst());
	return pResult;
}
	
CSysMdbTradeFrontOrderRttStat *CSysMdbTradeFrontOrderRttStatFactory::getNext(void)
{
	CSysMdbTradeFrontOrderRttStat *pResult=(CSysMdbTradeFrontOrderRttStat *)(pMem->getNext());
	return pResult;
}
	
void CSysMdbTradeFrontOrderRttStatFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMdbTradeFrontOrderRttStatFactory::beforeAdd(CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMdbTradeFrontOrderRttStat);
	}
}
	
void CSysMdbTradeFrontOrderRttStatFactory::afterAdd(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::beforeUpdate(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pNewSysMdbTradeFrontOrderRttStat)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMdbTradeFrontOrderRttStat,pNewSysMdbTradeFrontOrderRttStat);
	}
}
	
void CSysMdbTradeFrontOrderRttStatFactory::afterUpdate(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMdbTradeFrontOrderRttStat);
	}
}
	
void CSysMdbTradeFrontOrderRttStatFactory::beforeRemove(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::commitAdd(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMdbTradeFrontOrderRttStat++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::commitUpdate(CSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat, CWriteableSysMdbTradeFrontOrderRttStat *pOldSysMdbTradeFrontOrderRttStat)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMdbTradeFrontOrderRttStat++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMdbTradeFrontOrderRttStat,pOldSysMdbTradeFrontOrderRttStat);
	}
}
	
void CSysMdbTradeFrontOrderRttStatFactory::commitRemove(CWriteableSysMdbTradeFrontOrderRttStat *pSysMdbTradeFrontOrderRttStat)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMdbTradeFrontOrderRttStat++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMdbTradeFrontOrderRttStat);
	}
}

void CSysMdbTradeFrontOrderRttStatFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTradeTimeIndexinSysInstrumentStatus(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysInstrumentStatus=0;
int updateWithIndexActionForSysInstrumentStatus=0;
int updateWithoutIndexActionForSysInstrumentStatus=0;
int removeActionForSysInstrumentStatus=0;
int addCommitForSysInstrumentStatus=0;
int updateCommitForSysInstrumentStatus=0;
int removeCommitForSysInstrumentStatus=0;
#endif
void CSysInstrumentStatusFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysInstrumentStatus,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysInstrumentStatus_SysTradeTimeIndex",pSysTradeTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysInstrumentStatus_SysTradeTimeIndex");
			if(it != pIndexMap->end()) {
				pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysInstrumentStatus,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTradeTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysInstrumentStatusActionTrigger *>;
	pCommitTriggers=new vector<CSysInstrumentStatusCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysInstrumentStatusFactory::CSysInstrumentStatusFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInstrumentStatus),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysInstrumentStatusFactory::CSysInstrumentStatusFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysInstrumentStatus),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysInstrumentStatusFactory::~CSysInstrumentStatusFactory(void)
{
	if (runLevel>=0) {
		if (pSysTradeTimeIndex!=NULL)
			delete pSysTradeTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysInstrumentStatusFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysInstrumentStatusFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTradeTimeIndex->output(pLogger,indent+1);
	}
}

int CSysInstrumentStatusFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysInstrumentStatus thisSysInstrumentStatus;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysInstrumentStatus.readCSV(input,pNames))
		add(&thisSysInstrumentStatus);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysInstrumentStatusFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysInstrumentStatus.csv");
	return readCSV(szFileName);
}

int CSysInstrumentStatusFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysInstrumentStatus *pSysInstrumentStatus;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysInstrumentStatus::writeCSVHead(output);
	pSysInstrumentStatus=(CWriteableSysInstrumentStatus *)(pMem->getFirst());
	while (pSysInstrumentStatus!=NULL) {
		if (!pSysInstrumentStatus->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysInstrumentStatus=(CWriteableSysInstrumentStatus *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysInstrumentStatusFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysInstrumentStatus.csv");
	return writeCSV(szFileName);
}

void CSysInstrumentStatusFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysInstrumentStatusFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysInstrumentStatus *pSysInstrumentStatus;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysInstrumentStatusFactory={       Total Count=%d\n", pMem->getCount());
	pSysInstrumentStatus=(CWriteableSysInstrumentStatus *)(pMem->getFirst());
	while (pSysInstrumentStatus!=NULL) {
		pSysInstrumentStatus->dump(fp,index++);
		pSysInstrumentStatus=(CWriteableSysInstrumentStatus *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysInstrumentStatusFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeAll();
	}
}

CSysInstrumentStatus *CSysInstrumentStatusFactory::internalAdd(CWriteableSysInstrumentStatus *pSysInstrumentStatus, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysInstrumentStatus++;
#endif
	CSysInstrumentStatus *pTarget;	
	beforeAdd(pSysInstrumentStatus);
	pTarget=(CSysInstrumentStatus *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysInstrumentStatus in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysInstrumentStatus, sizeof(CSysInstrumentStatus));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTradeTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysInstrumentStatus *CSysInstrumentStatusFactory::add(CWriteableSysInstrumentStatus *pSysInstrumentStatus, CTransaction *pTransaction)
{
	pSysInstrumentStatus->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysInstrumentStatus,true);
	}
	else {
		CSysInstrumentStatus *pNewSysInstrumentStatus;
		pNewSysInstrumentStatus = internalAdd(pSysInstrumentStatus,false);
		pTransaction->addResource(CSysInstrumentStatusResource::alloc(CREATE_ACTION,this,pNewSysInstrumentStatus,NULL));
		return pNewSysInstrumentStatus;
	}
}

void CSysInstrumentStatusFactory::internalUpdate(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pNewSysInstrumentStatus, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysInstrumentStatus++;
	}
	else {
		updateWithoutIndexActionForSysInstrumentStatus++;
	}
#endif
	CWriteableSysInstrumentStatus theOldSysInstrumentStatus;
	beforeUpdate(pSysInstrumentStatus,pNewSysInstrumentStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSysInstrumentStatus,pSysInstrumentStatus,sizeof(CSysInstrumentStatus));
	}
	if (updateIndex) {
	}

	forceCopy(pSysInstrumentStatus,pNewSysInstrumentStatus,sizeof(CSysInstrumentStatus));
	pMem->updateObject(pSysInstrumentStatus);
	if (updateIndex) {
	}
	afterUpdate(pSysInstrumentStatus);
	if (bNoTransaction) {
		commitUpdate(pSysInstrumentStatus,&theOldSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::update(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pNewSysInstrumentStatus, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysInstrumentStatus->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysInstrumentStatus,pNewSysInstrumentStatus,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysInstrumentStatusResource::alloc(UPDATE_ACTION,this,pSysInstrumentStatus,pNewSysInstrumentStatus,updateIndex));
		internalUpdate(pSysInstrumentStatus,pNewSysInstrumentStatus,updateIndex,false);
	}
}

void CSysInstrumentStatusFactory::internalRemove(CSysInstrumentStatus *pSysInstrumentStatus, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysInstrumentStatus++;
#endif
	CWriteableSysInstrumentStatus theOldSysInstrumentStatus;
	beforeRemove(pSysInstrumentStatus);
	if (bNoTransaction) {
		forceCopy(&theOldSysInstrumentStatus,pSysInstrumentStatus,sizeof(CSysInstrumentStatus));
	}
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeObject(pSysInstrumentStatus);
	}
	pMem->free(pSysInstrumentStatus);
	if(bNoTransaction) {
		commitRemove(&theOldSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::remove(CSysInstrumentStatus *pSysInstrumentStatus, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysInstrumentStatus,true);
	}
	else {
		pTransaction->addResource(CSysInstrumentStatusResource::alloc(DELETE_ACTION,this,pSysInstrumentStatus,NULL));
		internalRemove(pSysInstrumentStatus,false);		
	}
}

CSysInstrumentStatus* CSysInstrumentStatusFactory::addOrUpdate(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pNewSysInstrumentStatus, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysInstrumentStatus == NULL) {
		return add(pNewSysInstrumentStatus,pTransaction);
	}
	else {
		update(pSysInstrumentStatus,pNewSysInstrumentStatus,pTransaction,updateIndex);
		return pSysInstrumentStatus;
	}
}

void CSysInstrumentStatusFactory::retrieve(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pTargetSysInstrumentStatus)
{
	forceCopy(pTargetSysInstrumentStatus, pSysInstrumentStatus, sizeof(CSysInstrumentStatus));
}
	
int CSysInstrumentStatusFactory::addActionTrigger(CSysInstrumentStatusActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysInstrumentStatusFactory::removeActionTrigger(CSysInstrumentStatusActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysInstrumentStatusFactory::addCommitTrigger(CSysInstrumentStatusCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysInstrumentStatusFactory::removeCommitTrigger(CSysInstrumentStatusCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysInstrumentStatus *CSysInstrumentStatusFactory::getFirst(void)
{
	CSysInstrumentStatus *pResult=(CSysInstrumentStatus *)(pMem->getFirst());
	return pResult;
}
	
CSysInstrumentStatus *CSysInstrumentStatusFactory::getNext(void)
{
	CSysInstrumentStatus *pResult=(CSysInstrumentStatus *)(pMem->getNext());
	return pResult;
}
	
void CSysInstrumentStatusFactory::endGet(void)
{
	pMem->endGet();
}

void CSysInstrumentStatusFactory::beforeAdd(CWriteableSysInstrumentStatus *pSysInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysInstrumentStatus);
	}
}
	
void CSysInstrumentStatusFactory::afterAdd(CSysInstrumentStatus *pSysInstrumentStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::beforeUpdate(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pNewSysInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysInstrumentStatus,pNewSysInstrumentStatus);
	}
}
	
void CSysInstrumentStatusFactory::afterUpdate(CSysInstrumentStatus *pSysInstrumentStatus)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysInstrumentStatus);
	}
}
	
void CSysInstrumentStatusFactory::beforeRemove(CSysInstrumentStatus *pSysInstrumentStatus)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::commitAdd(CSysInstrumentStatus *pSysInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::commitUpdate(CSysInstrumentStatus *pSysInstrumentStatus, CWriteableSysInstrumentStatus *pOldSysInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysInstrumentStatus,pOldSysInstrumentStatus);
	}
}
	
void CSysInstrumentStatusFactory::commitRemove(CWriteableSysInstrumentStatus *pSysInstrumentStatus)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysInstrumentStatus++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysInstrumentStatus);
	}
}

void CSysInstrumentStatusFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysTradeTimeIndexinSysCurrTradingSegmentAttr(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysCurrTradingSegmentAttr=0;
int updateWithIndexActionForSysCurrTradingSegmentAttr=0;
int updateWithoutIndexActionForSysCurrTradingSegmentAttr=0;
int removeActionForSysCurrTradingSegmentAttr=0;
int addCommitForSysCurrTradingSegmentAttr=0;
int updateCommitForSysCurrTradingSegmentAttr=0;
int removeCommitForSysCurrTradingSegmentAttr=0;
#endif
void CSysCurrTradingSegmentAttrFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysCurrTradingSegmentAttr,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysCurrTradingSegmentAttr_SysTradeTimeIndex",pSysTradeTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysCurrTradingSegmentAttr_SysTradeTimeIndex");
			if(it != pIndexMap->end()) {
				pSysTradeTimeIndex=new CAVLTree(maxUnit,compareForSysTradeTimeIndexinSysCurrTradingSegmentAttr,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysTradeTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByActionTime=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pActionTriggers=new vector<CSysCurrTradingSegmentAttrActionTrigger *>;
	pCommitTriggers=new vector<CSysCurrTradingSegmentAttrCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysCurrTradingSegmentAttrFactory::CSysCurrTradingSegmentAttrFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysCurrTradingSegmentAttr),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysCurrTradingSegmentAttrFactory::CSysCurrTradingSegmentAttrFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysCurrTradingSegmentAttr),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysCurrTradingSegmentAttrFactory::~CSysCurrTradingSegmentAttrFactory(void)
{
	if (runLevel>=0) {
		if (pSysTradeTimeIndex!=NULL)
			delete pSysTradeTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysCurrTradingSegmentAttrFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysCurrTradingSegmentAttrFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysTradeTimeIndex->output(pLogger,indent+1);
	}
}

int CSysCurrTradingSegmentAttrFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysCurrTradingSegmentAttr thisSysCurrTradingSegmentAttr;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysCurrTradingSegmentAttr.readCSV(input,pNames))
		add(&thisSysCurrTradingSegmentAttr);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysCurrTradingSegmentAttrFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysCurrTradingSegmentAttr.csv");
	return readCSV(szFileName);
}

int CSysCurrTradingSegmentAttrFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysCurrTradingSegmentAttr::writeCSVHead(output);
	pSysCurrTradingSegmentAttr=(CWriteableSysCurrTradingSegmentAttr *)(pMem->getFirst());
	while (pSysCurrTradingSegmentAttr!=NULL) {
		if (!pSysCurrTradingSegmentAttr->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysCurrTradingSegmentAttr=(CWriteableSysCurrTradingSegmentAttr *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysCurrTradingSegmentAttrFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysCurrTradingSegmentAttr.csv");
	return writeCSV(szFileName);
}

void CSysCurrTradingSegmentAttrFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysCurrTradingSegmentAttrFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysCurrTradingSegmentAttrFactory={       Total Count=%d\n", pMem->getCount());
	pSysCurrTradingSegmentAttr=(CWriteableSysCurrTradingSegmentAttr *)(pMem->getFirst());
	while (pSysCurrTradingSegmentAttr!=NULL) {
		pSysCurrTradingSegmentAttr->dump(fp,index++);
		pSysCurrTradingSegmentAttr=(CWriteableSysCurrTradingSegmentAttr *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysCurrTradingSegmentAttrFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeAll();
	}
}

CSysCurrTradingSegmentAttr *CSysCurrTradingSegmentAttrFactory::internalAdd(CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysCurrTradingSegmentAttr++;
#endif
	CSysCurrTradingSegmentAttr *pTarget;	
	beforeAdd(pSysCurrTradingSegmentAttr);
	pTarget=(CSysCurrTradingSegmentAttr *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysCurrTradingSegmentAttr in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysCurrTradingSegmentAttr, sizeof(CSysCurrTradingSegmentAttr));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysTradeTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysCurrTradingSegmentAttr *CSysCurrTradingSegmentAttrFactory::add(CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CTransaction *pTransaction)
{
	pSysCurrTradingSegmentAttr->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysCurrTradingSegmentAttr,true);
	}
	else {
		CSysCurrTradingSegmentAttr *pNewSysCurrTradingSegmentAttr;
		pNewSysCurrTradingSegmentAttr = internalAdd(pSysCurrTradingSegmentAttr,false);
		pTransaction->addResource(CSysCurrTradingSegmentAttrResource::alloc(CREATE_ACTION,this,pNewSysCurrTradingSegmentAttr,NULL));
		return pNewSysCurrTradingSegmentAttr;
	}
}

void CSysCurrTradingSegmentAttrFactory::internalUpdate(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pNewSysCurrTradingSegmentAttr, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysCurrTradingSegmentAttr++;
	}
	else {
		updateWithoutIndexActionForSysCurrTradingSegmentAttr++;
	}
#endif
	CWriteableSysCurrTradingSegmentAttr theOldSysCurrTradingSegmentAttr;
	beforeUpdate(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysCurrTradingSegmentAttr,pSysCurrTradingSegmentAttr,sizeof(CSysCurrTradingSegmentAttr));
	}
	if (updateIndex) {
	}

	forceCopy(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr,sizeof(CSysCurrTradingSegmentAttr));
	pMem->updateObject(pSysCurrTradingSegmentAttr);
	if (updateIndex) {
	}
	afterUpdate(pSysCurrTradingSegmentAttr);
	if (bNoTransaction) {
		commitUpdate(pSysCurrTradingSegmentAttr,&theOldSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::update(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pNewSysCurrTradingSegmentAttr, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysCurrTradingSegmentAttr->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysCurrTradingSegmentAttrResource::alloc(UPDATE_ACTION,this,pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr,updateIndex));
		internalUpdate(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr,updateIndex,false);
	}
}

void CSysCurrTradingSegmentAttrFactory::internalRemove(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysCurrTradingSegmentAttr++;
#endif
	CWriteableSysCurrTradingSegmentAttr theOldSysCurrTradingSegmentAttr;
	beforeRemove(pSysCurrTradingSegmentAttr);
	if (bNoTransaction) {
		forceCopy(&theOldSysCurrTradingSegmentAttr,pSysCurrTradingSegmentAttr,sizeof(CSysCurrTradingSegmentAttr));
	}
	if (runLevel>=0) {
		pSysTradeTimeIndex->removeObject(pSysCurrTradingSegmentAttr);
	}
	pMem->free(pSysCurrTradingSegmentAttr);
	if(bNoTransaction) {
		commitRemove(&theOldSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::remove(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysCurrTradingSegmentAttr,true);
	}
	else {
		pTransaction->addResource(CSysCurrTradingSegmentAttrResource::alloc(DELETE_ACTION,this,pSysCurrTradingSegmentAttr,NULL));
		internalRemove(pSysCurrTradingSegmentAttr,false);		
	}
}

CSysCurrTradingSegmentAttr* CSysCurrTradingSegmentAttrFactory::addOrUpdate(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pNewSysCurrTradingSegmentAttr, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysCurrTradingSegmentAttr == NULL) {
		return add(pNewSysCurrTradingSegmentAttr,pTransaction);
	}
	else {
		update(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr,pTransaction,updateIndex);
		return pSysCurrTradingSegmentAttr;
	}
}

void CSysCurrTradingSegmentAttrFactory::retrieve(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pTargetSysCurrTradingSegmentAttr)
{
	forceCopy(pTargetSysCurrTradingSegmentAttr, pSysCurrTradingSegmentAttr, sizeof(CSysCurrTradingSegmentAttr));
}
	
int CSysCurrTradingSegmentAttrFactory::addActionTrigger(CSysCurrTradingSegmentAttrActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysCurrTradingSegmentAttrFactory::removeActionTrigger(CSysCurrTradingSegmentAttrActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysCurrTradingSegmentAttrFactory::addCommitTrigger(CSysCurrTradingSegmentAttrCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysCurrTradingSegmentAttrFactory::removeCommitTrigger(CSysCurrTradingSegmentAttrCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysCurrTradingSegmentAttr *CSysCurrTradingSegmentAttrFactory::getFirst(void)
{
	CSysCurrTradingSegmentAttr *pResult=(CSysCurrTradingSegmentAttr *)(pMem->getFirst());
	return pResult;
}
	
CSysCurrTradingSegmentAttr *CSysCurrTradingSegmentAttrFactory::getNext(void)
{
	CSysCurrTradingSegmentAttr *pResult=(CSysCurrTradingSegmentAttr *)(pMem->getNext());
	return pResult;
}
	
void CSysCurrTradingSegmentAttrFactory::endGet(void)
{
	pMem->endGet();
}

void CSysCurrTradingSegmentAttrFactory::beforeAdd(CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysCurrTradingSegmentAttr);
	}
}
	
void CSysCurrTradingSegmentAttrFactory::afterAdd(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::beforeUpdate(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pNewSysCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysCurrTradingSegmentAttr,pNewSysCurrTradingSegmentAttr);
	}
}
	
void CSysCurrTradingSegmentAttrFactory::afterUpdate(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysCurrTradingSegmentAttr);
	}
}
	
void CSysCurrTradingSegmentAttrFactory::beforeRemove(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::commitAdd(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::commitUpdate(CSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr, CWriteableSysCurrTradingSegmentAttr *pOldSysCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysCurrTradingSegmentAttr,pOldSysCurrTradingSegmentAttr);
	}
}
	
void CSysCurrTradingSegmentAttrFactory::commitRemove(CWriteableSysCurrTradingSegmentAttr *pSysCurrTradingSegmentAttr)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysCurrTradingSegmentAttr++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysCurrTradingSegmentAttr);
	}
}

void CSysCurrTradingSegmentAttrFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysPayTimeIndexinSysMemberLinkCost(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysMemberLinkCost=0;
int updateWithIndexActionForSysMemberLinkCost=0;
int updateWithoutIndexActionForSysMemberLinkCost=0;
int removeActionForSysMemberLinkCost=0;
int addCommitForSysMemberLinkCost=0;
int updateCommitForSysMemberLinkCost=0;
int removeCommitForSysMemberLinkCost=0;
#endif
void CSysMemberLinkCostFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysPayTimeIndex=new CAVLTree(maxUnit,compareForSysPayTimeIndexinSysMemberLinkCost,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysMemberLinkCost_SysPayTimeIndex",pSysPayTimeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysMemberLinkCost_SysPayTimeIndex");
			if(it != pIndexMap->end()) {
				pSysPayTimeIndex=new CAVLTree(maxUnit,compareForSysPayTimeIndexinSysMemberLinkCost,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysPayTimeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByPayTime=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysMemberLinkCostActionTrigger *>;
	pCommitTriggers=new vector<CSysMemberLinkCostCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysMemberLinkCostFactory::CSysMemberLinkCostFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMemberLinkCost),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysMemberLinkCostFactory::CSysMemberLinkCostFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysMemberLinkCost),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysMemberLinkCostFactory::~CSysMemberLinkCostFactory(void)
{
	if (runLevel>=0) {
		if (pSysPayTimeIndex!=NULL)
			delete pSysPayTimeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysMemberLinkCostFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysMemberLinkCostFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysPayTimeIndex->output(pLogger,indent+1);
	}
}

int CSysMemberLinkCostFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysMemberLinkCost thisSysMemberLinkCost;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysMemberLinkCost.readCSV(input,pNames))
		add(&thisSysMemberLinkCost);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysMemberLinkCostFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysMemberLinkCost.csv");
	return readCSV(szFileName);
}

int CSysMemberLinkCostFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysMemberLinkCost *pSysMemberLinkCost;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysMemberLinkCost::writeCSVHead(output);
	pSysMemberLinkCost=(CWriteableSysMemberLinkCost *)(pMem->getFirst());
	while (pSysMemberLinkCost!=NULL) {
		if (!pSysMemberLinkCost->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysMemberLinkCost=(CWriteableSysMemberLinkCost *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysMemberLinkCostFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysMemberLinkCost.csv");
	return writeCSV(szFileName);
}

void CSysMemberLinkCostFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysMemberLinkCostFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysMemberLinkCost *pSysMemberLinkCost;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysMemberLinkCostFactory={       Total Count=%d\n", pMem->getCount());
	pSysMemberLinkCost=(CWriteableSysMemberLinkCost *)(pMem->getFirst());
	while (pSysMemberLinkCost!=NULL) {
		pSysMemberLinkCost->dump(fp,index++);
		pSysMemberLinkCost=(CWriteableSysMemberLinkCost *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysMemberLinkCostFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysPayTimeIndex->removeAll();
	}
}

CSysMemberLinkCost *CSysMemberLinkCostFactory::internalAdd(CWriteableSysMemberLinkCost *pSysMemberLinkCost, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysMemberLinkCost++;
#endif
	CSysMemberLinkCost *pTarget;	
	beforeAdd(pSysMemberLinkCost);
	pTarget=(CSysMemberLinkCost *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysMemberLinkCost in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysMemberLinkCost, sizeof(CSysMemberLinkCost));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysPayTimeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysMemberLinkCost *CSysMemberLinkCostFactory::add(CWriteableSysMemberLinkCost *pSysMemberLinkCost, CTransaction *pTransaction)
{
	pSysMemberLinkCost->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysMemberLinkCost,true);
	}
	else {
		CSysMemberLinkCost *pNewSysMemberLinkCost;
		pNewSysMemberLinkCost = internalAdd(pSysMemberLinkCost,false);
		pTransaction->addResource(CSysMemberLinkCostResource::alloc(CREATE_ACTION,this,pNewSysMemberLinkCost,NULL));
		return pNewSysMemberLinkCost;
	}
}

void CSysMemberLinkCostFactory::internalUpdate(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pNewSysMemberLinkCost, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysMemberLinkCost++;
	}
	else {
		updateWithoutIndexActionForSysMemberLinkCost++;
	}
#endif
	CWriteableSysMemberLinkCost theOldSysMemberLinkCost;
	beforeUpdate(pSysMemberLinkCost,pNewSysMemberLinkCost);
	if (bNoTransaction) {
		forceCopy(&theOldSysMemberLinkCost,pSysMemberLinkCost,sizeof(CSysMemberLinkCost));
	}
	if (updateIndex) {
	}

	forceCopy(pSysMemberLinkCost,pNewSysMemberLinkCost,sizeof(CSysMemberLinkCost));
	pMem->updateObject(pSysMemberLinkCost);
	if (updateIndex) {
	}
	afterUpdate(pSysMemberLinkCost);
	if (bNoTransaction) {
		commitUpdate(pSysMemberLinkCost,&theOldSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::update(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pNewSysMemberLinkCost, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysMemberLinkCost->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysMemberLinkCost,pNewSysMemberLinkCost,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysMemberLinkCostResource::alloc(UPDATE_ACTION,this,pSysMemberLinkCost,pNewSysMemberLinkCost,updateIndex));
		internalUpdate(pSysMemberLinkCost,pNewSysMemberLinkCost,updateIndex,false);
	}
}

void CSysMemberLinkCostFactory::internalRemove(CSysMemberLinkCost *pSysMemberLinkCost, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysMemberLinkCost++;
#endif
	CWriteableSysMemberLinkCost theOldSysMemberLinkCost;
	beforeRemove(pSysMemberLinkCost);
	if (bNoTransaction) {
		forceCopy(&theOldSysMemberLinkCost,pSysMemberLinkCost,sizeof(CSysMemberLinkCost));
	}
	if (runLevel>=0) {
		pSysPayTimeIndex->removeObject(pSysMemberLinkCost);
	}
	pMem->free(pSysMemberLinkCost);
	if(bNoTransaction) {
		commitRemove(&theOldSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::remove(CSysMemberLinkCost *pSysMemberLinkCost, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysMemberLinkCost,true);
	}
	else {
		pTransaction->addResource(CSysMemberLinkCostResource::alloc(DELETE_ACTION,this,pSysMemberLinkCost,NULL));
		internalRemove(pSysMemberLinkCost,false);		
	}
}

CSysMemberLinkCost* CSysMemberLinkCostFactory::addOrUpdate(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pNewSysMemberLinkCost, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysMemberLinkCost == NULL) {
		return add(pNewSysMemberLinkCost,pTransaction);
	}
	else {
		update(pSysMemberLinkCost,pNewSysMemberLinkCost,pTransaction,updateIndex);
		return pSysMemberLinkCost;
	}
}

void CSysMemberLinkCostFactory::retrieve(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pTargetSysMemberLinkCost)
{
	forceCopy(pTargetSysMemberLinkCost, pSysMemberLinkCost, sizeof(CSysMemberLinkCost));
}
	
int CSysMemberLinkCostFactory::addActionTrigger(CSysMemberLinkCostActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysMemberLinkCostFactory::removeActionTrigger(CSysMemberLinkCostActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysMemberLinkCostFactory::addCommitTrigger(CSysMemberLinkCostCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysMemberLinkCostFactory::removeCommitTrigger(CSysMemberLinkCostCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysMemberLinkCost *CSysMemberLinkCostFactory::getFirst(void)
{
	CSysMemberLinkCost *pResult=(CSysMemberLinkCost *)(pMem->getFirst());
	return pResult;
}
	
CSysMemberLinkCost *CSysMemberLinkCostFactory::getNext(void)
{
	CSysMemberLinkCost *pResult=(CSysMemberLinkCost *)(pMem->getNext());
	return pResult;
}
	
void CSysMemberLinkCostFactory::endGet(void)
{
	pMem->endGet();
}

void CSysMemberLinkCostFactory::beforeAdd(CWriteableSysMemberLinkCost *pSysMemberLinkCost)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysMemberLinkCost);
	}
}
	
void CSysMemberLinkCostFactory::afterAdd(CSysMemberLinkCost *pSysMemberLinkCost)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::beforeUpdate(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pNewSysMemberLinkCost)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysMemberLinkCost,pNewSysMemberLinkCost);
	}
}
	
void CSysMemberLinkCostFactory::afterUpdate(CSysMemberLinkCost *pSysMemberLinkCost)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysMemberLinkCost);
	}
}
	
void CSysMemberLinkCostFactory::beforeRemove(CSysMemberLinkCost *pSysMemberLinkCost)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::commitAdd(CSysMemberLinkCost *pSysMemberLinkCost)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysMemberLinkCost++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::commitUpdate(CSysMemberLinkCost *pSysMemberLinkCost, CWriteableSysMemberLinkCost *pOldSysMemberLinkCost)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysMemberLinkCost++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysMemberLinkCost,pOldSysMemberLinkCost);
	}
}
	
void CSysMemberLinkCostFactory::commitRemove(CWriteableSysMemberLinkCost *pSysMemberLinkCost)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysMemberLinkCost++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysMemberLinkCost);
	}
}

void CSysMemberLinkCostFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysLineNameIndexinSysNetPartylinkMonthlyRent(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetPartylinkMonthlyRent=0;
int updateWithIndexActionForSysNetPartylinkMonthlyRent=0;
int updateWithoutIndexActionForSysNetPartylinkMonthlyRent=0;
int removeActionForSysNetPartylinkMonthlyRent=0;
int addCommitForSysNetPartylinkMonthlyRent=0;
int updateCommitForSysNetPartylinkMonthlyRent=0;
int removeCommitForSysNetPartylinkMonthlyRent=0;
#endif
void CSysNetPartylinkMonthlyRentFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysLineNameIndex=new CAVLTree(maxUnit,compareForSysLineNameIndexinSysNetPartylinkMonthlyRent,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetPartylinkMonthlyRent_SysLineNameIndex",pSysLineNameIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetPartylinkMonthlyRent_SysLineNameIndex");
			if(it != pIndexMap->end()) {
				pSysLineNameIndex=new CAVLTree(maxUnit,compareForSysLineNameIndexinSysNetPartylinkMonthlyRent,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysLineNameIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByLineName=NULL;
	pLastFoundInSearchBytheAll=NULL;
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetPartylinkMonthlyRentActionTrigger *>;
	pCommitTriggers=new vector<CSysNetPartylinkMonthlyRentCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetPartylinkMonthlyRentFactory::CSysNetPartylinkMonthlyRentFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartylinkMonthlyRent),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetPartylinkMonthlyRentFactory::CSysNetPartylinkMonthlyRentFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetPartylinkMonthlyRent),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetPartylinkMonthlyRentFactory::~CSysNetPartylinkMonthlyRentFactory(void)
{
	if (runLevel>=0) {
		if (pSysLineNameIndex!=NULL)
			delete pSysLineNameIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetPartylinkMonthlyRentFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetPartylinkMonthlyRentFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysLineNameIndex->output(pLogger,indent+1);
	}
}

int CSysNetPartylinkMonthlyRentFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetPartylinkMonthlyRent thisSysNetPartylinkMonthlyRent;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetPartylinkMonthlyRent.readCSV(input,pNames))
		add(&thisSysNetPartylinkMonthlyRent);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetPartylinkMonthlyRentFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetPartylinkMonthlyRent.csv");
	return readCSV(szFileName);
}

int CSysNetPartylinkMonthlyRentFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetPartylinkMonthlyRent::writeCSVHead(output);
	pSysNetPartylinkMonthlyRent=(CWriteableSysNetPartylinkMonthlyRent *)(pMem->getFirst());
	while (pSysNetPartylinkMonthlyRent!=NULL) {
		if (!pSysNetPartylinkMonthlyRent->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetPartylinkMonthlyRent=(CWriteableSysNetPartylinkMonthlyRent *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetPartylinkMonthlyRentFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetPartylinkMonthlyRent.csv");
	return writeCSV(szFileName);
}

void CSysNetPartylinkMonthlyRentFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetPartylinkMonthlyRentFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetPartylinkMonthlyRentFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetPartylinkMonthlyRent=(CWriteableSysNetPartylinkMonthlyRent *)(pMem->getFirst());
	while (pSysNetPartylinkMonthlyRent!=NULL) {
		pSysNetPartylinkMonthlyRent->dump(fp,index++);
		pSysNetPartylinkMonthlyRent=(CWriteableSysNetPartylinkMonthlyRent *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetPartylinkMonthlyRentFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysLineNameIndex->removeAll();
	}
}

CSysNetPartylinkMonthlyRent *CSysNetPartylinkMonthlyRentFactory::internalAdd(CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetPartylinkMonthlyRent++;
#endif
	CSysNetPartylinkMonthlyRent *pTarget;	
	beforeAdd(pSysNetPartylinkMonthlyRent);
	pTarget=(CSysNetPartylinkMonthlyRent *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetPartylinkMonthlyRent in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetPartylinkMonthlyRent, sizeof(CSysNetPartylinkMonthlyRent));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysLineNameIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetPartylinkMonthlyRent *CSysNetPartylinkMonthlyRentFactory::add(CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CTransaction *pTransaction)
{
	pSysNetPartylinkMonthlyRent->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetPartylinkMonthlyRent,true);
	}
	else {
		CSysNetPartylinkMonthlyRent *pNewSysNetPartylinkMonthlyRent;
		pNewSysNetPartylinkMonthlyRent = internalAdd(pSysNetPartylinkMonthlyRent,false);
		pTransaction->addResource(CSysNetPartylinkMonthlyRentResource::alloc(CREATE_ACTION,this,pNewSysNetPartylinkMonthlyRent,NULL));
		return pNewSysNetPartylinkMonthlyRent;
	}
}

void CSysNetPartylinkMonthlyRentFactory::internalUpdate(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pNewSysNetPartylinkMonthlyRent, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetPartylinkMonthlyRent++;
	}
	else {
		updateWithoutIndexActionForSysNetPartylinkMonthlyRent++;
	}
#endif
	CWriteableSysNetPartylinkMonthlyRent theOldSysNetPartylinkMonthlyRent;
	beforeUpdate(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartylinkMonthlyRent,pSysNetPartylinkMonthlyRent,sizeof(CSysNetPartylinkMonthlyRent));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent,sizeof(CSysNetPartylinkMonthlyRent));
	pMem->updateObject(pSysNetPartylinkMonthlyRent);
	if (updateIndex) {
	}
	afterUpdate(pSysNetPartylinkMonthlyRent);
	if (bNoTransaction) {
		commitUpdate(pSysNetPartylinkMonthlyRent,&theOldSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::update(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pNewSysNetPartylinkMonthlyRent, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetPartylinkMonthlyRent->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetPartylinkMonthlyRentResource::alloc(UPDATE_ACTION,this,pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent,updateIndex));
		internalUpdate(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent,updateIndex,false);
	}
}

void CSysNetPartylinkMonthlyRentFactory::internalRemove(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetPartylinkMonthlyRent++;
#endif
	CWriteableSysNetPartylinkMonthlyRent theOldSysNetPartylinkMonthlyRent;
	beforeRemove(pSysNetPartylinkMonthlyRent);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetPartylinkMonthlyRent,pSysNetPartylinkMonthlyRent,sizeof(CSysNetPartylinkMonthlyRent));
	}
	if (runLevel>=0) {
		pSysLineNameIndex->removeObject(pSysNetPartylinkMonthlyRent);
	}
	pMem->free(pSysNetPartylinkMonthlyRent);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::remove(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetPartylinkMonthlyRent,true);
	}
	else {
		pTransaction->addResource(CSysNetPartylinkMonthlyRentResource::alloc(DELETE_ACTION,this,pSysNetPartylinkMonthlyRent,NULL));
		internalRemove(pSysNetPartylinkMonthlyRent,false);		
	}
}

CSysNetPartylinkMonthlyRent* CSysNetPartylinkMonthlyRentFactory::addOrUpdate(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pNewSysNetPartylinkMonthlyRent, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetPartylinkMonthlyRent == NULL) {
		return add(pNewSysNetPartylinkMonthlyRent,pTransaction);
	}
	else {
		update(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent,pTransaction,updateIndex);
		return pSysNetPartylinkMonthlyRent;
	}
}

void CSysNetPartylinkMonthlyRentFactory::retrieve(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pTargetSysNetPartylinkMonthlyRent)
{
	forceCopy(pTargetSysNetPartylinkMonthlyRent, pSysNetPartylinkMonthlyRent, sizeof(CSysNetPartylinkMonthlyRent));
}
	
int CSysNetPartylinkMonthlyRentFactory::addActionTrigger(CSysNetPartylinkMonthlyRentActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetPartylinkMonthlyRentFactory::removeActionTrigger(CSysNetPartylinkMonthlyRentActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetPartylinkMonthlyRentFactory::addCommitTrigger(CSysNetPartylinkMonthlyRentCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetPartylinkMonthlyRentFactory::removeCommitTrigger(CSysNetPartylinkMonthlyRentCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetPartylinkMonthlyRent *CSysNetPartylinkMonthlyRentFactory::getFirst(void)
{
	CSysNetPartylinkMonthlyRent *pResult=(CSysNetPartylinkMonthlyRent *)(pMem->getFirst());
	return pResult;
}
	
CSysNetPartylinkMonthlyRent *CSysNetPartylinkMonthlyRentFactory::getNext(void)
{
	CSysNetPartylinkMonthlyRent *pResult=(CSysNetPartylinkMonthlyRent *)(pMem->getNext());
	return pResult;
}
	
void CSysNetPartylinkMonthlyRentFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetPartylinkMonthlyRentFactory::beforeAdd(CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetPartylinkMonthlyRent);
	}
}
	
void CSysNetPartylinkMonthlyRentFactory::afterAdd(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::beforeUpdate(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pNewSysNetPartylinkMonthlyRent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetPartylinkMonthlyRent,pNewSysNetPartylinkMonthlyRent);
	}
}
	
void CSysNetPartylinkMonthlyRentFactory::afterUpdate(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetPartylinkMonthlyRent);
	}
}
	
void CSysNetPartylinkMonthlyRentFactory::beforeRemove(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::commitAdd(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetPartylinkMonthlyRent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::commitUpdate(CSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent, CWriteableSysNetPartylinkMonthlyRent *pOldSysNetPartylinkMonthlyRent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetPartylinkMonthlyRent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetPartylinkMonthlyRent,pOldSysNetPartylinkMonthlyRent);
	}
}
	
void CSysNetPartylinkMonthlyRentFactory::commitRemove(CWriteableSysNetPartylinkMonthlyRent *pSysNetPartylinkMonthlyRent)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetPartylinkMonthlyRent++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetPartylinkMonthlyRent);
	}
}

void CSysNetPartylinkMonthlyRentFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}

extern int compareForSysIDTypeIndexinSysNetNonPartyLinkInfo(const void *pV1, const void *pV2);
#ifdef COUNT_OPERATION
int addActionForSysNetNonPartyLinkInfo=0;
int updateWithIndexActionForSysNetNonPartyLinkInfo=0;
int updateWithoutIndexActionForSysNetNonPartyLinkInfo=0;
int removeActionForSysNetNonPartyLinkInfo=0;
int addCommitForSysNetNonPartyLinkInfo=0;
int updateCommitForSysNetNonPartyLinkInfo=0;
int removeCommitForSysNetNonPartyLinkInfo=0;
#endif
void CSysNetNonPartyLinkInfoFactory::init(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly)
{
	if (runLevel>=0) {
		if(!reuse) {
			pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetNonPartyLinkInfo,pAllocator,reuse,reuseID,readOnly);
			if(pIndexMap != NULL)
				pIndexMap->insert(map<string,int>::value_type("SysNetNonPartyLinkInfo_SysIDTypeIndex",pSysIDTypeIndex->getReuseID()));
		}
		else {
			map<string,int>::iterator it = pIndexMap->find("SysNetNonPartyLinkInfo_SysIDTypeIndex");
			if(it != pIndexMap->end()) {
				pSysIDTypeIndex=new CAVLTree(maxUnit,compareForSysIDTypeIndexinSysNetNonPartyLinkInfo,pAllocator,reuse,it->second,readOnly);
			}
		}
		if (pSysIDTypeIndex==NULL)
			RAISE_RUNTIME_ERROR("Insufficient memory space");
	}
	pLastFoundInSearchByAll=NULL;
	pActionTriggers=new vector<CSysNetNonPartyLinkInfoActionTrigger *>;
	pCommitTriggers=new vector<CSysNetNonPartyLinkInfoCommitTrigger *>;
	m_activeCommitTrigger=true;
}

CSysNetNonPartyLinkInfoFactory::CSysNetNonPartyLinkInfoFactory(int maxUnit,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetNonPartyLinkInfo),maxUnit,pAllocator,reuse,reuseID, readOnly)
{
	m_pConfig=NULL;
	init(maxUnit,pAllocator,pIndexMap,reuse,reuseID,readOnly);
}

CSysNetNonPartyLinkInfoFactory::CSysNetNonPartyLinkInfoFactory(CConfig *pConfig,IMemoryAllocator *pAllocator,map<string,int>* pIndexMap,bool reuse,int reuseID,int readOnly) :
	CDatabaseDataFactory(sizeof(CSysNetNonPartyLinkInfo),MDB_DEFAULT_BLOCK_SIZE,pAllocator,reuse,reuseID,readOnly)
{
	m_pConfig=pConfig;
	init(MDB_DEFAULT_BLOCK_SIZE,pAllocator,pIndexMap,reuse,reuseID,readOnly);		
}

CSysNetNonPartyLinkInfoFactory::~CSysNetNonPartyLinkInfoFactory(void)
{
	if (runLevel>=0) {
		if (pSysIDTypeIndex!=NULL)
			delete pSysIDTypeIndex;
	}
	if (pActionTriggers!=NULL)
		delete pActionTriggers;
	if (pCommitTriggers!=NULL)
		delete pCommitTriggers;
}

void CSysNetNonPartyLinkInfoFactory::output(CLogger *pLogger,int indent)
{
	pLogger->output(indent,0,"CSysNetNonPartyLinkInfoFactory");
	CDatabaseDataFactory::output(pLogger,indent+1);
	if (runLevel>=0) {
		pSysIDTypeIndex->output(pLogger,indent+1);
	}
}

int CSysNetNonPartyLinkInfoFactory::readCSV(char *filename)
{
	FILE *input;
	CWriteableSysNetNonPartyLinkInfo thisSysNetNonPartyLinkInfo;
	char buffer[1025];
	vector<char *> *pNames;
	char *token;
	input=mfopen(filename,"rt");
	if (input==NULL)
		return 0;
	pNames=new vector<char *>;
	fgets(buffer,1024,input);
	token=getNextToken(buffer);
	while (token!=NULL) {
		pNames->push_back(token);
		token=getNextToken(NULL);
	}
	while (thisSysNetNonPartyLinkInfo.readCSV(input,pNames))
		add(&thisSysNetNonPartyLinkInfo);
	fclose(input);
	delete pNames;
	return 1;
}

int CSysNetNonPartyLinkInfoFactory::readCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVReadPath"));
	strcat(szFileName, "SysNetNonPartyLinkInfo.csv");
	return readCSV(szFileName);
}

int CSysNetNonPartyLinkInfoFactory::writeCSV(char *filename)
{
	FILE *output;
	CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo;
	output=mfopen(filename,"wt");
	if (output==NULL)
		return 0;
	CWriteableSysNetNonPartyLinkInfo::writeCSVHead(output);
	pSysNetNonPartyLinkInfo=(CWriteableSysNetNonPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetNonPartyLinkInfo!=NULL) {
		if (!pSysNetNonPartyLinkInfo->writeCSV(output)) {
			pMem->endGet();
			fclose(output);
			return 0;
		}
		pSysNetNonPartyLinkInfo=(CWriteableSysNetNonPartyLinkInfo *)(pMem->getNext());
	}
	pMem->endGet();
	fclose(output);
	return 1;
}

int CSysNetNonPartyLinkInfoFactory::writeCSV(CConfig *pConfig)
{
	char szFileName[300];
	strcpy(szFileName, pConfig->getConfig("CSVWritePath"));
	strcat(szFileName, "SysNetNonPartyLinkInfo.csv");
	return writeCSV(szFileName);
}

void CSysNetNonPartyLinkInfoFactory::dump(char *filename)
{
	FILE *fp;
	fp = mfopen(filename,"w+b");
	dump(fp);
	if (fp!=NULL) fclose(fp);
}	

void CSysNetNonPartyLinkInfoFactory::dump(FILE *fp)
{
	int index=0; ///下标
	CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo;
	if(fp==NULL) fp=stdout;
	pMem->dump(fp);
	fprintf(fp,"CSysNetNonPartyLinkInfoFactory={       Total Count=%d\n", pMem->getCount());
	pSysNetNonPartyLinkInfo=(CWriteableSysNetNonPartyLinkInfo *)(pMem->getFirst());
	while (pSysNetNonPartyLinkInfo!=NULL) {
		pSysNetNonPartyLinkInfo->dump(fp,index++);
		pSysNetNonPartyLinkInfo=(CWriteableSysNetNonPartyLinkInfo *)(pMem->getNext());
	}
	fprintf(fp,"}\n");
	pMem->endGet();
}

void CSysNetNonPartyLinkInfoFactory::clearAll(void)
{
	CDatabaseDataFactory::clearAll();
	if (runLevel>=0) {
		pSysIDTypeIndex->removeAll();
	}
}

CSysNetNonPartyLinkInfo *CSysNetNonPartyLinkInfoFactory::internalAdd(CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, bool bNoTransaction)
{	
#ifdef COUNT_OPERATION
	addActionForSysNetNonPartyLinkInfo++;
#endif
	CSysNetNonPartyLinkInfo *pTarget;	
	beforeAdd(pSysNetNonPartyLinkInfo);
	pTarget=(CSysNetNonPartyLinkInfo *)createObject();
	if (pTarget==NULL) {
		RAISE_DESIGN_ERROR("Can not alloc enough SysNetNonPartyLinkInfo in memory database");
		return NULL;
	}
	forceCopy(pTarget, pSysNetNonPartyLinkInfo, sizeof(CSysNetNonPartyLinkInfo));
	pMem->updateObject(pTarget);
	if (runLevel>=0) {
		pSysIDTypeIndex->addObject(pTarget);
	}
	afterAdd(pTarget);
	if (bNoTransaction) {
		commitAdd(pTarget);
	}
	return pTarget;
}

CSysNetNonPartyLinkInfo *CSysNetNonPartyLinkInfoFactory::add(CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CTransaction *pTransaction)
{
	pSysNetNonPartyLinkInfo->calAllHash();
	if (pTransaction==NULL) {
		return internalAdd(pSysNetNonPartyLinkInfo,true);
	}
	else {
		CSysNetNonPartyLinkInfo *pNewSysNetNonPartyLinkInfo;
		pNewSysNetNonPartyLinkInfo = internalAdd(pSysNetNonPartyLinkInfo,false);
		pTransaction->addResource(CSysNetNonPartyLinkInfoResource::alloc(CREATE_ACTION,this,pNewSysNetNonPartyLinkInfo,NULL));
		return pNewSysNetNonPartyLinkInfo;
	}
}

void CSysNetNonPartyLinkInfoFactory::internalUpdate(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pNewSysNetNonPartyLinkInfo, bool updateIndex,bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	if (updateIndex) {
		updateWithIndexActionForSysNetNonPartyLinkInfo++;
	}
	else {
		updateWithoutIndexActionForSysNetNonPartyLinkInfo++;
	}
#endif
	CWriteableSysNetNonPartyLinkInfo theOldSysNetNonPartyLinkInfo;
	beforeUpdate(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetNonPartyLinkInfo,pSysNetNonPartyLinkInfo,sizeof(CSysNetNonPartyLinkInfo));
	}
	if (updateIndex) {
	}

	forceCopy(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo,sizeof(CSysNetNonPartyLinkInfo));
	pMem->updateObject(pSysNetNonPartyLinkInfo);
	if (updateIndex) {
	}
	afterUpdate(pSysNetNonPartyLinkInfo);
	if (bNoTransaction) {
		commitUpdate(pSysNetNonPartyLinkInfo,&theOldSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::update(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pNewSysNetNonPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	pNewSysNetNonPartyLinkInfo->updateAllHash();
	if (pTransaction==NULL) {
		internalUpdate(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo,updateIndex,true);
	}
	else {
		pTransaction->addResource(CSysNetNonPartyLinkInfoResource::alloc(UPDATE_ACTION,this,pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo,updateIndex));
		internalUpdate(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo,updateIndex,false);
	}
}

void CSysNetNonPartyLinkInfoFactory::internalRemove(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, bool bNoTransaction)
{
#ifdef COUNT_OPERATION
	removeActionForSysNetNonPartyLinkInfo++;
#endif
	CWriteableSysNetNonPartyLinkInfo theOldSysNetNonPartyLinkInfo;
	beforeRemove(pSysNetNonPartyLinkInfo);
	if (bNoTransaction) {
		forceCopy(&theOldSysNetNonPartyLinkInfo,pSysNetNonPartyLinkInfo,sizeof(CSysNetNonPartyLinkInfo));
	}
	if (runLevel>=0) {
		pSysIDTypeIndex->removeObject(pSysNetNonPartyLinkInfo);
	}
	pMem->free(pSysNetNonPartyLinkInfo);
	if(bNoTransaction) {
		commitRemove(&theOldSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::remove(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CTransaction *pTransaction)
{
	if (pTransaction==NULL) {
		internalRemove(pSysNetNonPartyLinkInfo,true);
	}
	else {
		pTransaction->addResource(CSysNetNonPartyLinkInfoResource::alloc(DELETE_ACTION,this,pSysNetNonPartyLinkInfo,NULL));
		internalRemove(pSysNetNonPartyLinkInfo,false);		
	}
}

CSysNetNonPartyLinkInfo* CSysNetNonPartyLinkInfoFactory::addOrUpdate(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pNewSysNetNonPartyLinkInfo, CTransaction *pTransaction, bool updateIndex)
{
	if(pSysNetNonPartyLinkInfo == NULL) {
		return add(pNewSysNetNonPartyLinkInfo,pTransaction);
	}
	else {
		update(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo,pTransaction,updateIndex);
		return pSysNetNonPartyLinkInfo;
	}
}

void CSysNetNonPartyLinkInfoFactory::retrieve(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pTargetSysNetNonPartyLinkInfo)
{
	forceCopy(pTargetSysNetNonPartyLinkInfo, pSysNetNonPartyLinkInfo, sizeof(CSysNetNonPartyLinkInfo));
}
	
int CSysNetNonPartyLinkInfoFactory::addActionTrigger(CSysNetNonPartyLinkInfoActionTrigger *pActionTrigger)
{
	pActionTrigger->setFactory(this);
	pActionTriggers->push_back(pActionTrigger);
	return 1;
}

int CSysNetNonPartyLinkInfoFactory::removeActionTrigger(CSysNetNonPartyLinkInfoActionTrigger *pActionTrigger)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		if (pActionTriggers->at(i)==pActionTrigger) {
			pActionTriggers->erase(pActionTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

int CSysNetNonPartyLinkInfoFactory::addCommitTrigger(CSysNetNonPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	pCommitTrigger->setFactory(this);
	pCommitTriggers->push_back(pCommitTrigger);
	return 1;
}

int CSysNetNonPartyLinkInfoFactory::removeCommitTrigger(CSysNetNonPartyLinkInfoCommitTrigger *pCommitTrigger)
{
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		if (pCommitTriggers->at(i)==pCommitTrigger) {
			pCommitTriggers->erase(pCommitTriggers->begin()+i);
			return 1;
		}
	}
	return 0;
}

CSysNetNonPartyLinkInfo *CSysNetNonPartyLinkInfoFactory::getFirst(void)
{
	CSysNetNonPartyLinkInfo *pResult=(CSysNetNonPartyLinkInfo *)(pMem->getFirst());
	return pResult;
}
	
CSysNetNonPartyLinkInfo *CSysNetNonPartyLinkInfoFactory::getNext(void)
{
	CSysNetNonPartyLinkInfo *pResult=(CSysNetNonPartyLinkInfo *)(pMem->getNext());
	return pResult;
}
	
void CSysNetNonPartyLinkInfoFactory::endGet(void)
{
	pMem->endGet();
}

void CSysNetNonPartyLinkInfoFactory::beforeAdd(CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeAdd(pSysNetNonPartyLinkInfo);
	}
}
	
void CSysNetNonPartyLinkInfoFactory::afterAdd(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterAdd(pSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::beforeUpdate(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pNewSysNetNonPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeUpdate(pSysNetNonPartyLinkInfo,pNewSysNetNonPartyLinkInfo);
	}
}
	
void CSysNetNonPartyLinkInfoFactory::afterUpdate(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	for (int i=0;i<(int)pActionTriggers->size();i++) {
		pActionTriggers->at(i)->afterUpdate(pSysNetNonPartyLinkInfo);
	}
}
	
void CSysNetNonPartyLinkInfoFactory::beforeRemove(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	for (int i=pActionTriggers->size()-1;i>=0;i--) {
		pActionTriggers->at(i)->beforeRemove(pSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::commitAdd(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	addCommitForSysNetNonPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitAdd(pSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::commitUpdate(CSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo, CWriteableSysNetNonPartyLinkInfo *pOldSysNetNonPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	updateCommitForSysNetNonPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitUpdate(pSysNetNonPartyLinkInfo,pOldSysNetNonPartyLinkInfo);
	}
}
	
void CSysNetNonPartyLinkInfoFactory::commitRemove(CWriteableSysNetNonPartyLinkInfo *pSysNetNonPartyLinkInfo)
{
	if (!m_activeCommitTrigger) return;
#ifdef COUNT_OPERATION
	removeCommitForSysNetNonPartyLinkInfo++;
#endif
	for (int i=0;i<(int)pCommitTriggers->size();i++) {
		pCommitTriggers->at(i)->commitRemove(pSysNetNonPartyLinkInfo);
	}
}

void CSysNetNonPartyLinkInfoFactory::activeCommitTrigger(bool activation)
{
	m_activeCommitTrigger=activation;
}


#ifdef COUNT_OPERATION

#define clearCount(name)						\
	addActionFor ## name =0;					\
	updateWithIndexActionFor ## name =0;		\
	updateWithoutIndexActionFor ## name =0;		\
	removeActionFor ## name =0;					\
	addCommitFor ## name=0;						\
	updateCommitFor ## name =0;					\
	removeCommitFor ## name =0;

void initAllOperationCount(void)
{
	clearCount(SysInvalidateOrder);
	clearCount(SysOrderStatus);
	clearCount(SysBargainOrder);
	clearCount(SysInstProperty);
	clearCount(SysMarginRate);
	clearCount(SysPriceLimit);
	clearCount(SysPartPosiLimit);
	clearCount(SysClientPosiLimit);
	clearCount(SysSpecialPosiLimit);
	clearCount(SysTransactionChg);
	clearCount(SysClientChg);
	clearCount(SysPartClientChg);
	clearCount(SysPosiLimitChg);
	clearCount(SysClientPosiLimitChg);
	clearCount(SysSpecPosiLimitChg);
	clearCount(SysHedgeDetailChg);
	clearCount(SysParticipantChg);
	clearCount(SysMarginRateChg);
	clearCount(SysUserIpChg);
	clearCount(SysPartTrade);
	clearCount(SysMdbObjectAttr);
	clearCount(SysMdbSyslogInfo);
	clearCount(SysUserInfo);
	clearCount(SysOnlineUserInfo);
	clearCount(SysWarningEvent);
	clearCount(SysWarningQuery);
	clearCount(SyslogEvent);
	clearCount(SysEventDescrip);
	clearCount(RspQryHostEnvCommon);
	clearCount(RspQryHostEnvLan);
	clearCount(RspQryHostEnvStorage);
	clearCount(RspQryHostEnvIO);
	clearCount(RspQryHostEnvFS);
	clearCount(RspQryHostEnvSwap);
	clearCount(RspQryHostEnvLanCfg);
	clearCount(SysMdbTopCpuInfo);
	clearCount(SysMdbTopMemInfo);
	clearCount(SysMdbTopProcessInfo);
	clearCount(SysMdbFileSystemInfo);
	clearCount(SysMdbNetworkInfo);
	clearCount(SysParticipantInit);
	clearCount(SysUserInit);
	clearCount(SysClientInit);
	clearCount(SysTradeUserLoginInfo);
	clearCount(SysMdbWebAppInfo);
	clearCount(SysMdbMemPoolInfo);
	clearCount(SysMdbConnectorInfo);
	clearCount(SysMdbDBQuery);
	clearCount(SysNetArea);
	clearCount(SysNetSubArea);
	clearCount(SysNetSubAreaIP);
	clearCount(SysNetFuncArea);
	clearCount(SysNetDevice);
	clearCount(SysNetDeviceLinked);
	clearCount(SysNetOID);
	clearCount(SysNetDeviceType);
	clearCount(SysNetTimePolicy);
	clearCount(SysNetGatherTask);
	clearCount(SysNetDeviceCategory);
	clearCount(SysNetManufactory);
	clearCount(SysNetCommunity);
	clearCount(SysNetPortType);
	clearCount(SysNetInterface);
	clearCount(SysNetGeneralOID);
	clearCount(SysNetMonitorType);
	clearCount(SysNetMonitorAttrScope);
	clearCount(SysNetMonitorAttrType);
	clearCount(SysNetMonitorCommandType);
	clearCount(SysNetMonitorActionGroup);
	clearCount(SysNetMonitorDeviceGroup);
	clearCount(SysNetMonitorTaskInfo);
	clearCount(SysNetMonitorTaskObjectSet);
	clearCount(SysNetMonitorTaskResult);
	clearCount(SysNetPartyLinkInfo);
	clearCount(SysNetDelPartyLinkInfo);
	clearCount(SysNetPartyLinkAddrChange);
	clearCount(SysNetMonitorActionAttr);
	clearCount(SysNetModule);
	clearCount(SysNetEventExpr);
	clearCount(SysNetEventType);
	clearCount(SysNetSubEventType);
	clearCount(SysNetEventLevel);
	clearCount(SysNetMonitorDeviceTask);
	clearCount(SysNetMonitorTaskInstAttrs);
	clearCount(SysNetBaseLine);
	clearCount(SysNetBaseLineTask);
	clearCount(SysMdbNetPartyLinkStatusInfo);
	clearCount(SysNetMemberSDHLineInfo);
	clearCount(SysNetDDNLinkInfo);
	clearCount(SysNetPseudMemberLinkInfo);
	clearCount(SysNetOuterDeviceInfo);
	clearCount(SysLocalPingResultInfo);
	clearCount(SysRomotePingResultInfo);
	clearCount(SysParticTradeOrderStates);
	clearCount(SysMdbRouterInfo);
	clearCount(SysMdbDiskIO);
	clearCount(SysMdbStatInfo);
	clearCount(SysMdbTradeFrontOrderRttStat);
	clearCount(SysInstrumentStatus);
	clearCount(SysCurrTradingSegmentAttr);
	clearCount(SysMemberLinkCost);
	clearCount(SysNetPartylinkMonthlyRent);
	clearCount(SysNetNonPartyLinkInfo);
}

#define display(id)						\
	if (id!=0)							\
	{									\
		printf("\t" #id ":%d\n", id);	\
	}

#define displayAll(name)							\
	display(addActionFor ## name);					\
	display(updateWithIndexActionFor ## name);		\
	display(updateWithoutIndexActionFor ## name);	\
	display(removeActionFor ## name);				\
	display(addCommitFor ## name);					\
	display(updateCommitFor ## name);				\
	display(removeCommitFor ## name);

void showAllOperationCount(void)
{
	displayAll(SysInvalidateOrder);
	displayAll(SysOrderStatus);
	displayAll(SysBargainOrder);
	displayAll(SysInstProperty);
	displayAll(SysMarginRate);
	displayAll(SysPriceLimit);
	displayAll(SysPartPosiLimit);
	displayAll(SysClientPosiLimit);
	displayAll(SysSpecialPosiLimit);
	displayAll(SysTransactionChg);
	displayAll(SysClientChg);
	displayAll(SysPartClientChg);
	displayAll(SysPosiLimitChg);
	displayAll(SysClientPosiLimitChg);
	displayAll(SysSpecPosiLimitChg);
	displayAll(SysHedgeDetailChg);
	displayAll(SysParticipantChg);
	displayAll(SysMarginRateChg);
	displayAll(SysUserIpChg);
	displayAll(SysPartTrade);
	displayAll(SysMdbObjectAttr);
	displayAll(SysMdbSyslogInfo);
	displayAll(SysUserInfo);
	displayAll(SysOnlineUserInfo);
	displayAll(SysWarningEvent);
	displayAll(SysWarningQuery);
	displayAll(SyslogEvent);
	displayAll(SysEventDescrip);
	displayAll(RspQryHostEnvCommon);
	displayAll(RspQryHostEnvLan);
	displayAll(RspQryHostEnvStorage);
	displayAll(RspQryHostEnvIO);
	displayAll(RspQryHostEnvFS);
	displayAll(RspQryHostEnvSwap);
	displayAll(RspQryHostEnvLanCfg);
	displayAll(SysMdbTopCpuInfo);
	displayAll(SysMdbTopMemInfo);
	displayAll(SysMdbTopProcessInfo);
	displayAll(SysMdbFileSystemInfo);
	displayAll(SysMdbNetworkInfo);
	displayAll(SysParticipantInit);
	displayAll(SysUserInit);
	displayAll(SysClientInit);
	displayAll(SysTradeUserLoginInfo);
	displayAll(SysMdbWebAppInfo);
	displayAll(SysMdbMemPoolInfo);
	displayAll(SysMdbConnectorInfo);
	displayAll(SysMdbDBQuery);
	displayAll(SysNetArea);
	displayAll(SysNetSubArea);
	displayAll(SysNetSubAreaIP);
	displayAll(SysNetFuncArea);
	displayAll(SysNetDevice);
	displayAll(SysNetDeviceLinked);
	displayAll(SysNetOID);
	displayAll(SysNetDeviceType);
	displayAll(SysNetTimePolicy);
	displayAll(SysNetGatherTask);
	displayAll(SysNetDeviceCategory);
	displayAll(SysNetManufactory);
	displayAll(SysNetCommunity);
	displayAll(SysNetPortType);
	displayAll(SysNetInterface);
	displayAll(SysNetGeneralOID);
	displayAll(SysNetMonitorType);
	displayAll(SysNetMonitorAttrScope);
	displayAll(SysNetMonitorAttrType);
	displayAll(SysNetMonitorCommandType);
	displayAll(SysNetMonitorActionGroup);
	displayAll(SysNetMonitorDeviceGroup);
	displayAll(SysNetMonitorTaskInfo);
	displayAll(SysNetMonitorTaskObjectSet);
	displayAll(SysNetMonitorTaskResult);
	displayAll(SysNetPartyLinkInfo);
	displayAll(SysNetDelPartyLinkInfo);
	displayAll(SysNetPartyLinkAddrChange);
	displayAll(SysNetMonitorActionAttr);
	displayAll(SysNetModule);
	displayAll(SysNetEventExpr);
	displayAll(SysNetEventType);
	displayAll(SysNetSubEventType);
	displayAll(SysNetEventLevel);
	displayAll(SysNetMonitorDeviceTask);
	displayAll(SysNetMonitorTaskInstAttrs);
	displayAll(SysNetBaseLine);
	displayAll(SysNetBaseLineTask);
	displayAll(SysMdbNetPartyLinkStatusInfo);
	displayAll(SysNetMemberSDHLineInfo);
	displayAll(SysNetDDNLinkInfo);
	displayAll(SysNetPseudMemberLinkInfo);
	displayAll(SysNetOuterDeviceInfo);
	displayAll(SysLocalPingResultInfo);
	displayAll(SysRomotePingResultInfo);
	displayAll(SysParticTradeOrderStates);
	displayAll(SysMdbRouterInfo);
	displayAll(SysMdbDiskIO);
	displayAll(SysMdbStatInfo);
	displayAll(SysMdbTradeFrontOrderRttStat);
	displayAll(SysInstrumentStatus);
	displayAll(SysCurrTradingSegmentAttr);
	displayAll(SysMemberLinkCost);
	displayAll(SysNetPartylinkMonthlyRent);
	displayAll(SysNetNonPartyLinkInfo);
}
#endif

